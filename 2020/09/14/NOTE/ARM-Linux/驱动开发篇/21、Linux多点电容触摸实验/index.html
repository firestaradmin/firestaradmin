

<!DOCTYPE html>
<html lang="zh-cn" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux 电容触摸实验Linux 下电容触摸屏驱动框架简介1| 多点触摸(MT) 协议详解电容触摸驱动的基本原理回顾一下几个重要的知识点：  ①、电容触摸屏是 IIC 接口的，需要触摸 IC，以正点原子的 ATK7016 为例，其所使用的触摸屏控制 IC 为 FT5426，因此所谓的电容触摸驱动就是 IIC 设备驱动。 ②、触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。">
<meta property="og:type" content="article">
<meta property="og:title" content="21| Linux 电容触摸实验">
<meta property="og:url" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Linux 电容触摸实验Linux 下电容触摸屏驱动框架简介1| 多点触摸(MT) 协议详解电容触摸驱动的基本原理回顾一下几个重要的知识点：  ①、电容触摸屏是 IIC 接口的，需要触摸 IC，以正点原子的 ATK7016 为例，其所使用的触摸屏控制 IC 为 FT5426，因此所谓的电容触摸驱动就是 IIC 设备驱动。 ②、触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905142552964.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150121781.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150208249.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150308374.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150825437.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905151355239.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905151639612.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905151800603.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905152923501.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905153548331.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905153619823.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905154305722.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905154521160.png">
<meta property="article:published_time" content="2020-09-13T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-13T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905142552964.png">
  
  
  <title>21| Linux 电容触摸实验 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="21| Linux 电容触摸实验">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-14 00:00" pubdate>
        2020年9月14日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      61k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      506 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">21| Linux 电容触摸实验</h1>
            
            <div class="markdown-body">
              <h1 id="Linux-电容触摸实验"><a href="#Linux-电容触摸实验" class="headerlink" title="Linux 电容触摸实验"></a>Linux 电容触摸实验</h1><h2 id="Linux-下电容触摸屏驱动框架简介"><a href="#Linux-下电容触摸屏驱动框架简介" class="headerlink" title="Linux 下电容触摸屏驱动框架简介"></a>Linux 下电容触摸屏驱动框架简介</h2><h3 id="1-多点触摸-MT-协议详解"><a href="#1-多点触摸-MT-协议详解" class="headerlink" title="1| 多点触摸(MT) 协议详解"></a>1| 多点触摸(MT) 协议详解</h3><p><strong>电容触摸驱动的基本原理回顾一下几个重要的知识点：</strong></p>
<ul>
<li>①、电容触摸屏是 IIC 接口的，需要触摸 IC，以正点原子的 ATK7016 为例，其所使用的触摸屏控制 IC 为 FT5426，因此所谓的电容触摸驱动就是 IIC 设备驱动。</li>
<li>②、触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。</li>
<li>③、电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。</li>
<li>④、电容触摸屏不需要校准，当然了，这只是理论上的，如果电容触摸屏质量比较差，或者触摸玻璃和 TFT 之间没有完全对齐，那么也是需要校准的。</li>
</ul>
<p><strong>根据以上几个知识点，我们可以得出电容触摸屏驱动其实就是以下几种 linux 驱动框架的组合：</strong></p>
<ul>
<li>①、IIC 设备驱动，因为电容触摸 IC 基本都是 IIC 接口的，因此大框架就是 IIC 设备驱动。</li>
<li>②、通过中断引脚(INT)向 linux 内核上报触摸信息，因此需要用到 linux 中断驱动框架。坐标的上报在中断服务函数中完成。</li>
<li>③、触摸屏的坐标信息、屏幕按下和抬起信息都属于 linux 的 input 子系统，因此向 linux 内核上报触摸屏坐标信息就得使用 input 子系统。只是，我们得按照 linux 内核规定的规则来上报坐标信息。</li>
</ul>
<p>经过简单的分析，我们发现 IIC 驱动、中断驱动、input 子系统我们都已经在前面学过了，唯独没学过的就是 input 子系统下的多点电容触摸协议，这个才是我们本章学习的重点。linux内核中有一份文档详细的讲解了多点电容触摸屏协议，文档路径为：<code>Documentation/input/multi-touch-protocol.txt</code></p>
<p>老版本的 linux 内核是不支持多点电容触摸的(Multi-touch，简称 MT)，MT 协议是后面加入的，因此如果使用 2.x 版本 linux 内核的话可能找不到 MT 协议。</p>
<p><strong>MT 协议被分为两种类型，TypeA 和 TypeB，这两种类型的区别如下：</strong></p>
<ul>
<li>Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少！)。</li>
<li>Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息，FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。</li>
</ul>
<p>触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核，只有ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 linux&#x2F;input.h 中，相关事件如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">852</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_SLOT 		0x2f  <span class="hljs-comment">/* MT slot being modified */</span></span>
<span class="hljs-number">853</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOUCH_MAJOR 	0x30  <span class="hljs-comment">/* Major axis of touching ellipse */</span></span>
<span class="hljs-number">854</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOUCH_MINOR 	0x31  <span class="hljs-comment">/* Minor axis (omit if circular) */</span></span>
<span class="hljs-number">855</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_WIDTH_MAJOR 	0x32  <span class="hljs-comment">/* Major axis of approaching ellipse */</span></span>
<span class="hljs-number">856</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_WIDTH_MINOR 	0x33  <span class="hljs-comment">/* Minor axis (omit if circular) */</span></span>
<span class="hljs-number">857</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_ORIENTATION 	0x34  <span class="hljs-comment">/* Ellipse orientation */</span></span>
<span class="hljs-number">858</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_POSITION_X 	0x35  <span class="hljs-comment">/* Center X touch position */</span></span>
<span class="hljs-number">859</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_POSITION_Y 	0x36  <span class="hljs-comment">/* Center Y touch position */</span></span>
<span class="hljs-number">860</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOOL_TYPE 	0x37  <span class="hljs-comment">/* Type of touching device */</span></span>
<span class="hljs-number">861</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_BLOB_ID 		0x38  <span class="hljs-comment">/* Group a set of packets as a blob */</span></span>
<span class="hljs-number">862</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TRACKING_ID 	0x39  <span class="hljs-comment">/* Unique ID of initiated contact */</span></span>
<span class="hljs-number">863</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_PRESSURE 	0x3a  <span class="hljs-comment">/* Pressure on contact area */</span></span>
<span class="hljs-number">864</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_DISTANCE 	0x3b  <span class="hljs-comment">/* Contact hover distance */</span></span>
<span class="hljs-number">865</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOOL_X 		0x3c  <span class="hljs-comment">/* Center X tool position */</span></span>
<span class="hljs-number">866</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOOL_Y 		0x3d  <span class="hljs-comment">/* Center Y tool position */</span></span></code></pre></div>

<p>在 上 面 这 些 众 多 的 ABS_MT 事 件 中 ， 我 们 最 常 用 的 就 是 <strong>ABS_MT_SLOT</strong> 、<strong>ABS_MT_POSITION_X</strong> 、 <strong>ABS_MT_POSITION_Y</strong> 和 <strong>ABS_MT_TRACKING_ID</strong> 。 其 中ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 用来上报触摸点的(X,Y)坐标信息，ABS_MT_SLOT 用 来 上 报 触 摸 点 ID ， 对 于 Type B 类 型 的 设 备 ， 需 要 用 到ABS_MT_TRACKING_ID 事件来区分触摸点。</p>
<p><strong>对于 Type A 类型的设备</strong>，通过 input_mt_sync()函数来隔离不同的触摸点数据信息，此函数原型如下所示</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div>

<p>此函数只要一个参数，类型为 input_dev，用于指定具体的 input_dev 设备。input_mt_sync()函数会触发 SYN_MT_REPORT 事件，此事件会通知接收者获取当前触摸数据，并且准备接收下一个触摸点数据。</p>
<hr>
<p><strong>对于 Type B 类型的设备</strong>，上报触摸点信息的时候需要通过 input_mt_slot()函数区分是哪一个触摸点，input_mt_slot()函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_slot</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">int</span> slot)</span></code></pre></div>

<p>此函数有两个参数，第一个参数是 input_dev 设备，第二个参数 slot 用于指定当前上报的是哪个触摸点信息。input_mt_slot()函数会触发 ABS_MT_SLOT 事件，此事件会告诉接收者当前正在更新的是哪个触摸点(slot)的数据。</p>
<hr>
<p>不管是哪个类型的设备，最终都要调用 input_sync()函数来标识多点触摸信息传输完成，告诉接收者处理之前累计的所有消息，并且准备好下一次接收。</p>
<p>Type B 和 Type A 相比最大的区别就是 Type B 可以区分出触摸点， 因此可以减少发送到用户空间的数据。Type B 使用 slot 协议区分具体的触摸点，slot 需要用到 ABS_MT_TRACKING_ID 消息，这个 ID 需要硬件提供，或者通过原始数据计算出来。</p>
<p>对于 Type A 设备，内核驱动需要一次性将触摸屏上所有的触摸点信息全部上报，每个触摸点的信息在本次上报事件流中的顺序不重要，因为事件的过滤和手指(触摸点)跟踪是在内核空间处理的。</p>
<p>Type B 设备驱动需要给每个识别出来的触摸点分配一个 slot，后面使用这个 slot 来上报触摸点信息。可以通过 slot 的 ABS_MT_TRACKING_ID 来新增、替换或删除触摸点。一个非负数的 ID 表示一个有效的触摸点，-1 这个 ID 表示未使用 slot。一个以前不存在的 ID 表示这是一个新加的触摸点，一个 ID 如果再也不存在了就表示删除了。</p>
<p>有些设备识别或追踪的触摸点信息要比他上报的多，这些设备驱动应该给硬件上报的每个触摸点分配一个 Type B 的 slot。一旦检测到某一个 slot 关联的触摸点 ID 发生了变化，驱动就应该改变这个 slot 的 ABS_MT_TRACKING_ID，使这个 slot 失效。如果硬件设备追踪到了比他正在上报的还要多的触摸点，那么驱动程序应该发送 BTN_TOOL_*TAP 消息，并且调用input_mt_report_pointer_emulation()函数，将此函数的第二个参数 use_count 设置为 false。</p>
<h3 id="2-Type-A-触摸点信息上报时序"><a href="#2-Type-A-触摸点信息上报时序" class="headerlink" title="2| Type A 触摸点信息上报时序"></a>2| Type A 触摸点信息上报时序</h3><p>对于 Type A 类型的设备，发送触摸点信息的时序如下所示，这里以 2 个触摸点为例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ABS_MT_POSITION_X x[<span class="hljs-number">0</span>]
<span class="hljs-number">2</span> ABS_MT_POSITION_Y y[<span class="hljs-number">0</span>]
<span class="hljs-number">3</span> SYN_MT_REPORT
<span class="hljs-number">4</span> ABS_MT_POSITION_X x[<span class="hljs-number">1</span>]
<span class="hljs-number">5</span> ABS_MT_POSITION_Y y[<span class="hljs-number">1</span>]
<span class="hljs-number">6</span> SYN_MT_REPORT
<span class="hljs-number">7</span> SYN_REPORT</code></pre></div>

<p>第 1 行，通过 ABS_MT_POSITION_X 事件上报第一个触摸点的 X 坐标数据，<strong>通过input_report_abs 函数实现</strong>，下面同理。<br>第 2 行，通过 ABS_MT_POSITION_Y 事件上报第一个触摸点的 Y 坐标数据。<br>第 3 行，上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。<br>第 4 行，通过 ABS_MT_POSITION_X 事件上报第二个触摸点的 X 坐标数据。<br>第 5 行，通过 ABS_MT_POSITION_Y 事件上报第二个触摸点的 Y 坐标数据。<br>第 6 行，上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。<br>第 7 行，上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</p>
<p>我们在编写 Type A 类型的多点触摸驱动的时候就需要按照示例代码中的时序上报坐标信息。Linux 内核里面也有 Type A 类型的多点触摸驱动，找到 st2332.c 这个驱动文件，路径为 drivers&#x2F;input&#x2F;touchscreen&#x2F;st1232.c，找到 st1232_ts_irq_handler 函数，此函数里面就是上报触摸点坐标信息的。</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">103</span> <span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">st1232_ts_irq_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>
104 &#123;
......
<span class="hljs-number">111</span> 	ret = st1232_ts_read_data(ts);
<span class="hljs-number">112</span> 	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)
<span class="hljs-number">113</span> 		<span class="hljs-keyword">goto</span> end;
<span class="hljs-number">114</span>
<span class="hljs-number">115</span> 	<span class="hljs-comment">/* multi touch protocol */</span>
<span class="hljs-number">116</span> 	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_FINGERS; i++) &#123;
<span class="hljs-number">117</span> 		<span class="hljs-keyword">if</span> (!finger[i].is_valid)
<span class="hljs-number">118</span> 			<span class="hljs-keyword">continue</span>;
<span class="hljs-number">119</span>
<span class="hljs-number">120</span> 		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, finger[i].t);
<span class="hljs-number">121</span> 		input_report_abs(input_dev, ABS_MT_POSITION_X, finger[i].x);
<span class="hljs-number">122</span> 		input_report_abs(input_dev, ABS_MT_POSITION_Y, finger[i].y);
<span class="hljs-number">123</span> 		input_mt_sync(input_dev);
<span class="hljs-number">124</span> 		count++;
<span class="hljs-number">125</span> 	&#125;
......
<span class="hljs-number">140</span>
<span class="hljs-number">141</span> 	<span class="hljs-comment">/* SYN_REPORT */</span>
<span class="hljs-number">142</span> 	input_sync(input_dev);
<span class="hljs-number">143</span>
<span class="hljs-number">144</span> end:
<span class="hljs-number">145</span> 	<span class="hljs-keyword">return</span> IRQ_HANDLED;
<span class="hljs-number">146</span> &#125;</code></pre></div>

<ul>
<li>第 111 行，获取所有触摸点信息。</li>
<li>第 116~125 行，按照 Type A 类型轮流上报所有的触摸点坐标信息，第 121 和 122 行分别上报触摸点的(X,Y)轴坐标，也就是 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 事件。每上报完一个触摸点坐标，都要在第 123 行调用 input_mt_sync 函数上报一个 SYN_MT_REPORT信息。</li>
<li>第 142 行，每上报完一轮触摸点信息就调用一次 input_sync 函数，也就是发送一个SYN_REPORT 事件</li>
</ul>
<h3 id="3-Type-B-触摸点信息上报时序"><a href="#3-Type-B-触摸点信息上报时序" class="headerlink" title="3| Type B  触摸点信息上报时序"></a>3| Type B  触摸点信息上报时序</h3><p>对于 Type B 类型的设备，发送触摸点信息的时序如下所示，这里以 2 个触摸点为例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ABS_MT_SLOT <span class="hljs-number">0</span>
<span class="hljs-number">2</span> ABS_MT_TRACKING_ID <span class="hljs-number">45</span>
<span class="hljs-number">3</span> ABS_MT_POSITION_X x[<span class="hljs-number">0</span>]
<span class="hljs-number">4</span> ABS_MT_POSITION_Y y[<span class="hljs-number">0</span>]
<span class="hljs-number">5</span> ABS_MT_SLOT <span class="hljs-number">1</span>
<span class="hljs-number">6</span> ABS_MT_TRACKING_ID <span class="hljs-number">46</span>
<span class="hljs-number">7</span> ABS_MT_POSITION_X x[<span class="hljs-number">1</span>]
<span class="hljs-number">8</span> ABS_MT_POSITION_Y y[<span class="hljs-number">1</span>]
<span class="hljs-number">9</span> SYN_REPORT</code></pre></div>

<ul>
<li>第 1 行，上报 ABS_MT_SLOT 事件，也就是触摸点对应的 SLOT。每次上报一个触摸点坐标之前要先使用input_mt_slot函数上报当前触摸点SLOT，触摸点的SLOT其实就是触摸点ID，需要由触摸 IC 提供。</li>
<li>第 2 行，根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。具体用到的函数就是input_mt_report_slot_state，如果是添加一个新的触摸点，那么此函数的第三个参数active 要设置为 true，linux 内核会自动分配一个 ABS_MT_TRACKING_ID 值，不需要用户去指定具体的 ABS_MT_TRACKING_ID 值。</li>
<li>第 3 行，上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成。</li>
<li>第 4 行，上报触摸点 0 的 Y 轴坐标，使用函数 input_report_abs 来完成。</li>
<li>第 5<del>8 行，和第 1</del>4 行类似，只是换成了上报触摸点 0 的(X,Y)坐标信息</li>
<li>第9行，当所有的触摸点坐标都上传完毕以后就得发送SYN_REPORT事件，使用input_sync函数来完成。</li>
</ul>
<p>当一个触摸点移除以后，同样需要通过 SLOT 关联的 ABS_MT_TRACKING_ID 来处理，时序如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ABS_MT_TRACKING_ID <span class="hljs-number">-1</span>
<span class="hljs-number">2</span> SYN_REPORT</code></pre></div>

<ul>
<li>第 1 行，当一个触摸点(SLOT)移除以后，需要通过 ABS_MT_TRACKING_ID 事件发送一个-1 给内核。方法很简单，同样使用 input_mt_report_slot_state 函数来完成，只需要将此函数的第三个参数 active 设置为 false 即可，不需要用户手动去设置-1。</li>
<li>第 2 行，当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件。</li>
</ul>
<p>当要编写 Type B 类型的多点触摸驱动的时候就需要按照示例代码中的时序上报坐标信息。Linux 内核里面有大量的 Type B 类型的多点触摸驱动程序，我们可以参考这些现成的驱动程序来编写自己的驱动代码。这里就以 ili210x 这个触摸驱动 IC 为例，看看是 Type B 类型是 如 何 上 报 触 摸 点 坐 标 信 息 的 。 找 到 ili210x.c 这 个 驱 动 文 件 ， 路 径 为drivers&#x2F;input&#x2F;touchscreen&#x2F;ili210x.c，找到 ili210x_report_events 函数，此函数就是用于上报 ili210x触摸坐标信息的，函数内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">78</span> 	<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ili210x_report_events</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *input,</span>
<span class="hljs-params"><span class="hljs-number">79</span> 									  <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> touchdata *touchdata)</span>
80 	&#123;
<span class="hljs-number">81</span> 		<span class="hljs-type">int</span> i;
<span class="hljs-number">82</span> 		<span class="hljs-type">bool</span> touch;
<span class="hljs-number">83</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x, y;
<span class="hljs-number">84</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">finger</span> *<span class="hljs-title">finger</span>;</span>
<span class="hljs-number">85</span>
<span class="hljs-number">86</span> 		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_TOUCHES; i++) &#123;
<span class="hljs-number">87</span> 			input_mt_slot(input, i);
<span class="hljs-number">88</span>
<span class="hljs-number">89</span> 			finger = &amp;touchdata-&gt;finger[i];
<span class="hljs-number">90</span>
<span class="hljs-number">91</span> 			touch = touchdata-&gt;status &amp; (<span class="hljs-number">1</span> &lt;&lt; i);
<span class="hljs-number">92</span> 			input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
<span class="hljs-number">93</span> 			<span class="hljs-keyword">if</span> (touch) &#123;
<span class="hljs-number">94</span> 				x = finger-&gt;x_low | (finger-&gt;x_high &lt;&lt; <span class="hljs-number">8</span>);
<span class="hljs-number">95</span> 				y = finger-&gt;y_low | (finger-&gt;y_high &lt;&lt; <span class="hljs-number">8</span>);
<span class="hljs-number">96</span>
<span class="hljs-number">97</span> 				input_report_abs(input, ABS_MT_POSITION_X, x);
<span class="hljs-number">98</span> 				input_report_abs(input, ABS_MT_POSITION_Y, y);
<span class="hljs-number">99</span> 			&#125;
<span class="hljs-number">100</span> 	&#125;
<span class="hljs-number">101</span>
<span class="hljs-number">102</span> 	input_mt_report_pointer_emulation(input, <span class="hljs-literal">false</span>);
<span class="hljs-number">103</span> 	input_sync(input);
<span class="hljs-number">104</span> &#125;</code></pre></div>

<ul>
<li>第 86~100 行，使用 for 循环实现上报所有的触摸点坐标，第 87 行调用 input_mt_slot 函数上 报 ABS_MT_SLOT 事 件 。 第 92 行 调 用 input_mt_report_slot_state 函 数 上 报ABS_MT_TRACKING_ID 事件，也就是给 SLOT 关联一个 ABS_MT_TRACKING_ID。第 97 和98 行使用 input_report_abs 函数上报触摸点对应的(X,Y)坐标值。</li>
<li>第 103 行，使用 input_sync 函数上报 SYN_REPORT 事件。</li>
</ul>
<h3 id="4-MT-其他事件的使用"><a href="#4-MT-其他事件的使用" class="headerlink" title="4| MT  其他事件的使用"></a>4| MT  其他事件的使用</h3><p>在前面示例代码 中给出了 Linux 所支持的所有 ABS_MT 事件，大家可以根据实际需求将 这 些 事 件 组 成 各 种 事 件 组 合 。 最 简 单 的 组 合 就 是 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y，可以通过在这两个事件上报触摸点，如果设备支持的话，还可以使用ABS_MT_TOUCH_MAJOR 和ABS_MT_WIDTH_MAJOR 这两个消息上报触摸面积信息，关于其他 ABS_MT 事件的具体含义大家可以查看 Linux 内核中的 multi-touch-protocol.txt 文档，这里我们重点补充一下 ABS_MT_TOOL_TYPE 事件。</p>
<p><strong>ABS_MT_TOOL_TYPE 事件</strong>用于上报触摸工具类型，很多内核驱动都不能区分出触摸设备类型，是手指还是触摸笔？这种情况下，这个事件可以忽略掉。</p>
<p>目前的协议支持MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)和 MT_TOOL_PALM(手掌)这三种触摸设备类型， 于 Type B 类型，此事件 由 input 子系统内核处理。 如果驱动程序需要上 报ABS_MT_TOOL_TYPE 事件，那么可以使用 input_mt_report_slot_state 函数来完成此工作。</p>
<p>关于 Linux 系统下的多点触摸(MT)协议就讲解到这里，简单总结一下，MT 协议隶属于 linux的 input 子系统，驱动通过大量的 ABS_MT 事件向 linux 内核上报多点触摸坐标数据。根据触摸 IC 的不同，分为 Type A 和 Type B 两种类型，不同的类型其上报时序不同，目前使用最多的是 Type B 类型。接下来我们就根据前面学习过的 MT 协议来编写一个多点电容触摸驱动程序，</p>
<p>本章节所使用的触摸屏是正点原子的 ATK7084(7 寸 800<em>480)和 ATK7016(7 寸 1024</em>600)这两款触摸屏，这两款触摸屏都使用 FT5426 这款触摸 IC，因此驱动程序是完全通用的。</p>
<h3 id="5-多点触摸所使用到的-API-函数"><a href="#5-多点触摸所使用到的-API-函数" class="headerlink" title="5| 多点触摸所使用到的 API  函数"></a>5| 多点触摸所使用到的 API  函数</h3><p>根据前面的讲解，我们知道 linux 下的多点触摸协议其实就是通过不同的事件来上报触摸点坐标信息，这些事件都是通过 Linux 内核提供的对应 API 函数实现的，本小节我们来看一下一些常见的 API 函数。</p>
<h4 id="1-、input-mt-init-slots-函数"><a href="#1-、input-mt-init-slots-函数" class="headerlink" title="1 、input_mt_init_slots  函数"></a>1 、input_mt_init_slots  函数</h4><p><strong>input_mt_init_slots 函数用于初始化 MT 的输入 slots</strong>，编写 MT 驱动的时候必须先调用此函<br>数初始化 slots，此函数定义在文件 drivers&#x2F;input&#x2F;input-mt.c 中，函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">input_mt_init_slots</span><span class="hljs-params">( <span class="hljs-keyword">struct</span> input_dev *dev,</span>
<span class="hljs-params">                        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_slots,</span>
<span class="hljs-params">                        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev。<br><strong>num_slots</strong>：设备要使用的 SLOT 数量，也就是触摸点的数量。<br><strong>flags</strong> ：其他一些 flags 信息，可设置的 flags 如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_POINTER  	0x0001 <span class="hljs-comment">/* pointer device, e.g. trackpad */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_DIRECT  	0x0002 <span class="hljs-comment">/* direct device, e.g. touchscreen */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_DROP_UNUSED 0x0004 <span class="hljs-comment">/* drop contacts not seen in frame */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_TRACK  	0x0008 <span class="hljs-comment">/* use in-kernel tracking */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_SEMI_MT 	0x0010 <span class="hljs-comment">/* semi-mt device, finger count handled manually */</span></span></code></pre></div>

<p>可以采用‘|’运算来同时设置多个 flags 标识。<br><strong>返回值</strong>：0，成功；负值，失败。</p>
<h4 id="2-、input-mt-slot"><a href="#2-、input-mt-slot" class="headerlink" title="2 、input_mt_slot"></a>2 、input_mt_slot</h4><p>此函数用于 Type B 类型，此函数用于产生 ABS_MT_SLOT 事件，告诉内核当前上报的是哪个触摸点的坐标数据，此函数定义在文件 include&#x2F;linux&#x2F;input&#x2F;mt.h 中，函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_slot</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev,</span>
<span class="hljs-params">                   <span class="hljs-type">int</span> slot)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev。<br><strong>slot</strong>：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点。<br><strong>返回值</strong>：无。</p>
<h4 id="3-、input-mt-report-slot-state-函数"><a href="#3-、input-mt-report-slot-state-函数" class="headerlink" title="3 、input_mt_report_slot_state  函数"></a>3 、input_mt_report_slot_state  函数</h4><p>此函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE事 件 ， ABS_MT_TRACKING_ID 事 件 给 slot 关 联 一 个 ABS_MT_TRACKING_ID ，ABS_MT_TOOL_TYPE 事件指定触摸类型（是笔还是手指等）。此函数定义在文件drivers&#x2F;input&#x2F;input-mt.c 中，此函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_report_slot_state</span><span class="hljs-params">( <span class="hljs-keyword">struct</span> input_dev *dev,</span>
<span class="hljs-params">                                <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tool_type,</span>
<span class="hljs-params">                                <span class="hljs-type">bool</span> active)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev。<br><strong>tool_type</strong>：触摸类型，可以选择 MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或MT_TOOL_PALM(手掌)，对于多点电容触摸屏来说一般都是手指。<br><strong>active</strong>：true，连续触摸，input子系统内核会自动分配一个ABS_MT_TRACKING_ID 给 slot ; false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个-1 给 slot，表示触摸点溢出。<br><strong>返回值</strong>：无。</p>
<h4 id="4-、input-report-abs-函数"><a href="#4-、input-report-abs-函数" class="headerlink" title="4 、input_report_abs  函数"></a>4 、input_report_abs  函数</h4><p>Type A 和 Type B 类型都使用此函数上报触摸点坐标信息，通过 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y 事 件 实 现 X 和 Y 轴 坐 标 信 息 上 报 。 此 函 数 定 义 在 文 件include&#x2F;linux&#x2F;input.h 中，函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_report_abs</span><span class="hljs-params">( <span class="hljs-keyword">struct</span> input_dev *dev,</span>
<span class="hljs-params">                      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code,</span>
<span class="hljs-params">                      <span class="hljs-type">int</span> value)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev。<br><strong>code</strong>：要上报的是什么数据，可以设置为 ABS_MT_POSITION_X 或 ABS_MT_POSITION_Y，也就是 X 轴或者 Y 轴坐标数据。<br><strong>value</strong>：具体的 X 轴或 Y 轴坐标数据值。<br><strong>返回值</strong>：无。</p>
<h4 id="5-、input-mt-report-pointer-emulation-函数"><a href="#5-、input-mt-report-pointer-emulation-函数" class="headerlink" title="5 、input_mt_report_pointer_emulation  函数"></a>5 、input_mt_report_pointer_emulation  函数</h4><p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量，然后调用 input_mt_report_pointer_emulation 函数将use_count 参数设置为false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)，此函数定义在文件 drivers&#x2F;input&#x2F;input-mt.c中，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_report_pointer_emulation</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev,</span>
<span class="hljs-params">                                       <span class="hljs-type">bool</span> use_count)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev。<br><strong>use_count</strong>：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量。<br><strong>返回值</strong>：无。</p>
<h3 id="6-多点电容触摸驱动框架"><a href="#6-多点电容触摸驱动框架" class="headerlink" title="6| 多点电容触摸驱动框架"></a>6| 多点电容触摸驱动框架</h3><p>前面几小节已经详细的讲解了 linux 下多点触摸屏驱动原理，本小节我们来梳理一下 linux下多点电容触摸驱动的编写框架和步骤。首先确定驱动需要用到哪些知识点，哪些框架？根据前面的分析，我们在编写驱动的时候需要注意一下几点：</p>
<p>①、多点电容触摸芯片的接口，一般都为 I2C 接口，因此驱动主框架肯定是 I2C。<br>②、linux 里面一般都是通过中断来上报触摸点坐标信息，因此需要用到中断框架。<br>③、多点电容触摸属于 input 子系统，因此还要用到 input 子系统框架。<br>④、在中断处理程序中按照 linux 的 MT 协议上报坐标信息。</p>
<p>根据上面的分析，多点电容触摸驱动编写框架以及步骤如下：</p>
<h4 id="1-、I2C-驱动框架"><a href="#1-、I2C-驱动框架" class="headerlink" title="1 、I2C  驱动框架"></a>1 、I2C  驱动框架</h4><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 设备树匹配表 */</span>
<span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">xxx_ts_id</span>[] =</span> &#123;
<span class="hljs-number">3</span> 		&#123; <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">0</span>, &#125;,
<span class="hljs-number">4</span> 		&#123; <span class="hljs-comment">/* sentinel */</span> &#125;
<span class="hljs-number">5</span> &#125;;
<span class="hljs-number">6</span>
<span class="hljs-number">7</span> <span class="hljs-comment">/* 设备树匹配表 */</span>
<span class="hljs-number">8</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;
<span class="hljs-number">9</span> 		&#123; .compatible = <span class="hljs-string">&quot;xxx&quot;</span>, &#125;,
<span class="hljs-number">10</span> 		&#123; <span class="hljs-comment">/* sentinel */</span> &#125;
<span class="hljs-number">11</span> &#125;;
<span class="hljs-number">12</span>
<span class="hljs-number">13</span> <span class="hljs-comment">/* i2c 驱动结构体 */</span>
<span class="hljs-number">14</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">ft5x06_ts_driver</span> =</span> &#123;
<span class="hljs-number">15</span> 		.driver = &#123;
<span class="hljs-number">16</span> 			.owner = THIS_MODULE,
<span class="hljs-number">17</span> 			.name = <span class="hljs-string">&quot;edt_ft5x06&quot;</span>,
<span class="hljs-number">18</span> 			.of_match_table = of_match_ptr(xxx_of_match),
<span class="hljs-number">19</span> 		&#125;,
<span class="hljs-number">20</span> 		.id_table = xxx_ts_id,
<span class="hljs-number">21</span> 		.probe = xxx_ts_probe,
<span class="hljs-number">22</span> 		.remove = xxx_ts_remove,
<span class="hljs-number">23</span> &#125;;
<span class="hljs-number">24</span>
<span class="hljs-number">25</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">26 * @description : 驱动入口函数</span>
<span class="hljs-comment">27 * @param : 无</span>
<span class="hljs-comment">28 * @return : 无</span>
<span class="hljs-comment">29 */</span>
<span class="hljs-number">30</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
31 &#123;
<span class="hljs-number">32</span> 		<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
<span class="hljs-number">33</span>
<span class="hljs-number">34</span> 		ret = i2c_add_driver(&amp;xxx_ts_driver);
<span class="hljs-number">35</span>
<span class="hljs-number">36</span> 		<span class="hljs-keyword">return</span> ret;
<span class="hljs-number">37</span> &#125;
<span class="hljs-number">38</span>
<span class="hljs-number">39</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">40 * @description : 驱动出口函数</span>
<span class="hljs-comment">41 * @param : 无</span>
<span class="hljs-comment">42 * @return : 无</span>
<span class="hljs-comment">43 */</span>
<span class="hljs-number">44</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
45 &#123;
<span class="hljs-number">46</span> 		i2c_del_driver(&amp;ft5x06_ts_driver);
<span class="hljs-number">47</span> &#125;
<span class="hljs-number">48</span>
<span class="hljs-number">49</span> module_init(xxx_init);
<span class="hljs-number">50</span> module_exit(xxx_exit);
<span class="hljs-number">51</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-number">52</span> MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>I2C 驱动框架已经进行了详细的讲解，这里就不再赘述了。当设备树中触摸 IC的设备节点和驱动匹配以后，示例代码中第 21 行的 xxx_ts_probe 函数就会执行，我们可以在此函数中初始化触摸 IC，中断和 input 子系统等。</p>
<h4 id="2、初始化触摸-IC-、中断和-input-子系统"><a href="#2、初始化触摸-IC-、中断和-input-子系统" class="headerlink" title="2、初始化触摸 IC 、中断和 input 子系统"></a>2、初始化触摸 IC 、中断和 input 子系统</h4><p>初始化操作都是在 xxx_ts_probe 函数中完成，参考框架如下所示(以下代码中步骤顺序可以自行调整，不一定按照示例框架来)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_ts_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>
2 &#123;
<span class="hljs-number">3</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input</span>;</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span> 		<span class="hljs-comment">/* 1、初始化 I2C */</span>
<span class="hljs-number">6</span> 		......
<span class="hljs-number">7</span>
<span class="hljs-number">8</span> 		<span class="hljs-comment">/* 2，申请中断， */</span>
<span class="hljs-number">9</span> 		devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="hljs-literal">NULL</span>,
<span class="hljs-number">10</span> 							xxx_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
<span class="hljs-number">11</span> 							client-&gt;name, &amp;xxx);
<span class="hljs-number">12</span> 		......
<span class="hljs-number">13</span>
<span class="hljs-number">14</span> 		<span class="hljs-comment">/* 3，input 设备申请与初始化 */</span>
<span class="hljs-number">15</span> 		input = devm_input_allocate_device(&amp;client-&gt;dev);
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> 		input-&gt;name = client-&gt;name;
<span class="hljs-number">18</span> 		input-&gt;id.bustype = BUS_I2C;
<span class="hljs-number">19</span> 		input-&gt;dev.parent = &amp;client-&gt;dev;
<span class="hljs-number">20</span> 		......
<span class="hljs-number">21</span>
<span class="hljs-number">22</span> 		<span class="hljs-comment">/* 4，初始化 input 和 MT */</span>
<span class="hljs-number">23</span> 		__set_bit(EV_ABS, input-&gt;evbit);
<span class="hljs-number">24</span> 		__set_bit(BTN_TOUCH, input-&gt;keybit);
<span class="hljs-number">25</span>
<span class="hljs-number">26</span> 		input_set_abs_params(input, ABS_X, <span class="hljs-number">0</span>, width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-number">27</span> 		input_set_abs_params(input, ABS_Y, <span class="hljs-number">0</span>, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-number">28</span> 		input_set_abs_params(input, ABS_MT_POSITION_X,<span class="hljs-number">0</span>, width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-number">29</span> 		input_set_abs_params(input, ABS_MT_POSITION_Y,<span class="hljs-number">0</span>, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-number">30</span> 		input_mt_init_slots(input, MAX_SUPPORT_POINTS, <span class="hljs-number">0</span>);
<span class="hljs-number">31</span> 		......
<span class="hljs-number">32</span>
<span class="hljs-number">33</span> 		<span class="hljs-comment">/* 5，注册 input_dev */</span>
<span class="hljs-number">34</span> 		input_register_device(input);
<span class="hljs-number">35</span> 		......
<span class="hljs-number">36</span> &#125;</code></pre></div>

<ul>
<li><p>第 5~7 行，首先肯定是初始化触摸芯片，包括芯片的相关 IO，比如复位、中断等 IO 引脚，然后就是芯片本身的初始化，也就是配置触摸芯片的相关寄存器。</p>
</li>
<li><p>第 9 行，因为一般触摸芯片都是通过中断来向系统上报触摸点坐标信息的，因此我们需要初始化中断，这里又和第五十一章内容结合起来了。大家可能会发现第 9 行并没有使用request_irq 函数申请中断，而是采用了 devm_request_threaded_irq 这个函数，为什么使用这个函数呢？是不是 request_irq 函数不能使用？答案肯定不是的，这里用 request_irq 函数是绝对没问题的。那为何要用devm_request_threaded_irq 呢？这里我们就简单的介绍一下这个 API 函数，devm_request_threaded_irq 函数特点如下：</p>
<ul>
<li>①、用于申请中断，作用和 request_irq 函数类似。</li>
<li>②、此函数的作用是中断线程化，大家如果直接在网上搜索“devm_request_threaded_irq”会发现相关解释很少。但是大家去搜索 request_threaded_irq 函数就会有很多讲解的博客和帖子，这两个函数在名字上的差别就是前者比后者多了个“devm_”前缀，“devm_”前缀稍后讲解。大家应该注意到了“request_threaded_irq”相比“request_irq”多了个 threaded 函数，也就是线程的意思。那么为什么要中断线程化呢？我们都是知道硬件中断具有最高优先级，不论什么时候只要硬件中断发生，那么内核都会终止当前正在执行的操作，转而去执行中断处理程序(不考虑关闭中断和中断优先级的情况)，如果中断非常频繁的话那么内核将会频繁的执行中断处理程序，导致任务得不到及时的处理。中断线程化以后中断将作为内核线程运行，而且也可以被赋予不同的优先级，任务的优先级可能比中断线程的优先级高，这样做的目的就是保证高优先级的任务能被优先处理。大家可能会疑问，前面不是说可以将比较耗时的中断放到下半部(bottom half)处理吗？虽然下半部可以被延迟处理，但是依旧先于线程执行，中断线程化可以让这些比<br>较耗时的下半部与进程进行公平竞争。要注意，并不是所有的中断都可以被线程化，重要的中断就不能这么操作。对于触摸屏而言只要手指放到屏幕上，它可能就会一直产生中断(视具体芯片而定，FT5426 是这样的)，中断处理程序里面需要通过 I2C 读取触摸信息并上报给内核，I2C 的速度最大只有 400KHz，算是低速外设。不断的产生中断、读取触摸信息、上报信息会导致处理器在触摸中断上花费大量的时间，但是触摸相对来说不是那么重要的事件，因此可以将触摸中断线程化。如果你觉得触摸中断很重要，那么就可以不将其进行线程化处理。总之，要不要将一个中断进行线程化处理是需要自己根据实际情况去衡量的。linux 内核自带的 goodix.c(汇顶科技)、mms114.c(MELFAS 公司)、zforce_ts.c(zForce 公司)等多点电容触摸 IC 驱动程序都采用了中断线程化，当然也有一些驱动没有采用中断线程化。</li>
<li>③、最后来看一下“devm_”前缀，在 linux 内核中有很多的申请资源类的 API 函数都有对应的“devm_”前缀版本。比如 devm_request_irq 和 request_irq 这两个函数，这两个函数都是申请中断的，我们使用 request_irq 函数申请中断的时候，如果驱动初始化失败的话就要调用free_irq 函数对申请成功的 irq 进行释放，卸载驱动的时候也需要我们手动调用 free_irq 来释放irq。假如我们的驱动里面申请了很多资源，比如：gpio、irq、input_dev，那么就需要添加很多goto 语句对其做处理，当这样的标签多了以后代码看起来就不整洁了。“devm_”函数就是为了处理这种情况而诞生的，“devm_”函数最大的作用就是：<ul>
<li>使用“devm_ ”前缀的函数申请到的资源可以由系统自动释放，不需要我们手动处理。如果我们使用 devm_request_threaded_irq 函数来申请中断，那么就不需要我们再调用free_irq 函数对其进行释放。大家可以注意一下，带有“devm_”前缀的都是一些和设备资源管理有关的函数。关于“devm_”函数的实现原理这里就不做详细的讲解了，我们的重点在于学会如何使用这些 API 函数，感兴趣的可以查阅一些其他文档或者帖子来看一下“devm_”函数的实现原理。</li>
</ul>
</li>
</ul>
</li>
<li><p>第 15 行，接下来就是申请 input_dev，因为多点电容触摸属于 input 子系统。这里同样使用devm_input_allocate_device 函数来申请 input_dev，也就是我们前面讲解的 input_allocate_device函数加“devm_”前缀版本。申请到 input_dev 以后还需要对其进行初始化操作。</p>
</li>
<li><p>第 23~24 行，设置 input_dev 需要上报的事件为 EV_ABS 和 BTN_TOUCH，因为多点电容屏的触摸坐标为绝对值，因此需要上报 EV_ABS 事件。触摸屏有按下和抬起之分，因此需要上报 BTN_TOUCH 按键。</p>
</li>
<li><p>第 26~29 行，调用 input_set_abs_params 函数设置 EV_ABS 事件需要上报 ABS_X、ABS_Y、ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。单点触摸需要上报 ABS_X 和 ABS_Y，对于多点触摸需要上报 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。</p>
</li>
<li><p>第 30 行，调用 input_mt_init_slots 函数初始化多点电容触摸的 slots。</p>
</li>
<li><p>第 34 行，调用 input_register_device 函数系统注册前面申请到的 input_dev。</p>
</li>
</ul>
<h4 id="3、上报坐标信息"><a href="#3、上报坐标信息" class="headerlink" title="3、上报坐标信息"></a>3、上报坐标信息</h4><p>最后就是在中断服务程序中上报读取到的坐标信息，根据所使用的多点电容触摸设备类型选择使用 Type A 还是 Type B 时序。由于大多数的设备都是 Type B 类型，因此这里就以 Type B类型为例讲解一下上报过程，参考驱动框架如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">xxx_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>
2 &#123;
<span class="hljs-number">3</span>
<span class="hljs-number">4</span> 		<span class="hljs-type">int</span> num; <span class="hljs-comment">/* 触摸点数量 */</span>
<span class="hljs-number">5</span> 		<span class="hljs-type">int</span> x[n], y[n]; <span class="hljs-comment">/* 保存坐标值 */</span>
<span class="hljs-number">6</span>
<span class="hljs-number">7</span> 		<span class="hljs-comment">/* 1、从触摸芯片获取各个触摸点坐标值 */</span>
<span class="hljs-number">8</span> 		......
<span class="hljs-number">9</span>
<span class="hljs-number">10</span> 		<span class="hljs-comment">/* 2、上报每一个触摸点坐标 */</span>
<span class="hljs-number">11</span> 		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;
<span class="hljs-number">12</span> 			input_mt_slot(input, id);
<span class="hljs-number">13</span> 			input_mt_report_slot_state(input, MT_TOOL_FINGER, <span class="hljs-literal">true</span>);
<span class="hljs-number">14</span> 			input_report_abs(input, ABS_MT_POSITION_X, x[i]);
<span class="hljs-number">15</span> 			input_report_abs(input, ABS_MT_POSITION_Y, y[i]);
<span class="hljs-number">16</span> 		&#125;
<span class="hljs-number">17</span> 		......
<span class="hljs-number">18</span>
<span class="hljs-number">19</span> 		input_sync(input);
<span class="hljs-number">20</span> 		......
<span class="hljs-number">21</span>
<span class="hljs-number">22</span> 		<span class="hljs-keyword">return</span> IRQ_HANDLED;
<span class="hljs-number">23</span> &#125;</code></pre></div>

<p>进入中断处理程序以后首先肯定是从触摸 IC 里面读取触摸坐标以及触摸点数量，假设触摸点数量保存到 num 变量，触摸点坐标存放到 x，y 数组里面。</p>
<ul>
<li>第 11~16 行，循环上报每一个触摸点坐标，一定要按照 Type B 类型的时序进行，这个已经在前面小节进行详细的讲解，这里就不再赘述了。</li>
<li>第 19 行，每一轮触摸点坐标上报完毕以后就调用一次 input_sync 函数发送一个SYN_REPORT 事件。</li>
</ul>
<p>关于多点电容触摸驱动框架就讲解到这里，接下来我们就实际编写一个多点电容触摸驱动程序。</p>
<h2 id="硬件原理图分析"><a href="#硬件原理图分析" class="headerlink" title="硬件原理图分析"></a>硬件原理图分析</h2><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905142552964.png" srcset="/img/loading.gif" lazyload alt="image-20200905142552964"></p>
<h2 id="试验程序编写"><a href="#试验程序编写" class="headerlink" title="试验程序编写"></a>试验程序编写</h2><p>本试验以正点原子的 ATK7084(7 寸 800*480 分辨率)和 ATK7016(7 寸 1024*600 分辨率)这两款屏幕所使用的 FT5426 触摸芯片为例，讲解如何编写多点电容触摸驱动。</p>
<h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1| 修改设备树"></a>1| 修改设备树</h3><h4 id="1、添加-FT5426-所使用的-IO"><a href="#1、添加-FT5426-所使用的-IO" class="headerlink" title="1、添加 FT5426  所使用的 IO"></a>1、添加 FT5426  所使用的 IO</h4><p>FT5426 触摸芯片用到了 4 个 IO，一个复位 IO、一个中断 IO、I2C2 的 SCL 和 SDA，所以我们需要先在设备树中添加 IO 相关的信息。复位 IO 和中断 IO 是普通的 GPIO，因此这两个 IO可以放到同一个节点下去描述，I2C2 的 SCL 和 SDA 属于 I2C2，因此这两个要放到同一个节点下去描述。首先是复位 IO 和中断 IO，imx6ull-lxg-emmc.dts 文件里面默认有个名为“pinctrl_tsc”的节点，如果被删除了的话就自行创建，在此节点下添加触摸屏的中断引脚信息，修改以后的“pinctrl_tsc”节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_tsc: tscgrp &#123;
<span class="hljs-number">2</span> 		fsl,pins = &lt;
<span class="hljs-number">3</span> 			MX6UL_PAD_GPIO1_IO09__GPIO1_IO09 <span class="hljs-number">0xF080</span> <span class="hljs-comment">/* TSC_INT */</span>
<span class="hljs-number">4</span> 		&gt;;
<span class="hljs-number">5</span> &#125;;</code></pre></div>

<p>触摸屏复位引脚使用的是 SNVS_TAMPER9，因此复位引脚信息要添加到 iomuxc_snvs 节点下，在 iomuxc_snvs 节点新建一个名为 pinctrl_tsc_reset 的子节点，然后在此子节点里面输入复位引脚配置信息即可，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_tsc_reset: tsc_reset &#123;
<span class="hljs-number">2</span> 		fsl,pins = &lt;
<span class="hljs-number">3</span> 			MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09 <span class="hljs-number">0x10B0</span>
<span class="hljs-number">4</span> 		&gt;;
<span class="hljs-number">5</span> &#125;;</code></pre></div>

<p>继续添加 I2C2 的 SCL 和 SDA 这两个 IO 信息，imx6ull-lxg-emmc.dts 里面默认就已经添加了 I2C2 的 IO 信息，这是 NXP 官方添加的，所以不需要我们去修改。找到“pinctrl_i2c2”节点，此节点就是用于描述 I2C2 的 IO 信息，节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_i2c2: i2c2grp &#123;
<span class="hljs-number">2</span> 		fsl,pins = &lt;
<span class="hljs-number">3</span> 			MX6UL_PAD_UART5_TX_DATA__I2C2_SCL <span class="hljs-number">0x4001b8b0</span>
<span class="hljs-number">4</span> 			MX6UL_PAD_UART5_RX_DATA__I2C2_SDA <span class="hljs-number">0x4001b8b0</span>
<span class="hljs-number">5</span> 		&gt;;
<span class="hljs-number">6</span> &#125;;</code></pre></div>

<p>最后，一定要检查一下设备树，确保触摸屏所使用的 IO 没有被其他的外设使用，如果有的话就需要将其屏蔽掉，保证只有触摸屏用到了这四个 IO。</p>
<h4 id="2-、添加-FT5426-节点"><a href="#2-、添加-FT5426-节点" class="headerlink" title="2 、添加 FT5426  节点"></a>2 、添加 FT5426  节点</h4><p>FT5426 这个触摸 IC 挂载 I2C2 下，因此需要向 I2C2 节点下添加一个子节点，此子节点用于描述 FT5426，添加完成以后的 I2C2 节点内容如下所示(省略掉其他挂载到 I2C2 下的设备)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;i2c2 &#123;
<span class="hljs-number">2</span> 		clock_frequency = &lt;<span class="hljs-number">100000</span>&gt;;
<span class="hljs-number">3</span> 		pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">4</span> 		pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c2&gt;;
<span class="hljs-number">5</span> 		status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">6</span>
<span class="hljs-number">7</span>	 	<span class="hljs-comment">/****************************/</span>
<span class="hljs-number">8</span> 		<span class="hljs-comment">/* 省略掉其他的设备节点 */</span>
<span class="hljs-number">9</span> 		<span class="hljs-comment">/****************************/</span>
<span class="hljs-number">10</span>
<span class="hljs-number">11</span> 		<span class="hljs-comment">/* firestaradmin FT5406/FT5426 */</span>
<span class="hljs-number">12</span> 		ft5426: ft5426@<span class="hljs-number">38</span> &#123;
<span class="hljs-number">13</span> 			compatible = <span class="hljs-string">&quot;edt,edt-ft5426&quot;</span>;
<span class="hljs-number">14</span> 			reg = &lt;<span class="hljs-number">0x38</span>&gt;;
<span class="hljs-number">15</span> 			pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">16</span> 			pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_tsc
<span class="hljs-number">17</span> 					  	 &amp;pinctrl_tsc_reset &gt;; 
<span class="hljs-number">18</span> 			interrupt-parent = &lt;&amp;gpio1&gt;;
<span class="hljs-number">19</span> 			interrupts = &lt;<span class="hljs-number">9</span> <span class="hljs-number">0</span>&gt;;
<span class="hljs-number">20</span> 			reset-gpios = &lt;&amp;gpio5 <span class="hljs-number">9</span> GPIO_ACTIVE_LOW&gt;;
<span class="hljs-number">21</span> 			interrupt-gpios = &lt;&amp;gpio1 <span class="hljs-number">9</span> GPIO_ACTIVE_LOW&gt;;
<span class="hljs-number">22</span> 		&#125;;
<span class="hljs-number">23</span> &#125;;</code></pre></div>

<p>第 12 行，触摸屏所使用的 FT5426 芯片节点，挂载 I2C2 节点下，FT5426 的器件地址为0X38。<br>第 14 行，reg 属性描述 FT5426 的器件地址为 0x38。<br>第 16 和 17 行，pinctrl-0 属性描述 FT5426 的复位 IO 和中断 IO 所使用的节点为 pinctrl_tsc和 pinctrl_tsc_reset。<br>第 18 行，interrupt-parent 属性描述中断 IO 对应的 GPIO 组为 GPIO1。<br>第 19 行，interrupts 属性描述中断 IO 对应的是 GPIO1 组的 IOI09。<br>第 20 行，reset-gpios 属性描述复位 IO 对应的 GPIO 为 GPIO5_IO09。<br>第 21 行，interrupt-gpios 属性描述中断 IO 对应的 GPIO 为 GPIO1_IO09。</p>
<h3 id="2-编写多点电容触摸驱动"><a href="#2-编写多点电容触摸驱动" class="headerlink" title="2| 编写多点电容触摸驱动"></a>2| 编写多点电容触摸驱动</h3><p>新建名为“23_multitouch”的文件夹，然后在 23_multitouch 文件夹里面创建 vscode 工程，工作区命名为“multitouch”。工程创建好以后新建 ft5x06.c 这个驱动文件，在里面输入如下所示内容:</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ratelimit.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/debugfs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/mt.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/touchscreen.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/edt-ft5x06.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span>
<span class="hljs-comment">/***************************************************************</span>
<span class="hljs-comment">文件名		: ft5x06.c</span>
<span class="hljs-comment">版本	   	: V1.0</span>
<span class="hljs-comment">描述	   	: FT5X06，包括FT5206、FT5426等触摸屏驱动程序</span>
<span class="hljs-comment">***************************************************************/</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SUPPORT_POINTS		5			<span class="hljs-comment">/* 5点触摸 	*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_DOWN		0x00		<span class="hljs-comment">/* 按下 	*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_UP			0x01		<span class="hljs-comment">/* 抬起 	*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_ON			0x02		<span class="hljs-comment">/* 接触 	*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_RESERVED	0x03		<span class="hljs-comment">/* 保留 	*/</span></span>

<span class="hljs-comment">/* FT5X06寄存器相关宏定义 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FT5X06_TD_STATUS_REG	0X02		<span class="hljs-comment">/*	状态寄存器地址 		*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FT5x06_DEVICE_MODE_REG	0X00 		<span class="hljs-comment">/* 模式寄存器 			*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FT5426_IDG_MODE_REG		0XA4		<span class="hljs-comment">/* 中断模式				*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FT5X06_READLEN			29			<span class="hljs-comment">/* 要读取的寄存器个数 	*/</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ft5x06_dev</span> &#123;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>	*<span class="hljs-title">nd</span>;</span> 				<span class="hljs-comment">/* 设备节点 		*/</span>
	<span class="hljs-type">int</span> irq_pin,reset_pin;					<span class="hljs-comment">/* 中断和复位IO		*/</span>
	<span class="hljs-type">int</span> irqnum;								<span class="hljs-comment">/* 中断号    		*/</span>
	<span class="hljs-type">void</span> *private_data;						<span class="hljs-comment">/* 私有数据 		*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input</span>;</span>				<span class="hljs-comment">/* input结构体 		*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span>;</span>				<span class="hljs-comment">/* I2C客户端 		*/</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ft5x06_dev</span> <span class="hljs-title">ft5x06</span>;</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description     : 复位FT5X06</span>
<span class="hljs-comment"> * @param - client 	: 要操作的i2c</span>
<span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span>
<span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_ts_reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> ft5x06_dev *dev)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (gpio_is_valid(dev-&gt;reset_pin)) &#123;  		<span class="hljs-comment">/* 检查IO是否有效 */</span>
		<span class="hljs-comment">/* 申请复位IO，并且默认输出低电平 */</span>
		ret = devm_gpio_request_one(&amp;client-&gt;dev,	
					dev-&gt;reset_pin, GPIOF_OUT_INIT_LOW,
					<span class="hljs-string">&quot;edt-ft5x06 reset&quot;</span>);
		<span class="hljs-keyword">if</span> (ret) &#123;
			<span class="hljs-keyword">return</span> ret;
		&#125;

		msleep(<span class="hljs-number">5</span>);
		gpio_set_value(dev-&gt;reset_pin, <span class="hljs-number">1</span>);	<span class="hljs-comment">/* 输出高电平，停止复位 */</span>
		msleep(<span class="hljs-number">300</span>);
	&#125;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 从FT5X06读取多个寄存器数据</span>
<span class="hljs-comment"> * @param - dev:  ft5x06设备</span>
<span class="hljs-comment"> * @param - reg:  要读取的寄存器首地址</span>
<span class="hljs-comment"> * @param - val:  读取到的数据</span>
<span class="hljs-comment"> * @param - len:  要读取的数据长度</span>
<span class="hljs-comment"> * @return 		: 操作结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ft5x06_dev *dev, u8 reg, <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> len)</span>
&#123;
	<span class="hljs-type">int</span> ret;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>[2];</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;client;

	<span class="hljs-comment">/* msg[0]为发送要读取的首地址 */</span>
	msg[<span class="hljs-number">0</span>].addr = client-&gt;addr;			<span class="hljs-comment">/* ft5x06地址 */</span>
	msg[<span class="hljs-number">0</span>].flags = <span class="hljs-number">0</span>;					<span class="hljs-comment">/* 标记为发送数据 */</span>
	msg[<span class="hljs-number">0</span>].buf = &amp;reg;					<span class="hljs-comment">/* 读取的首地址 */</span>
	msg[<span class="hljs-number">0</span>].len = <span class="hljs-number">1</span>;						<span class="hljs-comment">/* reg长度*/</span>

	<span class="hljs-comment">/* msg[1]读取数据 */</span>
	msg[<span class="hljs-number">1</span>].addr = client-&gt;addr;			<span class="hljs-comment">/* ft5x06地址 */</span>
	msg[<span class="hljs-number">1</span>].flags = I2C_M_RD;			<span class="hljs-comment">/* 标记为读取数据*/</span>
	msg[<span class="hljs-number">1</span>].buf = val;					<span class="hljs-comment">/* 读取数据缓冲区 */</span>
	msg[<span class="hljs-number">1</span>].len = len;					<span class="hljs-comment">/* 要读取的数据长度*/</span>

	ret = i2c_transfer(client-&gt;adapter, msg, <span class="hljs-number">2</span>);
	<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">2</span>) &#123;
		ret = <span class="hljs-number">0</span>;
	&#125; <span class="hljs-keyword">else</span> &#123;
		ret = -EREMOTEIO;
	&#125;
	<span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 向ft5x06多个寄存器写入数据</span>
<span class="hljs-comment"> * @param - dev:  ft5x06设备</span>
<span class="hljs-comment"> * @param - reg:  要写入的寄存器首地址</span>
<span class="hljs-comment"> * @param - val:  要写入的数据缓冲区</span>
<span class="hljs-comment"> * @param - len:  要写入的数据长度</span>
<span class="hljs-comment"> * @return 	  :   操作结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> s32 <span class="hljs-title function_">ft5x06_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 *buf, u8 len)</span>
&#123;
	u8 b[<span class="hljs-number">256</span>];
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;client;
	
	b[<span class="hljs-number">0</span>] = reg;					<span class="hljs-comment">/* 寄存器首地址 */</span>
	<span class="hljs-built_in">memcpy</span>(&amp;b[<span class="hljs-number">1</span>],buf,len);		<span class="hljs-comment">/* 将要写入的数据拷贝到数组b里面 */</span>
		
	msg.addr = client-&gt;addr;	<span class="hljs-comment">/* ft5x06地址 */</span>
	msg.flags = <span class="hljs-number">0</span>;				<span class="hljs-comment">/* 标记为写数据 */</span>

	msg.buf = b;				<span class="hljs-comment">/* 要写入的数据缓冲区 */</span>
	msg.len = len + <span class="hljs-number">1</span>;			<span class="hljs-comment">/* 要写入的数据长度 */</span>

	<span class="hljs-keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 向ft5x06指定寄存器写入指定的值，写一个寄存器</span>
<span class="hljs-comment"> * @param - dev:  ft5x06设备</span>
<span class="hljs-comment"> * @param - reg:  要写的寄存器</span>
<span class="hljs-comment"> * @param - data: 要写入的值</span>
<span class="hljs-comment"> * @return   :    无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ft5x06_write_reg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 data)</span>
&#123;
	u8 buf = <span class="hljs-number">0</span>;
	buf = data;
	ft5x06_write_regs(dev, reg, &amp;buf, <span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description     : FT5X06中断服务函数</span>
<span class="hljs-comment"> * @param - irq 	: 中断号 </span>
<span class="hljs-comment"> * @param - dev_id	: 设备结构。</span>
<span class="hljs-comment"> * @return 			: 中断执行结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">ft5x06_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ft5x06_dev</span> *<span class="hljs-title">multidata</span> =</span> dev_id;

	u8 rdbuf[<span class="hljs-number">29</span>];
	<span class="hljs-type">int</span> i, type, x, y, id;
	<span class="hljs-type">int</span> offset, tplen;
	<span class="hljs-type">int</span> ret;
	<span class="hljs-type">bool</span> down;

	offset = <span class="hljs-number">1</span>; 	<span class="hljs-comment">/* 偏移1，也就是0X02+1=0x03,从0X03开始是触摸值 */</span>
	tplen = <span class="hljs-number">6</span>;		<span class="hljs-comment">/* 一个触摸点有6个寄存器来保存触摸值 */</span>

	<span class="hljs-built_in">memset</span>(rdbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(rdbuf));		<span class="hljs-comment">/* 清除 */</span>

	<span class="hljs-comment">/* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 */</span>
	ret = ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);
	<span class="hljs-keyword">if</span> (ret) &#123;
		<span class="hljs-keyword">goto</span> fail;
	&#125;

	<span class="hljs-comment">/* 上报每一个触摸点坐标 */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_SUPPORT_POINTS; i++) &#123;
		u8 *buf = &amp;rdbuf[i * tplen + offset];

		<span class="hljs-comment">/* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span>
<span class="hljs-comment">		 * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span>
<span class="hljs-comment">		 * bit5:4  保留</span>
<span class="hljs-comment">		 * bit3:0  X轴触摸点的11~8位。</span>
<span class="hljs-comment">		 */</span>
		type = buf[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">6</span>;     <span class="hljs-comment">/* 获取触摸类型 */</span>
		<span class="hljs-keyword">if</span> (type == TOUCH_EVENT_RESERVED)
			<span class="hljs-keyword">continue</span>;
 
		<span class="hljs-comment">/* 我们所使用的触摸屏和FT5X06是反过来的 */</span>
		x = ((buf[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">3</span>]) &amp; <span class="hljs-number">0x0fff</span>;
		y = ((buf[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">1</span>]) &amp; <span class="hljs-number">0x0fff</span>;
		
		<span class="hljs-comment">/* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span>
<span class="hljs-comment">		 * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span>
<span class="hljs-comment">		 * bit3:0  Y轴触摸点的11~8位。</span>
<span class="hljs-comment">		 */</span>
		id = (buf[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>;
		down = type != TOUCH_EVENT_UP;

		input_mt_slot(multidata-&gt;input, id);
		input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);

		<span class="hljs-keyword">if</span> (!down)
			<span class="hljs-keyword">continue</span>;

		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);
		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);
	&#125;

	input_mt_report_pointer_emulation(multidata-&gt;input, <span class="hljs-literal">true</span>);
	input_sync(multidata-&gt;input);

fail:
	<span class="hljs-keyword">return</span> IRQ_HANDLED;

&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description     : FT5x06中断初始化</span>
<span class="hljs-comment"> * @param - client 	: 要操作的i2c</span>
<span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span>
<span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_ts_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> ft5x06_dev *dev)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	<span class="hljs-comment">/* 1,申请中断GPIO */</span>
	<span class="hljs-keyword">if</span> (gpio_is_valid(dev-&gt;irq_pin)) &#123;
		ret = devm_gpio_request_one(&amp;client-&gt;dev, dev-&gt;irq_pin,
					GPIOF_IN, <span class="hljs-string">&quot;edt-ft5x06 irq&quot;</span>);
		<span class="hljs-keyword">if</span> (ret) &#123;
			dev_err(&amp;client-&gt;dev,
				<span class="hljs-string">&quot;Failed to request GPIO %d, error %d\n&quot;</span>,
				dev-&gt;irq_pin, ret);
			<span class="hljs-keyword">return</span> ret;
		&#125;
	&#125;

	<span class="hljs-comment">/* 2，申请中断,client-&gt;irq就是IO中断， */</span>
	ret = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="hljs-literal">NULL</span>,
					ft5x06_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
					client-&gt;name, &amp;ft5x06);
	<span class="hljs-keyword">if</span> (ret) &#123;
		dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to request touchscreen IRQ.\n&quot;</span>);
		<span class="hljs-keyword">return</span> ret;
	&#125;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

 <span class="hljs-comment">/*</span>
<span class="hljs-comment">  * @description     : i2c驱动的probe函数，当驱动与</span>
<span class="hljs-comment">  *                    设备匹配以后此函数就会执行</span>
<span class="hljs-comment">  * @param - client  : i2c设备</span>
<span class="hljs-comment">  * @param - id      : i2c设备ID</span>
<span class="hljs-comment">  * @return          : 0，成功;其他负值,失败</span>
<span class="hljs-comment">  */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_ts_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	ft5x06.client = client;

	<span class="hljs-comment">/* 1，获取设备树中的中断和复位引脚 */</span>
	ft5x06.irq_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="hljs-string">&quot;interrupt-gpios&quot;</span>, <span class="hljs-number">0</span>);
	ft5x06.reset_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="hljs-string">&quot;reset-gpios&quot;</span>, <span class="hljs-number">0</span>);

	<span class="hljs-comment">/* 2，复位FT5x06 */</span>
	ret = ft5x06_ts_reset(client, &amp;ft5x06);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">goto</span> fail;
	&#125;

	<span class="hljs-comment">/* 3，初始化中断 */</span>
	ret = ft5x06_ts_irq(client, &amp;ft5x06);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">goto</span> fail;
	&#125;

	<span class="hljs-comment">/* 4，初始化FT5X06 */</span>
	ft5x06_write_reg(&amp;ft5x06, FT5x06_DEVICE_MODE_REG, <span class="hljs-number">0</span>); 	<span class="hljs-comment">/* 进入正常模式 	*/</span>
	ft5x06_write_reg(&amp;ft5x06, FT5426_IDG_MODE_REG, <span class="hljs-number">1</span>); 		<span class="hljs-comment">/* FT5426中断模式	*/</span>

	<span class="hljs-comment">/* 5，input设备注册 */</span>
	ft5x06.input = devm_input_allocate_device(&amp;client-&gt;dev);
	<span class="hljs-keyword">if</span> (!ft5x06.input) &#123;
		ret = -ENOMEM;
		<span class="hljs-keyword">goto</span> fail;
	&#125;
	ft5x06.input-&gt;name = client-&gt;name;
	ft5x06.input-&gt;id.bustype = BUS_I2C;
	ft5x06.input-&gt;dev.parent = &amp;client-&gt;dev;

	__set_bit(EV_KEY, ft5x06.input-&gt;evbit);
	__set_bit(EV_ABS, ft5x06.input-&gt;evbit);
	__set_bit(BTN_TOUCH, ft5x06.input-&gt;keybit);

	input_set_abs_params(ft5x06.input, ABS_X, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	input_set_abs_params(ft5x06.input, ABS_Y, <span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	input_set_abs_params(ft5x06.input, ABS_MT_POSITION_X,<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	input_set_abs_params(ft5x06.input, ABS_MT_POSITION_Y,<span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);	     
	ret = input_mt_init_slots(ft5x06.input, MAX_SUPPORT_POINTS, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span> (ret) &#123;
		<span class="hljs-keyword">goto</span> fail;
	&#125;

	ret = input_register_device(ft5x06.input);
	<span class="hljs-keyword">if</span> (ret)
		<span class="hljs-keyword">goto</span> fail;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

fail:
	<span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span>
<span class="hljs-comment"> * @param - client 	: i2c设备</span>
<span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_ts_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span>
&#123;	
	<span class="hljs-comment">/* 释放input_dev */</span>
	input_unregister_device(ft5x06.input);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;


<span class="hljs-comment">/*</span>
<span class="hljs-comment"> *  传统驱动匹配表</span>
<span class="hljs-comment"> */</span> 
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">ft5x06_ts_id</span>[] =</span> &#123;
	&#123; <span class="hljs-string">&quot;edt-ft5206&quot;</span>, <span class="hljs-number">0</span>, &#125;,
	&#123; <span class="hljs-string">&quot;edt-ft5426&quot;</span>, <span class="hljs-number">0</span>, &#125;,
	&#123; <span class="hljs-comment">/* sentinel */</span> &#125;
&#125;;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * 设备树匹配表 </span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">ft5x06_of_match</span>[] =</span> &#123;
	&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5206&quot;</span>, &#125;,
	&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5426&quot;</span>, &#125;,
	&#123; <span class="hljs-comment">/* sentinel */</span> &#125;
&#125;;

<span class="hljs-comment">/* i2c驱动结构体 */</span>	
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">ft5x06_ts_driver</span> =</span> &#123;
	.driver = &#123;
		.owner = THIS_MODULE,
		.name = <span class="hljs-string">&quot;edt_ft5x06&quot;</span>,
		.of_match_table = of_match_ptr(ft5x06_of_match),
	&#125;,
	.id_table = ft5x06_ts_id,
	.probe    = ft5x06_ts_probe,
	.remove   = ft5x06_ts_remove,
&#125;;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动入口函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ft5x06_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	ret = i2c_add_driver(&amp;ft5x06_ts_driver);

	<span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动出口函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">ft5x06_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	i2c_del_driver(&amp;ft5x06_ts_driver);
&#125;

module_init(ft5x06_init);
module_exit(ft5x06_exit);
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<ul>
<li><code>struct ft5x06_dev</code>定义一个设备结构体，存放多点电容触摸设备相关属性信息。</li>
<li><code>static struct ft5x06_dev ft5x06;</code>定义一个名为 ft5x06 的全局变量，变量类型就是上面定义的 ft5x06_dev 结构体。</li>
<li><strong>ft5x06_ts_reset 函数</strong>，用于初始化 FT5426 触摸芯片，其实就是设置 FT5426的复位 IO 为高电平，防止芯片复位。使用 devm_gpio_request_one 函数来申请复位 IO，关于“devm_”前缀的作用已经在前面小节做了详细的讲解。使用“devm_”前缀的API 函数申请的资源不需要我们手动释放，内核会处理，所以这里使用 devm_gpio_request_one函数申请 IO 以后不需要我们在卸载驱动的时候手动去释放此 IO。</li>
<li><strong>ft5x06_read_regs 函数</strong>，用于连续的读取 FT5426 内部寄存器数据，就是 I2C读取函数，在之前I2C实验有详细的讲解。</li>
<li><strong>ft5x06_write_regs 函数</strong>，用于向 FT5426 寄存器写入连续的数据，也就是 I2C写函数，同样在之前I2C实验有详细的讲解. ft5x06_write_reg 函数，对 ft5x06_write_regs 函数的简单封装，向 FT5426 指定寄存器写入一个数据，用于配置 FT5426。</li>
<li><strong>ft5x06_handler 函数</strong>，触摸屏中断服务函数，触摸点坐标的上报就是在此函数中完成的。通过 ft5x06_read_regs 函数读取 FT5426 的所有触摸点信息寄存器数据，从 0X02 这个地址开始，一共 29 个寄存器。 for 循环就是一个一个的上报触摸点坐标数据，使用Type B时序，这个我们已经在前面说了很多次了。最后通过input_sync函数上报 SYN_REPORT 事件。如果理解了前面讲解的 Type B 时序，那么此函数就很好看懂。</li>
<li><strong>ft5x06_ts_irq 函数</strong>，初始化 FT5426 的中断 IO，使用devm_gpio_request_one 函数申请中断 IO。使用函数 devm_request_threaded_irq 申请中断，中断处理函数为 ft5x06_handler。</li>
<li><strong>ft5x06_ts_probe函数</strong>，当 I2C 设备与驱动匹配以后此函数就会执行，一般在此函数中完成一些初始化工作。我们重点来看一下关于 input_dev 设备的初始化，申请并简单的初始化input_dev，设置input_dev需要上报的事件为 EV_KEY 和 EV_ABS，需要上报的按键码为 BTN_TOUCH。EV_KEY 是按键事件，用于上报触摸屏是否被按下，相当于把触摸屏当做一个按键。EV_ABS 是触摸点坐标数据，BTN_TOUCH 表示将触摸屏的按下和抬起用作 BTN_TOUCH 按键。调用input_set_abs_params函数设置EV_ABS 事件需要上报ABS_X、ABS_Y、ABS_MT_POSITION_X和 ABS_MT_POSITION_Y。单点触摸需要上报 ABS_X 和 ABS_Y，对于多点触摸需要上报ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。调用 input_mt_init_slots 函数初始化 slots，也就是最大触摸点数量，FT5426 是个 5 点电容触摸芯片，因此一共 5 个 slot。最后调用input_register_device 函数向系统注册 input_dev。</li>
<li><strong>当卸载驱动的时候 ft5x06_ts_remove 函数就会执行</strong>，因为前面很多资源我们都是用“devm_”前缀函数来申请的，因此不需要手动释放。此函数只需要调用input_unregister_device 来释放掉前面添加到内核中的 input_dev。</li>
<li><strong>结束</strong>，剩下的就是 I2C 驱动框架那一套，已经在之前实验进行了详细的讲解。</li>
</ul>
<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><h3 id="1-编译驱动程序"><a href="#1-编译驱动程序" class="headerlink" title="1| 编译驱动程序"></a>1| 编译驱动程序</h3><p>编译成功以后就会生成一个名为“ft5x06.ko”的驱动模块文件。</p>
<h3 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2| 运行测试"></a>2| 运行测试</h3><p>编译设备树，然后使用新的设备树启动 linux 内核。多点电容触摸屏测试不需要编写专门的 APP，将上一小节编译出来 ft5x06.ko 拷贝到rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15 目录中，启动开发板，进入到目录lib&#x2F;modules&#x2F;4.1.15 中，输入如下命令加载 ft5x06.ko 这个驱动模块。</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">depmod //第一次加载驱动的时候需要运行此命令
modprobe ft5x06.ko  //加载驱动模块</code></pre></div>

<p>当驱动模块加载成功以后会有如图 所示信息输入：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150121781.png" srcset="/img/loading.gif" lazyload alt="image-20200905150121781"></p>
<p>驱动加载成功以后就会生成&#x2F;dev&#x2F;input&#x2F;eventX(X&#x3D;1,2,3…)，比如本实验的多点电容触摸驱动就会在我所使用的 ALPHA 开发板平台下就会生成&#x2F;dev&#x2F;input&#x2F;event2 这个文件，如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150208249.png" srcset="/img/loading.gif" lazyload alt="image-20200905150208249"></p>
<p>不同的平台 event 序号不同，也可能是 event3，event4 等，一切以实际情况为准！输入如下命令查看 event2，也就是多点电容触摸屏上报的原始数据：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">hexdump /dev/input/event2</code></pre></div>

<p>现在用一根手指触摸屏幕的右上角，然后再抬起，理论坐标值为(1023,0)，但是由于触摸误差的原因，大概率不会是绝对的(1023,0)，应该是在此值附近的一个触摸坐标值，实际的上报数据如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150308374.png" srcset="/img/loading.gif" lazyload alt="image-20200905150308374"></p>
<p>图上报的信息是按照 input_event 类型呈现的，这个同样在前面INPUT子系统实验做了详细的介绍，这里我们重点来分析一下，在多点电容触摸屏上其所代表的具体含义，将图中的数据进行整理，结果如下所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150825437.png" srcset="/img/loading.gif" lazyload alt="image-20200905150825437"></p>
<p>第 1 行，type 为 0x3，说明是一个 EV_ABS 事件，code 为 0x2f，为 ABS_MT_SLOT，因此这一行就是 input_mt_slot 函数上报的 ABS_MT_SLOT 事件。value&#x3D;0，说明接下来上报的是第一个触摸点坐标。</p>
<p>第 2 行 ， type 为 0x3 ， 说 明 是 一 个 EV_ABS 事 件 ， code 为 0x39 ， 也 就 是ABS_MT_TRACKING_ID ， 这 一 行 就 是 input_mt_report_slot_state 函 数 上 报ABS_MT_TRACKING_ID 事件。value&#x3D;5 说明给SLOT0 分配的 ID 为 5。</p>
<p>第 3 行，type 为 0x3，是一个 EV_ABS 事件，code 为 0x35，为 ABS_MT_POSITION_X，这一行就是 input_report_abs 函数上报的 ABS_MT_POSITION_X 事件，也就是触摸点的 X 轴坐标。value&#x3D;0x03ec&#x3D;1004，说明触摸点 X 轴坐标为 1004，属于屏幕右上角区域。</p>
<p>第 4 行，type 为 0x3，是一个 EV_ABS 事件，code 为 0x36，为 ABS_MT_POSITION_Y，这一行就是 input_mt_report_slot_state 函数上报的 ABS_MT_POSITION_Y 事件，也就是触摸点的 Y 轴坐标。value&#x3D;0x17&#x3D;23，说明 Y 轴坐标为 23，由此可以看出本次触摸的坐标为(1004,23)，处于屏幕右上角区域。</p>
<p>第 5 行，type 为 0x1，是一个 EV_KEY 事件，code&#x3D;0x14a，为 BTN_TOUCH，value&#x3D;0x1 表示触摸屏被按下。</p>
<p>第 6 行，type 为 0x3，是一个 EV_ABS 事件，code 为 0x0，为 ABS_X，用于单点触摸的时候上报 X 轴坐标。在这里和 ABS_MT_POSITION_X 相同，value 也为 0x3f0&#x3D;1008。ABS_X 是由input_mt_report_pointer_emulation 函数上报的。</p>
<p>第 7 行，type 为 0x3，是一个 EV_ABS 事件，code 为 0x1，为 ABS_Y，用于单点触摸的时候上报 Y 轴坐标。在这里和 ABS_MT_POSITION_Y 相同，value 也为 0x29&#x3D;41。ABS_Y 是由input_mt_report_pointer_emulation 函数上报的。</p>
<p>第 8 行，type 为 0x0，是一个 EV_SYN 事件，由 input_sync 函数上报。</p>
<p>第9行，type为0x3，是一个EV_ABS事件，code为0x39，也就是ABS_MT_TRACKING_ID，value&#x3D;0xffffffff&#x3D;-1，说明触摸点离开了屏幕。</p>
<p>第 10 行，type 为 0x1，是一个 EV_KEY 事件，code&#x3D;0x14a，为 BTN_TOUCH，value&#x3D;0x0表示手指离开触摸屏，也就是触摸屏没有被按下了。</p>
<p>第 11 行，type 为 0x0，是一个 EV_SYN 事件，由 input_sync 函数上报。以上就是一个触摸点的坐标上报过程，和我们前面讲解的 Type B 类型设备一致。</p>
<h3 id="3-将驱动添加到内核中"><a href="#3-将驱动添加到内核中" class="headerlink" title="3| 将驱动添加到内核中"></a>3| 将驱动添加到内核中</h3><p>前面我们一直将触摸驱动编译为模块，每次系统启动以后在手动加载驱动模块，这样很不方便。当我们把驱动调试成功以后一般都会将其编译到内核中，这样内核启动以后就会自动加载驱动，不需要我们再手动 modprobe 了。本节我们就来学习一下如何将 ft5x06.c 添加到 linux内核里面，步骤如下所示：</p>
<h4 id="1-、将驱动文件放到合适的位置"><a href="#1-、将驱动文件放到合适的位置" class="headerlink" title="1 、将驱动文件放到合适的位置"></a>1 、将驱动文件放到合适的位置</h4><p>首先肯定是在内核源码中找个合适的位置将 ft5x06.c 放进去，ft5x06.c 是个触摸屏驱动，因此我们需要查找一下 linux 内核里面触摸屏驱动放到了哪个目录下。linux 内核里面将触摸屏驱动放到了drivers&#x2F;input&#x2F;touchscreen 目录下，因此我们要将 ft5x06.c 拷贝到此目录下，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> ft5x06.c (内核源码目录)/drivers/input/touchscreen/ -f</code></pre></div>



<h4 id="2-、修改对应的-Makefile"><a href="#2-、修改对应的-Makefile" class="headerlink" title="2 、修改对应的 Makefile"></a>2 、修改对应的 Makefile</h4><p>修改 drivers&#x2F;input&#x2F;touchscreen 目录下的 Makefile，在最下面添加下面一行：</p>
<div class="hljs code-wrapper"><pre><code class="hljs makefile">obj-y += ft5x06.o</code></pre></div>

<p>完成以后如图 所示:</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905151355239.png" srcset="/img/loading.gif" lazyload alt="image-20200905151355239"></p>
<p>修改完成以后重新编译 linux 内核，然后用新的 zImage 启动开发板。如果驱动添加成功的话系统启动的时候就会输出如图所示的信息：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905151639612.png" srcset="/img/loading.gif" lazyload alt="image-20200905151639612"></p>
<p>从图可以看出，触摸屏驱动已经启动了，这个时候就会自动生成&#x2F;dev&#x2F;input&#x2F;evenvtX。在本实验中将触摸屏驱动添加到 linux 内核里面以后触摸屏对应的是 event1，而不是前面编译为模块对应的 event2，这一点一定要注意！输入如下命令，查看驱动工作是否正常：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">hexdump /dev/input/event1 //查看触摸屏原始数据上报信息</code></pre></div>

<p>结果如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905151800603.png" srcset="/img/loading.gif" lazyload alt="image-20200905151800603"></p>
<p>可以看出，坐标数据上报正常，说明驱动工作没问题。</p>
<h2 id="tslib-移植与使用"><a href="#tslib-移植与使用" class="headerlink" title="tslib  移植与使用"></a>tslib  移植与使用</h2><h3 id="1-tslib-移植"><a href="#1-tslib-移植" class="headerlink" title="1| tslib 移植"></a>1| tslib 移植</h3><p>tslib 是一个开源的第三方库，用于触摸屏性能调试，使用电阻屏的时候一般使用 tslib 进行校准。虽然电容屏不需要校准，但是由于电容屏加工的原因，有的时候其不一定精准，因此有时候也需要进行校准。最主要的是 tslib 提供了一些其他软件，我们可以通过这些软件来测试触摸屏工作是否正常。最新版本的 tslib 已经支持了多点电容触摸屏，因此可以通过 tslib 来直观的测试多点电容触摸屏驱动，这个要比观看 eventX 原始数据方便的多。tslib 的移植很简单，步骤如下：</p>
<h4 id="1-、获取-tslib-源码"><a href="#1-、获取-tslib-源码" class="headerlink" title="1 、获取 tslib  源码"></a>1 、获取 tslib  源码</h4><p>首先肯定是获取 tslib 的源码，git 地址为 <a target="_blank" rel="noopener" href="https://github.com/kergoth/tslib%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AF1.21%E3%80%82%E5%B0%86tslib%E6%BA%90%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%8F%91%E9%80%81%E5%88%B0">https://github.com/kergoth/tslib，目前最新的版本是1.21。将tslib源码压缩包发送到</a> ubuntu 中并解压，得到名为“tslib-1.21”的目录，此目录下就是 tslib 源码。</p>
<h4 id="2-、修改-tslib-源码所属用户"><a href="#2-、修改-tslib-源码所属用户" class="headerlink" title="2 、修改 tslib  源码所属用户"></a>2 、修改 tslib  源码所属用户</h4><p>修改解压得到的 tslib-1.21 目录所属用户为当前用户，这一步一定要做！否则在稍后的编译中会遇到各种问题。我当前 ubuntu 的登录用户名为“firestaradmin”，那么修改命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chown</span> firestaradmin:firestaradmin tslib-1.21 -R</code></pre></div>



<h4 id="3-、ubuntu-工具安装"><a href="#3-、ubuntu-工具安装" class="headerlink" title="3 、ubuntu  工具安装"></a>3 、ubuntu  工具安装</h4><p>编译 tslib 的时候需要先在 ubuntu 中安装一些文件，防止编译 tslib 过程中出错，命令如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">sudo apt-get install autoconf
sudo apt-get install automake
sudo apt-get install libtool</code></pre></div>



<h4 id="4-、编译-tslib"><a href="#4-、编译-tslib" class="headerlink" title="4 、编译 tslib"></a>4 、编译 tslib</h4><p>首先在 ubuntu 中创建一个名为“tslib”的目录存放编译结果，比如我们创建的 tslib 目录全路为：&#x2F;home&#x2F;firestaradmin&#x2F;linux&#x2F;tools&#x2F;tslib。接下来输入如下命令配置并编译 talib：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> tslib-1.21/ 		//进入 tslib 源码目录
./autogen.sh 
./configure --host=arm-linux-gnueabihf --prefix=/home/firestaradmin/linux/tools/tslib
make  //编译
make install  //安装</code></pre></div>

<p>注意，在使用.&#x2F;configure 配置 tslib 的时候“–host”参数指定编译器，“–prefix”参数指定编<br>译完成以后的 tslib 文件安装到哪里，这里肯定是安装到我们刚刚创建的“tslib”目录下。</p>
<p>完成以后 tslib 目录下的内容如图  所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905152923501.png" srcset="/img/loading.gif" lazyload alt="image-20200905152923501"></p>
<p>bin 目录下是可执行文件，包括 tslib 的测试工具。etc 目录下是 tslib 的配置文件，lib 目录下是相关的库文件。</p>
<p>将图 中的所有文件拷贝到开发板的根文件系统中，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">sudo <span class="hljs-built_in">cp</span> * -rf /home/firestaradmin/linux/nfs/rootfs</code></pre></div>

<h4 id="5、配置-tslib"><a href="#5、配置-tslib" class="headerlink" title="5、配置 tslib"></a>5、配置 tslib</h4><p>打开&#x2F;etc&#x2F;ts.conf 文件，找到下面这一行：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ceylon"><span class="hljs-keyword">module</span><span class="hljs-number">_</span>raw input</code></pre></div>

<p>如果上面这句前面有“#”的话就删除掉“#”。</p>
<p>打开&#x2F;etc&#x2F;profile 文件，在里面加入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> export TSLIB_TSDEVICE=/dev/input/event1
<span class="hljs-number">2</span> export TSLIB_CALIBFILE=/etc/pointercal
<span class="hljs-number">3</span> export TSLIB_CONFFILE=/etc/ts.conf
<span class="hljs-number">4</span> export TSLIB_PLUGINDIR=/lib/ts
<span class="hljs-number">5</span> export TSLIB_CONSOLEDEVICE=none
<span class="hljs-number">6</span> export TSLIB_FBDEVICE=/dev/fb0</code></pre></div>

<ul>
<li>第 1 行，TSLIB_TSDEVICE 表示触摸设备文件，这里设置为&#x2F;dev&#x2F;input&#x2F;event1，这个要根据具体情况设置，如果你的触摸设备文件为event2那么就应该设置为&#x2F;dev&#x2F;input&#x2F;event2，以此类推。</li>
<li>第 2 行，TSLIB_CALIBFILE 表示校准文件，如果进行屏幕校准的话校准结果就保存在这个文件中，这里设置校准文件为&#x2F;etc&#x2F;pointercal，此文件可以不存在，校准的时候会自动生成。</li>
<li>第 3 行，TSLIB_CONFFILE 表示触摸配置文件，文件为&#x2F;etc&#x2F;ts.conf，此文件在移植 tslib 的时候会生成。</li>
<li>第 4 行，TSLIB_PLUGINDIR 表示 tslib 插件目录位置，目录为&#x2F;lib&#x2F;ts。</li>
<li>第 5 行，TSLIB_CONSOLEDEVICE 表示控制台设置，这里不设置，因此为 none。</li>
<li>第 6 行，TSLIB_FBDEVICE 表示 FB 设备，也就是屏幕，根据实际情况配置，我的屏幕文件为&#x2F;dev&#x2F;fb0，因此这里设置为&#x2F;dev&#x2F;fb0。</li>
</ul>
<p>全部配置好以后重启开发板，然后就可以进行测试了。</p>
<h3 id="2-tslib-测试"><a href="#2-tslib-测试" class="headerlink" title="2| tslib  测试"></a>2| tslib  测试</h3><p>电容屏可以不用校准，如果是电阻屏就要先进行校准！校准的话输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">ts_calibrate</code></pre></div>

<p>校准完成以后如果不满意，或者不小心对电容屏做了校准，那么直接删除掉&#x2F;etc&#x2F;pointercal文件即可。</p>
<p>最后我们使用 ts_test_mt 这个软件来测试触摸屏工作是否正常，以及多点触摸是否有效，执行如下所示命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">ts_test_mt</code></pre></div>

<p>此命令会打开一个触摸测试界面，如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905153548331.png" srcset="/img/loading.gif" lazyload alt="image-20200905153548331"></p>
<p>在图 上有三个按钮“Drag”、“Draw”和“Quit”，这三个按钮的功能如下：</p>
<ul>
<li>Drag： ：拖拽按钮，默认就是此功能，大家可以看到屏幕中间有一个十字光标，我们可以通过触摸屏幕来拖拽此光标。一个触摸点一个十字光标，对于 5 点电容触摸屏，如果 5 个手指都放到屏幕上，那么就有 5 个光标，一个手指一个。</li>
<li>Draw： ：绘制按钮，按下此按钮我们就可以在屏幕上进行简单的绘制，可以通过此功能检测多点触摸工作是否正常。</li>
<li>Quit ：退出按钮，退出 ts_test_mt 测试软件。</li>
</ul>
<p>点击“Draw”按钮，使用绘制功能，5 个手指一起划过屏幕，如果多点电容屏工作正常的话就会在屏幕上留下 5 条线，如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905153619823.png" srcset="/img/loading.gif" lazyload alt="image-20200905153619823"></p>
<p>从图可以看出，屏幕上有 5 条线，说明 5 点电容触摸工作正常。这 5 跳线都是白色的，图 中由于拍照并处理的原因，导致 5 条线开起来不是白色的。</p>
<h2 id="使用内核自带的驱动"><a href="#使用内核自带的驱动" class="headerlink" title="使用内核自带的驱动"></a>使用内核自带的驱动</h2><p>Linux 内核已经集成了很多电容触摸 IC 的驱动文件，比如本章实验我们所使用 FT5426，本节我们就来学习一下，如何使用 Linux 内核自带的多点电容触摸驱动。在使用之前要先将前面我们自己添加到内核的 ft5x06.c这个文件从内核中去除掉 ， 只 需 要 修 改drivers&#x2F;input&#x2F;touchscreen&#x2F;Makefile 这个文件即可，将下面这一行删除掉：</p>
<div class="hljs code-wrapper"><pre><code class="hljs fix"><span class="hljs-attr">obj-y  +</span>=<span class="hljs-string"> ft5x06.o</span></code></pre></div>

<p>内核自带的 FT5426 的驱动文件为 drivers&#x2F;input&#x2F;touchscreen&#x2F;edt-ft5x06.c，此驱动文件不仅仅能够驱动 FT5426，FT5206、FT5406 这些都可以驱动。按照如下步骤来操作，学习如何使用此驱动。</p>
<h3 id="1-、修改-edt-ft5x06-c"><a href="#1-、修改-edt-ft5x06-c" class="headerlink" title="1 、修改 edt-ft5x06.c"></a>1 、修改 edt-ft5x06.c</h3><p>edt-ft5x06.c 直接使用的话是不行的，需要对其做修改，由于此文件太大，这里就不一一指出来如何修改了。我会将代码放到本篇末尾，大家可以参考看下，对比和原本的文件修改了哪里。</p>
<h3 id="2-、使能内核自带的-FT5X06-驱动"><a href="#2-、使能内核自带的-FT5X06-驱动" class="headerlink" title="2 、使能内核自带的 FT5X06  驱动"></a>2 、使能内核自带的 FT5X06  驱动</h3><p>edt-ft5x06.c 这个驱动默认是没有使能的，我们需要配置 Linux 内核，使能此驱动，通过图形化配置界面即可完成配置。进入 linux 内核源码目录，输入如下所示命令打开图形化配置界面：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span></code></pre></div>

<p>配置路径如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">Location:
-&gt; Device Drivers
    -&gt; Input device support
        -&gt; Generic input <span class="hljs-title function_">layer</span> <span class="hljs-params">(needed <span class="hljs-keyword">for</span> keyboard, mouse, ...)</span> <span class="hljs-params">(INPUT [=y])</span>
            -&gt; <span class="hljs-title function_">Touchscreens</span> <span class="hljs-params">(INPUT_TOUCHSCREEN [=y])</span>
            	-&gt; &lt;*&gt; EDT FocalTech FT5x06 I2C Touchscreen support</code></pre></div>

<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905154305722.png" srcset="/img/loading.gif" lazyload alt="image-20200905154305722"></p>
<p>配置好以后重新编译 linux 内核，生成 zImage，但是还不能直接用，要修改设备树。</p>
<h3 id="3-、修改设备树"><a href="#3-、修改设备树" class="headerlink" title="3 、修改设备树"></a>3 、修改设备树</h3><p>修改我们在前面中编写的 ft5426 这个设备节点，需要在里面添加 compatible 属性，添加的内容就要参考 edt-ft5x06.c 文件了，edt-ft5x06.c 所支持的 compatible 属性列表如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">edt_ft5x06_of_match</span>[] =</span> &#123;
    &#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5206&quot;</span>, &#125;,
    &#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5306&quot;</span>, &#125;,
    &#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5406&quot;</span>, &#125;,
    &#123; <span class="hljs-comment">/* sentinel */</span> &#125;
&#125;;</code></pre></div>

<p>可以看出，edt-ft5x06.c 文件默认支持的 compatible 属性只要三个“edt,edt-ft5206”、“edt,edt-ft5306”和“edt,edt-ft5406”。</p>
<p>我们可以修改设备树中的 ft5426 节点，在 compatible 属性值添加一条“edt,edt-ft5406”(示例代码中三选一即可)。或者修改示例代码中的 edt_ft5x06_of_match 表，在里面添加一条：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">&#123; <span class="hljs-string">.compatible</span> = <span class="hljs-string">&quot;edt,edt-ft5426&quot;</span>, &#125;</code></pre></div>

<p>总之一句话，让 ft5426 这个设备和 edt-ft5x06.c 这个驱动匹配起来！这里我选择修改设备树中的 ft5426 这个节点，修改后的 ft5426 节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ft5426: ft5426@<span class="hljs-number">38</span> &#123;
<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;edt,edt-ft5426&quot;</span>,<span class="hljs-string">&quot;edt,edt-ft5406&quot;</span>;
<span class="hljs-number">3</span> reg = &lt;<span class="hljs-number">0x38</span>&gt;;
。。。。。。</code></pre></div>

<p>第 2 行，添加一条“edt,edt-ft5406”兼容性值。</p>
<p>修改完成以后重新编译设备树，然后使用新得到的.dtb 和 zImage 文件启动 linux 内核。如果一切正常的话系统启动的时候就会输出如图所示信息：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905154521160.png" srcset="/img/loading.gif" lazyload alt="image-20200905154521160"></p>
<p>直接运行 ts_test_mt 来测试触摸屏是否可以使用。至此，关于 Linux 下的多点电容触摸驱动就结束了，重点就是掌握 linux 下的触摸屏上报时序，大多数都是 Type B 类型。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="修改过的edt-ft5x06-c"><a href="#修改过的edt-ft5x06-c" class="headerlink" title="修改过的edt-ft5x06.c"></a>修改过的edt-ft5x06.c</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Copyright (C) 2012 Simon Budig, &lt;simon.budig@kernelconcepts.de&gt;</span>
<span class="hljs-comment"> * Daniel Wagener &lt;daniel.wagener@kernelconcepts.de&gt; (M09 firmware support)</span>
<span class="hljs-comment"> * Lothar Waßmann &lt;LW@KARO-electronics.de&gt; (DT support)</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * This software is licensed under the terms of the GNU General Public</span>
<span class="hljs-comment"> * License version 2, as published by the Free Software Foundation, and</span>
<span class="hljs-comment"> * may be copied, distributed, and modified under those terms.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * This program is distributed in the hope that it will be useful,</span>
<span class="hljs-comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="hljs-comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="hljs-comment"> * GNU General Public License for more details.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * You should have received a copy of the GNU General Public</span>
<span class="hljs-comment"> * License along with this library; if not, write to the Free Software</span>
<span class="hljs-comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="hljs-comment"> */</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * This is a driver for the EDT &quot;Polytouch&quot; family of touch controllers</span>
<span class="hljs-comment"> * based on the FocalTech FT5x06 line of chips.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Development of this driver has been sponsored by Glyn:</span>
<span class="hljs-comment"> *    http://www.glyn.com/Products/Displays</span>
<span class="hljs-comment"> */</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ratelimit.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/debugfs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/mt.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/touchscreen.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/edt-ft5x06.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SUPPORT_POINTS		5</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_THRESHOLD		0x00</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_REPORT_RATE	0x08</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_GAIN		0x30</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_OFFSET		0x31</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_NUM_X		0x33</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_NUM_Y		0x34</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_THRESHOLD		0x80</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_GAIN		0x92</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_OFFSET		0x93</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_NUM_X		0x94</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_NUM_Y		0x95</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_REGISTER			0xff</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_OPMODE		0x3c</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FACTORY_REGISTER_OPMODE		0x01</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_DOWN		0x00</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_UP			0x01</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_ON			0x02</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_RESERVED		0x03</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_NAME_LEN			23</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_SWITCH_MODE_RETRIES		10</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_SWITCH_MODE_DELAY		5 <span class="hljs-comment">/* msec */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_RAW_DATA_RETRIES		10</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_RAW_DATA_DELAY		1 <span class="hljs-comment">/* msec */</span></span>

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">edt_ver</span> &#123;</span>
	M06,
	M09,
&#125;;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> &#123;</span>
	<span class="hljs-type">int</span> reg_threshold;
	<span class="hljs-type">int</span> reg_report_rate;
	<span class="hljs-type">int</span> reg_gain;
	<span class="hljs-type">int</span> reg_offset;
	<span class="hljs-type">int</span> reg_num_x;
	<span class="hljs-type">int</span> reg_num_y;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> &#123;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input</span>;</span>
	u16 num_x;
	u16 num_y;

	<span class="hljs-type">int</span> reset_pin;
	<span class="hljs-type">int</span> irq_pin;
	<span class="hljs-type">int</span> wake_pin;

<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_DEBUG_FS)</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">debug_dir</span>;</span>
	u8 *raw_buffer;
	<span class="hljs-type">size_t</span> raw_bufsize;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span>
	<span class="hljs-type">bool</span> factory_mode;
	<span class="hljs-type">int</span> threshold;
	<span class="hljs-type">int</span> gain;
	<span class="hljs-type">int</span> offset;
	<span class="hljs-type">int</span> report_rate;

	<span class="hljs-type">char</span> name[EDT_NAME_LEN];

	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> <span class="hljs-title">reg_addr</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">edt_ver</span> <span class="hljs-title">version</span>;</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_readwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client,</span>
<span class="hljs-params">				   u16 wr_len, u8 *wr_buf,</span>
<span class="hljs-params">				   u16 rd_len, u8 *rd_buf)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">wrmsg</span>[2];</span>
	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> ret;

	<span class="hljs-keyword">if</span> (wr_len) &#123;
		wrmsg[i].addr  = client-&gt;addr;
		wrmsg[i].flags = <span class="hljs-number">0</span>;
		wrmsg[i].len = wr_len;
		wrmsg[i].buf = wr_buf;
		i++;
	&#125;
	<span class="hljs-keyword">if</span> (rd_len) &#123;
		wrmsg[i].addr  = client-&gt;addr;
		wrmsg[i].flags = I2C_M_RD;
		wrmsg[i].len = rd_len;
		wrmsg[i].buf = rd_buf;
		i++;
	&#125;

	ret = i2c_transfer(client-&gt;adapter, wrmsg, i);
	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)
		<span class="hljs-keyword">return</span> ret;
	<span class="hljs-keyword">if</span> (ret != i)
		<span class="hljs-keyword">return</span> -EIO;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">edt_ft5x06_ts_check_crc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span>
<span class="hljs-params">				    u8 *buf, <span class="hljs-type">int</span> buflen)</span>
&#123;
	<span class="hljs-type">int</span> i;
	u8 crc = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; buflen - <span class="hljs-number">1</span>; i++)
		crc ^= buf[i];

	<span class="hljs-keyword">if</span> (crc != buf[buflen<span class="hljs-number">-1</span>]) &#123;
		dev_err_ratelimited(&amp;tsdata-&gt;client-&gt;dev,
				    <span class="hljs-string">&quot;crc error: 0x%02x expected, got 0x%02x\n&quot;</span>,
				    crc, buf[buflen<span class="hljs-number">-1</span>]);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;

	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">edt_ft5x06_ts_isr</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> dev_id;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;tsdata-&gt;client-&gt;dev;
	u8 cmd;
	u8 rdbuf[<span class="hljs-number">29</span>];
	<span class="hljs-type">int</span> i, type, x, y, id;
	<span class="hljs-type">int</span> offset, tplen, datalen;
	<span class="hljs-type">int</span> error;
	<span class="hljs-type">bool</span> down;

	cmd = <span class="hljs-number">0x02</span>; 	<span class="hljs-comment">/* 0X02是触摸状态寄存器 */</span>
	offset = <span class="hljs-number">1</span>; 	<span class="hljs-comment">/* 偏移1，也就是0X02+1=0x03,从0X03开始是触摸值 */</span>
	tplen = <span class="hljs-number">6</span>;		<span class="hljs-comment">/* 一个触摸点有6个寄存器来保存触摸值 */</span>
	datalen = <span class="hljs-number">29</span>;	<span class="hljs-comment">/* 数据读取长度为29 */</span>

	<span class="hljs-built_in">memset</span>(rdbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(rdbuf));

	error = edt_ft5x06_ts_readwrite(tsdata-&gt;client,
					<span class="hljs-keyword">sizeof</span>(cmd), &amp;cmd,
					datalen, rdbuf);
	<span class="hljs-keyword">if</span> (error) &#123;
		dev_err_ratelimited(dev, <span class="hljs-string">&quot;Unable to fetch data, error: %d\n&quot;</span>,
				    error);
		<span class="hljs-keyword">goto</span> out;
	&#125;

	<span class="hljs-comment">/* 上报每一个触摸点坐标 */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_SUPPORT_POINTS; i++) &#123;
		u8 *buf = &amp;rdbuf[i * tplen + offset];

		<span class="hljs-comment">/* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span>
<span class="hljs-comment">		 * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span>
<span class="hljs-comment">		 * bit5:4  保留</span>
<span class="hljs-comment">		 * bit3:0  X轴触摸点的11~8位。</span>
<span class="hljs-comment">		 */</span>
		type = buf[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">6</span>;     <span class="hljs-comment">/* 获取触摸类型 */</span>
		<span class="hljs-keyword">if</span> (type == TOUCH_EVENT_RESERVED)
			<span class="hljs-keyword">continue</span>;
 
		<span class="hljs-comment">/* 我们所使用的触摸屏和FT5X06是反过来的 */</span>
		x = ((buf[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">3</span>]) &amp; <span class="hljs-number">0x0fff</span>;
		y = ((buf[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">1</span>]) &amp; <span class="hljs-number">0x0fff</span>;
		
		<span class="hljs-comment">/* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span>
<span class="hljs-comment">		 * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span>
<span class="hljs-comment">		 * bit3:0  Y轴触摸点的11~8位。</span>
<span class="hljs-comment">		 */</span>
		id = (buf[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>;
		down = type != TOUCH_EVENT_UP;

		input_mt_slot(tsdata-&gt;input, id);
		input_mt_report_slot_state(tsdata-&gt;input, MT_TOOL_FINGER, down);

		<span class="hljs-keyword">if</span> (!down)
			<span class="hljs-keyword">continue</span>;

		input_report_abs(tsdata-&gt;input, ABS_MT_POSITION_X, x);
		input_report_abs(tsdata-&gt;input, ABS_MT_POSITION_Y, y);
	&#125;

	input_mt_report_pointer_emulation(tsdata-&gt;input, <span class="hljs-literal">true</span>);
	input_sync(tsdata-&gt;input);

out:
	<span class="hljs-keyword">return</span> IRQ_HANDLED;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_register_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span>
<span class="hljs-params">				     u8 addr, u8 value)</span>
&#123;
	u8 wrbuf[<span class="hljs-number">4</span>];

	<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;
	<span class="hljs-keyword">case</span> M06:
		wrbuf[<span class="hljs-number">0</span>] = tsdata-&gt;factory_mode ? <span class="hljs-number">0xf3</span> : <span class="hljs-number">0xfc</span>;
		wrbuf[<span class="hljs-number">1</span>] = tsdata-&gt;factory_mode ? addr &amp; <span class="hljs-number">0x7f</span> : addr &amp; <span class="hljs-number">0x3f</span>;
		wrbuf[<span class="hljs-number">2</span>] = value;
		wrbuf[<span class="hljs-number">3</span>] = wrbuf[<span class="hljs-number">0</span>] ^ wrbuf[<span class="hljs-number">1</span>] ^ wrbuf[<span class="hljs-number">2</span>];
		<span class="hljs-keyword">return</span> edt_ft5x06_ts_readwrite(tsdata-&gt;client, <span class="hljs-number">4</span>,
					wrbuf, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);
	<span class="hljs-keyword">case</span> M09:
		wrbuf[<span class="hljs-number">0</span>] = addr;
		wrbuf[<span class="hljs-number">1</span>] = value;

		<span class="hljs-keyword">return</span> edt_ft5x06_ts_readwrite(tsdata-&gt;client, <span class="hljs-number">2</span>,
					wrbuf, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);

	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> -EINVAL;
	&#125;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_register_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span>
<span class="hljs-params">				    u8 addr)</span>
&#123;
	u8 wrbuf[<span class="hljs-number">2</span>], rdbuf[<span class="hljs-number">2</span>];
	<span class="hljs-type">int</span> error;

	<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;
	<span class="hljs-keyword">case</span> M06:
		wrbuf[<span class="hljs-number">0</span>] = tsdata-&gt;factory_mode ? <span class="hljs-number">0xf3</span> : <span class="hljs-number">0xfc</span>;
		wrbuf[<span class="hljs-number">1</span>] = tsdata-&gt;factory_mode ? addr &amp; <span class="hljs-number">0x7f</span> : addr &amp; <span class="hljs-number">0x3f</span>;
		wrbuf[<span class="hljs-number">1</span>] |= tsdata-&gt;factory_mode ? <span class="hljs-number">0x80</span> : <span class="hljs-number">0x40</span>;

		error = edt_ft5x06_ts_readwrite(tsdata-&gt;client, <span class="hljs-number">2</span>, wrbuf, <span class="hljs-number">2</span>,
						rdbuf);
		<span class="hljs-keyword">if</span> (error)
			<span class="hljs-keyword">return</span> error;

		<span class="hljs-keyword">if</span> ((wrbuf[<span class="hljs-number">0</span>] ^ wrbuf[<span class="hljs-number">1</span>] ^ rdbuf[<span class="hljs-number">0</span>]) != rdbuf[<span class="hljs-number">1</span>]) &#123;
			dev_err(&amp;tsdata-&gt;client-&gt;dev,
				<span class="hljs-string">&quot;crc error: 0x%02x expected, got 0x%02x\n&quot;</span>,
				wrbuf[<span class="hljs-number">0</span>] ^ wrbuf[<span class="hljs-number">1</span>] ^ rdbuf[<span class="hljs-number">0</span>],
				rdbuf[<span class="hljs-number">1</span>]);
			<span class="hljs-keyword">return</span> -EIO;
		&#125;
		<span class="hljs-keyword">break</span>;

	<span class="hljs-keyword">case</span> M09:
		wrbuf[<span class="hljs-number">0</span>] = addr;
		error = edt_ft5x06_ts_readwrite(tsdata-&gt;client, <span class="hljs-number">1</span>,
						wrbuf, <span class="hljs-number">1</span>, rdbuf);
		<span class="hljs-keyword">if</span> (error)
			<span class="hljs-keyword">return</span> error;
		<span class="hljs-keyword">break</span>;

	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> -EINVAL;
	&#125;

	<span class="hljs-keyword">return</span> rdbuf[<span class="hljs-number">0</span>];
&#125;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_attribute</span> &#123;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_attribute</span> <span class="hljs-title">dattr</span>;</span>
	<span class="hljs-type">size_t</span> field_offset;
	u8 limit_low;
	u8 limit_high;
	u8 addr_m06;
	u8 addr_m09;
&#125;;

<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_ATTR(_field, _mode, _addr_m06, _addr_m09,			\</span>
<span class="hljs-meta">		_limit_low, _limit_high)				\</span>
<span class="hljs-meta">	struct edt_ft5x06_attribute edt_ft5x06_attr_##_field = &#123;	\</span>
<span class="hljs-meta">		.dattr = __ATTR(_field, _mode,				\</span>
<span class="hljs-meta">				edt_ft5x06_setting_show,		\</span>
<span class="hljs-meta">				edt_ft5x06_setting_store),		\</span>
<span class="hljs-meta">		.field_offset = offsetof(struct edt_ft5x06_ts_data, _field), \</span>
<span class="hljs-meta">		.addr_m06 = _addr_m06,					\</span>
<span class="hljs-meta">		.addr_m09 = _addr_m09,					\</span>
<span class="hljs-meta">		.limit_low = _limit_low,				\</span>
<span class="hljs-meta">		.limit_high = _limit_high,				\</span>
<span class="hljs-meta">	&#125;</span>

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">edt_ft5x06_setting_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span>
<span class="hljs-params">				       <span class="hljs-keyword">struct</span> device_attribute *dattr,</span>
<span class="hljs-params">				       <span class="hljs-type">char</span> *buf)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> to_i2c_client(dev);
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> i2c_get_clientdata(client);
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_attribute</span> *<span class="hljs-title">attr</span> =</span>
			container_of(dattr, <span class="hljs-keyword">struct</span> edt_ft5x06_attribute, dattr);
	u8 *field = (u8 *)tsdata + attr-&gt;field_offset;
	<span class="hljs-type">int</span> val;
	<span class="hljs-type">size_t</span> count = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;
	u8 addr;

	mutex_lock(&amp;tsdata-&gt;mutex);

	<span class="hljs-keyword">if</span> (tsdata-&gt;factory_mode) &#123;
		error = -EIO;
		<span class="hljs-keyword">goto</span> out;
	&#125;

	<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;
	<span class="hljs-keyword">case</span> M06:
		addr = attr-&gt;addr_m06;
		<span class="hljs-keyword">break</span>;

	<span class="hljs-keyword">case</span> M09:
		addr = attr-&gt;addr_m09;
		<span class="hljs-keyword">break</span>;

	<span class="hljs-keyword">default</span>:
		error = -ENODEV;
		<span class="hljs-keyword">goto</span> out;
	&#125;

	<span class="hljs-keyword">if</span> (addr != NO_REGISTER) &#123;
		val = edt_ft5x06_register_read(tsdata, addr);
		<span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) &#123;
			error = val;
			dev_err(&amp;tsdata-&gt;client-&gt;dev,
				<span class="hljs-string">&quot;Failed to fetch attribute %s, error %d\n&quot;</span>,
				dattr-&gt;attr.name, error);
			<span class="hljs-keyword">goto</span> out;
		&#125;
	&#125; <span class="hljs-keyword">else</span> &#123;
		val = *field;
	&#125;

	<span class="hljs-keyword">if</span> (val != *field) &#123;
		dev_warn(&amp;tsdata-&gt;client-&gt;dev,
			 <span class="hljs-string">&quot;%s: read (%d) and stored value (%d) differ\n&quot;</span>,
			 dattr-&gt;attr.name, val, *field);
		*field = val;
	&#125;

	count = scnprintf(buf, PAGE_SIZE, <span class="hljs-string">&quot;%d\n&quot;</span>, val);
out:
	mutex_unlock(&amp;tsdata-&gt;mutex);
	<span class="hljs-keyword">return</span> error ?: count;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">edt_ft5x06_setting_store</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span>
<span class="hljs-params">					<span class="hljs-keyword">struct</span> device_attribute *dattr,</span>
<span class="hljs-params">					<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> count)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> to_i2c_client(dev);
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> i2c_get_clientdata(client);
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_attribute</span> *<span class="hljs-title">attr</span> =</span>
			container_of(dattr, <span class="hljs-keyword">struct</span> edt_ft5x06_attribute, dattr);
	u8 *field = (u8 *)tsdata + attr-&gt;field_offset;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val;
	<span class="hljs-type">int</span> error;
	u8 addr;

	mutex_lock(&amp;tsdata-&gt;mutex);

	<span class="hljs-keyword">if</span> (tsdata-&gt;factory_mode) &#123;
		error = -EIO;
		<span class="hljs-keyword">goto</span> out;
	&#125;

	error = kstrtouint(buf, <span class="hljs-number">0</span>, &amp;val);
	<span class="hljs-keyword">if</span> (error)
		<span class="hljs-keyword">goto</span> out;

	<span class="hljs-keyword">if</span> (val &lt; attr-&gt;limit_low || val &gt; attr-&gt;limit_high) &#123;
		error = -ERANGE;
		<span class="hljs-keyword">goto</span> out;
	&#125;

	<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;
	<span class="hljs-keyword">case</span> M06:
		addr = attr-&gt;addr_m06;
		<span class="hljs-keyword">break</span>;

	<span class="hljs-keyword">case</span> M09:
		addr = attr-&gt;addr_m09;
		<span class="hljs-keyword">break</span>;

	<span class="hljs-keyword">default</span>:
		error = -ENODEV;
		<span class="hljs-keyword">goto</span> out;
	&#125;

	<span class="hljs-keyword">if</span> (addr != NO_REGISTER) &#123;
		error = edt_ft5x06_register_write(tsdata, addr, val);
		<span class="hljs-keyword">if</span> (error) &#123;
			dev_err(&amp;tsdata-&gt;client-&gt;dev,
				<span class="hljs-string">&quot;Failed to update attribute %s, error: %d\n&quot;</span>,
				dattr-&gt;attr.name, error);
			<span class="hljs-keyword">goto</span> out;
		&#125;
	&#125;
	*field = val;

out:
	mutex_unlock(&amp;tsdata-&gt;mutex);
	<span class="hljs-keyword">return</span> error ?: count;
&#125;

<span class="hljs-type">static</span> <span class="hljs-title function_">EDT_ATTR</span><span class="hljs-params">(gain, S_IWUSR | S_IRUGO, WORK_REGISTER_GAIN,</span>
<span class="hljs-params">		M09_REGISTER_GAIN, <span class="hljs-number">0</span>, <span class="hljs-number">31</span>)</span>;
<span class="hljs-type">static</span> <span class="hljs-title function_">EDT_ATTR</span><span class="hljs-params">(offset, S_IWUSR | S_IRUGO, WORK_REGISTER_OFFSET,</span>
<span class="hljs-params">		M09_REGISTER_OFFSET, <span class="hljs-number">0</span>, <span class="hljs-number">31</span>)</span>;
<span class="hljs-type">static</span> <span class="hljs-title function_">EDT_ATTR</span><span class="hljs-params">(threshold, S_IWUSR | S_IRUGO, WORK_REGISTER_THRESHOLD,</span>
<span class="hljs-params">		M09_REGISTER_THRESHOLD, <span class="hljs-number">20</span>, <span class="hljs-number">80</span>)</span>;
<span class="hljs-type">static</span> <span class="hljs-title function_">EDT_ATTR</span><span class="hljs-params">(report_rate, S_IWUSR | S_IRUGO, WORK_REGISTER_REPORT_RATE,</span>
<span class="hljs-params">		NO_REGISTER, <span class="hljs-number">3</span>, <span class="hljs-number">14</span>)</span>;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> *<span class="hljs-title">edt_ft5x06_attrs</span>[] =</span> &#123;
	&amp;edt_ft5x06_attr_gain.dattr.attr,
	&amp;edt_ft5x06_attr_offset.dattr.attr,
	&amp;edt_ft5x06_attr_threshold.dattr.attr,
	&amp;edt_ft5x06_attr_report_rate.dattr.attr,
	<span class="hljs-literal">NULL</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> <span class="hljs-title">edt_ft5x06_attr_group</span> =</span> &#123;
	.attrs = edt_ft5x06_attrs,
&#125;;

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_FS</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_factory_mode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> tsdata-&gt;client;
	<span class="hljs-type">int</span> retries = EDT_SWITCH_MODE_RETRIES;
	<span class="hljs-type">int</span> ret;
	<span class="hljs-type">int</span> error;

	disable_irq(client-&gt;irq);

	<span class="hljs-keyword">if</span> (!tsdata-&gt;raw_buffer) &#123;
		tsdata-&gt;raw_bufsize = tsdata-&gt;num_x * tsdata-&gt;num_y *
				      <span class="hljs-keyword">sizeof</span>(u16);
		tsdata-&gt;raw_buffer = kzalloc(tsdata-&gt;raw_bufsize, GFP_KERNEL);
		<span class="hljs-keyword">if</span> (!tsdata-&gt;raw_buffer) &#123;
			error = -ENOMEM;
			<span class="hljs-keyword">goto</span> err_out;
		&#125;
	&#125;

	<span class="hljs-comment">/* mode register is 0x3c when in the work mode */</span>
	<span class="hljs-keyword">if</span> (tsdata-&gt;version == M09)
		<span class="hljs-keyword">goto</span> m09_out;

	error = edt_ft5x06_register_write(tsdata, WORK_REGISTER_OPMODE, <span class="hljs-number">0x03</span>);
	<span class="hljs-keyword">if</span> (error) &#123;
		dev_err(&amp;client-&gt;dev,
			<span class="hljs-string">&quot;failed to switch to factory mode, error %d\n&quot;</span>, error);
		<span class="hljs-keyword">goto</span> err_out;
	&#125;

	tsdata-&gt;factory_mode = <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">do</span> &#123;
		mdelay(EDT_SWITCH_MODE_DELAY);
		<span class="hljs-comment">/* mode register is 0x01 when in factory mode */</span>
		ret = edt_ft5x06_register_read(tsdata, FACTORY_REGISTER_OPMODE);
		<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0x03</span>)
			<span class="hljs-keyword">break</span>;
	&#125; <span class="hljs-keyword">while</span> (--retries &gt; <span class="hljs-number">0</span>);

	<span class="hljs-keyword">if</span> (retries == <span class="hljs-number">0</span>) &#123;
		dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;not in factory mode after %dms.\n&quot;</span>,
			EDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);
		error = -EIO;
		<span class="hljs-keyword">goto</span> err_out;
	&#125;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

err_out:
	kfree(tsdata-&gt;raw_buffer);
	tsdata-&gt;raw_buffer = <span class="hljs-literal">NULL</span>;
	tsdata-&gt;factory_mode = <span class="hljs-literal">false</span>;
	enable_irq(client-&gt;irq);

	<span class="hljs-keyword">return</span> error;

m09_out:
	dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;No factory mode support for M09\n&quot;</span>);
	<span class="hljs-keyword">return</span> -EINVAL;

&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_work_mode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> tsdata-&gt;client;
	<span class="hljs-type">int</span> retries = EDT_SWITCH_MODE_RETRIES;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;
	<span class="hljs-type">int</span> ret;
	<span class="hljs-type">int</span> error;

	<span class="hljs-comment">/* mode register is 0x01 when in the factory mode */</span>
	error = edt_ft5x06_register_write(tsdata, FACTORY_REGISTER_OPMODE, <span class="hljs-number">0x1</span>);
	<span class="hljs-keyword">if</span> (error) &#123;
		dev_err(&amp;client-&gt;dev,
			<span class="hljs-string">&quot;failed to switch to work mode, error: %d\n&quot;</span>, error);
		<span class="hljs-keyword">return</span> error;
	&#125;

	tsdata-&gt;factory_mode = <span class="hljs-literal">false</span>;

	<span class="hljs-keyword">do</span> &#123;
		mdelay(EDT_SWITCH_MODE_DELAY);
		<span class="hljs-comment">/* mode register is 0x01 when in factory mode */</span>
		ret = edt_ft5x06_register_read(tsdata, WORK_REGISTER_OPMODE);
		<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0x01</span>)
			<span class="hljs-keyword">break</span>;
	&#125; <span class="hljs-keyword">while</span> (--retries &gt; <span class="hljs-number">0</span>);

	<span class="hljs-keyword">if</span> (retries == <span class="hljs-number">0</span>) &#123;
		dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;not in work mode after %dms.\n&quot;</span>,
			EDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);
		tsdata-&gt;factory_mode = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">return</span> -EIO;
	&#125;

	kfree(tsdata-&gt;raw_buffer);
	tsdata-&gt;raw_buffer = <span class="hljs-literal">NULL</span>;

	<span class="hljs-comment">/* restore parameters */</span>
	edt_ft5x06_register_write(tsdata, reg_addr-&gt;reg_threshold,
				  tsdata-&gt;threshold);
	edt_ft5x06_register_write(tsdata, reg_addr-&gt;reg_gain,
				  tsdata-&gt;gain);
	edt_ft5x06_register_write(tsdata, reg_addr-&gt;reg_offset,
				  tsdata-&gt;offset);
	<span class="hljs-keyword">if</span> (reg_addr-&gt;reg_report_rate)
		edt_ft5x06_register_write(tsdata, reg_addr-&gt;reg_report_rate,
				  tsdata-&gt;report_rate);

	enable_irq(client-&gt;irq);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_debugfs_mode_get</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, u64 *mode)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> data;

	*mode = tsdata-&gt;factory_mode;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_debugfs_mode_set</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, u64 mode)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> data;
	<span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (mode &gt; <span class="hljs-number">1</span>)
		<span class="hljs-keyword">return</span> -ERANGE;

	mutex_lock(&amp;tsdata-&gt;mutex);

	<span class="hljs-keyword">if</span> (mode != tsdata-&gt;factory_mode) &#123;
		retval = mode ? edt_ft5x06_factory_mode(tsdata) :
				edt_ft5x06_work_mode(tsdata);
	&#125;

	mutex_unlock(&amp;tsdata-&gt;mutex);

	<span class="hljs-keyword">return</span> retval;
&#125;;

DEFINE_SIMPLE_ATTRIBUTE(debugfs_mode_fops, edt_ft5x06_debugfs_mode_get,
			edt_ft5x06_debugfs_mode_set, <span class="hljs-string">&quot;%llu\n&quot;</span>);

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">edt_ft5x06_debugfs_raw_data_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file,</span>
<span class="hljs-params">				<span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *off)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> file-&gt;private_data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> tsdata-&gt;client;
	<span class="hljs-type">int</span> retries  = EDT_RAW_DATA_RETRIES;
	<span class="hljs-type">int</span> val, i, error;
	<span class="hljs-type">size_t</span> read = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> colbytes;
	<span class="hljs-type">char</span> wrbuf[<span class="hljs-number">3</span>];
	u8 *rdbuf;

	<span class="hljs-keyword">if</span> (*off &lt; <span class="hljs-number">0</span> || *off &gt;= tsdata-&gt;raw_bufsize)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	mutex_lock(&amp;tsdata-&gt;mutex);

	<span class="hljs-keyword">if</span> (!tsdata-&gt;factory_mode || !tsdata-&gt;raw_buffer) &#123;
		error = -EIO;
		<span class="hljs-keyword">goto</span> out;
	&#125;

	error = edt_ft5x06_register_write(tsdata, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x01</span>);
	<span class="hljs-keyword">if</span> (error) &#123;
		dev_dbg(&amp;client-&gt;dev,
			<span class="hljs-string">&quot;failed to write 0x08 register, error %d\n&quot;</span>, error);
		<span class="hljs-keyword">goto</span> out;
	&#125;

	<span class="hljs-keyword">do</span> &#123;
		msleep(EDT_RAW_DATA_DELAY);
		val = edt_ft5x06_register_read(tsdata, <span class="hljs-number">0x08</span>);
		<span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">1</span>)
			<span class="hljs-keyword">break</span>;
	&#125; <span class="hljs-keyword">while</span> (--retries &gt; <span class="hljs-number">0</span>);

	<span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) &#123;
		error = val;
		dev_dbg(&amp;client-&gt;dev,
			<span class="hljs-string">&quot;failed to read 0x08 register, error %d\n&quot;</span>, error);
		<span class="hljs-keyword">goto</span> out;
	&#125;

	<span class="hljs-keyword">if</span> (retries == <span class="hljs-number">0</span>) &#123;
		dev_dbg(&amp;client-&gt;dev,
			<span class="hljs-string">&quot;timed out waiting for register to settle\n&quot;</span>);
		error = -ETIMEDOUT;
		<span class="hljs-keyword">goto</span> out;
	&#125;

	rdbuf = tsdata-&gt;raw_buffer;
	colbytes = tsdata-&gt;num_y * <span class="hljs-keyword">sizeof</span>(u16);

	wrbuf[<span class="hljs-number">0</span>] = <span class="hljs-number">0xf5</span>;
	wrbuf[<span class="hljs-number">1</span>] = <span class="hljs-number">0x0e</span>;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tsdata-&gt;num_x; i++) &#123;
		wrbuf[<span class="hljs-number">2</span>] = i;  <span class="hljs-comment">/* column index */</span>
		error = edt_ft5x06_ts_readwrite(tsdata-&gt;client,
						<span class="hljs-keyword">sizeof</span>(wrbuf), wrbuf,
						colbytes, rdbuf);
		<span class="hljs-keyword">if</span> (error)
			<span class="hljs-keyword">goto</span> out;

		rdbuf += colbytes;
	&#125;

	read = <span class="hljs-type">min_t</span>(<span class="hljs-type">size_t</span>, count, tsdata-&gt;raw_bufsize - *off);
	<span class="hljs-keyword">if</span> (copy_to_user(buf, tsdata-&gt;raw_buffer + *off, read)) &#123;
		error = -EFAULT;
		<span class="hljs-keyword">goto</span> out;
	&#125;

	*off += read;
out:
	mutex_unlock(&amp;tsdata-&gt;mutex);
	<span class="hljs-keyword">return</span> error ?: read;
&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">debugfs_raw_data_fops</span> =</span> &#123;
	.open = simple_open,
	.read = edt_ft5x06_debugfs_raw_data_read,
&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">void</span>
<span class="hljs-title function_">edt_ft5x06_ts_prepare_debugfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span>
<span class="hljs-params">			      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *debugfs_name)</span>
&#123;
	tsdata-&gt;debug_dir = debugfs_create_dir(debugfs_name, <span class="hljs-literal">NULL</span>);
	<span class="hljs-keyword">if</span> (!tsdata-&gt;debug_dir)
		<span class="hljs-keyword">return</span>;

	debugfs_create_u16(<span class="hljs-string">&quot;num_x&quot;</span>, S_IRUSR, tsdata-&gt;debug_dir, &amp;tsdata-&gt;num_x);
	debugfs_create_u16(<span class="hljs-string">&quot;num_y&quot;</span>, S_IRUSR, tsdata-&gt;debug_dir, &amp;tsdata-&gt;num_y);

	debugfs_create_file(<span class="hljs-string">&quot;mode&quot;</span>, S_IRUSR | S_IWUSR,
			    tsdata-&gt;debug_dir, tsdata, &amp;debugfs_mode_fops);
	debugfs_create_file(<span class="hljs-string">&quot;raw_data&quot;</span>, S_IRUSR,
			    tsdata-&gt;debug_dir, tsdata, &amp;debugfs_raw_data_fops);
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">void</span>
<span class="hljs-title function_">edt_ft5x06_ts_teardown_debugfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
	debugfs_remove_recursive(tsdata-&gt;debug_dir);
	kfree(tsdata-&gt;raw_buffer);
&#125;

<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>

<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>
<span class="hljs-title function_">edt_ft5x06_ts_prepare_debugfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span>
<span class="hljs-params">			      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *debugfs_name)</span>
&#123;
&#125;

<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>
<span class="hljs-title function_">edt_ft5x06_ts_teardown_debugfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
&#125;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_DEBUGFS */</span></span>

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client,</span>
<span class="hljs-params">			<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
	<span class="hljs-type">int</span> error;

	<span class="hljs-keyword">if</span> (gpio_is_valid(tsdata-&gt;wake_pin)) &#123;
		error = devm_gpio_request_one(&amp;client-&gt;dev,
					tsdata-&gt;wake_pin, GPIOF_OUT_INIT_LOW,
					<span class="hljs-string">&quot;edt-ft5x06 wake&quot;</span>);
		<span class="hljs-keyword">if</span> (error) &#123;
			dev_err(&amp;client-&gt;dev,
				<span class="hljs-string">&quot;Failed to request GPIO %d as wake pin, error %d\n&quot;</span>,
				tsdata-&gt;wake_pin, error);
			<span class="hljs-keyword">return</span> error;
		&#125;

		msleep(<span class="hljs-number">5</span>);
		gpio_set_value(tsdata-&gt;wake_pin, <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-keyword">if</span> (gpio_is_valid(tsdata-&gt;reset_pin)) &#123;
		<span class="hljs-comment">/* this pulls reset down, enabling the low active reset */</span>
		error = devm_gpio_request_one(&amp;client-&gt;dev,
					tsdata-&gt;reset_pin, GPIOF_OUT_INIT_LOW,
					<span class="hljs-string">&quot;edt-ft5x06 reset&quot;</span>);
		<span class="hljs-keyword">if</span> (error) &#123;
			dev_err(&amp;client-&gt;dev,
				<span class="hljs-string">&quot;Failed to request GPIO %d as reset pin, error %d\n&quot;</span>,
				tsdata-&gt;reset_pin, error);
			<span class="hljs-keyword">return</span> error;
		&#125;

		msleep(<span class="hljs-number">5</span>);
		gpio_set_value(tsdata-&gt;reset_pin, <span class="hljs-number">1</span>);
		msleep(<span class="hljs-number">300</span>);
	&#125;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_identify</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client,</span>
<span class="hljs-params">					<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span>
<span class="hljs-params">					<span class="hljs-type">char</span> *fw_version)</span>
&#123;
	u8 rdbuf[EDT_NAME_LEN];
	<span class="hljs-type">char</span> *p;
	<span class="hljs-type">int</span> error;
	<span class="hljs-type">char</span> *model_name = tsdata-&gt;name;

	<span class="hljs-comment">/* see what we find if we assume it is a M06 *</span>
<span class="hljs-comment">	 * if we get less than EDT_NAME_LEN, we don&#x27;t want</span>
<span class="hljs-comment">	 * to have garbage in there</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-built_in">memset</span>(rdbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(rdbuf));
	error = edt_ft5x06_ts_readwrite(client, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;\xbb&quot;</span>,
					EDT_NAME_LEN - <span class="hljs-number">1</span>, rdbuf);
	<span class="hljs-keyword">if</span> (error)
		<span class="hljs-keyword">return</span> error;

	<span class="hljs-comment">/* if we find something consistent, stay with that assumption</span>
<span class="hljs-comment">	 * at least M09 won&#x27;t send 3 bytes here</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-keyword">if</span> (!(strncasecmp(rdbuf + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;EP0&quot;</span>, <span class="hljs-number">3</span>))) &#123;
		tsdata-&gt;version = M06;

		<span class="hljs-comment">/* remove last &#x27;$&#x27; end marker */</span>
		rdbuf[EDT_NAME_LEN - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;
		<span class="hljs-keyword">if</span> (rdbuf[EDT_NAME_LEN - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;$&#x27;</span>)
			rdbuf[EDT_NAME_LEN - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;

		<span class="hljs-comment">/* look for Model/Version separator */</span>
		p = <span class="hljs-built_in">strchr</span>(rdbuf, <span class="hljs-string">&#x27;*&#x27;</span>);
		<span class="hljs-keyword">if</span> (p)
			*p++ = <span class="hljs-string">&#x27;\0&#x27;</span>;
		strlcpy(model_name, rdbuf + <span class="hljs-number">1</span>, EDT_NAME_LEN);
		strlcpy(fw_version, p ? p : <span class="hljs-string">&quot;&quot;</span>, EDT_NAME_LEN);
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-comment">/* since there are only two versions around (M06, M09) */</span>
		tsdata-&gt;version = M09;

		error = edt_ft5x06_ts_readwrite(client, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;\xA6&quot;</span>,
						<span class="hljs-number">2</span>, rdbuf);
		<span class="hljs-keyword">if</span> (error)
			<span class="hljs-keyword">return</span> error;

		strlcpy(fw_version, rdbuf, <span class="hljs-number">2</span>);

		error = edt_ft5x06_ts_readwrite(client, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;\xA8&quot;</span>,
						<span class="hljs-number">1</span>, rdbuf);
		<span class="hljs-keyword">if</span> (error)
			<span class="hljs-keyword">return</span> error;

		<span class="hljs-built_in">snprintf</span>(model_name, EDT_NAME_LEN, <span class="hljs-string">&quot;EP0%i%i0M09&quot;</span>,
			rdbuf[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">4</span>, rdbuf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x0F</span>);
	&#125;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_ATTR_CHECKSET(name, reg) \</span>
<span class="hljs-meta">do &#123;								\</span>
<span class="hljs-meta">	<span class="hljs-keyword">if</span> (pdata-&gt;name &gt;= edt_ft5x06_attr_##name.limit_low &amp;&amp;		\</span>
<span class="hljs-meta">	    pdata-&gt;name &lt;= edt_ft5x06_attr_##name.limit_high)		\</span>
<span class="hljs-meta">		edt_ft5x06_register_write(tsdata, reg, pdata-&gt;name);	\</span>
<span class="hljs-meta">&#125; while (0)</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_GET_PROP(name, reg) &#123;				\</span>
<span class="hljs-meta">	u32 val;						\</span>
<span class="hljs-meta">	<span class="hljs-keyword">if</span> (of_property_read_u32(np, #name, &amp;val) == 0)		\</span>
<span class="hljs-meta">		edt_ft5x06_register_write(tsdata, reg, val);	\</span>
<span class="hljs-meta">&#125;</span>

<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">edt_ft5x06_ts_get_dt_defaults</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">					<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;

	EDT_GET_PROP(threshold, reg_addr-&gt;reg_threshold);
	EDT_GET_PROP(gain, reg_addr-&gt;reg_gain);
	EDT_GET_PROP(offset, reg_addr-&gt;reg_offset);
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">void</span>
<span class="hljs-title function_">edt_ft5x06_ts_get_defaults</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span>
<span class="hljs-params">			   <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> edt_ft5x06_platform_data *pdata)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;

	<span class="hljs-keyword">if</span> (!pdata-&gt;use_parameters)
		<span class="hljs-keyword">return</span>;

	<span class="hljs-comment">/* pick up defaults from the platform data */</span>
	EDT_ATTR_CHECKSET(threshold, reg_addr-&gt;reg_threshold);
	EDT_ATTR_CHECKSET(gain, reg_addr-&gt;reg_gain);
	EDT_ATTR_CHECKSET(offset, reg_addr-&gt;reg_offset);
	<span class="hljs-keyword">if</span> (reg_addr-&gt;reg_report_rate != NO_REGISTER)
		EDT_ATTR_CHECKSET(report_rate, reg_addr-&gt;reg_report_rate);
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">void</span>
<span class="hljs-title function_">edt_ft5x06_ts_get_parameters</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;

	tsdata-&gt;threshold = edt_ft5x06_register_read(tsdata,
						     reg_addr-&gt;reg_threshold);
	tsdata-&gt;gain = edt_ft5x06_register_read(tsdata, reg_addr-&gt;reg_gain);
	tsdata-&gt;offset = edt_ft5x06_register_read(tsdata, reg_addr-&gt;reg_offset);
	<span class="hljs-keyword">if</span> (reg_addr-&gt;reg_report_rate != NO_REGISTER)
		tsdata-&gt;report_rate = edt_ft5x06_register_read(tsdata,
						reg_addr-&gt;reg_report_rate);
	tsdata-&gt;num_x = edt_ft5x06_register_read(tsdata, reg_addr-&gt;reg_num_x);
	tsdata-&gt;num_y = edt_ft5x06_register_read(tsdata, reg_addr-&gt;reg_num_y);
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">void</span>
<span class="hljs-title function_">edt_ft5x06_ts_set_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;

	<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;
	<span class="hljs-keyword">case</span> M06:
		reg_addr-&gt;reg_threshold = WORK_REGISTER_THRESHOLD;
		reg_addr-&gt;reg_report_rate = WORK_REGISTER_REPORT_RATE;
		reg_addr-&gt;reg_gain = WORK_REGISTER_GAIN;
		reg_addr-&gt;reg_offset = WORK_REGISTER_OFFSET;
		reg_addr-&gt;reg_num_x = WORK_REGISTER_NUM_X;
		reg_addr-&gt;reg_num_y = WORK_REGISTER_NUM_Y;
		<span class="hljs-keyword">break</span>;

	<span class="hljs-keyword">case</span> M09:
		reg_addr-&gt;reg_threshold = M09_REGISTER_THRESHOLD;
		reg_addr-&gt;reg_gain = M09_REGISTER_GAIN;
		reg_addr-&gt;reg_offset = M09_REGISTER_OFFSET;
		reg_addr-&gt;reg_num_x = M09_REGISTER_NUM_X;
		reg_addr-&gt;reg_num_y = M09_REGISTER_NUM_Y;
		<span class="hljs-keyword">break</span>;
	&#125;
&#125;

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_OF</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_i2c_ts_probe_dt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span>
<span class="hljs-params">				<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span> =</span> dev-&gt;of_node;

	<span class="hljs-comment">/*</span>
<span class="hljs-comment">	 * irq_pin is not needed for DT setup.</span>
<span class="hljs-comment">	 * irq is associated via &#x27;interrupts&#x27; property in DT</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-comment">//tsdata-&gt;irq_pin = -EINVAL;</span>
	tsdata-&gt;irq_pin = of_get_named_gpio(np, <span class="hljs-string">&quot;interrupt-gpios&quot;</span>, <span class="hljs-number">0</span>);
	tsdata-&gt;reset_pin = of_get_named_gpio(np, <span class="hljs-string">&quot;reset-gpios&quot;</span>, <span class="hljs-number">0</span>);
	tsdata-&gt;wake_pin = of_get_named_gpio(np, <span class="hljs-string">&quot;wake-gpios&quot;</span>, <span class="hljs-number">0</span>);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_i2c_ts_probe_dt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span>
<span class="hljs-params">					<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>
&#123;
	<span class="hljs-keyword">return</span> -ENODEV;
&#125;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client,</span>
<span class="hljs-params">					 <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>
&#123;
	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_platform_data</span> *<span class="hljs-title">pdata</span> =</span>
						dev_get_platdata(&amp;client-&gt;dev);
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input</span>;</span>
	<span class="hljs-type">int</span> error;
	<span class="hljs-type">char</span> fw_version[EDT_NAME_LEN];

	dev_dbg(&amp;client-&gt;dev, <span class="hljs-string">&quot;probing for EDT FT5x06 I2C\n&quot;</span>);

	tsdata = devm_kzalloc(&amp;client-&gt;dev, <span class="hljs-keyword">sizeof</span>(*tsdata), GFP_KERNEL);
	<span class="hljs-keyword">if</span> (!tsdata) &#123;
		dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;failed to allocate driver data.\n&quot;</span>);
		<span class="hljs-keyword">return</span> -ENOMEM;
	&#125;

	<span class="hljs-keyword">if</span> (!pdata) &#123;
		error = edt_ft5x06_i2c_ts_probe_dt(&amp;client-&gt;dev, tsdata);
		<span class="hljs-keyword">if</span> (error) &#123;
			dev_err(&amp;client-&gt;dev,
				<span class="hljs-string">&quot;DT probe failed and no platform data present\n&quot;</span>);
			<span class="hljs-keyword">return</span> error;
		&#125;
	&#125; <span class="hljs-keyword">else</span> &#123;
		tsdata-&gt;reset_pin = pdata-&gt;reset_pin;
		tsdata-&gt;irq_pin = pdata-&gt;irq_pin;
		tsdata-&gt;wake_pin = -EINVAL;
	&#125;
	
	error = edt_ft5x06_ts_reset(client, tsdata);
	<span class="hljs-keyword">if</span> (error)
		<span class="hljs-keyword">return</span> error;

	<span class="hljs-keyword">if</span> (gpio_is_valid(tsdata-&gt;irq_pin)) &#123;
		error = devm_gpio_request_one(&amp;client-&gt;dev, tsdata-&gt;irq_pin,
					GPIOF_IN, <span class="hljs-string">&quot;edt-ft5x06 irq&quot;</span>);
		<span class="hljs-keyword">if</span> (error) &#123;
			dev_err(&amp;client-&gt;dev,
				<span class="hljs-string">&quot;Failed to request GPIO %d, error %d\n&quot;</span>,
				tsdata-&gt;irq_pin, error);
			<span class="hljs-keyword">return</span> error;
		&#125;
	&#125;

	input = devm_input_allocate_device(&amp;client-&gt;dev);
	<span class="hljs-keyword">if</span> (!input) &#123;
		dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;failed to allocate input device.\n&quot;</span>);
		<span class="hljs-keyword">return</span> -ENOMEM;
	&#125;

	mutex_init(&amp;tsdata-&gt;mutex);
	tsdata-&gt;client = client;
	tsdata-&gt;input = input;
	tsdata-&gt;factory_mode = <span class="hljs-literal">false</span>;

	error = edt_ft5x06_ts_identify(client, tsdata, fw_version);
	<span class="hljs-keyword">if</span> (error) &#123;
		dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;touchscreen probe failed\n&quot;</span>);
		<span class="hljs-keyword">return</span> error;
	&#125;

	edt_ft5x06_ts_set_regs(tsdata);

	<span class="hljs-keyword">if</span> (!pdata)
		edt_ft5x06_ts_get_dt_defaults(client-&gt;dev.of_node, tsdata);
	<span class="hljs-keyword">else</span>
		edt_ft5x06_ts_get_defaults(tsdata, pdata);

	edt_ft5x06_ts_get_parameters(tsdata);

	dev_dbg(&amp;client-&gt;dev,
		<span class="hljs-string">&quot;Model \&quot;%s\&quot;, Rev. \&quot;%s\&quot;, %dx%d sensors\n&quot;</span>,
		tsdata-&gt;name, fw_version, tsdata-&gt;num_x, tsdata-&gt;num_y);

	input-&gt;name = tsdata-&gt;name;
	input-&gt;id.bustype = BUS_I2C;
	input-&gt;dev.parent = &amp;client-&gt;dev;

	<span class="hljs-comment">//__set_bit(EV_KEY, input-&gt;evbit);</span>
	__set_bit(EV_ABS, input-&gt;evbit);
	__set_bit(BTN_TOUCH, input-&gt;keybit);

	<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
	input_set_abs_params(input, ABS_X, <span class="hljs-number">0</span>, tsdata-&gt;num_x * <span class="hljs-number">64</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	input_set_abs_params(input, ABS_Y, <span class="hljs-number">0</span>, tsdata-&gt;num_y * <span class="hljs-number">64</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	input_set_abs_params(input, ABS_MT_POSITION_X,
			     <span class="hljs-number">0</span>, tsdata-&gt;num_x * <span class="hljs-number">64</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	input_set_abs_params(input, ABS_MT_POSITION_Y,
			     <span class="hljs-number">0</span>, tsdata-&gt;num_y * <span class="hljs-number">64</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
	input_set_abs_params(input, ABS_X, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	input_set_abs_params(input, ABS_Y, <span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	input_set_abs_params(input, ABS_MT_POSITION_X,<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	input_set_abs_params(input, ABS_MT_POSITION_Y,<span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
			     
		<span class="hljs-keyword">if</span> (!pdata)
		touchscreen_parse_of_params(input);

	error = input_mt_init_slots(input, MAX_SUPPORT_POINTS, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span> (error) &#123;
		dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to init MT slots.\n&quot;</span>);
		<span class="hljs-keyword">return</span> error;
	&#125;

	input_set_drvdata(input, tsdata);
	i2c_set_clientdata(client, tsdata);


	<span class="hljs-comment">/* zuozhongkai 2019/1/30 */</span>	
	<span class="hljs-comment">//printk(&quot;tsdata-&gt;irq_pin=%d\r\n&quot;,tsdata-&gt;irq_pin);</span>
	gpio_request(tsdata-&gt;irq_pin, <span class="hljs-string">&quot;interrupt-gpios&quot;</span>);
	gpio_direction_input(tsdata-&gt;irq_pin);

	error = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="hljs-literal">NULL</span>,
					edt_ft5x06_ts_isr,
					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
					client-&gt;name, tsdata);
	<span class="hljs-keyword">if</span> (error) &#123;
		dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to request touchscreen IRQ.\n&quot;</span>);
		<span class="hljs-keyword">return</span> error;
	&#125;

	error = sysfs_create_group(&amp;client-&gt;dev.kobj, &amp;edt_ft5x06_attr_group);
	<span class="hljs-keyword">if</span> (error)
		<span class="hljs-keyword">return</span> error;

	error = input_register_device(input);
	<span class="hljs-keyword">if</span> (error)
		<span class="hljs-keyword">goto</span> err_remove_attrs;

	edt_ft5x06_ts_prepare_debugfs(tsdata, dev_driver_string(&amp;client-&gt;dev));
	device_init_wakeup(&amp;client-&gt;dev, <span class="hljs-number">1</span>);

	dev_dbg(&amp;client-&gt;dev,
		<span class="hljs-string">&quot;EDT FT5x06 initialized: IRQ %d, WAKE pin %d, Reset pin %d.\n&quot;</span>,
		client-&gt;irq, tsdata-&gt;wake_pin, tsdata-&gt;reset_pin);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

err_remove_attrs:
	sysfs_remove_group(&amp;client-&gt;dev.kobj, &amp;edt_ft5x06_attr_group);
	<span class="hljs-keyword">return</span> error;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> i2c_get_clientdata(client);

	edt_ft5x06_ts_teardown_debugfs(tsdata);
	sysfs_remove_group(&amp;client-&gt;dev.kobj, &amp;edt_ft5x06_attr_group);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> __maybe_unused <span class="hljs-title function_">edt_ft5x06_ts_suspend</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> to_i2c_client(dev);

	<span class="hljs-keyword">if</span> (device_may_wakeup(dev))
		enable_irq_wake(client-&gt;irq);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> __maybe_unused <span class="hljs-title function_">edt_ft5x06_ts_resume</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> to_i2c_client(dev);

	<span class="hljs-keyword">if</span> (device_may_wakeup(dev))
		disable_irq_wake(client-&gt;irq);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-title function_">SIMPLE_DEV_PM_OPS</span><span class="hljs-params">(edt_ft5x06_ts_pm_ops,</span>
<span class="hljs-params">			 edt_ft5x06_ts_suspend, edt_ft5x06_ts_resume)</span>;

<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">edt_ft5x06_ts_id</span>[] =</span> &#123;
	&#123; <span class="hljs-string">&quot;edt-ft5x06&quot;</span>, <span class="hljs-number">0</span>, &#125;,
	&#123; <span class="hljs-comment">/* sentinel */</span> &#125;
&#125;;
MODULE_DEVICE_TABLE(i2c, edt_ft5x06_ts_id);

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_OF</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">edt_ft5x06_of_match</span>[] =</span> &#123;
	&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5206&quot;</span>, &#125;,
	&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5306&quot;</span>, &#125;,
	&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5406&quot;</span>, &#125;,
	&#123; <span class="hljs-comment">/* sentinel */</span> &#125;
&#125;;
MODULE_DEVICE_TABLE(of, edt_ft5x06_of_match);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">edt_ft5x06_ts_driver</span> =</span> &#123;
	.driver = &#123;
		.owner = THIS_MODULE,
		.name = <span class="hljs-string">&quot;edt_ft5x06&quot;</span>,
		.of_match_table = of_match_ptr(edt_ft5x06_of_match),
		.pm = &amp;edt_ft5x06_ts_pm_ops,
	&#125;,
	.id_table = edt_ft5x06_ts_id,
	.probe    = edt_ft5x06_ts_probe,
	.remove   = edt_ft5x06_ts_remove,
&#125;;

module_i2c_driver(edt_ft5x06_ts_driver);

MODULE_AUTHOR(<span class="hljs-string">&quot;Simon Budig &lt;simon.budig@kernelconcepts.de&gt;&quot;</span>);
MODULE_DESCRIPTION(<span class="hljs-string">&quot;EDT FT5x06 I2C Touchscreen Driver&quot;</span>);
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
</code></pre></div>
























            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/20%E3%80%81Linux_UART%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">20| Linux UART串口实验</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">22| Linux 音频驱动</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
