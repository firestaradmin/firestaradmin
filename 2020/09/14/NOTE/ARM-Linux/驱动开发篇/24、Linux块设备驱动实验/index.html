

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux 块设备驱动实验块设备驱动是Linux 三大驱动类型之一。块设备驱动要远比字符设备驱动复杂得多，不同类型的存储设备又对应不同的驱动子系统，本章我们重点学习一下块设备相关驱动概念，不涉及到具体的存储设备。最后，我们使用 ALPHA 开发板板载 RAM 模拟一个块设备，学习块设备驱动框架的使用。 一、什么是块设备？块设备是针对存储设备的，比如 SD 卡、EMMC、NAND Flash、Nor">
<meta property="og:type" content="article">
<meta property="og:title" content="24| Linux 块设备驱动实验">
<meta property="og:url" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Linux 块设备驱动实验块设备驱动是Linux 三大驱动类型之一。块设备驱动要远比字符设备驱动复杂得多，不同类型的存储设备又对应不同的驱动子系统，本章我们重点学习一下块设备相关驱动概念，不涉及到具体的存储设备。最后，我们使用 ALPHA 开发板板载 RAM 模拟一个块设备，学习块设备驱动框架的使用。 一、什么是块设备？块设备是针对存储设备的，比如 SD 卡、EMMC、NAND Flash、Nor">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909164818191.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909164843110.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909165121668.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909170421873.png">
<meta property="article:published_time" content="2020-09-13T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-13T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909164818191.png">
  
  
  <title>24| Linux 块设备驱动实验 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//at.alicdn.com/t/font_3219187_rorsfvmryjl.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="24| Linux 块设备驱动实验">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-14 00:00" pubdate>
        2020年9月14日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      186 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">24| Linux 块设备驱动实验</h1>
            
            <div class="markdown-body">
              <h1 id="Linux-块设备驱动实验"><a href="#Linux-块设备驱动实验" class="headerlink" title="Linux 块设备驱动实验"></a>Linux 块设备驱动实验</h1><p>块设备驱动是Linux 三大驱动类型之一。块设备驱动要远比字符设备驱动复杂得多，不同类型的存储设备又对应不同的驱动子系统，本章我们重点学习一下块设备相关驱动概念，不涉及到具体的存储设备。最后，我们使用 ALPHA 开发板板载 RAM 模拟一个块设备，学习块设备驱动框架的使用。</p>
<h2 id="一、什么是块设备？"><a href="#一、什么是块设备？" class="headerlink" title="一、什么是块设备？"></a>一、什么是块设备？</h2><p>块设备是针对存储设备的，比如 SD 卡、EMMC、NAND Flash、Nor Flash、SPI Flash、机械硬盘、固态硬盘等。因此块设备驱动其实就是这些存储设备驱动，块设备驱动相比字符设备驱动的主要区别如下：</p>
<ul>
<li>①、块设备只能以块为单位进行读写访问，块是 linux 虚拟文件系统(VFS)基本的数据传输单位。字符设备是以字节为单位进行数据传输的，不需要缓冲。</li>
<li>②、块设备在结构上是可以进行随机访问的，对于这些设备的读写都是按块进行的，块设备使用缓冲区来暂时存放数据，等到条件成熟以后在一次性将缓冲区中的数据写入块设备中。这么做的目的为了提高块设备寿命，大家如果仔细观察的话就会发现有些硬盘或者 NAND Flash就会标明擦除次数(flash 的特性，写之前要先擦除)，比如擦除 100000 次等。因此，为了提高块设备寿命而引入了缓冲区，数据先写入到缓冲区中，等满足一定条件后再一次性写入到真正的物理存储设备中，这样就减少了对块设备的擦除次数，提高了块设备寿命。</li>
</ul>
<p>字符设备是顺序的数据流设备，字符设备是按照字节进行读写访问的。字符设备不需要缓冲区，对于字符设备的访问都是实时的，而且也不需要按照固定的块大小进行访问。</p>
<p>块设备结构的不同其 I&#x2F;O 算法也会不同，比如对于 EMMC、SD 卡、NAND Flash 这类没有任何机械设备的存储设备就可以任意读写任何的扇区(块设备物理存储单元)。但是对于机械硬盘这样带有磁头的设备，读取不同的盘面或者磁道里面的数据，磁头都需要进行移动，因此对于机械硬盘而言，将那些杂乱的访问按照一定的顺序进行排列可以有效提高磁盘性能，linux 里面针对不同的存储设备实现了不同的 I&#x2F;O 调度算法。</p>
<h2 id="二、块设备驱动框架"><a href="#二、块设备驱动框架" class="headerlink" title="二、块设备驱动框架"></a>二、块设备驱动框架</h2><h3 id="1-block-device-结构体"><a href="#1-block-device-结构体" class="headerlink" title="1| block_device  结构体"></a>1| block_device  结构体</h3><p>linux 内核使用 block_device 表示块设备，block_device 为一个结构体，定义在include&#x2F;linux&#x2F;fs.h 文件中，结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> &#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-type">dev_t</span> bd_dev; <span class="hljs-comment">/* not a kdev_t - it&#x27;s a search key */</span>
<span class="hljs-number">3</span> 		<span class="hljs-type">int</span> bd_openers;
<span class="hljs-number">4</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">bd_inode</span>;</span> <span class="hljs-comment">/* will die */</span>
<span class="hljs-number">5</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">bd_super</span>;</span>
<span class="hljs-number">6</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">bd_mutex</span>;</span> <span class="hljs-comment">/* open/close mutex */</span>
<span class="hljs-number">7</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">bd_inodes</span>;</span>
<span class="hljs-number">8</span> 		<span class="hljs-type">void</span> * bd_claiming;
<span class="hljs-number">9</span> 		<span class="hljs-type">void</span> * bd_holder;
<span class="hljs-number">10</span> 		<span class="hljs-type">int</span> bd_holders;
<span class="hljs-number">11</span> 		<span class="hljs-type">bool</span> bd_write_holder;
<span class="hljs-number">12</span> 	<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSFS</span>
<span class="hljs-number">13</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">bd_holder_disks</span>;</span>
<span class="hljs-number">14</span> 	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-number">15</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> *<span class="hljs-title">bd_contains</span>;</span>
<span class="hljs-number">16</span> 		<span class="hljs-type">unsigned</span> bd_block_size;
<span class="hljs-number">15</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_struct</span> *<span class="hljs-title">bd_part</span>;</span>
<span class="hljs-number">18</span> 		<span class="hljs-comment">/*number of times partitions within this device have been opened.*/</span>
<span class="hljs-number">19</span> 		<span class="hljs-type">unsigned</span> bd_part_count;
<span class="hljs-number">20</span> 		<span class="hljs-type">int</span> bd_invalidated;
<span class="hljs-number">21</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> *<span class="hljs-title">bd_disk</span>;</span>
<span class="hljs-number">22</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">bd_queue</span>;</span>
<span class="hljs-number">23</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">bd_list</span>;</span>
<span class="hljs-number">24</span> 		<span class="hljs-comment">/*</span>
<span class="hljs-comment">25 		* Private data. You must have bd_claim&#x27;ed the block_device</span>
<span class="hljs-comment">26 		* to use this. <span class="hljs-doctag">NOTE:</span> bd_claim allows an owner to claim</span>
<span class="hljs-comment">27 		* the same device multiple times, the owner must take special</span>
<span class="hljs-comment">28 		* care to not mess up bd_private for that case.</span>
<span class="hljs-comment">29 		*/</span>
<span class="hljs-number">30</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bd_private;
<span class="hljs-number">31</span>
<span class="hljs-number">32</span> 		<span class="hljs-comment">/* The counter of freeze processes */</span>
<span class="hljs-number">33</span> 		<span class="hljs-type">int</span> bd_fsfreeze_count;
<span class="hljs-number">34</span> 		<span class="hljs-comment">/* Mutex for freeze */</span>
<span class="hljs-number">35</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">bd_fsfreeze_mutex</span>;</span>
<span class="hljs-number">36</span> &#125;;</code></pre></div>

<p>对于 block_device 结构体，我们重点关注一下第 21 行的 bd_disk 成员变量，此成员变量为gendisk 结构体指针类型。内核使用 block_device 来表示一个具体的块设备对象，比如一个硬盘或者分区，如果是硬盘的话 bd_disk 就指向通用磁盘结构 gendisk。</p>
<h4 id="注册块设备"><a href="#注册块设备" class="headerlink" title="注册块设备"></a>注册块设备</h4><p>和字符设备驱动一样，我们需要向内核注册新的块设备、申请设备号，块设备注册函数为register_blkdev，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">register_blkdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>major</strong> ：主设备号。<br><strong>name</strong> ：块设备名字。<br><strong>返回值</strong>：如果参数 major 在 1<del>255 之间的话表示自定义主设备号，那么返回 0 表示注册成功，如果返回负值的话表示注册失败。如果 major 为 0 的话表示由系统自动分配主设备号，那么返回值就是系统分配的主设备号(1</del>255)，如果返回负值那就表示注册失败。</p>
<h4 id="注销块设备"><a href="#注销块设备" class="headerlink" title="注销块设备"></a>注销块设备</h4><p>和字符设备驱动一样，如果不使用某个块设备了，那么就需要注销掉，函数为unregister_blkdev，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_blkdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>major</strong> ：要注销的块设备主设备号。<br><strong>name</strong>： ： 要注销的块设备名字。<br><strong>返回值</strong>：无。</p>
<h3 id="2-gendisk-结构体"><a href="#2-gendisk-结构体" class="headerlink" title="2| gendisk  结构体"></a>2| gendisk  结构体</h3><p>linux 内核使用 gendisk 来描述一个磁盘设备，这是一个结构体，定义在 include&#x2F;linux&#x2F;genhd.h中，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> &#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-comment">/* major, first_minor and minors are input parameters only,</span>
<span class="hljs-comment">3 		* don&#x27;t use directly. Use disk_devt() and disk_max_parts().</span>
<span class="hljs-comment">4 		*/</span>
<span class="hljs-number">5</span> 		<span class="hljs-type">int</span> major; <span class="hljs-comment">/* major number of driver */</span>
<span class="hljs-number">6</span> 		<span class="hljs-type">int</span> first_minor;
<span class="hljs-number">7</span> 		<span class="hljs-type">int</span> minors; <span class="hljs-comment">/* maximum number of minors, =1 for</span>
<span class="hljs-comment">8 				* disks that can&#x27;t be partitioned. */</span>
<span class="hljs-number">9</span>
<span class="hljs-number">10</span> 		<span class="hljs-type">char</span> disk_name[DISK_NAME_LEN]; <span class="hljs-comment">/* name of major driver */</span>
<span class="hljs-number">11</span> 		<span class="hljs-type">char</span> *(*devnode)(<span class="hljs-keyword">struct</span> gendisk *gd, <span class="hljs-type">umode_t</span> *mode);
<span class="hljs-number">12</span>
<span class="hljs-number">13</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> events; <span class="hljs-comment">/* supported events */</span>
<span class="hljs-number">14</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> async_events; <span class="hljs-comment">/* async events, subset of all */</span>
<span class="hljs-number">15</span>
<span class="hljs-number">16</span> 		<span class="hljs-comment">/* Array of pointers to partitions indexed by partno.</span>
<span class="hljs-comment">17 		* Protected with matching bdev lock but stat and other</span>
<span class="hljs-comment">18 				* non-critical accesses use RCU. Always access through</span>
<span class="hljs-comment">19 		* helpers.</span>
<span class="hljs-comment">20 				*/</span>
<span class="hljs-number">21</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk_part_tbl</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">part_tbl</span>;</span>
<span class="hljs-number">22</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_struct</span> <span class="hljs-title">part0</span>;</span>
<span class="hljs-number">23</span>
<span class="hljs-number">24</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device_operations</span> *<span class="hljs-title">fops</span>;</span>
<span class="hljs-number">25</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">queue</span>;</span>
<span class="hljs-number">26</span> 		<span class="hljs-type">void</span> *private_data;
<span class="hljs-number">27</span>
<span class="hljs-number">28</span> 		<span class="hljs-type">int</span> flags;
<span class="hljs-number">29</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">driverfs_dev</span>;</span> <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> remove</span>
<span class="hljs-number">30</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">slave_dir</span>;</span>
<span class="hljs-number">31</span>
<span class="hljs-number">32</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_rand_state</span> *<span class="hljs-title">random</span>;</span>
<span class="hljs-number">33</span> 		<span class="hljs-type">atomic_t</span> sync_io; <span class="hljs-comment">/* RAID */</span>
<span class="hljs-number">34</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk_events</span> *<span class="hljs-title">ev</span>;</span>
<span class="hljs-number">35</span> 	<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEV_INTEGRITY</span>
<span class="hljs-number">36</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_integrity</span> *<span class="hljs-title">integrity</span>;</span>
<span class="hljs-number">37</span> 	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-number">38</span> 		<span class="hljs-type">int</span> node_id;
<span class="hljs-number">39</span> 	&#125;;</code></pre></div>

<p>我们简单看一下 gendisk 结构体中比较重要的几个成员变量：</p>
<ul>
<li>第 5 行，major 为磁盘设备的主设备号。</li>
<li>第 6 行，first_minor 为磁盘的第一个次设备号。</li>
<li>第 7 行，minors 为磁盘的此设备号数量，也就是磁盘的分区数量，这些分区的主设备号一样，此设备号不同。</li>
<li>第 21 行，part_tbl 为磁盘对应的分区表，为结构体 disk_part_tbl 类型，disk_part_tbl 的核心是一个 hd_struct 结构体指针数组，此数组每一项都对应一个分区信息。</li>
<li>第 24 行，fops 为块设备操作集，为 block_device_operations 结构体类型。和字符设备操作集 file_operations 一样，是块设备驱动中的重点！</li>
<li>第 25 行，queue 为磁盘对应的请求队列，所以针对该磁盘设备的请求都放到此队列中，驱动程序需要处理此队列中的所有请求。</li>
</ul>
<p>编写块的设备驱动的时候需要分配并初始化一个 gendisk，linux 内核提供了一组 gendisk 操<br>作函数，我们来看一下一些常用的 API 函数。</p>
<h4 id="1、-申请-gendisk"><a href="#1、-申请-gendisk" class="headerlink" title="1、 申请 gendisk"></a>1、 申请 gendisk</h4><p>使用 gendisk 之前要先申请，allo_disk 函数用于申请一个 gendisk，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> gendisk *<span class="hljs-title function_">alloc_disk</span><span class="hljs-params">(<span class="hljs-type">int</span> minors)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>minors</strong> ：次设备号数量，也就是 gendisk 对应的分区数量。<br><strong>返回值</strong>：成功：返回申请到的 gendisk，失败：NULL。</p>
<h4 id="2-、删除-gendisk"><a href="#2-、删除-gendisk" class="headerlink" title="2 、删除 gendisk"></a>2 、删除 gendisk</h4><p>如果要删除 gendisk 的话可以使用函数 del_gendisk，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">del_gendisk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *gp)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>gp</strong> ：要删除的 gendisk。<br><strong>返回值</strong>：无。</p>
<h4 id="3-、将-gendisk-添加到内核"><a href="#3-、将-gendisk-添加到内核" class="headerlink" title="3 、将 gendisk  添加到内核"></a>3 、将 gendisk  添加到内核</h4><p>使用 alloc_disk 申请到 gendisk 以后系统还不能使用，必须使用 add_disk 函数将申请到的gendisk 添加到内核中，add_disk 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">add_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>disk</strong> ：要添加到内核的 gendisk。<br><strong>返回值</strong>：无。</p>
<h4 id="4-、设置-gendisk-容量"><a href="#4-、设置-gendisk-容量" class="headerlink" title="4 、设置 gendisk  容量"></a>4 、设置 gendisk  容量</h4><p>每一个磁盘都有容量，所以在初始化 gendisk 的时候也需要设置其容量，使用函数set_capacity，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">set_capacity</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk, <span class="hljs-type">sector_t</span> size)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>disk</strong> ：要设置容量的 gendisk。<br><strong>size</strong>： ：磁盘容量大小，注意这里是扇区数量。块设备中最小的可寻址单元是扇区，一个扇区一般是 512 字节，有些设备的物理扇区可能不是 512 字节。不管物理扇区是多少，内核和块设备驱动之间的扇区都是 512 字节。所以 set_capacity 函数设置的大小就是块设备实际容量除以512 字节得到的扇区数量。比如一个 2MB 的磁盘，其扇区数量就是(2<em>1024</em>1024)&#x2F;512&#x3D;4096。<br><strong>返回值</strong>：无。</p>
<h4 id="5-、调整-gendisk-引用计数"><a href="#5-、调整-gendisk-引用计数" class="headerlink" title="5 、调整 gendisk  引用计数"></a>5 、调整 gendisk  引用计数</h4><p>内核会通过 get_disk 和 put_disk 这两个函数来调整 gendisk 的引用计数，根据名字就可以知道，get_disk 是增加 gendisk 的引用计数，put_disk 是减少 gendisk 的引用计数，这两个函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">truct kobject *<span class="hljs-title function_">get_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">put_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk)</span></code></pre></div>

<h3 id="3-block-device-operations-结构体"><a href="#3-block-device-operations-结构体" class="headerlink" title="3| block_device_operations  结构体"></a>3| block_device_operations  结构体</h3><p>和字符设备的 file _operations 一样，块设备也有操作集，为结构体 block_device_operations，此结构体定义在 include&#x2F;linux&#x2F;blkdev.h 中，结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device_operations</span> &#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">fmode_t</span>);
<span class="hljs-number">3</span> 		<span class="hljs-type">void</span> (*release) (<span class="hljs-keyword">struct</span> gendisk *, <span class="hljs-type">fmode_t</span>);
<span class="hljs-number">4</span> 		<span class="hljs-type">int</span> (*rw_page)(<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">sector_t</span>, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span> rw);
<span class="hljs-number">5</span> 		<span class="hljs-type">int</span> (*ioctl) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">fmode_t</span>, <span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);
<span class="hljs-number">6</span> 		<span class="hljs-type">int</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">fmode_t</span>, <span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);
<span class="hljs-number">7</span> 		<span class="hljs-type">long</span> (*direct_access)(<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">sector_t</span>,
<span class="hljs-number">8</span> 						<span class="hljs-type">void</span> **, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *pfn, <span class="hljs-type">long</span> size);
<span class="hljs-number">9</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*check_events)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk,</span>
<span class="hljs-params"><span class="hljs-number">10</span> 						<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> clearing)</span>;
<span class="hljs-number">11</span> 		<span class="hljs-comment">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span>
<span class="hljs-number">12</span> 		<span class="hljs-type">int</span> (*media_changed) (<span class="hljs-keyword">struct</span> gendisk *);
<span class="hljs-number">13</span> 		<span class="hljs-type">void</span> (*unlock_native_capacity) (<span class="hljs-keyword">struct</span> gendisk *);
<span class="hljs-number">14</span> 		<span class="hljs-type">int</span> (*revalidate_disk) (<span class="hljs-keyword">struct</span> gendisk *);
<span class="hljs-number">15</span> 		<span class="hljs-type">int</span> (*getgeo)(<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-keyword">struct</span> hd_geometry *);
<span class="hljs-number">16</span> 		<span class="hljs-comment">/* this callback is with swap_lock and sometimes page table lock held */</span>
<span class="hljs-number">17</span> 		<span class="hljs-type">void</span> (*swap_slot_free_notify) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);
<span class="hljs-number">18</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span>
<span class="hljs-number">19</span> 	&#125;;</code></pre></div>

<p>可以看出，block_device_operations 结构体里面的操作集函数和字符设备的 file_operations操作集基本类似，但是块设备的操作集函数比较少，我们来看一下其中比较重要的几个成员函数：</p>
<ul>
<li>第 2 行，open 函数用于打开指定的块设备。</li>
<li>第 3 行，release 函数用于关闭(释放)指定的块设备。</li>
<li>第 4 行，rw_page 函数用于读写指定的页。</li>
<li>第 5 行，ioctl 函数用于块设备的 I&#x2F;O 控制。</li>
<li>第 6 行，compat_ioctl 函数和 ioctl 函数一样，都是用于块设备的 I&#x2F;O 控制。区别在于在 64位系统上，32 位应用程序的 ioctl 会调用 compat_iotl 函数。在 32 位系统上运行的 32 位应用程序调用的就是 ioctl 函数。</li>
<li>第 15 行，getgeo 函数用于获取磁盘信息，包括磁头、柱面和扇区等信息。</li>
<li>第 18 行，owner 表示此结构体属于哪个模块，一般直接设置为 THIS_MODULE。</li>
</ul>
<h3 id="4-块设备-I-x2F-O-请求过程"><a href="#4-块设备-I-x2F-O-请求过程" class="headerlink" title="4| 块设备 I&#x2F;O  请求过程"></a>4| 块设备 I&#x2F;O  请求过程</h3><p>大家如果仔细观察的话会在 block_device_operations 结构体中并没有找到 read和 write 这样<br>的读写函数，那么块设备是怎么从物理块设备中读写数据？这里就引处理块设备驱动中非常重<br>要的 request_queue、request 和 bio。</p>
<h4 id="1、请求队列-request-queue"><a href="#1、请求队列-request-queue" class="headerlink" title="1、请求队列 request_queue"></a>1、请求队列 request_queue</h4><p>内核将对块设备的读写都发送到请求队列 request_queue 中，request_queue 中是大量的request(请求结构体)，而 request 又包含了 bio，bio 保存了读写相关数据，比如从块设备的哪个地址开始读取、读取的数据长度，读取到哪里，如果是写的话还包括要写入的数据等。我们先来看一下 request_queue，这是一个结构体，定义在文件 include&#x2F;linux&#x2F;blkdev.h 中，由于request_queue 结构体比较长，这里就不列出来了。大家回过头看一下示例代码的 gendisk结构体就会发现里面有一个 request_queue 结构体指针类型成员变量 queue，也就说在编写块设备驱动的时候，每个磁盘(gendisk)都要分配一个 request_queue。</p>
<h5 id="①、初始化请求队列"><a href="#①、初始化请求队列" class="headerlink" title="①、初始化请求队列"></a>①、初始化请求队列</h5><p>我们首先需要申请并初始化一个 request_queue，然后在初始化 gendisk 的时候将这个request_queue 地址赋值给 gendisk 的 queue 成员变量。使用 blk_init_queue 函数来完成request_queue 的申请与初始化，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">request_queue *<span class="hljs-title function_">blk_init_queue</span><span class="hljs-params">(request_fn_proc *rfn, <span class="hljs-type">spinlock_t</span> *lock)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><p><strong>rfn</strong> ：请求处理函数指针，每个 request_queue 都要有一个请求处理函数，请求处理函数request_fn_proc 原型如下：</p>
  <div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> (request_fn_proc) (<span class="hljs-keyword">struct</span> request_queue *q)</code></pre></div>

<p>  请求处理函数需要驱动编写人员自行实现。</p>
</li>
<li><p><strong>lock</strong>： ：自旋锁指针，需要驱动编写人员定义一个自旋锁，然后传递进来。，请求队列会使用这个自旋锁。</p>
</li>
<li><p><strong>返回值</strong>：如果为 NULL 的话表示失败，成功的话就返回申请到的 request_queue 地址。</p>
</li>
</ul>
<h5 id="②、删除请求队列"><a href="#②、删除请求队列" class="headerlink" title="②、删除请求队列"></a>②、删除请求队列</h5><p>当卸载块设备驱动的时候我们还需要删除掉前面申请到的 request_queue，删除请求队列使用函数 blk_cleanup_queue，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs reasonml">void blk<span class="hljs-constructor">_cleanup_queue(<span class="hljs-params">struct</span> <span class="hljs-params">request_queue</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><strong>q</strong> ：需要删除的请求队列。</li>
<li><strong>返回值</strong>：无。</li>
</ul>
<h5 id="③、分配请求队列-并绑定制造请求函数"><a href="#③、分配请求队列-并绑定制造请求函数" class="headerlink" title="③、分配请求队列 并绑定制造请求函数"></a>③、分配请求队列 并绑定制造请求函数</h5><p>blk_init_queue 函数完成了请求队列的申请已经请求处理函数的绑定，这个一般用于像机械硬盘这样的存储设备，需要 I&#x2F;O 调度器来优化数据读写过程。但是对于 EMMC、SD 卡这样的非机械设备，可以进行完全随机访问，所以就不需要复杂的 I&#x2F;O 调度器了。对于非机械设备我们可以先申请 request_queue，然后将申请到的 request_queue 与“制造请求”函数绑定在一起。</p>
<p>先来看一下 request_queue 申请函数 blk_alloc_queue，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> request_queue *<span class="hljs-title function_">blk_alloc_queue</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><strong>gfp_mask</strong>：内存分配掩码，具体可选择的掩码值请参考 include&#x2F;linux&#x2F;gfp.h 中的相关宏定义，一般为 GFP_KERNEL。</li>
<li><strong>返回 值</strong>：申请到的无 I&#x2F;O 调度的 request_queue。</li>
</ul>
<p>我们需要为 blk_alloc_queue 函数申请到的请求队列绑定一个“制造请求”函数(其他参考资料将其直接翻译为“制造请求”函数)。这里我们需要用到函数 blk_queue_make_request，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">blk_queue_make_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, make_request_fn *mfn)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><p><strong>q</strong> ：需要绑定的请求队列，也就是 blk_alloc_queue 申请到的请求队列。</p>
</li>
<li><p><strong>mfn</strong>：需要绑定的“制造”请求函数，函数原型如下：</p>
<ul>
<li>&#96;&#96;&#96;c<br>  void (make_request_fn) (struct request_queue *q, struct bio *bio)  <div class="hljs code-wrapper"><pre><code class="hljs clean">
    “制造请求”函数需要驱动编写人员实现。

- **返回值**：无。

一般 blk_alloc_queue 和 blk_queue_make_request 是搭配在一起使用的，用于那么非机械的存储设备、无需 I/O 调度器，比如 EMMC、SD 卡等。blk_init_queue 函数会给请求队列分配一个 I/O 调度器，用于机械存储设备，比如机械硬盘等。



### <span class="hljs-number">2</span>、请求 request

请求队列(request_queue)里面包含的就是一系列的请求(request)，request 是一个结构体，定义在 include/linux/blkdev.h 里面，这里就不展开 request 结构体了，太长了。request 里面有一个名为“bio”的成员变量，类型为 bio 结构体指针。前面说了，真正的数据就保存在 bio 里面，所以我们需要从 request_queue 中取出一个一个的 request，然后再从每个 request 里面取出 bio，最后根据 bio 的描述讲数据写入到块设备，或者从块设备中读取数据。

#### ①、 获取请求

我们需要从request_queue中依次获取每个request，使用blk_peek_request函数完成此操作，函数原型如下：

```c
request *blk_peek_request(struct request_queue *q)</code></pre></div></li>
</ul>
</li>
</ul>
<p>函数参数和返回值含义如下：<br><strong>q</strong> ：指定 request_queue。<br><strong>返回值</strong>：request_queue 中下一个要处理的请求(request)，如果没有要处理的请求就返回 NULL。</p>
<h4 id="②、开启请求"><a href="#②、开启请求" class="headerlink" title="②、开启请求"></a>②、开启请求</h4><p>使用 blk_peek_request 函数获取到下一个要处理的请求以后就要开始处理这个请求，这里要用到 blk_start_request 函数，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">blk_start_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *req)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>req</strong> ：要开始处理的请求。<br><strong>返回值</strong>：无。</p>
<h4 id="③、一步到位处理请求"><a href="#③、一步到位处理请求" class="headerlink" title="③、一步到位处理请求"></a>③、一步到位处理请求</h4><p>我们也可以使用 blk_fetch_request 函数来一次性完成请求的获取和开启，blk_fetch_request函数很简单，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> 	<span class="hljs-keyword">struct</span> request *<span class="hljs-title function_">blk_fetch_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span>
2 	&#123;
<span class="hljs-number">3</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span> 		rq = blk_peek_request(q);
<span class="hljs-number">6</span> 		<span class="hljs-keyword">if</span> (rq)
<span class="hljs-number">7</span> 		blk_start_request(rq);
<span class="hljs-number">8</span> 		<span class="hljs-keyword">return</span> rq;
<span class="hljs-number">9</span> 	&#125;</code></pre></div>

<p>可以看出，blk_fetch_request 就是直接调用了 blk_peek_request 和 blk_start_request 这两个函 数。</p>
<h4 id="④、其他和请求有关的函数"><a href="#④、其他和请求有关的函数" class="headerlink" title="④、其他和请求有关的函数"></a>④、其他和请求有关的函数</h4><p>关于请求的 API 还有很多，常见的见表 ： </p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909164818191.png" srcset="/img/loading.gif" lazyload alt="image-20200909164818191"></p>
<h3 id="3-、bio-结构"><a href="#3-、bio-结构" class="headerlink" title="3 、bio  结构"></a>3 、bio  结构</h3><p>每个 request 里面里面会有多个 bio，bio 保存着最终要读写的数据、地址等信息。上层应用程序对于块设备的都写会被构造成一个或多个 bio 结构，bio 结构描述了要读写的起始扇区、要读写的扇区数量、是读取还是写入、页便宜、数据长度等等信息。上层会讲 bio 提交给 I&#x2F;O 调度器，I&#x2F;O 调度器会将这些 bio 构造成 request 结构，而一个物理存储设备对应一个 request_queue，request_queue 里面顺序存放着一系列的 request。新产生的 bio 可能被合并到 request_queue 里现有的 request 中，也可能产生新的 request，然后插入到 request_queue 中合适的位置，这一切都是由 I&#x2F;O 调度器来完成的。request_queue、request 和 bio 之间的关系如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909164843110.png" srcset="/img/loading.gif" lazyload alt="image-20200909164843110"></p>
<p>bio 是个结构体，定义在 include&#x2F;linux&#x2F;blk_types.h 中，结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> &#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">bi_next</span>;</span> <span class="hljs-comment">/* 请求队列的下一个 bio */</span>
<span class="hljs-number">3</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> *<span class="hljs-title">bi_bdev</span>;</span> <span class="hljs-comment">/* 指向块设备  */</span>
<span class="hljs-number">4</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bi_flags; <span class="hljs-comment">/* bio 状态等信息  */</span>
<span class="hljs-number">5</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bi_rw; <span class="hljs-comment">/* I/O 操作,读或写 */</span>
<span class="hljs-number">6</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bvec_iter</span> <span class="hljs-title">bi_iter</span>;</span>  <span class="hljs-comment">/* I/O 操作,读或写 */</span>
<span class="hljs-number">7</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_phys_segments;
<span class="hljs-number">8</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_seg_front_size;
<span class="hljs-number">9</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_seg_back_size;
<span class="hljs-number">10</span> 		<span class="hljs-type">atomic_t</span> bi_remaining;
<span class="hljs-number">11</span> 		<span class="hljs-type">bio_end_io_t</span> *bi_end_io;
<span class="hljs-number">12</span> 		<span class="hljs-type">void</span> *bi_private;
<span class="hljs-number">13</span> 	<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_CGROUP</span>
<span class="hljs-number">14</span> 		<span class="hljs-comment">/*</span>
<span class="hljs-comment">15 		* Optional ioc and css associated with this bio. Put on bio</span>
<span class="hljs-comment">16 		* release. Read comment on top of bio_associate_current().</span>
<span class="hljs-comment">17 		*/</span>
<span class="hljs-number">18</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_context</span> *<span class="hljs-title">bi_ioc</span>;</span>
<span class="hljs-number">19</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cgroup_subsys_state</span> *<span class="hljs-title">bi_css</span>;</span>
<span class="hljs-number">20</span> 	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-number">21</span> 		<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>
<span class="hljs-number">22</span> 	<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span>
<span class="hljs-number">23</span> 			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_integrity_payload</span> *<span class="hljs-title">bi_integrity</span>;</span>
<span class="hljs-number">24</span> 	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-number">25</span> 		&#125;;
<span class="hljs-number">26</span>
<span class="hljs-number">27</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> bi_vcnt; <span class="hljs-comment">/* bio_vec 列表中元素数量  */</span>
<span class="hljs-number">28</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> bi_max_vecs; <span class="hljs-comment">/* bio_vec 列表长度 */</span>
<span class="hljs-number">29</span> 		<span class="hljs-type">atomic_t</span> bi_cnt; <span class="hljs-comment">/* pin count */</span>
<span class="hljs-number">30</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> *<span class="hljs-title">bi_io_vec</span>;</span> <span class="hljs-comment">/* bio_vec  列表 */</span>
<span class="hljs-number">31</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_set</span> *<span class="hljs-title">bi_pool</span>;</span>
<span class="hljs-number">32</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> <span class="hljs-title">bi_inline_vecs</span>[0];</span>
<span class="hljs-number">33</span> 	&#125;;</code></pre></div>

<p>重点来看一下第 6 行和第 30 行，第 6 行为 bvec_iter 结构体类型的成员变量，第 30 行为bio_vec 结构体指针类型的成员变量。</p>
<p>bvec_iter 结构体描述了要操作的设备扇区等信息，结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bvec_iter</span> &#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-type">sector_t</span> bi_sector; <span class="hljs-comment">/* I/O 请求的设备起始扇区(512 字节) */</span>
<span class="hljs-number">3</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_size; <span class="hljs-comment">/* 剩余的 I/O 数量 */</span>
<span class="hljs-number">4</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_idx; <span class="hljs-comment">/* blv_vec 中当前索引 */</span>
<span class="hljs-number">5</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_bvec_done; <span class="hljs-comment">/* 当前 bvec 中已经处理完成的字节数 */</span>
<span class="hljs-number">6</span> 	&#125;;</code></pre></div>

<p>bio_vec 结构体描述了内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> &#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">bv_page</span>;</span> <span class="hljs-comment">/* 页 */</span>
<span class="hljs-number">3</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bv_len;  <span class="hljs-comment">/* 长度 */</span>
<span class="hljs-number">4</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bv_offset; <span class="hljs-comment">/* 偏移 */</span>
<span class="hljs-number">5</span> 	&#125;;</code></pre></div>

<p>可以看出 bio_vec 就是“page,offset,len”组合，page 指定了所在的物理页，offset 表示所处页的偏移地址，len 就是数据长度。</p>
<p>我们对于物理存储设备的操作不外乎就是将 RAM 中的数据写入到物理存储设备中，或者将物理设备中的数据读取到 RAM 中去处理。数据传输三个要求：数据源、数据长度以及数据目的地，也就是你要从物理存储设备的哪个地址开始读取、读取到 RAM 中的哪个地址处、读取的数据长度是多少。既然 bio 是块设备最小的数据传输单元，那么 bio 就有必要描述清楚这些信息，其中 bi_iter 这个结构体成员变量就用于描述物理存储设备地址信息，比如要操作的扇区地址。bi_io_vec 指向 bio_vec 数组首地址，bio_vec 数组就是 RAM 信息，比如页地址、页偏移以及长度，“页地址”是 linux 内核里面内存管理相关的概念，这里我们不深究 linux 内存管理，我们只需要知道对于 RAM 的操作最终会转换为页相关操作。</p>
<p>bio、bvec_iter 以及 bio_vec 这三个机构体之间的关系如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909165121668.png" srcset="/img/loading.gif" lazyload alt="image-20200909165121668"></p>
<h4 id="①、遍历请求中的-bio"><a href="#①、遍历请求中的-bio" class="headerlink" title="①、遍历请求中的 bio"></a>①、遍历请求中的 bio</h4><p>前面说了，请求中包含有大量的 bio，因此就涉及到遍历请求中所有 bio 并进行处理。遍历请求中的 bio 使用函数__rq_for_each_bio，这是一个宏，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __rq_for_each_bio(_bio, rq) \</span>
<span class="hljs-meta">	<span class="hljs-keyword">if</span> ((rq-&gt;bio)) \</span>
<span class="hljs-meta">		for (_bio = (rq)-&gt;bio; _bio; _bio = _bio-&gt;bi_next)_</span></code></pre></div>

<p>__bio 就是遍历出来的每个 bio，rq 是要进行遍历操作的请求，_bio 参数为 bio 结构体指针类 型，rq 参数为 request 结构体指针类型。</p>
<h4 id="②、遍历-bio-中的所有段"><a href="#②、遍历-bio-中的所有段" class="headerlink" title="②、遍历 bio  中的所有段"></a>②、遍历 bio  中的所有段</h4><p>bio 包含了最终要操作的数据，因此还需要遍历 bio 中的所有段，这里要用到 bio_for_each_segment 函数，此函数也是一个宏，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> bio_for_each_segment(bvl, bio, iter) \</span>
<span class="hljs-meta">	__bio_for_each_segment(bvl, bio, iter, (bio)-&gt;bi_iter)</span></code></pre></div>

<p>第一个 bvl 参数就是遍历出来的每个 bio_vec，第二个 bio 参数就是要遍历的 bio，类型为bio 结构体指针，第三个 iter 参数保存要遍历的 bio 中 bi_iter 成员变量。</p>
<h4 id="③、通知-bio-处理结束"><a href="#③、通知-bio-处理结束" class="headerlink" title="③、通知 bio  处理结束"></a>③、通知 bio  处理结束</h4><p>如果使用“制造请求”，也就是抛开 I&#x2F;O 调度器直接处理 bio 的话，在 bio 处理完成以后要通过内核 bio 处理完成，使用 bio_endio 函数，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">bvoid <span class="hljs-title function_">bio_endio</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bio *bio, <span class="hljs-type">int</span> error)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><p><strong>bio</strong> ：要结束的 bio。</p>
</li>
<li><p><strong>error</strong> ：如果 bio 处理成功的话就直接填 0，如果失败的话就填个负值，比如-EIO。</p>
</li>
<li><p><strong>返回值</strong>：无</p>
</li>
</ul>
<h2 id="三、使用请求队列实验"><a href="#三、使用请求队列实验" class="headerlink" title="三、使用请求队列实验"></a>三、使用请求队列实验</h2><p>关于块设备架构就讲解这些，接下来我们使用开发板上的 RAM 模拟一段块设备，也就是ramdisk，然后编写块设备驱动。</p>
<h3 id="1-实验程序编写"><a href="#1-实验程序编写" class="headerlink" title="1| 实验程序编写"></a>1| 实验程序编写</h3><p>首先是传统的使用请求队列的时候，也就是针对机械硬盘的时候如何编写驱动。由于实验程序稍微有点长，因此我们就分步骤来讲解一下，本实验参考自 linux 内核 drivers&#x2F;block&#x2F;z2ram.c。打开实验源码，我们先来看一下一相关的宏定义和结构体，代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span>
......
<span class="hljs-number">21</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span>
......
<span class="hljs-number">33</span>
<span class="hljs-number">34</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> RAMDISK_SIZE (2 * 1024 * 1024) <span class="hljs-comment">/* 容量大小为 2MB */</span></span>
<span class="hljs-number">35</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> RAMDISK_NAME <span class="hljs-string">&quot;ramdisk&quot;</span> <span class="hljs-comment">/* 名字 */</span></span>
<span class="hljs-number">36</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> RADMISK_MINOR 3 <span class="hljs-comment">/* 表示三个磁盘分区！不是次设备号为 3！ */</span></span>
<span class="hljs-number">37</span>
<span class="hljs-number">38</span> 	<span class="hljs-comment">/* ramdisk 设备结构体 */</span>
<span class="hljs-number">39</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ramdisk_dev</span>&#123;</span>
<span class="hljs-number">40</span> 	<span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span>
<span class="hljs-number">41</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ramdiskbuf; <span class="hljs-comment">/* ramdisk 内存空间,用于模拟块设备 */</span>
<span class="hljs-number">42</span> 	<span class="hljs-type">spinlock_t</span> lock; <span class="hljs-comment">/* 自旋锁 */</span>
<span class="hljs-number">43</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> *<span class="hljs-title">gendisk</span>;</span> <span class="hljs-comment">/* gendisk */</span>
<span class="hljs-number">44</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">queue</span>;</span><span class="hljs-comment">/* 请求队列 */</span>
<span class="hljs-number">45</span> &#125;;
<span class="hljs-number">46</span>
<span class="hljs-number">47</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ramdisk_dev</span> <span class="hljs-title">ramdisk</span>;</span> <span class="hljs-comment">/* ramdisk 设备 */</span></code></pre></div>

<ul>
<li><strong>第34~36行</strong>，实验相关宏定义，RAMDISK_SIZE就是模拟块设备的大小，这里设置为2MB，也就是说本实验中的虚拟块设备大小为 2MB。RAMDISK_NAME 为本实验名字，RADMISK_MINOR 是本实验此设备号数量，注意不是次设备号！此设备号数量决定了本块设备的磁盘分区数量。</li>
<li><strong>第 39~45 行</strong>，ramdisk 的设备结构体。</li>
<li><strong>第 47 行</strong>，定义一个 ramdisk 示例。</li>
</ul>
<p>接下来看一下驱动模块的加载与卸载，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">2 * @description : 驱动出口函数</span>
<span class="hljs-comment">3 * @param : 无</span>
<span class="hljs-comment">4 * @return : 无</span>
<span class="hljs-comment">5 */</span>
<span class="hljs-number">6</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ramdisk_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
7 &#123;
<span class="hljs-number">8</span> 		<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
<span class="hljs-number">9</span>
<span class="hljs-number">10</span> 		<span class="hljs-comment">/* 1、申请用于 ramdisk 内存 */</span>
<span class="hljs-number">11</span> 		ramdisk.ramdiskbuf = kzalloc(RAMDISK_SIZE, GFP_KERNEL);
<span class="hljs-number">12</span> 		<span class="hljs-keyword">if</span>(ramdisk.ramdiskbuf == <span class="hljs-literal">NULL</span>) &#123;
<span class="hljs-number">13</span> 			ret = -EINVAL;
<span class="hljs-number">14</span> 			<span class="hljs-keyword">goto</span> ram_fail;
<span class="hljs-number">15</span> 		&#125;
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> 		<span class="hljs-comment">/* 2、初始化自旋锁 */</span>
<span class="hljs-number">18</span> 		spin_lock_init(&amp;ramdisk.lock);
<span class="hljs-number">19</span>
<span class="hljs-number">20</span> 		<span class="hljs-comment">/* 3、注册块设备 */</span>
<span class="hljs-number">21</span> 		ramdisk.major = register_blkdev(<span class="hljs-number">0</span>, RAMDISK_NAME); <span class="hljs-comment">/* 自动分配 */</span>
<span class="hljs-number">22</span> 		<span class="hljs-keyword">if</span>(ramdisk.major &lt; <span class="hljs-number">0</span>) &#123;
<span class="hljs-number">23</span> 			<span class="hljs-keyword">goto</span> register_blkdev_fail;
<span class="hljs-number">24</span> 		&#125;
<span class="hljs-number">25</span>		printk(<span class="hljs-string">&quot;ramdisk major = %d\r\n&quot;</span>, ramdisk.major);
<span class="hljs-number">26</span>
<span class="hljs-number">27</span> 		<span class="hljs-comment">/* 4、分配并初始化 gendisk */</span>
<span class="hljs-number">28</span> 		ramdisk.gendisk = alloc_disk(RADMISK_MINOR);
<span class="hljs-number">29</span> 		<span class="hljs-keyword">if</span>(!ramdisk.gendisk) &#123;
<span class="hljs-number">30</span> 			ret = -EINVAL;
<span class="hljs-number">31</span> 			<span class="hljs-keyword">goto</span> gendisk_alloc_fail;
<span class="hljs-number">32</span> 		&#125;
<span class="hljs-number">33</span>
<span class="hljs-number">34</span> 		<span class="hljs-comment">/* 5、分配并初始化请求队列 */</span>
<span class="hljs-number">35</span> 		ramdisk.<span class="hljs-built_in">queue</span> = blk_init_queue(ramdisk_request_fn,&amp;ramdisk.lock);
<span class="hljs-number">36</span> 		<span class="hljs-keyword">if</span>(!ramdisk.<span class="hljs-built_in">queue</span>) &#123;
<span class="hljs-number">37</span> 			ret = EINVAL;
<span class="hljs-number">38</span> 			<span class="hljs-keyword">goto</span> blk_init_fail;
<span class="hljs-number">39</span> 		&#125;
<span class="hljs-number">40</span>
<span class="hljs-number">41</span> 		<span class="hljs-comment">/* 6、添加(注册)disk */</span>
<span class="hljs-number">42</span> 		ramdisk.gendisk-&gt;major = ramdisk.major;  <span class="hljs-comment">/* 主设备号 */</span>
<span class="hljs-number">43</span> 		ramdisk.gendisk-&gt;first_minor = <span class="hljs-number">0</span>; <span class="hljs-comment">/*起始次设备号) */</span>
<span class="hljs-number">44</span> 		ramdisk.gendisk-&gt;fops = &amp;ramdisk_fops; <span class="hljs-comment">/* 操作函数 */</span>
<span class="hljs-number">45</span> 		ramdisk.gendisk-&gt;private_data = &amp;ramdisk; <span class="hljs-comment">/* 私有数据 */</span>
<span class="hljs-number">46</span> 		ramdisk.gendisk-&gt;<span class="hljs-built_in">queue</span> = ramdisk.<span class="hljs-built_in">queue</span>; <span class="hljs-comment">/* 请求队列 */</span>
<span class="hljs-number">47</span> 		<span class="hljs-built_in">sprintf</span>(ramdisk.gendisk-&gt;disk_name, RAMDISK_NAME);<span class="hljs-comment">/* 名字 */</span>
<span class="hljs-number">48</span> 		set_capacity(ramdisk.gendisk, RAMDISK_SIZE/<span class="hljs-number">512</span>); <span class="hljs-comment">/* 设备容量(单位 为扇区)*/</span>
<span class="hljs-number">49</span> 		add_disk(ramdisk.gendisk);
<span class="hljs-number">50</span>
<span class="hljs-number">51</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">52</span>
<span class="hljs-number">53</span> 		blk_init_fail:
<span class="hljs-number">54</span> 		put_disk(ramdisk.gendisk);
<span class="hljs-number">55</span> 		gendisk_alloc_fail:
<span class="hljs-number">56</span> 		unregister_blkdev(ramdisk.major, RAMDISK_NAME);
<span class="hljs-number">57</span> 		register_blkdev_fail:
<span class="hljs-number">58</span> 		kfree(ramdisk.ramdiskbuf); <span class="hljs-comment">/* 释放内存 */</span>
<span class="hljs-number">59</span> 		ram_fail:
<span class="hljs-number">60</span> 		<span class="hljs-keyword">return</span> ret;
<span class="hljs-number">61</span> &#125;
<span class="hljs-number">62</span>
<span class="hljs-number">63</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">64 * @description : 驱动出口函数</span>
<span class="hljs-comment">65 * @param : 无</span>
<span class="hljs-comment">66 * @return : 无</span>
<span class="hljs-comment">67 */</span>
<span class="hljs-number">68</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">ramdisk_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
69 &#123;
<span class="hljs-number">70</span> 		<span class="hljs-comment">/* 释放 gendisk */</span>
<span class="hljs-number">71</span> 		put_disk(ramdisk.gendisk);
<span class="hljs-number">72</span> 		del_gendisk(ramdisk.gendisk);
<span class="hljs-number">73</span>
<span class="hljs-number">74</span> 		<span class="hljs-comment">/* 清除请求队列 */</span>
<span class="hljs-number">75</span> 		blk_cleanup_queue(ramdisk.<span class="hljs-built_in">queue</span>);
<span class="hljs-number">76</span>
<span class="hljs-number">77</span> 		<span class="hljs-comment">/* 注销块设备 */</span>
<span class="hljs-number">78</span> 		unregister_blkdev(ramdisk.major, RAMDISK_NAME);
<span class="hljs-number">79</span>
<span class="hljs-number">80</span> 		<span class="hljs-comment">/* 释放内存 */</span>
<span class="hljs-number">81</span> 		kfree(ramdisk.ramdiskbuf);
<span class="hljs-number">82</span> &#125;
<span class="hljs-number">83</span>
<span class="hljs-number">84</span> module_init(ramdisk_init);
<span class="hljs-number">85</span> module_exit(ramdisk_exit);
<span class="hljs-number">86</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-number">87</span> MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>ramdisk_init 和 ramdisk_exit 这两个函数分别为驱动入口以及出口函数，我们依次来看一下这两个函数。</p>
<ul>
<li>第 11 行，因为本实验是使用一块内存模拟真实的块设备，因此这里先使用 kzalloc 函数申请用于 ramdisk 实验的内存，大小为 2MB。</li>
<li>第 18 行，初始化一个自旋锁，blk_init_queue 函数在分配并初始化请求队列的时候需要用到一次自旋锁。</li>
<li>第 21 行，使用 register_blkdev 函数向内核注册一个块设备，返回值就是注册成功的块设备主设备号。这里我们让内核自动分配一个主设备号，因此 register_blkdev 函数的第一个参数为0。</li>
<li>第 28 行，使用 alloc_disk 分配一个 gendisk。</li>
<li>第 35 行，使用 blk_init_queue 函数分配并初始化一个请求队列，请求处理函数为ramdisk_request_fn，具体的块设备读写操作就在此函数中完成，这个需要驱动开发人员去编写，稍后讲解。</li>
<li>第 42~47 行，初始化第 28 行申请到的 gendisk，重点是第 44 行设置 gendisk 的 fops 成员变量，也就是设置块设备的操作集。这里设置为 ramdisk_fops，需要驱动开发人员自行编写实现，稍后讲解。</li>
<li>第 48 行，使用 set_capacity 函数设置本块设备容量大小，注意这里的大小是扇区数，不是字节数，一个扇区是 512 字节。</li>
<li>第 48 行，gendisk 初始化完成以后就可以使用 add_disk 函数将 gendisk 添加到内核中，也就是向内核添加一个磁盘设备。</li>
<li>ramdisk_exit 函数就比较简单了，在卸载块设备驱动的时候需要将前面申请的内容都释放掉。第 71 和 72 行使用 put_disk 和 del_gendis 函数释放前面申请的 gendisk，第 75 行使用blk_cleanup_queue 函数消除前面申请的请求队列，第 78 行使用 unregister_blkdev 函数注销前面注册的块设备，最后调用 kfree 来释放掉申请的内存。</li>
</ul>
<p>在 ramdisk_init 函数中设置了 gendisk 的 fops 成员变量，也就是块设备的操作集，具体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">2 * @description : 打开块设备</span>
<span class="hljs-comment">3 * @param - dev : 块设备</span>
<span class="hljs-comment">4 * @param - mode : 打开模式</span>
<span class="hljs-comment">5 * @return : 0 成功;其他 失败</span>
<span class="hljs-comment">6 */</span>
<span class="hljs-number">7</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ramdisk_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> block_device *dev, <span class="hljs-type">fmode_t</span> mode)</span>
8 &#123;
<span class="hljs-number">9</span> 		printk(<span class="hljs-string">&quot;ramdisk open\r\n&quot;</span>);
<span class="hljs-number">10</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">11</span> &#125;
<span class="hljs-number">12</span>
<span class="hljs-number">13</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">14 * @description : 释放块设备</span>
<span class="hljs-comment">15 * @param - disk : gendisk</span>
<span class="hljs-comment">16 * @param - mode : 模式</span>
<span class="hljs-comment">17 * @return : 0 成功;其他 失败</span>
<span class="hljs-comment">18 */</span>
<span class="hljs-number">19</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ramdisk_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk, <span class="hljs-type">fmode_t</span> mode)</span>
20 &#123;
<span class="hljs-number">21</span> 		printk(<span class="hljs-string">&quot;ramdisk release\r\n&quot;</span>);
<span class="hljs-number">22</span> &#125;
<span class="hljs-number">23</span>
<span class="hljs-number">24</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">25 * @description  : 获取磁盘信息</span>
<span class="hljs-comment">26 * @param - dev : 块设备</span>
<span class="hljs-comment">27 * @param - geo : 模式</span>
<span class="hljs-comment">28 * @return : 0 成功;其他 失败</span>
<span class="hljs-comment">29 */</span>
<span class="hljs-number">30</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ramdisk_getgeo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> block_device *dev, <span class="hljs-keyword">struct</span> hd_geometry *geo)</span>
31 &#123;
<span class="hljs-number">32</span> 		<span class="hljs-comment">/* 这是相对于机械硬盘的概念 */</span>
<span class="hljs-number">33</span> 		geo-&gt;heads = <span class="hljs-number">2</span>; <span class="hljs-comment">/* 磁头 */</span>
<span class="hljs-number">34</span> 		geo-&gt;cylinders = <span class="hljs-number">32</span>; <span class="hljs-comment">/* 柱面 */</span>
<span class="hljs-number">35</span> 		geo-&gt;sectors = RAMDISK_SIZE / (<span class="hljs-number">2</span> * <span class="hljs-number">32</span> *<span class="hljs-number">512</span>); <span class="hljs-comment">/* 磁道上的扇区数量 */</span>
<span class="hljs-number">36</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">37</span> &#125;
<span class="hljs-number">38</span>
<span class="hljs-number">39</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">40 * 块设备操作函数</span>
<span class="hljs-comment">41 */</span>
<span class="hljs-number">42</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device_operations</span> <span class="hljs-title">ramdisk_fops</span> =</span>
<span class="hljs-number">43</span> &#123;
<span class="hljs-number">44</span> 		.owner = THIS_MODULE,
<span class="hljs-number">45</span> 		.open = ramdisk_open,
<span class="hljs-number">46</span> 		.release = ramdisk_release,
<span class="hljs-number">47</span> 		.getgeo = ramdisk_getgeo,
<span class="hljs-number">48</span> &#125;;</code></pre></div>

<p>第 42<del>48 行就是块设备的操作集 block_device_operations，本例程实现的比较简单，仅仅实现了 open、release 和 getgeo，其中 open 和 release 函数都是空函数。重点是 getgeo 函数，第30</del>37 行就是 getgeo 的具体实现，此函数用户获取磁盘信息，信息保存在参数 geo 中，为结构体 hd_geometry 类型，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_geometry</span> &#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> heads; <span class="hljs-comment">/* 磁头 */</span>
<span class="hljs-number">3</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sectors; <span class="hljs-comment">/*一个磁道上的扇区数量 */</span>
<span class="hljs-number">4</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cylinders; <span class="hljs-comment">/* 柱面 */</span>
<span class="hljs-number">5</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start;
<span class="hljs-number">6</span> &#125;;</code></pre></div>

<p>本例程中设置 ramdisk 有 2 个磁头(head)、一共有 32 个柱面(cylinderr)。知道磁盘总容量、磁头数、柱面数以后我们就可以计算出一个磁道上有多少个扇区了，也就是 hd_geometry 中的sectors 成员变量。</p>
<p>最后就是非常重要的请求处理函数，使用 blk_init_queue 函数初始化队列的时候需要指定一个请求处理函数，本例程中注册的请求处理函数如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">2 * @description : 处理传输过程</span>
<span class="hljs-comment">3 * @param-req : 请求</span>
<span class="hljs-comment">4 * @return : 无</span>
<span class="hljs-comment">5 */</span>
<span class="hljs-number">6</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ramdisk_transfer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *req)</span>
7 &#123;
<span class="hljs-number">8</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start = blk_rq_pos(req) &lt;&lt; <span class="hljs-number">9</span>; <span class="hljs-comment">/* blk_rq_pos 获取到的是扇区地址，左移 9 位转换为字节地址 */</span>
<span class="hljs-number">9</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len = blk_rq_cur_bytes(req); <span class="hljs-comment">/* 大小 */</span>
<span class="hljs-number">10</span>
<span class="hljs-number">11</span> 		<span class="hljs-comment">/* bio 中的数据缓冲区</span>
<span class="hljs-comment">12 		* 读：从磁盘读取到的数据存放到 buffer 中</span>
<span class="hljs-comment">13 		* 写：buffer 保存这要写入磁盘的数据</span>
<span class="hljs-comment">14 		*/</span>
<span class="hljs-number">15</span> 		<span class="hljs-type">void</span> *buffer = bio_data(req-&gt;bio);
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> 		<span class="hljs-keyword">if</span>(rq_data_dir(req) == READ) <span class="hljs-comment">/* 读数据 */</span>
<span class="hljs-number">18</span> 			<span class="hljs-built_in">memcpy</span>(buffer, ramdisk.ramdiskbuf + start, len);
<span class="hljs-number">19</span> 		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rq_data_dir(req) == WRITE) <span class="hljs-comment">/* 写数据 */</span>
<span class="hljs-number">20</span> 			<span class="hljs-built_in">memcpy</span>(ramdisk.ramdiskbuf + start, buffer, len);
<span class="hljs-number">21</span>
<span class="hljs-number">22</span> &#125;
<span class="hljs-number">23</span>
<span class="hljs-number">24</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">25 * @description : 请求处理函数</span>
<span class="hljs-comment">26 * @param-q : 请求队列</span>
<span class="hljs-comment">27 * @return : 无</span>
<span class="hljs-comment">28 */</span>
<span class="hljs-number">29</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ramdisk_request_fn</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span>
30 &#123;
<span class="hljs-number">31</span> 		<span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;
<span class="hljs-number">32</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">req</span>;</span>
<span class="hljs-number">33</span>
<span class="hljs-number">34</span> 		<span class="hljs-comment">/* 循环处理请求队列中的每个请求 */</span>
<span class="hljs-number">35</span> 		req = blk_fetch_request(q);
<span class="hljs-number">36</span> 		<span class="hljs-keyword">while</span>(req != <span class="hljs-literal">NULL</span>) &#123;
<span class="hljs-number">37</span>
<span class="hljs-number">38</span> 			<span class="hljs-comment">/* 针对请求做具体的传输处理 */</span>
<span class="hljs-number">39</span> 			ramdisk_transfer(req);
<span class="hljs-number">40</span>
<span class="hljs-number">41</span> 			<span class="hljs-comment">/* 判断是否为最后一个请求，如果不是的话就获取下一个请求</span>
<span class="hljs-comment">42 			* 循环处理完请求队列中的所有请求。</span>
<span class="hljs-comment">43 			*/</span>
<span class="hljs-number">44</span> 			<span class="hljs-keyword">if</span> (!__blk_end_request_cur(req, err))
<span class="hljs-number">45</span> 				req = blk_fetch_request(q);
<span class="hljs-number">46</span> 			&#125;
<span class="hljs-number">47</span> &#125;</code></pre></div>

<p>请求处理函数的重要内容就是完成从块设备中读取数据，或者向块设备中写入数据。首先c来看一下 29~47 行的 ramdisk_request_fn 函数，这个就是请求处理函数。此函数只要一个参数q，为 request_queue 结构体指针类型，也就是要处理的请求队列，因此 ramdisk_request_fn 函数的主要工作就是依次处理请求队列中的所有请求。第 35 行，首先使用 blk_fetch_request 函数获取请求队列中第一个请求，如果请求不为空的话就调用 ramdisk_transfer 函数进行对请求做进一步的处理，然后就是 while 循环依次处理完请求队列中的每个请求。第 44 行使用__blk_end_request_cur 函数检查是否为最后一个请求，如果不是的话就继续获取下一个，直至整个请求队列处理完成。</p>
<p>ramdisk_transfer 函数完成清楚中的数据处理，第 8 行调用 blk_rq_pos 函数从请求中获取要操作的块设备扇区地址，第 9 行使用 blk_rq_cur_bytes 函数获取请求要操作的数据长度，第 15行使用 bio_data 函数获取请求中 bio 保存的数据。第 17 ~20 行调用 rq_data_dir 函数判断当前是读还是写，如果是写的话就将 bio 中的数据拷贝到 ramdisk 指定地址(扇区)，如果是读的话就从ramdisk 中的指定地址(扇区)读取数据放到 bio 中。</p>
<h3 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2| 运行测试"></a>2| 运行测试</h3><p>编译上一小节的驱动，得到 ramdisk.ko 驱动模块，然后拷贝到 rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15 目录中，重启开发板，进入到目录 lib&#x2F;modules&#x2F;4.1.15 中。输入如下命令加载 ramdisk.ko 这个驱动模块。</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">depmod //第一次加载驱动的时候需要运行此命令
modprobe ramdisk.ko  //加载驱动模块</code></pre></div>

<h4 id="1-、查看-ramdisk-磁盘"><a href="#1-、查看-ramdisk-磁盘" class="headerlink" title="1 、查看 ramdisk  磁盘"></a>1 、查看 ramdisk  磁盘</h4><p>驱动加载成功以后就会在&#x2F;dev&#x2F;目录下生成一个名为“ramdisk”的设备， 输入如下命令查看ramdisk 磁盘信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">fdisk -l  //查看磁盘信息</code></pre></div>

<p>上述命令会将当前系统中所有的磁盘信息都打印出来，其中就包括了 ramdisk 设备，如图 所示</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909170421873.png" srcset="/img/loading.gif" lazyload alt="image-20200909170421873"></p>
<p>从图可以看出，ramdisk已经识别出来了，大小为2MB，但是同时也提示&#x2F;dev&#x2F;ramdisk没有分区表，因为我们还没有格式化&#x2F;dev&#x2F;ramdisk。</p>
<h4 id="2-、格式化-x2F-dev-x2F-ramdisk"><a href="#2-、格式化-x2F-dev-x2F-ramdisk" class="headerlink" title="2 、格式化&#x2F;dev&#x2F;ramdisk"></a>2 、格式化&#x2F;dev&#x2F;ramdisk</h4><p>使用 mkfs.vfat 命令格式化&#x2F;dev&#x2F;ramdisk，将其格式化成 vfat 格式，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">mkfs.vfat /dev/ramdisk</code></pre></div>

<p>格式化完成以后就可以挂载&#x2F;dev&#x2F;ramdisk 来访问了，挂载点可以自定义，这里笔者就将其挂载到&#x2F;tmp 目录下，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">mount /dev/ramdisk /tmp</code></pre></div>

<p>挂载成功以后就可以通过&#x2F;tmp 来访问 ramdisk 这个磁盘了，进入到&#x2F;tmp 目录中，可以通过 vi 命令新建一个 txt 文件来测试磁盘访问是否正常。</p>
<h2 id="四、不使用请求队列实验"><a href="#四、不使用请求队列实验" class="headerlink" title="四、不使用请求队列实验"></a>四、不使用请求队列实验</h2><h3 id="1-实验程序编写-1"><a href="#1-实验程序编写-1" class="headerlink" title="1| 实验程序编写"></a>1| 实验程序编写</h3><p>本实验对应的例程路径为：开发板光盘-&gt; 2、Linux 驱动例程-&gt; 25_ramdisk_norequest。</p>
<p>前面我们学习了如何使用请求队列，请求队列会用到 I&#x2F;O 调度器，适合机械硬盘这种存储设备。对于 EMMC、SD、ramdisk 这样没有机械结构的存储设备，我们可以直接访问任意一个扇区，因此可以不需要 I&#x2F;O 调度器，也就不需要请求队列了，这个我们前面已经说过了。本实验就来学习一下如何使用“制造请求”方法，本实验在上一个实验的基础上修改而来，参考了linux 内核 drivers&#x2F;block&#x2F;zram&#x2F;zram_drv.c。重点来看一下与上一个实验不同的地方，首先是驱动入口函数 ramdisk_init，ramdisk_init 函数大部分和上一个实验相同，只是本实验中改为使用blk_queue_make_request 函数设置“制造请求”函数，修改后的 ramdisk_init 函数内容如下(有省略)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ramdisk_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
2 &#123;
......
<span class="hljs-number">29</span>
<span class="hljs-number">30</span> 		<span class="hljs-comment">/* 5、分配请求队列 */</span>
<span class="hljs-number">31</span> 		ramdisk.<span class="hljs-built_in">queue</span> = blk_alloc_queue(GFP_KERNEL);
<span class="hljs-number">32</span> 		<span class="hljs-keyword">if</span>(!ramdisk.<span class="hljs-built_in">queue</span>)&#123;
<span class="hljs-number">33</span> 			ret = -EINVAL;
<span class="hljs-number">34</span> 			<span class="hljs-keyword">goto</span> blk_allo_fail;
<span class="hljs-number">35</span> 		&#125;
<span class="hljs-number">36</span>
<span class="hljs-number">37</span> 		<span class="hljs-comment">/* 6 、设置“ 制造请求” 函数 */</span>
<span class="hljs-number">38</span> 		blk_queue_make_request(ramdisk.<span class="hljs-built_in">queue</span>, ramdisk_make_request_fn);
<span class="hljs-number">39</span>
<span class="hljs-number">40</span> 		<span class="hljs-comment">/* 7、添加(注册)disk */</span>
<span class="hljs-number">41</span> 		ramdisk.gendisk-&gt;major = ramdisk.major; <span class="hljs-comment">/* 主设备号 */</span>
<span class="hljs-number">42</span> 		ramdisk.gendisk-&gt;first_minor = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 起始次设备号 */</span>
<span class="hljs-number">43</span> 		ramdisk.gendisk-&gt;fops = &amp;ramdisk_fops; <span class="hljs-comment">/*  操作函数 */</span>
<span class="hljs-number">44</span> 		ramdisk.gendisk-&gt;private_data = &amp;ramdisk; <span class="hljs-comment">/* 私有数据 */</span>
<span class="hljs-number">45</span> 		ramdisk.gendisk-&gt;<span class="hljs-built_in">queue</span> = ramdisk.<span class="hljs-built_in">queue</span>; <span class="hljs-comment">/* 请求队列 */</span>
<span class="hljs-number">46</span> 		<span class="hljs-built_in">sprintf</span>(ramdisk.gendisk-&gt;disk_name, RAMDISK_NAME); <span class="hljs-comment">/* 名字 */</span>
<span class="hljs-number">47</span> 		set_capacity(ramdisk.gendisk, RAMDISK_SIZE/<span class="hljs-number">512</span>); <span class="hljs-comment">/* 设备容量*/</span>
<span class="hljs-number">48</span> 		add_disk(ramdisk.gendisk);
<span class="hljs-number">49</span>
......
<span class="hljs-number">60</span> 		<span class="hljs-keyword">return</span> ret;
<span class="hljs-number">61</span> &#125;</code></pre></div>

<p>amdisk_init 函数中第 31~38 行就是与上一个实验不同的地方，这里使用 blk_alloc_queue和 blk_queue_make_request 这两个函数取代了上一个实验的 blk_init_queue 函数。</p>
<p>第 31 行，使用 blk_alloc_queue 函数申请一个请求队列。</p>
<p>第 38 行，使用 blk_queue_make_request 函数设置“制造请求”函数，这里设置的制造请求函数为 ramdisk_make_request_fn，这个需要驱动编写人员去实现，稍后讲解。</p>
<p>第 43 行，设置块设备操作集为 ramdisk_fops，和上一个实验一模一样，这里就不讲解了。</p>
<p>接下来重点看一下“制造请求”函数 ramdisk_make_request_fn，函数内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">2 * @description : “制造请求”函数</span>
<span class="hljs-comment">3 * @param-q : 请求队列</span>
<span class="hljs-comment">4 * @return : 无</span>
<span class="hljs-comment">5 */</span>
<span class="hljs-number">6</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ramdisk_make_request_fn</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> bio *bio)</span>
7 &#123;
<span class="hljs-number">8</span> 		<span class="hljs-type">int</span> offset;
<span class="hljs-number">9</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> <span class="hljs-title">bvec</span>;</span>
<span class="hljs-number">10</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bvec_iter</span> <span class="hljs-title">iter</span>;</span>
<span class="hljs-number">11</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len = <span class="hljs-number">0</span>;
<span class="hljs-number">12</span>
<span class="hljs-number">13</span> 		offset = (bio-&gt;bi_iter.bi_sector) &lt;&lt; <span class="hljs-number">9</span>; <span class="hljs-comment">/* 获取设备的偏移地址 */</span>
<span class="hljs-number">14</span>
<span class="hljs-number">15</span> 		<span class="hljs-comment">/* 处理 bio 中的每个段 */</span>
<span class="hljs-number">16</span> 		bio_for_each_segment(bvec, bio, iter)&#123;
<span class="hljs-number">17</span> 			<span class="hljs-type">char</span> *ptr = page_address(bvec.bv_page) + bvec.bv_offset;
<span class="hljs-number">18</span> 			len = bvec.bv_len;
<span class="hljs-number">19</span>
<span class="hljs-number">20</span> 			<span class="hljs-keyword">if</span>(bio_data_dir(bio) == READ) <span class="hljs-comment">/* 读数据 */</span>
<span class="hljs-number">21</span> 				<span class="hljs-built_in">memcpy</span>(ptr, ramdisk.ramdiskbuf + offset, len);
<span class="hljs-number">22</span> 			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bio_data_dir(bio) == WRITE) <span class="hljs-comment">/* 写数据 */</span>
<span class="hljs-number">23</span> 				<span class="hljs-built_in">memcpy</span>(ramdisk.ramdiskbuf + offset, ptr, len);
<span class="hljs-number">24</span> 			offset += len;
<span class="hljs-number">25</span> 		&#125;
<span class="hljs-number">26</span> 		set_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags);
<span class="hljs-number">27</span> 		bio_endio(bio, <span class="hljs-number">0</span>);
<span class="hljs-number">28</span> &#125;</code></pre></div>

<p>虽然 ramdisk_make_request_fn 函数第一个参数依旧是请求队列，但是实际上这个请求队列不包含真正的请求，所有的处理内容都在第二个 bio 参数里面，所以 ramdisk_make_request_fn 函数里面是全部是对 bio 的操作。</p>
<p>第 13 行，直接读取 bio 的 bi_iter 成员变量的 bi_sector 来获取要操作的设备地址(扇区)。</p>
<p>第 16~25 行，使用 bio_for_each_segment 函数循环获取 bio 中的每个段，然后对其每个段进行处理。</p>
<p>第 17 行，根据 bio_vec 中页地址以及偏移地址转换为真正的数据起始地址。</p>
<p>第 18 行，获取要出来的数据长度，也就是 bio_vec 的 bv_len 成员变量。</p>
<p>第 20~23 行，和上一个实验一样，要操作的块设备起始地址知道了，数据的存放地址以及长度也知道，接下来就是根据读写操作将数据从块设备中读出来，或者将数据写入到块设备中。</p>
<p>第 27 行，调用 bio_endio 函数，结束 bio。</p>
<h3 id="2-运行测试-1"><a href="#2-运行测试-1" class="headerlink" title="2| 运行测试"></a>2| 运行测试</h3><p>测试方法和上一个实验一样，参考前面小节即可。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">22| Linux 音频驱动</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/13%E3%80%81Linux%E8%87%AA%E5%B8%A6%E7%9A%84LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">13| Linux自带的LED灯驱动</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
