

<!DOCTYPE html>
<html lang="zh-cn" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux SPI驱动实验上一章我们讲解了如何编写 Linux 下的 I2C 设备驱动，SPI 也是很常用的串行通信协议，本章我们就来学习如何在 Linux 下编写 SPI 设备驱动。本章实验的最终目的就是驱动 I.MX6U-ALPHA 开发板上的 ICM-20608 这个 SPI 接口的六轴传感器，可以在应用程序中读取 ICM-20608的原始传感器数据。 1| Linux 下 下 SPI 驱动">
<meta property="og:type" content="article">
<meta property="og:title" content="19| Linux SPI驱动实验">
<meta property="og:url" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Linux SPI驱动实验上一章我们讲解了如何编写 Linux 下的 I2C 设备驱动，SPI 也是很常用的串行通信协议，本章我们就来学习如何在 Linux 下编写 SPI 设备驱动。本章实验的最终目的就是驱动 I.MX6U-ALPHA 开发板上的 ICM-20608 这个 SPI 接口的六轴传感器，可以在应用程序中读取 ICM-20608的原始传感器数据。 1| Linux 下 下 SPI 驱动">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200904113227640.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200904121240231.png">
<meta property="article:published_time" content="2020-09-13T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-13T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200904113227640.png">
  
  
  <title>19| Linux SPI驱动实验 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="19| Linux SPI驱动实验">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-14 00:00" pubdate>
        2020年9月14日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      26k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      220 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">19| Linux SPI驱动实验</h1>
            
            <div class="markdown-body">
              <h1 id="Linux-SPI驱动实验"><a href="#Linux-SPI驱动实验" class="headerlink" title="Linux SPI驱动实验"></a>Linux SPI驱动实验</h1><p>上一章我们讲解了如何编写 Linux 下的 I2C 设备驱动，SPI 也是很常用的串行通信协议，本章我们就来学习如何在 Linux 下编写 SPI 设备驱动。本章实验的最终目的就是驱动 I.MX6U-ALPHA 开发板上的 ICM-20608 这个 SPI 接口的六轴传感器，可以在应用程序中读取 ICM-20608的原始传感器数据。</p>
<h2 id="1-Linux-下-下-SPI-驱动框架简介"><a href="#1-Linux-下-下-SPI-驱动框架简介" class="headerlink" title="1| Linux 下 下 SPI 驱动框架简介"></a>1| Linux 下 下 SPI 驱动框架简介</h2><p>SPI 驱动框架和 I2C 很类似，都分为主机控制器驱动和设备驱动，主机控制器也就是 SOC的SPI控制器接口。我们编写好 SPI 控制器驱动以后就可以直接使用了，不管是什么 SPI 设备，SPI 控制器部分的驱动都是一样，我们的重点就落在了种类繁多的 SPI 设备驱动。</p>
<h3 id="1-SPI-主机驱动"><a href="#1-SPI-主机驱动" class="headerlink" title="1. SPI  主机驱动"></a>1. SPI  主机驱动</h3><p>SPI 主机驱动就是 SOC 的 SPI 控制器驱动，类似 I2C 驱动里面的适配器驱动。Linux 内核使用 spi_master 表示 SPI 主机驱动，spi_master 是个结构体，定义在 include&#x2F;linux&#x2F;spi&#x2F;spi.h 文件中，内容如下(有缩减)：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">315</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_master</span> &#123;</span>
<span class="hljs-number">316</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>
<span class="hljs-number">317</span>
<span class="hljs-number">318</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span>
......
<span class="hljs-number">326</span> 	s16 bus_num;
<span class="hljs-number">327</span>
<span class="hljs-number">328</span> 	<span class="hljs-comment">/* chipselects will be integral to many controllers; some others</span>
<span class="hljs-comment">329 	* might use board-specific GPIOs.</span>
<span class="hljs-comment">330 	*/</span>
<span class="hljs-number">331</span> 	u16 num_chipselect;
<span class="hljs-number">332</span>
<span class="hljs-number">333</span> 	<span class="hljs-comment">/* some SPI controllers pose alignment requirements on DMAable</span>
<span class="hljs-comment">334 	* buffers; let protocol drivers know about these requirements.</span>
<span class="hljs-comment">335 	*/</span>
<span class="hljs-number">336</span> 	u16 dma_alignment;
<span class="hljs-number">337</span>
<span class="hljs-number">338</span> 	<span class="hljs-comment">/* spi_device.mode flags understood by this controller driver */</span>
<span class="hljs-number">339</span> 	u16 mode_bits;
<span class="hljs-number">340</span>
<span class="hljs-number">341</span> 	<span class="hljs-comment">/* bitmask of supported bits_per_word for transfers */</span>
<span class="hljs-number">342</span> 	u32 bits_per_word_mask;
......
<span class="hljs-number">347</span> 	<span class="hljs-comment">/* limits on transfer speed */</span>
<span class="hljs-number">348</span> 	u32 min_speed_hz;
<span class="hljs-number">349</span> 	u32 max_speed_hz;
<span class="hljs-number">350</span>
<span class="hljs-number">351</span> 	<span class="hljs-comment">/* other constraints relevant to this driver */</span>
<span class="hljs-number">352</span> 	u16 flags;
......
<span class="hljs-number">359</span> 	<span class="hljs-comment">/* lock and mutex for SPI bus locking */</span>
<span class="hljs-number">360</span> 	<span class="hljs-type">spinlock_t</span> bus_lock_spinlock;
<span class="hljs-number">361</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">bus_lock_mutex</span>;</span>
<span class="hljs-number">362</span>
<span class="hljs-number">363</span> 	<span class="hljs-comment">/* flag indicating that the SPI bus is locked for exclusive use */</span>
<span class="hljs-number">364</span> 	<span class="hljs-type">bool</span> bus_lock_flag;
......
<span class="hljs-number">372</span> 	<span class="hljs-type">int</span> (*setup)(<span class="hljs-keyword">struct</span> spi_device *spi);
<span class="hljs-number">373</span>
......
<span class="hljs-number">393</span> 	<span class="hljs-type">int</span> (*transfer)(<span class="hljs-keyword">struct</span> spi_device *spi,
<span class="hljs-number">394</span> 					<span class="hljs-keyword">struct</span> spi_message *mesg);
......
<span class="hljs-number">434</span> 	<span class="hljs-type">int</span> (*transfer_one_message)(<span class="hljs-keyword">struct</span> spi_master *master,
<span class="hljs-number">435</span> 								<span class="hljs-keyword">struct</span> spi_message *mesg);
......
<span class="hljs-number">462</span> &#125;;</code></pre></div>

<p>第 393 行，transfer 函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函数。</p>
<p>第 434 行，transfer_one_message 函数，也用于 SPI 数据发送，用于发送一个 spi_message，SPI 的数据会打包成 spi_message，然后以队列方式发送出去。也就是 SPI 主机端最终会通过 transfer 函数与 SPI 设备进行通信，因此对于 SPI 主机控制器的驱动编写者而言 transfer 函数是需要实现的，因为不同的 SOC 其 SPI 控制器不同，寄存器都不一样。和 I2C 适配器驱动一样，SPI 主机驱动一般都是 SOC 厂商去编写的，所以我们作为 SOC 的使用者，这一部分的驱动就不用操心了，除非你是在 SOC 原厂工作，内容就是写 SPI 主机驱动。</p>
<p>SPI 主机驱动的核心就是申请 spi_master，然后初始化 spi_master，最后向 Linux 内核注册spi_master。</p>
<h4 id="1-、spi-master-申请与释放"><a href="#1-、spi-master-申请与释放" class="headerlink" title="1 、spi_master 申请与释放"></a>1 、spi_master 申请与释放</h4><p>spi_alloc_master 函数用于<strong>申请 spi_master</strong>，函数原型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> spi_master *<span class="hljs-title function_">spi_alloc_master</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">unsigned</span> size)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<p><strong>dev</strong>：设备，一般是 platform_device 中的 dev 成员变量。<br><strong>size</strong> ：私有数据大小，可以通过 spi_master_get_devdata 函数获取到这些私有数据。<br><strong>返回值</strong>：申请到的 spi_master。</p>
<hr>
<p><strong>spi_master 的释放</strong>通过 spi_master_put 函数来完成，当我们删除一个 SPI 主机驱动的时候就需要释放掉前面申请的 spi_master，spi_master_put 函数原型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_master_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_master *master)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>master</strong>：要释放的 spi_master。<br><strong>返回值</strong>：无。</p>
<h4 id="2、spi-master-的注册与注销"><a href="#2、spi-master-的注册与注销" class="headerlink" title="2、spi_master 的注册与注销"></a>2、spi_master 的注册与注销</h4><p>当 spi_master 初始化完成以后就需要将其注册到 Linux 内核，spi_master <strong>注册函数</strong>为<br>spi_register_master，函数原型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_register_master</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_master *master)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>master</strong>：要注册的 spi_master。<br><strong>返回值</strong>：0，成功；负值，失败。</p>
<p>I.MX6U 的 SPI 主机驱动会采用 spi_bitbang_start 这个 API 函数来完成 spi_master 的注册，spi_bitbang_start 函数内部其实也是通过调用 spi_register_master 函数来完成 spi_master 的注册。</p>
<hr>
<p>如果要<strong>注销 spi_master</strong> 的话可以使用 spi_unregister_master 函数，此函数原型为：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_unregister_master</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_master *master)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<p><strong>master</strong>：要注销的 spi_master。<br><strong>返回值</strong>：无。<br>如果使用 spi_bitbang_start 注册 spi_master 的话就要使用 spi_bitbang_stop 来注销掉spi_master。</p>
<h3 id="2-SPI-设备驱动"><a href="#2-SPI-设备驱动" class="headerlink" title="2. SPI  设备驱动"></a>2. SPI  设备驱动</h3><p>spi 设备驱动也和 i2c 设备驱动也很类似，Linux 内核使用 spi_driver 结构体来表示 spi 设备驱动，我们在编写 SPI 设备驱动的时候需要实现 spi_driver。spi_driver 结构体定义在include&#x2F;linux&#x2F;spi&#x2F;spi.h 文件中，结构体内容如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">180</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_driver</span> &#123;</span>
<span class="hljs-number">181</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device_id</span> *<span class="hljs-title">id_table</span>;</span>
<span class="hljs-number">182</span> 	<span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> spi_device *spi);
<span class="hljs-number">183</span> 	<span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> spi_device *spi);
<span class="hljs-number">184</span> 	<span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> spi_device *spi);
<span class="hljs-number">185</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span>
<span class="hljs-number">186</span> &#125;;</code></pre></div>

<p>可以看出，spi_driver 和 i2c_driver、platform_driver 基本一样，当 SPI 设备和驱动匹配成功以后 probe 函数就会执行。</p>
<p>同样的，spi_driver 初始化完成以后需要向 Linux 内核注册，spi_driver 注册函数为spi_register_driver，函数原型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_driver *sdrv)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>sdrv</strong> ：要注册的 spi_driver。<br><strong>返回值</strong>：0，注册成功；赋值，注册失败。</p>
<hr>
<p>注销 SPI 设备驱动以后也需要注销掉前面注册的 spi_driver，使用 spi_unregister_driver 函数完成 spi_driver 的注销，函数原型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_unregister_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_driver *sdrv)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>sdrv</strong> ：要注销的 spi_driver。</p>
<p><strong>返回值</strong>：无。</p>
<p>spi_driver 注册示例程序如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* probe 函数 */</span>
<span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span>
3 &#123;
<span class="hljs-number">4</span> 		<span class="hljs-comment">/* 具体函数内容 */</span>
<span class="hljs-number">5</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">6</span> &#125;
<span class="hljs-number">7</span>
<span class="hljs-number">8</span> <span class="hljs-comment">/* remove 函数 */</span>
<span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span>
10 &#123;
<span class="hljs-number">11</span> 		<span class="hljs-comment">/* 具体函数内容 */</span>
<span class="hljs-number">12</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">13</span> &#125;
<span class="hljs-number">14</span> <span class="hljs-comment">/* 传统匹配方式 ID 列表 */</span>
<span class="hljs-number">15</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device_id</span> <span class="hljs-title">xxx_id</span>[] =</span> &#123;
<span class="hljs-number">16</span> 		&#123;<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">0</span>&#125;,
<span class="hljs-number">17</span> 		&#123;&#125;
<span class="hljs-number">18</span> &#125;;
<span class="hljs-number">19</span>
<span class="hljs-number">20</span> <span class="hljs-comment">/* 设备树匹配列表 */</span>
<span class="hljs-number">21</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;
<span class="hljs-number">22</span> 		&#123; .compatible = <span class="hljs-string">&quot;xxx&quot;</span> &#125;,
<span class="hljs-number">23</span> 		&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;
<span class="hljs-number">24</span> &#125;;
<span class="hljs-number">25</span>
<span class="hljs-number">26</span> <span class="hljs-comment">/* SPI 驱动结构体 */</span>
<span class="hljs-number">27</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_driver</span> <span class="hljs-title">xxx_driver</span> =</span> &#123;
<span class="hljs-number">28</span> 		.probe = xxx_probe,
<span class="hljs-number">29</span> 		.remove = xxx_remove,
<span class="hljs-number">30</span> 		.driver = &#123;
<span class="hljs-number">31</span> 			.owner = THIS_MODULE,
<span class="hljs-number">32</span> 			.name = <span class="hljs-string">&quot;xxx&quot;</span>,
<span class="hljs-number">33</span> 			.of_match_table = xxx_of_match,
<span class="hljs-number">34</span> 		&#125;,
<span class="hljs-number">35</span> 		.id_table = xxx_id,
<span class="hljs-number">36</span> &#125;;
<span class="hljs-number">37</span>
<span class="hljs-number">38</span> <span class="hljs-comment">/* 驱动入口函数 */</span>
<span class="hljs-number">39</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
40 &#123;
<span class="hljs-number">41</span> 		<span class="hljs-keyword">return</span> spi_register_driver(&amp;xxx_driver);
<span class="hljs-number">42</span> &#125;
<span class="hljs-number">43</span>
<span class="hljs-number">44</span> <span class="hljs-comment">/* 驱动出口函数 */</span>
<span class="hljs-number">45</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
46 &#123;
<span class="hljs-number">47</span> 		spi_unregister_driver(&amp;xxx_driver);
<span class="hljs-number">48</span> &#125;
<span class="hljs-number">49</span>
<span class="hljs-number">50</span> module_init(xxx_init);
<span class="hljs-number">51</span> module_exit(xxx_exit);</code></pre></div>

<p>第 1~36 行，spi_driver 结构体，需要 SPI 设备驱动人员编写，包括匹配表、probe 函数等。和 i2c_driver、platform_driver 一样，就不详细讲解了。</p>
<p>第 39~42 行，在驱动入口函数中调用 spi_register_driver 来注册 spi_driver。</p>
<p>第 45~48 行，在驱动出口函数中调用 spi_unregister_driver 来注销 spi_driver。</p>
<h3 id="3-SPI-设备和驱动匹配过程"><a href="#3-SPI-设备和驱动匹配过程" class="headerlink" title="3. SPI  设备和驱动匹配过程"></a>3. SPI  设备和驱动匹配过程</h3><p>具体参考正点原子IMX6UL驱动开发指南62.1.3节</p>
<h2 id="2-I-MX6U-SPI-主机驱动分析"><a href="#2-I-MX6U-SPI-主机驱动分析" class="headerlink" title="2| I.MX6U SPI  主机驱动分析"></a>2| I.MX6U SPI  主机驱动分析</h2><p>和 I2C 的适配器驱动一样，SPI 主机驱动一般都由 SOC 厂商编写好了，打开 imx6ull.dtsi文件，找到如下所示内容：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ecspi3: ecspi@<span class="hljs-number">02010000</span> &#123;
<span class="hljs-number">2</span> 		<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">3</span> 		<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
<span class="hljs-number">4</span> 		compatible = <span class="hljs-string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="hljs-string">&quot;fsl,imx51-ecspi&quot;</span>;
<span class="hljs-number">5</span> 		reg = &lt;<span class="hljs-number">0x02010000</span> <span class="hljs-number">0x4000</span>&gt;;
<span class="hljs-number">6</span> 		interrupts = &lt;GIC_SPI <span class="hljs-number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;
<span class="hljs-number">7</span> 		clocks = &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;,
<span class="hljs-number">8</span> 				 &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;;
<span class="hljs-number">9</span> 		clock-names = <span class="hljs-string">&quot;ipg&quot;</span>, <span class="hljs-string">&quot;per&quot;</span>;
<span class="hljs-number">10</span> 		dmas = &lt;&amp;sdma <span class="hljs-number">7</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span>&gt;, &lt;&amp;sdma <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span>&gt;;
<span class="hljs-number">11</span> 		dma-names = <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-string">&quot;tx&quot;</span>;
<span class="hljs-number">12</span> 		status = <span class="hljs-string">&quot;disabled&quot;</span>;
<span class="hljs-number">13</span> &#125;;</code></pre></div>

<p>重点来看一下第 4 行的 compatible 属性值，compatible 属性有两个值“fsl,imx6ul-ecspi”和“fsl,imx51-ecspi”，在 Linux 内核源码中搜素这两个属性值即可找到 I.MX6U 对应的 ECSPI(SPI)主机驱动。I.MX6U 的 ECSPI 主机驱动文件为 drivers&#x2F;spi&#x2F;spi-imx.c。</p>
<p><strong>具体参考正点原子IMX6UL驱动开发指南62.2节</strong></p>
<h2 id="3-SPI设备驱动编写流程"><a href="#3-SPI设备驱动编写流程" class="headerlink" title="3| SPI设备驱动编写流程"></a>3| SPI设备驱动编写流程</h2><h3 id="1-SPI-设备信息描述"><a href="#1-SPI-设备信息描述" class="headerlink" title="1.SPI  设备信息描述"></a>1.SPI  设备信息描述</h3><h4 id="1-、IO-的-的-pinctrl-子节点创建与修改"><a href="#1-、IO-的-的-pinctrl-子节点创建与修改" class="headerlink" title="1 、IO 的 的 pinctrl  子节点创建与修改"></a>1 、IO 的 的 pinctrl  子节点创建与修改</h4><p>首先肯定是根据所使用的 IO 来创建或修改 pinctrl 子节点，这个没什么好说的，唯独要注意的就是检查相应的 IO 有没有被其他的设备所使用，如果有的话需要将其删除掉！</p>
<h4 id="2-、SPI-设备节点的创建与修改"><a href="#2-、SPI-设备节点的创建与修改" class="headerlink" title="2 、SPI  设备节点的创建与修改"></a>2 、SPI  设备节点的创建与修改</h4><p>采用设备树的情况下，SPI 设备信息描述就通过创建相应的设备子节点来完成，我们可以打开 imx6qdl-sabresd.dtsi 这个设备树头文件，在此文件里面找到如下所示内容：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">308</span> &amp;ecspi1 &#123;
<span class="hljs-number">309</span> 	fsl,spi-num-chipselects = &lt;<span class="hljs-number">1</span>&gt;;
<span class="hljs-number">310</span> 	cs-gpios = &lt;&amp;gpio4 <span class="hljs-number">9</span> <span class="hljs-number">0</span>&gt;;
<span class="hljs-number">311</span> 	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">312</span> 	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_ecspi1&gt;;
<span class="hljs-number">313</span> 	status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">314</span>
<span class="hljs-number">315</span> 	flash: m25p80@<span class="hljs-number">0</span> &#123;
<span class="hljs-number">316</span> 		<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">317</span> 		<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">318</span> 		compatible = <span class="hljs-string">&quot;st,m25p32&quot;</span>;
<span class="hljs-number">319</span> 		spi-max-frequency = &lt;<span class="hljs-number">20000000</span>&gt;;
<span class="hljs-number">320</span> 		reg = &lt;<span class="hljs-number">0</span>&gt;;
<span class="hljs-number">321</span> 	&#125;;
<span class="hljs-number">322</span> &#125;;</code></pre></div>

<p>示例代码是 I.MX6Q 的一款板子上的一个 SPI 设备节点，在这个板子的 ECSPI 接口上接了一个 m25p80，这是一个 SPI 接口的设备。</p>
<ul>
<li>第 309 行，设置“fsl,spi-num-chipselects”属性为 1，表示只有一个设备。</li>
<li>第 310 行，设置“cs-gpios”属性，也就是片选信号为 GPIO4_IO09。</li>
<li>第 311 行，设置“pinctrl-names”属性，也就是 SPI 设备所使用的 IO 名字。</li>
<li>第 312 行，设置“pinctrl-0”属性，也就是所使用的 IO 对应的 pinctrl 节点。</li>
<li>第 313 行，将 ecspi1 节点的“status”属性改为“okay”。</li>
<li>第 315~320 行，ecspi1 下的 m25p80 设备信息，每一个 SPI 设备都采用一个子节点来描述其设备信息。第 315 行的“m25p80@0”后面的“0”表示 m25p80 的接到了 ECSPI 的通道 0上。这个要根据自己的具体硬件来设置。</li>
<li>第 318 行，SPI 设备的 compatible 属性值，用于匹配设备驱动。</li>
<li>第 319 行，“spi-max-frequency”属性设置 SPI 控制器的最高频率，这个要根据所使用的SPI 设备来设置，比如在这里将 SPI 控制器最高频率设置为 20MHz。</li>
<li>第 320 行，reg 属性设置 m25p80 这个设备所使用的 ECSPI 通道，和“m25p80@0”后面的“0”一样。</li>
</ul>
<p>我们一会在编写 ICM20608 的设备树节点信息的时候就参考示例代码中的内容即可。</p>
<h3 id="2-SPI-设备数据收发处理流程"><a href="#2-SPI-设备数据收发处理流程" class="headerlink" title="2.SPI  设备数据收发处理流程"></a>2.SPI  设备数据收发处理流程</h3><p>SPI 设备驱动的核心是 spi_driver，这个我们已经在前面讲过了。当我们向 Linux 内核注册成功 spi_driver 以后就可以使用 SPI 核心层提供的 API 函数来对设备进行读写操作了。</p>
<p>首先是 spi_transfer 结构体，此结构体用于描述 SPI 传输信息，结构体内容如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">603</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> &#123;</span>
<span class="hljs-number">604</span> 	<span class="hljs-comment">/* it&#x27;s ok if tx_buf == rx_buf (right?)</span>
<span class="hljs-comment">605 	* for MicroWire, one buffer must be null</span>
<span class="hljs-comment">606 	* buffers must work with dma_*map_single() calls, unless</span>
<span class="hljs-comment">607 	* spi_message.is_dma_mapped reports a pre-existing mapping</span>
<span class="hljs-comment">608 	*/</span>
<span class="hljs-number">609</span> 	<span class="hljs-type">const</span> <span class="hljs-type">void</span> *tx_buf;
<span class="hljs-number">610</span> 	<span class="hljs-type">void</span> *rx_buf;
<span class="hljs-number">611</span> 	<span class="hljs-type">unsigned</span> len;
<span class="hljs-number">612</span>
<span class="hljs-number">613</span> 	<span class="hljs-type">dma_addr_t</span> tx_dma;
<span class="hljs-number">614</span> 	<span class="hljs-type">dma_addr_t</span> rx_dma;
<span class="hljs-number">615</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> <span class="hljs-title">tx_sg</span>;</span>
<span class="hljs-number">616</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> <span class="hljs-title">rx_sg</span>;</span>
<span class="hljs-number">617</span>
<span class="hljs-number">618</span> 	<span class="hljs-type">unsigned</span> cs_change:<span class="hljs-number">1</span>;
<span class="hljs-number">619</span> 	<span class="hljs-type">unsigned</span> tx_nbits:<span class="hljs-number">3</span>;
<span class="hljs-number">620</span> 	<span class="hljs-type">unsigned</span> rx_nbits:<span class="hljs-number">3</span>;
<span class="hljs-number">621</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_NBITS_SINGLE 0x01 <span class="hljs-comment">/* 1bit transfer */</span></span>
<span class="hljs-number">622</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_NBITS_DUAL 0x02 <span class="hljs-comment">/* 2bits transfer */</span></span>
<span class="hljs-number">623</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_NBITS_QUAD 0x04 <span class="hljs-comment">/* 4bits transfer */</span></span>
<span class="hljs-number">624</span> 	u8 bits_per_word;
<span class="hljs-number">625</span> 	u16 delay_usecs;
<span class="hljs-number">626</span> 	u32 speed_hz;
<span class="hljs-number">627</span>
<span class="hljs-number">628</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">transfer_list</span>;</span>
<span class="hljs-number">629</span> &#125;;</code></pre></div>

<p>第 609 行，tx_buf 保存着要发送的数据。<br>第 610 行，rx_buf 用于保存接收到的数据。<br>第 611 行，len 是要进行传输的数据长度，SPI 是全双工通信，因此在一次通信中发送和接收的字节数都是一样的，所以 spi_transfer 中也就没有发送长度和接收长度之分。</p>
<p><strong>spi_transfer 需要组织成 spi_message</strong>，spi_message 也是一个结构体，内容如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">660</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> &#123;</span>
<span class="hljs-number">661</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">transfers</span>;</span>
<span class="hljs-number">662</span>
<span class="hljs-number">663</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device</span> *<span class="hljs-title">spi</span>;</span>
<span class="hljs-number">664</span>
<span class="hljs-number">665</span> 	<span class="hljs-type">unsigned</span> is_dma_mapped:<span class="hljs-number">1</span>;
......
<span class="hljs-number">678</span> 	<span class="hljs-comment">/* completion is reported through a callback */</span>
<span class="hljs-number">679</span> 	<span class="hljs-type">void</span> (*complete)(<span class="hljs-type">void</span> *context);
<span class="hljs-number">680</span> 	<span class="hljs-type">void</span> *context;
<span class="hljs-number">681</span> 	<span class="hljs-type">unsigned</span> frame_length;
<span class="hljs-number">682</span> 	<span class="hljs-type">unsigned</span> actual_length;
<span class="hljs-number">683</span> 	<span class="hljs-type">int</span> status;
<span class="hljs-number">684</span>
<span class="hljs-number">685</span> 	<span class="hljs-comment">/* for optional use by whatever driver currently owns the</span>
<span class="hljs-comment">686 	* spi_message ... between calls to spi_async and then later</span>
<span class="hljs-comment">687 	* complete(), that&#x27;s the spi_master controller driver.</span>
<span class="hljs-comment">688 	*/</span>
<span class="hljs-number">689</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">queue</span>;</span>
<span class="hljs-number">690</span> 	<span class="hljs-type">void</span> *state;
<span class="hljs-number">691</span> &#125;;</code></pre></div>

<p>在使用spi_message之前需要对其进行初始化，<strong>spi_message初始化函数为spi_message_init</strong>，函数原型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_message_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_message *m)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>m</strong> ：要初始化的 spi_message。<br><strong>返回值</strong>：无。</p>
<hr>
<p>spi_message 初始化完成以后需要<strong>将 spi_transfer 添加到 spi_message 队列</strong>中，这里我们要用到 spi_message_add_tail 函数，此函数原型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_message_add_tail</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_transfer *t, <span class="hljs-keyword">struct</span> spi_message *m)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>t</strong> ：要添加到队列中的 spi_transfer。<br><strong>m</strong>：spi_transfer 要加入的 spi_message。<br><strong>返回值</strong>：无。</p>
<hr>
<p>spi_message 准备好以后既可以进行数据传输了，数据传输分为同步传输和异步传输，同步传输会阻塞的等待 SPI 数据传输完成，<strong>同步传输函数为 spi_sync</strong>，函数原型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-keyword">struct</span> spi_message *message)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>spi</strong> ：要进行数据传输的 spi_device。<br><strong>message</strong>：要传输的 spi_message。<br><strong>返回值</strong>：无。</p>
<hr>
<p>异步传输不会阻塞的等到 SPI 数据传输完成，异步传输需要设置 spi_message 中的 complete成员变量，complete 是一个回调函数，当 SPI 异步传输完成以后此函数就会被调用。<strong>SPI 异步传输函数为 spi_async</strong>，函数原型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_async</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-keyword">struct</span> spi_message *message)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>spi</strong> ：要进行数据传输的 spi_device。<br><strong>message</strong>：要传输的 spi_message。<br><strong>返回值</strong>：无。</p>
<p>在本章实验中，我们采用同步传输方式来完成 SPI 数据的传输工作，也就是 spi_sync 函数。综上所述，SPI 数据传输步骤如下：</p>
<ul>
<li>①、申请并初始化 spi_transfer，设置 spi_transfer 的 tx_buf 成员变量，tx_buf 为要发送的数据。然后设置 rx_buf 成员变量，rx_buf 保存着接收到的数据。最后设置 len 成员变量，也就是要进行数据通信的长度。</li>
<li>②、使用 spi_message_init 函数初始化 spi_message。</li>
<li>③、使用spi_message_add_tail函数将前面设置好的spi_transfer添加到spi_message队列中。</li>
<li>④、使用 spi_sync 函数完成 SPI 数据同步传输。</li>
</ul>
<p>通过 SPI 进行 n 个字节的数据发送和接收的示例代码如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* SPI 多字节发送 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_send</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, u8 *buf, <span class="hljs-type">int</span> len)</span>
&#123;
    <span class="hljs-type">int</span> ret;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> <span class="hljs-title">t</span> =</span> &#123;
        .tx_buf = buf,
        .len = len,
    &#125;;
    spi_message_init(&amp;m); <span class="hljs-comment">/* 初始化 spi_message */</span>
    spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span>
    ret = spi_sync(spi, &amp;m); <span class="hljs-comment">/* 同步传输 */</span>
    <span class="hljs-keyword">return</span> ret;
&#125;
<span class="hljs-comment">/* SPI 多字节接收 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_receive</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, u8 *buf, <span class="hljs-type">int</span> len)</span>
&#123;
    <span class="hljs-type">int</span> ret;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> <span class="hljs-title">t</span> =</span> &#123;
        .rx_buf = buf,
        .len = len,
    &#125;;
    spi_message_init(&amp;m); <span class="hljs-comment">/* 初始化 spi_message */</span>
    spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span>
    ret = spi_sync(spi, &amp;m); <span class="hljs-comment">/* 同步传输 */</span>
    <span class="hljs-keyword">return</span> ret;
&#125;</code></pre></div>

<h2 id="4-硬件原理图分析"><a href="#4-硬件原理图分析" class="headerlink" title="4| 硬件原理图分析"></a>4| 硬件原理图分析</h2><p>ICM-20608 是在 I.MX6U-ALPHA 开发板底板上，原理图如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200904113227640.png" srcset="/img/loading.gif" lazyload alt="image-20200904113227640"></p>
<h2 id="5-实验程序编写"><a href="#5-实验程序编写" class="headerlink" title="5| 实验程序编写"></a>5| 实验程序编写</h2><h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1.修改设备树"></a>1.修改设备树</h3><h4 id="1-、添加-ICM20608-所使用的IO"><a href="#1-、添加-ICM20608-所使用的IO" class="headerlink" title="1 、添加 ICM20608 所使用的IO"></a>1 、添加 ICM20608 所使用的IO</h4><p>首先在 imx6ull-lxg-emmc.dts 文件中添加 ICM20608 所使用的 IO 信息，在 iomuxc 节点中添加一个新的子节点来描述 ICM20608 所使用的 SPI 引脚，子节点名字为 pinctrl_ecspi3，节点内容如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_ecspi3: icm20608 &#123;
<span class="hljs-number">2</span> 	fsl,pins = &lt;
<span class="hljs-number">3</span> 		MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 <span class="hljs-number">0x10b0</span> <span class="hljs-comment">/* CS */</span>
<span class="hljs-number">4</span> 		MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK <span class="hljs-number">0x10b1</span> <span class="hljs-comment">/* SCLK */</span>
<span class="hljs-number">5</span> 		MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO <span class="hljs-number">0x10b1</span> <span class="hljs-comment">/* MISO */</span>
<span class="hljs-number">6</span> 		MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI <span class="hljs-number">0x10b1</span> <span class="hljs-comment">/* MOSI */</span>
<span class="hljs-number">7</span> 	&gt;;
<span class="hljs-number">8</span> &#125;;</code></pre></div>

<p>UART2_TX_DATA 这个 IO 是 ICM20608 的片选信号，这里我们并没有将其复用为 ECSPI3的 SS0 信号，而是将其复用为了普通的 GPIO。因为我们需要自己控制片选信号，所以将其复用为普通的 GPIO。</p>
<h4 id="2-、在-ecspi3-节点追加-icm20608-子节点"><a href="#2-、在-ecspi3-节点追加-icm20608-子节点" class="headerlink" title="2 、在 ecspi3  节点追加 icm20608  子节点"></a>2 、在 ecspi3  节点追加 icm20608  子节点</h4><p>在 imx6ull-lxg-emmc.dts 文件中并没有任何向 ecspi3 节点追加内容的代码，这是因为NXP 官方的 6ULL EVK 开发板上没有连接 SPI 设备。在 imx6ull-lxg-emmc.dts 文件最后面加入如下所示内容：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;ecspi3 &#123;
<span class="hljs-number">2</span> 		fsl,spi-num-chipselects = &lt;<span class="hljs-number">1</span>&gt;;
<span class="hljs-number">3</span> 		cs-gpio = &lt;&amp;gpio1 <span class="hljs-number">20</span> GPIO_ACTIVE_LOW&gt;; <span class="hljs-comment">/* cant&#x27;t use cs-gpios! */</span>
<span class="hljs-number">4</span> 		pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">5</span> 		pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;
<span class="hljs-number">6</span> 		status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">7</span>
<span class="hljs-number">8</span> 		spidev: icm20608@<span class="hljs-number">0</span> &#123;
<span class="hljs-number">9</span> 			compatible = <span class="hljs-string">&quot;alientek,icm20608&quot;</span>;
<span class="hljs-number">10</span> 			spi-max-frequency = &lt;<span class="hljs-number">8000000</span>&gt;;
<span class="hljs-number">11</span> 			reg = &lt;<span class="hljs-number">0</span>&gt;;
<span class="hljs-number">12</span> 		&#125;;
<span class="hljs-number">13</span> &#125;;</code></pre></div>

<ul>
<li>第 2 行，设置当前片选数量为 1，因为就只接了一个 ICM20608。</li>
<li>第 3 行，注意！这里并没有用到“cs-gpios”属性，而是用了一个自己定义的“cs-gpio”属性，因为我们要自己控制片选引脚。如果使用“cs-gpios”属性的话 SPI 主机驱动就会控制片选引脚。</li>
<li>第 5 行，设置 IO 要使用的 pinctrl 子节点，也就是我们在前面示例代码中新建的pinctrl_ecspi3。</li>
<li>第 6 行，imx6ull.dtsi 文件中默认将 ecspi3 节点状态(status)设置为“disable”，这里我们要将其改为“okay”。</li>
<li>第 8~12 行，icm20608 设备子节点，因为 icm20608 连接在 ECSPI3 的第 0 个通道上，因此@后面为 0。第 9 行设置节点属性兼容值为“alientek,icm20608”，第 10 行设置 SPI 最大时钟频率为 8MHz，这是ICM20608 的 SPI 接口所能支持的最大的时钟频率。第 11 行，icm20608 连接在通道 0 上，因此 reg 为 0。</li>
</ul>
<p>imx6ull-lxg-emmc.dts 文件修改完成以后重新编译一下，得到新的 dtb 文件，并使用新的 dtb 启动 Linux 系统。</p>
<h3 id="2-编写-ICM20608-驱动"><a href="#2-编写-ICM20608-驱动" class="headerlink" title="2.编写 ICM20608 驱动"></a>2.编写 ICM20608 驱动</h3><p>新建名为“22_spi”的文件夹，然后在 22_spi 文件夹里面创建 vscode 工程，工作区命名为“spi”。工程创建好以后新建 icm20608.c 和 icm20608reg.h 这两个文件，icm20608.c 为 ICM20608的驱动代码，icm20608reg.h是 ICM20608寄存器头文件。</p>
<p>先在 icm20608reg.h中定义好 ICM20608的寄存器，输入如下内容：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ICM20608_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ICM20608_H</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> ICM20608G_ID			0XAF	<span class="hljs-comment">/* ID值 */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ICM20608D_ID			0XAE	<span class="hljs-comment">/* ID值 */</span></span>

<span class="hljs-comment">/* ICM20608寄存器 </span>
<span class="hljs-comment"> *复位后所有寄存器地址都为0，除了</span>
<span class="hljs-comment"> *Register 107(0X6B) Power Management 1 	= 0x40</span>
<span class="hljs-comment"> *Register 117(0X75) WHO_AM_I 				= 0xAF或0xAE</span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">/* 陀螺仪和加速度自测(出产时设置，用于与用户的自检输出值比较） */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_SELF_TEST_X_GYRO		0x00</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_SELF_TEST_Y_GYRO		0x01</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_SELF_TEST_Z_GYRO		0x02</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_SELF_TEST_X_ACCEL		0x0D</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_SELF_TEST_Y_ACCEL		0x0E</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_SELF_TEST_Z_ACCEL		0x0F</span>

<span class="hljs-comment">/* 陀螺仪静态偏移 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_XG_OFFS_USRH			0x13</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_XG_OFFS_USRL			0x14</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_YG_OFFS_USRH			0x15</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_YG_OFFS_USRL			0x16</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ZG_OFFS_USRH			0x17</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ZG_OFFS_USRL			0x18</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_SMPLRT_DIV			0x19</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_CONFIG				0x1A</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_GYRO_CONFIG			0x1B</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_CONFIG			0x1C</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_CONFIG2			0x1D</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_LP_MODE_CFG			0x1E</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_WOM_THR			0x1F</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_FIFO_EN				0x23</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_FSYNC_INT				0x36</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_INT_PIN_CFG			0x37</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_INT_ENABLE			0x38</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_INT_STATUS			0x3A</span>

<span class="hljs-comment">/* 加速度输出 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_XOUT_H			0x3B</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_XOUT_L			0x3C</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_YOUT_H			0x3D</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_YOUT_L			0x3E</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_ZOUT_H			0x3F</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_ZOUT_L			0x40</span>

<span class="hljs-comment">/* 温度输出 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_TEMP_OUT_H			0x41</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_TEMP_OUT_L			0x42</span>

<span class="hljs-comment">/* 陀螺仪输出 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_GYRO_XOUT_H			0x43</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_GYRO_XOUT_L			0x44</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_GYRO_YOUT_H			0x45</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_GYRO_YOUT_L			0x46</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_GYRO_ZOUT_H			0x47</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_GYRO_ZOUT_L			0x48</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_SIGNAL_PATH_RESET		0x68</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ACCEL_INTEL_CTRL 		0x69</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_USER_CTRL				0x6A</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_PWR_MGMT_1			0x6B</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_PWR_MGMT_2			0x6C</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_FIFO_COUNTH			0x72</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_FIFO_COUNTL			0x73</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_FIFO_R_W				0x74</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_WHO_AM_I 				0x75</span>

<span class="hljs-comment">/* 加速度静态偏移 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_XA_OFFSET_H			0x77</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_XA_OFFSET_L			0x78</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_YA_OFFSET_H			0x7A</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_YA_OFFSET_L			0x7B</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ZA_OFFSET_H			0x7D</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>	ICM20_ZA_OFFSET_L 			0x7E</span>


<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>

<p>接下来继续编写 icm20608.c 文件，因为 icm20608.c 文件内容比较长，因此这里就将其分开来讲解。</p>
<h4 id="1、icm20608-设备结构体创建"><a href="#1、icm20608-设备结构体创建" class="headerlink" title="1、icm20608  设备结构体创建"></a>1、icm20608  设备结构体创建</h4><p>首先创建一个 icm20608 设备结构体，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icm20608_dev</span> &#123;</span>
	<span class="hljs-type">dev_t</span> devid;				<span class="hljs-comment">/* 设备号 	 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>			<span class="hljs-comment">/* cdev 	*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>		<span class="hljs-comment">/* 类 		*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>		<span class="hljs-comment">/* 设备 	 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>	*<span class="hljs-title">nd</span>;</span> 	<span class="hljs-comment">/* 设备节点 */</span>
	<span class="hljs-type">int</span> major;					<span class="hljs-comment">/* 主设备号 */</span>
	<span class="hljs-type">void</span> *private_data;			<span class="hljs-comment">/* 私有数据 		*/</span>
	<span class="hljs-type">int</span> cs_gpio;				<span class="hljs-comment">/* 片选所使用的GPIO编号		*/</span>
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> gyro_x_adc;		<span class="hljs-comment">/* 陀螺仪X轴原始值 	 */</span>
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> gyro_y_adc;		<span class="hljs-comment">/* 陀螺仪Y轴原始值		*/</span>
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> gyro_z_adc;		<span class="hljs-comment">/* 陀螺仪Z轴原始值 		*/</span>
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> accel_x_adc;		<span class="hljs-comment">/* 加速度计X轴原始值 	*/</span>
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> accel_y_adc;		<span class="hljs-comment">/* 加速度计Y轴原始值	*/</span>
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> accel_z_adc;		<span class="hljs-comment">/* 加速度计Z轴原始值 	*/</span>
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> temp_adc;		<span class="hljs-comment">/* 温度原始值 			*/</span>
&#125;;</code></pre></div>

<p>icm20608 的设备结构体 icm20608_dev 没什么好讲的，重点看一下 <strong>private_data</strong>，对于 SPI 设备驱动来讲最核心的就是 spi_device。probe 函数会向驱动提供当前 SPI 设备对应的spi_device，因此在 probe 函数中设置 private_data 为 probe 函数传递进来的 spi_device 参数。</p>
<h4 id="2-、icm20608-的-的-spi-driver-注册与注销"><a href="#2-、icm20608-的-的-spi-driver-注册与注销" class="headerlink" title="2 、icm20608 的 的 spi_driver  注册与注销"></a>2 、icm20608 的 的 spi_driver  注册与注销</h4><p>对于 SPI 设备驱动，首先就是要初始化并向系统注册 spi_driver，icm20608 的 spi_driver 初始化、注册与注销代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 传统匹配方式ID列表 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device_id</span> <span class="hljs-title">icm20608_id</span>[] =</span> &#123;
	&#123;<span class="hljs-string">&quot;alientek,icm20608&quot;</span>, <span class="hljs-number">0</span>&#125;,  
	&#123;&#125;
&#125;;

<span class="hljs-comment">/* 设备树匹配列表 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">icm20608_of_match</span>[] =</span> &#123;
	&#123; .compatible = <span class="hljs-string">&quot;alientek,icm20608&quot;</span> &#125;,
	&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;
&#125;;

<span class="hljs-comment">/* SPI驱动结构体 */</span>	
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_driver</span> <span class="hljs-title">icm20608_driver</span> =</span> &#123;
	.probe = icm20608_probe,
	.remove = icm20608_remove,
	.driver = &#123;
			.owner = THIS_MODULE,
		   	.name = <span class="hljs-string">&quot;icm20608&quot;</span>,
		   	.of_match_table = icm20608_of_match, 
		   &#125;,
	.id_table = icm20608_id,
&#125;;
		   
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动入口函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">icm20608_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-keyword">return</span> spi_register_driver(&amp;icm20608_driver);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动出口函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">icm20608_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	spi_unregister_driver(&amp;icm20608_driver);
&#125;

module_init(icm20608_init);
module_exit(icm20608_exit);
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>当 icm20608 设备和此驱动匹配成功以后 icm20608_probe 函数就会执行。同样的，当注销此驱动的时候 icm20608_remove 函数会执行。</p>
<h4 id="3-、probe-amp-remove-函数"><a href="#3-、probe-amp-remove-函数" class="headerlink" title="3 、probe&amp;remove  函数"></a>3 、probe&amp;remove  函数</h4><div class="code-wrapper"><pre><code class="hljs c"> <span class="hljs-comment">/*</span>
<span class="hljs-comment">  * @description     : spi驱动的probe函数，当驱动与</span>
<span class="hljs-comment">  *                    设备匹配以后此函数就会执行</span>
<span class="hljs-comment">  * @param - client  : spi设备</span>
<span class="hljs-comment">  * @param - id      : spi设备ID</span>
<span class="hljs-comment">  * </span>
<span class="hljs-comment">  */</span>	
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	<span class="hljs-comment">/* 1、构建设备号 */</span>
	<span class="hljs-keyword">if</span> (icm20608dev.major) &#123;
		icm20608dev.devid = MKDEV(icm20608dev.major, <span class="hljs-number">0</span>);
		register_chrdev_region(icm20608dev.devid, ICM20608_CNT, ICM20608_NAME);
	&#125; <span class="hljs-keyword">else</span> &#123;
		alloc_chrdev_region(&amp;icm20608dev.devid, <span class="hljs-number">0</span>, ICM20608_CNT, ICM20608_NAME);
		icm20608dev.major = MAJOR(icm20608dev.devid);
	&#125;

	<span class="hljs-comment">/* 2、注册设备 */</span>
	cdev_init(&amp;icm20608dev.cdev, &amp;icm20608_ops);
	cdev_add(&amp;icm20608dev.cdev, icm20608dev.devid, ICM20608_CNT);

	<span class="hljs-comment">/* 3、创建类 */</span>
	icm20608dev.class = class_create(THIS_MODULE, ICM20608_NAME);
	<span class="hljs-keyword">if</span> (IS_ERR(icm20608dev.class)) &#123;
		<span class="hljs-keyword">return</span> PTR_ERR(icm20608dev.class);
	&#125;

	<span class="hljs-comment">/* 4、创建设备 */</span>
	icm20608dev.device = device_create(icm20608dev.class, <span class="hljs-literal">NULL</span>, icm20608dev.devid, <span class="hljs-literal">NULL</span>, ICM20608_NAME);
	<span class="hljs-keyword">if</span> (IS_ERR(icm20608dev.device)) &#123;
		<span class="hljs-keyword">return</span> PTR_ERR(icm20608dev.device);
	&#125;

	<span class="hljs-comment">/* 获取设备树中cs片选信号 */</span>
	icm20608dev.nd = of_find_node_by_path(<span class="hljs-string">&quot;/soc/aips-bus@02000000/spba-bus@02000000/ecspi@02010000&quot;</span>);
	<span class="hljs-keyword">if</span>(icm20608dev.nd == <span class="hljs-literal">NULL</span>) &#123;
		printk(<span class="hljs-string">&quot;ecspi3 node not find!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> -EINVAL;
	&#125; 

	<span class="hljs-comment">/* 2、 获取设备树中的gpio属性，得到CS所使用的编号 */</span>
	icm20608dev.cs_gpio = of_get_named_gpio(icm20608dev.nd, <span class="hljs-string">&quot;cs-gpio&quot;</span>, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span>(icm20608dev.cs_gpio &lt; <span class="hljs-number">0</span>) &#123;
		printk(<span class="hljs-string">&quot;can&#x27;t get cs-gpio&quot;</span>);
		<span class="hljs-keyword">return</span> -EINVAL;
	&#125;

	<span class="hljs-comment">/* 3、设置GPIO1_IO20为输出，并且输出高电平 */</span>
	ret = gpio_direction_output(icm20608dev.cs_gpio, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;
		printk(<span class="hljs-string">&quot;can&#x27;t set gpio!\r\n&quot;</span>);
	&#125;

	<span class="hljs-comment">/*初始化spi_device */</span>
	spi-&gt;mode = SPI_MODE_0;	<span class="hljs-comment">/*MODE0，CPOL=0，CPHA=0*/</span>
	spi_setup(spi);
	icm20608dev.private_data = spi; <span class="hljs-comment">/* 设置私有数据 */</span>

	<span class="hljs-comment">/* 初始化ICM20608内部寄存器 */</span>
	icm20608_reginit();		
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description     : spi驱动的remove函数，移除spi驱动的时候此函数会执行</span>
<span class="hljs-comment"> * @param - client 	: spi设备</span>
<span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span>
&#123;
	<span class="hljs-comment">/* 删除设备 */</span>
	cdev_del(&amp;icm20608dev.cdev);
	unregister_chrdev_region(icm20608dev.devid, ICM20608_CNT);

	<span class="hljs-comment">/* 注销掉类和设备 */</span>
	device_destroy(icm20608dev.class, icm20608dev.devid);
	class_destroy(icm20608dev.class);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>probe 函数，当设备与驱动匹配成功以后此函数就会执行，先是标准的注册字符设备驱动。然后获取设备节点中的“cs-gpio”属性，也就是获取到设备的片选 IO。</p>
<p>设置 SPI 为模式 0，也就是 CPOL&#x3D;0，CPHA&#x3D;0。<br>设置好 spi_device 以后需要使用 spi_setup 配置一下。<br>设置 icm20608dev 的 private_data 成员变量为 spi_device。<br>调用 icm20608_reginit 函数初始化 ICM20608，主要是初始化 ICM20608 指定寄存器。<br>icm20608_remove 函数，注销驱动的时候此函数就会执行。</p>
<h4 id="4-、icm20608-寄存器读写与初始化"><a href="#4-、icm20608-寄存器读写与初始化" class="headerlink" title="4 、icm20608  寄存器读写与初始化"></a>4 、icm20608  寄存器读写与初始化</h4><p>SPI 驱动最终是通过读写 icm20608 的寄存器来实现的，因此需要编写相应的寄存器读写函数，并且使用这些读写函数来完成对 icm20608 的初始化。icm20608 的寄存器读写以及初始化代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 从icm20608读取多个寄存器数据</span>
<span class="hljs-comment"> * @param - dev:  icm20608设备</span>
<span class="hljs-comment"> * @param - reg:  要读取的寄存器首地址</span>
<span class="hljs-comment"> * @param - val:  读取到的数据</span>
<span class="hljs-comment"> * @param - len:  要读取的数据长度</span>
<span class="hljs-comment"> * @return 		: 操作结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> len)</span>
&#123;
	<span class="hljs-type">int</span> ret;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> txdata[len];
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> *<span class="hljs-title">t</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device</span> *<span class="hljs-title">spi</span> =</span> (<span class="hljs-keyword">struct</span> spi_device *)dev-&gt;private_data;

	gpio_set_value(dev-&gt;cs_gpio, <span class="hljs-number">0</span>);				<span class="hljs-comment">/* 片选拉低，选中ICM20608 */</span>
	t = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> spi_transfer), GFP_KERNEL);	<span class="hljs-comment">/* 申请内存 */</span>

	<span class="hljs-comment">/* 第1次，发送要读取的寄存地址 */</span>
	txdata[<span class="hljs-number">0</span>] = reg | <span class="hljs-number">0x80</span>;		<span class="hljs-comment">/* 写数据的时候寄存器地址bit8要置1 */</span>
	t-&gt;tx_buf = txdata;			<span class="hljs-comment">/* 要发送的数据 */</span>
	t-&gt;len = <span class="hljs-number">1</span>;					<span class="hljs-comment">/* 1个字节 */</span>
	spi_message_init(&amp;m);		<span class="hljs-comment">/* 初始化spi_message */</span>
	spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将spi_transfer添加到spi_message队列 */</span>
	ret = spi_sync(spi, &amp;m);	<span class="hljs-comment">/* 同步发送 */</span>

	<span class="hljs-comment">/* 第2次，读取数据 */</span>
	txdata[<span class="hljs-number">0</span>] = <span class="hljs-number">0xff</span>;			<span class="hljs-comment">/* 随便一个值，此处无意义 */</span>
	t-&gt;rx_buf = buf;			<span class="hljs-comment">/* 读取到的数据 */</span>
	t-&gt;len = len;				<span class="hljs-comment">/* 要读取的数据长度 */</span>
	spi_message_init(&amp;m);		<span class="hljs-comment">/* 初始化spi_message */</span>
	spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将spi_transfer添加到spi_message队列 */</span>
	ret = spi_sync(spi, &amp;m);	<span class="hljs-comment">/* 同步发送 */</span>

	kfree(t);									<span class="hljs-comment">/* 释放内存 */</span>
	gpio_set_value(dev-&gt;cs_gpio, <span class="hljs-number">1</span>);			<span class="hljs-comment">/* 片选拉高，释放ICM20608 */</span>

	<span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 向icm20608多个寄存器写入数据</span>
<span class="hljs-comment"> * @param - dev:  icm20608设备</span>
<span class="hljs-comment"> * @param - reg:  要写入的寄存器首地址</span>
<span class="hljs-comment"> * @param - val:  要写入的数据缓冲区</span>
<span class="hljs-comment"> * @param - len:  要写入的数据长度</span>
<span class="hljs-comment"> * @return 	  :   操作结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> s32 <span class="hljs-title function_">icm20608_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev, u8 reg, u8 *buf, u8 len)</span>
&#123;
	<span class="hljs-type">int</span> ret;

	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> txdata[len];
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> *<span class="hljs-title">t</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device</span> *<span class="hljs-title">spi</span> =</span> (<span class="hljs-keyword">struct</span> spi_device *)dev-&gt;private_data;

	t = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> spi_transfer), GFP_KERNEL);	<span class="hljs-comment">/* 申请内存 */</span>
	gpio_set_value(dev-&gt;cs_gpio, <span class="hljs-number">0</span>);			<span class="hljs-comment">/* 片选拉低 */</span>

	<span class="hljs-comment">/* 第1次，发送要读取的寄存地址 */</span>
	txdata[<span class="hljs-number">0</span>] = reg &amp; ~<span class="hljs-number">0x80</span>;	<span class="hljs-comment">/* 写数据的时候寄存器地址bit8要清零 */</span>
	t-&gt;tx_buf = txdata;			<span class="hljs-comment">/* 要发送的数据 */</span>
	t-&gt;len = <span class="hljs-number">1</span>;					<span class="hljs-comment">/* 1个字节 */</span>
	spi_message_init(&amp;m);		<span class="hljs-comment">/* 初始化spi_message */</span>
	spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将spi_transfer添加到spi_message队列 */</span>
	ret = spi_sync(spi, &amp;m);	<span class="hljs-comment">/* 同步发送 */</span>

	<span class="hljs-comment">/* 第2次，发送要写入的数据 */</span>
	t-&gt;tx_buf = buf;			<span class="hljs-comment">/* 要写入的数据 */</span>
	t-&gt;len = len;				<span class="hljs-comment">/* 写入的字节数 */</span>
	spi_message_init(&amp;m);		<span class="hljs-comment">/* 初始化spi_message */</span>
	spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将spi_transfer添加到spi_message队列 */</span>
	ret = spi_sync(spi, &amp;m);	<span class="hljs-comment">/* 同步发送 */</span>

	kfree(t);					<span class="hljs-comment">/* 释放内存 */</span>
	gpio_set_value(dev-&gt;cs_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 片选拉高，释放ICM20608 */</span>
	<span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 读取icm20608指定寄存器值，读取一个寄存器</span>
<span class="hljs-comment"> * @param - dev:  icm20608设备</span>
<span class="hljs-comment"> * @param - reg:  要读取的寄存器</span>
<span class="hljs-comment"> * @return 	  :   读取到的寄存器值</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">icm20608_read_onereg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev, u8 reg)</span>
&#123;
	u8 data = <span class="hljs-number">0</span>;
	icm20608_read_regs(dev, reg, &amp;data, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">return</span> data;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 向icm20608指定寄存器写入指定的值，写一个寄存器</span>
<span class="hljs-comment"> * @param - dev:  icm20608设备</span>
<span class="hljs-comment"> * @param - reg:  要写的寄存器</span>
<span class="hljs-comment"> * @param - data: 要写入的值</span>
<span class="hljs-comment"> * @return   :    无</span>
<span class="hljs-comment"> */</span>	

<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">icm20608_write_onereg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev, u8 reg, u8 value)</span>
&#123;
	u8 buf = value;
	icm20608_write_regs(dev, reg, &amp;buf, <span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 读取ICM20608的数据，读取原始数据，包括三轴陀螺仪、</span>
<span class="hljs-comment"> * 				: 三轴加速度计和内部温度。</span>
<span class="hljs-comment"> * @param - dev	: ICM20608设备</span>
<span class="hljs-comment"> * @return 		: 无。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">icm20608_readdata</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">14</span>];
	icm20608_read_regs(dev, ICM20_ACCEL_XOUT_H, data, <span class="hljs-number">14</span>);

	dev-&gt;accel_x_adc = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">1</span>]); 
	dev-&gt;accel_y_adc = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">3</span>]); 
	dev-&gt;accel_z_adc = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">5</span>]); 
	dev-&gt;temp_adc    = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">6</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">7</span>]); 
	dev-&gt;gyro_x_adc  = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">8</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">9</span>]); 
	dev-&gt;gyro_y_adc  = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">10</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">11</span>]);
	dev-&gt;gyro_z_adc  = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">12</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">13</span>]);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * ICM20608内部寄存器初始化函数 </span>
<span class="hljs-comment"> * @param  	: 无</span>
<span class="hljs-comment"> * @return 	: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">icm20608_reginit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	u8 value = <span class="hljs-number">0</span>;
	
	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="hljs-number">0x80</span>);
	mdelay(<span class="hljs-number">50</span>);
	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="hljs-number">0x01</span>);
	mdelay(<span class="hljs-number">50</span>);

	value = icm20608_read_onereg(&amp;icm20608dev, ICM20_WHO_AM_I);
	printk(<span class="hljs-string">&quot;ICM20608 ID = %#X\r\n&quot;</span>, value);	

	icm20608_write_onereg(&amp;icm20608dev, ICM20_SMPLRT_DIV, <span class="hljs-number">0x00</span>); 	<span class="hljs-comment">/* 输出速率是内部采样率					*/</span>
	icm20608_write_onereg(&amp;icm20608dev, ICM20_GYRO_CONFIG, <span class="hljs-number">0x18</span>); 	<span class="hljs-comment">/* 陀螺仪±2000dps量程 				*/</span>
	icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG, <span class="hljs-number">0x18</span>); 	<span class="hljs-comment">/* 加速度计±16G量程 					*/</span>
	icm20608_write_onereg(&amp;icm20608dev, ICM20_CONFIG, <span class="hljs-number">0x04</span>); 		<span class="hljs-comment">/* 陀螺仪低通滤波BW=20Hz 				*/</span>
	icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG2, <span class="hljs-number">0x04</span>); <span class="hljs-comment">/* 加速度计低通滤波BW=21.2Hz 			*/</span>
	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_2, <span class="hljs-number">0x00</span>); 	<span class="hljs-comment">/* 打开加速度计和陀螺仪所有轴 				*/</span>
	icm20608_write_onereg(&amp;icm20608dev, ICM20_LP_MODE_CFG, <span class="hljs-number">0x00</span>); 	<span class="hljs-comment">/* 关闭低功耗 						*/</span>
	icm20608_write_onereg(&amp;icm20608dev, ICM20_FIFO_EN, <span class="hljs-number">0x00</span>);		<span class="hljs-comment">/* 关闭FIFO						*/</span>
&#125;</code></pre></div>

<p><strong>icm20608_read_regs 函数</strong>，从 icm20608 中读取连续多个寄存器数据。</p>
<p><strong>icm20608_write_regs 函数</strong>，向 icm20608 连续写入多个寄存器数据。</p>
<p><strong>icm20608_read_onereg 函数</strong>，读取 icm20608 指定寄存器数据。</p>
<p><strong>icm20608_write_onereg 函数</strong>，向 icm20608 指定寄存器写入数据。</p>
<p><strong>icm20608_readdata 函数</strong>，读取 icm20608 六轴传感器和温度传感器原始数据值，应用程序读取icm20608 的时候这些传感器原始数据就会上报给应用程序。</p>
<p><strong>icm20608_reginit 函数</strong>，初始化 icm20608，和我们 spi 裸机实验里面的初始化过程一样。</p>
<h4 id="5-、字符设备驱动框架"><a href="#5-、字符设备驱动框架" class="headerlink" title="5 、字符设备驱动框架"></a>5 、字符设备驱动框架</h4><p>icm20608 的字符设备驱动框架如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 打开设备</span>
<span class="hljs-comment"> * @param - inode 	: 传递给驱动的inode</span>
<span class="hljs-comment"> * @param - filp 	: 设备文件，file结构体有个叫做pr似有ate_data的成员变量</span>
<span class="hljs-comment"> * 					  一般在open的时候将private_data似有向设备结构体。</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	filp-&gt;private_data = &amp;icm20608dev; <span class="hljs-comment">/* 设置私有数据 */</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 从设备读取数据 </span>
<span class="hljs-comment"> * @param - filp 	: 要打开的设备文件(文件描述符)</span>
<span class="hljs-comment"> * @param - buf 	: 返回给用户空间的数据缓冲区</span>
<span class="hljs-comment"> * @param - cnt 	: 要读取的数据长度</span>
<span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span>
<span class="hljs-comment"> * @return 			: 读取的字节数，如果为负值，表示读取失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">icm20608_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *off)</span>
&#123;
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> data[<span class="hljs-number">7</span>];
	<span class="hljs-type">long</span> err = <span class="hljs-number">0</span>;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icm20608_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> icm20608_dev *)filp-&gt;private_data;

	icm20608_readdata(dev);
	data[<span class="hljs-number">0</span>] = dev-&gt;gyro_x_adc;
	data[<span class="hljs-number">1</span>] = dev-&gt;gyro_y_adc;
	data[<span class="hljs-number">2</span>] = dev-&gt;gyro_z_adc;
	data[<span class="hljs-number">3</span>] = dev-&gt;accel_x_adc;
	data[<span class="hljs-number">4</span>] = dev-&gt;accel_y_adc;
	data[<span class="hljs-number">5</span>] = dev-&gt;accel_z_adc;
	data[<span class="hljs-number">6</span>] = dev-&gt;temp_adc;
	err = copy_to_user(buf, data, <span class="hljs-keyword">sizeof</span>(data));
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 关闭/释放设备</span>
<span class="hljs-comment"> * @param - filp 	: 要关闭的设备文件(文件描述符)</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* icm20608操作函数 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">icm20608_ops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.open = icm20608_open,
	.read = icm20608_read,
	.release = icm20608_release,
&#125;;</code></pre></div>

<p>字符设备驱动框架没什么好说的，重点是 icm20608_read 函数，当应用程序调用 read 函数读取 icm20608 设备文件的时候此函数就会执行。此函数调用上面编写好的icm20608_readdata 函数读取 icm20608 的原始数据并将其上报给应用程序。大家注意，在内核中尽量不要使用浮点运算，所以不要在驱动将 icm20608 的原始值转换为对应的实际值，因为会涉及到浮点计算。</p>
<h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3.编写测试 APP"></a>3.编写测试 APP</h3><p>新建 icm20608App.c 文件，然后在里面输入如下所示内容：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/ioctl.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>


<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: main主程序</span>
<span class="hljs-comment"> * @param - argc 	: argv数组元素个数</span>
<span class="hljs-comment"> * @param - argv 	: 具体参数</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
&#123;
	<span class="hljs-type">int</span> fd;
	<span class="hljs-type">char</span> *filename;
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> databuf[<span class="hljs-number">7</span>];
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">14</span>];
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> gyro_x_adc, gyro_y_adc, gyro_z_adc;
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> accel_x_adc, accel_y_adc, accel_z_adc;
	<span class="hljs-type">signed</span> <span class="hljs-type">int</span> temp_adc;

	<span class="hljs-type">float</span> gyro_x_act, gyro_y_act, gyro_z_act;
	<span class="hljs-type">float</span> accel_x_act, accel_y_act, accel_z_act;
	<span class="hljs-type">float</span> temp_act;

	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;

	filename = argv[<span class="hljs-number">1</span>];
	fd = open(filename, O_RDWR);
	<span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;

	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
		ret = read(fd, databuf, <span class="hljs-keyword">sizeof</span>(databuf));
		<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123; 			<span class="hljs-comment">/* 数据读取成功 */</span>
			gyro_x_adc = databuf[<span class="hljs-number">0</span>];
			gyro_y_adc = databuf[<span class="hljs-number">1</span>];
			gyro_z_adc = databuf[<span class="hljs-number">2</span>];
			accel_x_adc = databuf[<span class="hljs-number">3</span>];
			accel_y_adc = databuf[<span class="hljs-number">4</span>];
			accel_z_adc = databuf[<span class="hljs-number">5</span>];
			temp_adc = databuf[<span class="hljs-number">6</span>];

			<span class="hljs-comment">/* 计算实际值 */</span>
			gyro_x_act = (<span class="hljs-type">float</span>)(gyro_x_adc)  / <span class="hljs-number">16.4</span>;
			gyro_y_act = (<span class="hljs-type">float</span>)(gyro_y_adc)  / <span class="hljs-number">16.4</span>;
			gyro_z_act = (<span class="hljs-type">float</span>)(gyro_z_adc)  / <span class="hljs-number">16.4</span>;
			accel_x_act = (<span class="hljs-type">float</span>)(accel_x_adc) / <span class="hljs-number">2048</span>;
			accel_y_act = (<span class="hljs-type">float</span>)(accel_y_adc) / <span class="hljs-number">2048</span>;
			accel_z_act = (<span class="hljs-type">float</span>)(accel_z_adc) / <span class="hljs-number">2048</span>;
			temp_act = ((<span class="hljs-type">float</span>)(temp_adc) - <span class="hljs-number">25</span> ) / <span class="hljs-number">326.8</span> + <span class="hljs-number">25</span>;


			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n原始值:\r\n&quot;</span>);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;gx = %d, gy = %d, gz = %d\r\n&quot;</span>, gyro_x_adc, gyro_y_adc, gyro_z_adc);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ax = %d, ay = %d, az = %d\r\n&quot;</span>, accel_x_adc, accel_y_adc, accel_z_adc);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;temp = %d\r\n&quot;</span>, temp_adc);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;实际值:&quot;</span>);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;act gx = %.2f°/S, act gy = %.2f°/S, act gz = %.2f°/S\r\n&quot;</span>, gyro_x_act, gyro_y_act, gyro_z_act);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;act ax = %.2fg, act ay = %.2fg, act az = %.2fg\r\n&quot;</span>, accel_x_act, accel_y_act, accel_z_act);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;act temp = %.2f°C\r\n&quot;</span>, temp_act);
		&#125;
		usleep(<span class="hljs-number">100000</span>); <span class="hljs-comment">/*100ms */</span>
	&#125;
	close(fd);	<span class="hljs-comment">/* 关闭文件 */</span>	
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>在 while 循环中每隔 100ms 从 icm20608 中读取一次数据，读取到 icm20608原始数据以后将其转换为实际值，比如陀螺仪就是角速度、加速度计就是 g 值。注意，我们在icm20608 驱动中将陀螺仪和加速度计的测量范围全部设置到了最大，分别为±2000 和±16g。因此，在计算实际值的时候陀螺仪使用 16.4，加速度计使用 2048。最终将传感器原始数据和得到的实际值显示在终端上。</p>
<h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4.运行测试"></a>4.运行测试</h3><p>编译运行。</p>
<p>在 icm20608App.c 这个测试 APP 中我们用到了浮点计算，而 I.MX6U 是支持硬件浮点的，因此我们在编译 icm20608App.c 的时候就可以使能硬件浮点，这样可以加速浮点计算。使能硬件浮点很简单，在编译的时候加入如下参数即可：</p>
<div class="code-wrapper"><pre><code class="hljs c">-march-armv7-a -mfpu-neon -mfloat=hard</code></pre></div>

<p>输入如下命令使能硬件浮点编译 icm20608App.c 这个测试程序：</p>
<div class="code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-gcc -march=armv7-a -mfpu=neon -mfloat-abi=hard icm20608App.c -o icm20608App</code></pre></div>

<p>编译成功以后就会生成 icm20608App 这个应用程序，那么究竟有没有使用硬件浮点呢？使用 <code>arm-linux-gnueabihf-readelf</code> 查看一下编译出来的 icm20608App 就知道了，输入如下命令：</p>
<div class="code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-readelf -A icm20608App</code></pre></div>

<p>结果如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200904121240231.png" srcset="/img/loading.gif" lazyload alt="image-20200904121240231"></p>
<p>从图 可以看出 FPU 架构为 VFPv3，SIMD 使用了 NEON，并且使用了 SP 和 DP，说明 icm20608App 这个应用程序使用了硬件浮点。</p>
<p>当驱动模块加载成功以后使用 icm20608App 来测试，输入如下命令：</p>
<div class="code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/icm20608App /</span>dev/icm20608</code></pre></div>

<p>测试 APP 会不断的从 ICM20608 中读取数据，然后输出到终端上，如图所示：</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/16/PROJECT/software/uart_xfer_BIN/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">STM32串口烧录BIN文件、字库文件【QT上位机】</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/20%E3%80%81Linux_UART%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">20| Linux UART串口实验</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
