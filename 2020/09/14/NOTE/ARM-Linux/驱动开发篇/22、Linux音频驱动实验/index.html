

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux 音频驱动一、音频接口简介1| 为何需要音频编解码芯片？处理器要想“听到”外界的声音必须要把外界的声音转化为自己能够理解的“语言”，处理器能理解的就是 0 和 1，也就是二进制数据。所以我们需要先把外界的声音转换为处理器能理解的 0 和 1，在信号处理领域，外界的声音是模拟信号，处理器能理解的是数字信号，因此这里就涉及到一个模拟信号转换为数字信号的过程，而完成这个功能的就是 ADC 芯片">
<meta property="og:type" content="article">
<meta property="og:title" content="22| Linux 音频驱动">
<meta property="og:url" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Linux 音频驱动一、音频接口简介1| 为何需要音频编解码芯片？处理器要想“听到”外界的声音必须要把外界的声音转化为自己能够理解的“语言”，处理器能理解的就是 0 和 1，也就是二进制数据。所以我们需要先把外界的声音转换为处理器能理解的 0 和 1，在信号处理领域，外界的声音是模拟信号，处理器能理解的是数字信号，因此这里就涉及到一个模拟信号转换为数字信号的过程，而完成这个功能的就是 ADC 芯片">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907161531045.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162620883.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162658396.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162754213.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162904361.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907163008088.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907165744149.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907165845744.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170423473.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170550815.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170616116.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170812231.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907171829579.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907172030992.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907172142141.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907174836127.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175325585.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175501178.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175532792.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175630338.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907180428743.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181151417.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181517384.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181757589.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181902945.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182057667.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182313324.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182326254.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182411920.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182452001.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182600316.png">
<meta property="article:published_time" content="2020-09-13T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-13T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907161531045.png">
  
  
  <title>22| Linux 音频驱动 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="22| Linux 音频驱动">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-14 00:00" pubdate>
        2020年9月14日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      25k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      208 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">22| Linux 音频驱动</h1>
            
            <div class="markdown-body">
              <h1 id="Linux-音频驱动"><a href="#Linux-音频驱动" class="headerlink" title="Linux 音频驱动"></a>Linux 音频驱动</h1><h2 id="一、音频接口简介"><a href="#一、音频接口简介" class="headerlink" title="一、音频接口简介"></a>一、音频接口简介</h2><h3 id="1-为何需要音频编解码芯片？"><a href="#1-为何需要音频编解码芯片？" class="headerlink" title="1| 为何需要音频编解码芯片？"></a>1| 为何需要音频编解码芯片？</h3><p>处理器要想“听到”外界的声音必须要把外界的声音转化为自己能够理解的“语言”，处理器能理解的就是 0 和 1，也就是二进制数据。所以我们需要先把外界的声音转换为处理器能理解的 0 和 1，在信号处理领域，外界的声音是模拟信号，处理器能理解的是数字信号，因此这里就涉及到一个模拟信号转换为数字信号的过程，而完成这个功能的就是 ADC 芯片。</p>
<p>同理，如果处理器要向外界传达自己的“心声”，也就是放音，那么就涉及到将处理器能理解的 0 和 1 转化为外界能理解的连续变化的声音，这个过程就是将数字信号转化为模拟信号，而完成这个功能的是 DAC 芯片。</p>
<p>现在我们知道了，处理器如果既想“听到”外界的声音，又想向外界传达自己的“心声”，那么就需要同时用到 DAC 和 ADC 这两款芯片。那是不是买两颗 DAC 和 ADC 芯片就行了呢？答案肯定是可以的，但是音频不单单是能出声、能听到就行。我们往往需要听到的声音动听、录进去的语音贴近真实、可以调节音效、对声音能够进行一些处理(需要 DSP 单元)、拥有统一的标准接口，方便开发等等。将这些针对声音的各种要求全部叠加到 DAC 和 ADC 芯片上，那么就会得到一个专门用于音频的芯片，也就是音频编解码芯片，英文名字就是 Audio CODEC，所以我们在手机或者电脑的介绍中看到“CODEC”这个词语，一般说的都是音频编解码。</p>
<p>既然音频 CODEC 的本质是 ADC 和 DAC，那么采样率和采样位数就是衡量一款音频CODEC 最重要的指标。比如常见音频采样率有 8K、44.1K、48K、192K 甚至 384K 和 768K，采样位数常见的有 8 位、16 位、24 位、32 位。采样率和采样位数越高，那么音频 CODEC 越能真实的还原声音，也就是大家说的HIFI。因此大家会看到高端的音频播放器都会有很高的采样率和采样位数，同样的价格也会越高。当然了，实际的效果还与其他部分有关，采样率和采样位数只是其中重要的指标之一。</p>
<h3 id="2-WM8960简介"><a href="#2-WM8960简介" class="headerlink" title="2| WM8960简介"></a>2| WM8960简介</h3><p>前面我们已经分析了为何需要音频编解码芯片，那是因为专用的音频编解码芯片提供了很多针对音频的特性。我们就以正点原子 ALPHA 开发板所使用的 WM8960 这颗芯片为例，来看一下专用的音频编解码芯片都有哪些特性。</p>
<p>WM8960 是一颗由 wolfson(欧胜)公司出品的音频编解码芯片，是一颗低功耗、高质量的立体声音频 CODEC。集成 D 类喇叭功放，每个通道可以驱动一个 1W 喇叭(8Ω)。内部集成 3 个立体声输入源，可以灵活配置，拥有一路完整的麦克风接口。WM8960 内部 ADC 和 DAC 都为24 位，WM8960 主要特性如下所示：</p>
<ul>
<li>①、DAC 的 SNR(信噪比)为 98dB，3.3V、48KHz 下 THD(谐波失真)为-84dB。</li>
<li>②、ADC 的 SNR(信噪比)为 94dB，3.3V、48KHz 下 THD(谐波失真)为-82dB。</li>
<li>③、3D 增强。</li>
<li>④、立体声 D 类功放，可以直接外接喇叭，8Ω负载下每通道 1W。</li>
<li>⑤、集成耳机接口。</li>
<li>⑥、集成麦克风接口。</li>
<li>⑦、采样率支持 8K、11.025K、12K、16K、22.05K、24K、32K、44.1K 和 48K。</li>
<li>……</li>
</ul>
<p>WM8960 整体框图如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907161531045.png" srcset="/img/loading.gif" lazyload alt="image-20200907161531045"></p>
<p>依次来看一下图中这四部分接口都是什么功能：</p>
<ul>
<li><p>①、此部分是 WM8960 提供的输入接口，作为立体声音频输入源，一共提供了三路，分别为 LINPUT1&#x2F;RINPUT1、LINPUT2&#x2F;RINPUT2、LINPUT3&#x2F;RINPUT3。麦克风或线路输入就连接到此接口上，这部分是需要硬件工程师重点关心的，因为音频选择从哪一路进入需要在画 PCB 的时候就应该定好。</p>
</li>
<li><p>②、此部分是 WM8960 的输出接口，比如输出给耳机或喇叭，SPK_LP&#x2F;SPK_LN 用于连接左声道的喇叭，支持 1W 的 8Ω喇叭。SPK_RP&#x2F;SPK_RN 用于连接右声道的喇叭，同样支持 1W的 8Ω喇叭，最后就是HP_L&#x2F;HP_R，用于连接耳机。</p>
</li>
<li><p>③、此部分是数字音频接口，用于和主控制器连接，有 5 根线，用于主控制器和 WM8960之间进行数据“沟通”。主控制器向 WM8960 的 DAC 发送的数据，WM8960 的 ADC 向主控制传递的数据都是通过此音频接口来完成的。这个接口非常重要，是我们驱动开发人员重点关注的，此接口支持 I2S 格式。此接口 5 根线的作用如下：</p>
<ul>
<li><p><strong>ADCDAT</strong>：ADC 数据输出引脚，采集到的音频数据转换为数字信号以后通过此引脚传输给主控制器。</p>
</li>
<li><p><strong>ADCLRC</strong>：ADC 数据对齐时钟，也就是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率就是采样率。此引脚可以配置为 GPIO 功能，配置为 GPIO 以后 ADC 就会使用 DACLRC引脚作为帧时钟。</p>
</li>
<li><p><strong>DACDAT</strong>：DAC 数据输入引脚，主控器通过此引脚将数字信号输入给 WM8960 的 DAC。</p>
</li>
<li><p><strong>DACLRC</strong> ：DAC 数据对齐时钟，功能和 ADCLRC 一样，都是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率等于采样率。</p>
</li>
<li><p><strong>BCLK</strong> ：位时钟，用于同步。</p>
</li>
<li><p><strong>MCLK</strong> ：主时钟，WM8960 工作的时候还需要一路主时钟，此时钟由 I.MX6ULL 提供，MCLK 频率等于采样率的 256 或 384 倍，因此大家在 WM8960 的数据手册里面常看到MCLK&#x3D;256fs 或 MCLK&#x3D;384fs。</p>
</li>
</ul>
</li>
<li><p>④、此部分为控制接口，是一个标准的 I2C 接口，WM8960 要想工作必须对其进行配置，这个 I2C 接口就是用于配置 WM8960 的。</p>
</li>
</ul>
<h3 id="3-I2S总线接口"><a href="#3-I2S总线接口" class="headerlink" title="3| I2S总线接口"></a>3| I2S总线接口</h3><p>I2S(Inter-IC Sound)总线有时候也写作 IIS，I2S 是飞利浦公司提出的一种<strong>用于数字音频设备之间进行音频数据传输的总线</strong>。和 I2C、SPI 这些常见的通信协议一样，I2S 总线用于主控制器和音频 CODEC 芯片之间传输音频数据。因此，要想使用 I2S 协议，主控制器和音频 CODEC 都得支持 I2S 协议，I.MX6ULL 的 SAI 外设就支持 I2S 协议，WM8960 同样也支持 I2S，所以本章实验就是使用 I2S 协议来完成的。I2S 接口需要 3 根信号线(如果需要实现收和发，那么就要 4根信号线，收和发分别使用一根信号线)：</p>
<ul>
<li><strong>SCK</strong> ：串行时钟信号，也叫做位时钟(BCLK)，音频数据的每一位数据都对应一个 SCK，立体声都是双声道的，因此 SCK&#x3D;2×采样率×采样位数。比如采样率为 44.1KHz、16 位的立体声音频，那么 SCK&#x3D;2×44100×16&#x3D;1411200Hz&#x3D;1.4112MHz。</li>
<li><strong>WS</strong> ：字段(声道)选择信号，也叫做 LRCK，也叫做帧时钟，用于切换左右声道数据，WS 为“1”表示正在传输左声道的数据，WS 为“0”表示正在传输右声道的数据。WS 的频率等于采样率，比如采样率为 44.1KHz 的音频，WS&#x3D;44.1KHz。</li>
<li><strong>SD</strong>： ：串行数据信号，也就是我们实际的音频数据，如果要同时实现放音和录音，那么就需要 2 根数据线，比如 WM8960 的 ADCDAT 和 DACDAT，就是分别用于录音和放音。不管音频数据是多少位的，数据的最高位都是最先传输的。数据的最高位总是出现在一帧开始后(LRCK变化)的第 2 个 SCK 脉冲处。</li>
</ul>
<p>另外，有时候为了使音频 CODEC 芯片与主控制器之间能够更好的同步，会引入另外一个叫做 MCLK 的信号，也叫做主时钟或系统时钟，一般是采样率的 256 倍或 384 倍。下图 就是一帧立体声音频时序图：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162620883.png" srcset="/img/loading.gif" lazyload alt="image-20200907162620883"></p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162658396.png" srcset="/img/loading.gif" lazyload alt="image-20200907162658396"></p>
<p>图 65.1.3.2 中通道 0 是 LRCK 时钟，通道 1 为 BCLK，通道 2 是 DACDATA，通道 3 是MCLK。随着技术的发展，在统一的 I2S 接口下，出现了不同的数据格式，根据 DATA 数据相对于 LRCK 和 SCLK 位置的不同，出现了 Left Justified(左对齐)和 Right Justified(右对齐)两种格式，这两种格式的时序图如下图所示</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162754213.png" srcset="/img/loading.gif" lazyload alt="image-20200907162754213"></p>
<h3 id="4-I-MX6ULL-SAI-简介"><a href="#4-I-MX6ULL-SAI-简介" class="headerlink" title="4| I.MX6ULL SAI  简介"></a>4| I.MX6ULL SAI  简介</h3><p>音频 CODEC 支持 I2S 协议，那么主控制器也必须支持 I2S 协议，大家如果学过STM32F4&#x2F;F7&#x2F;H7 的话应该知道 SAI 接口，因为在 STM32 中就是通过 SAI 接口来连接音频CODEC。I.MX6ULL 也提供了一个叫做 SAI 的外设，全称为 Synchronous Audio Interface，翻译过来就是同步音频接口。</p>
<p>I.MX6ULL 的 SAI 是一个全双工、支持帧同步的串行接口，支持 I2S、AC97、TDM 和音频DSP，SAI 主要特性如下：</p>
<ul>
<li>①、帧最大为 32 个字。</li>
<li>②、字大小可选择 8bit 或 32bit。</li>
<li>③、每个接收和发送通道拥有 32×32bit 的 FIFO。</li>
<li>④、FIFO 错误以后支持平滑重启。</li>
</ul>
<p>I.MX6ULL 的 SAI 框图如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162904361.png" srcset="/img/loading.gif" lazyload alt="image-20200907162904361"></p>
<p>图中右侧“SAI_TX”和“SAI_RX”开头的就是 SAI 外设提供给外部连接音频CODEC 的信号线，具体连接方法查看下一节的原理图。</p>
<h2 id="二、硬件原理图分析"><a href="#二、硬件原理图分析" class="headerlink" title="二、硬件原理图分析"></a>二、硬件原理图分析</h2><p>正点原子 ALPHA 开发板音频原理图如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907163008088.png" srcset="/img/loading.gif" lazyload alt="image-20200907163008088"></p>
<p>图中我们重点关注两个接口，SAI 和 I2C，我们依次来看一下这两个接口：</p>
<ul>
<li>①、SAI 接口一共用到了 6 根数据线，这 6 根数据线用于 I.MX6ULL 与 WM8960 之间的音频数据收发。</li>
<li>②、WM8960 在使用的时候需要进行配置，配置接口为 I2C，连接到了 I.MX6ULL 的 I2C2上。</li>
</ul>
<h2 id="三、Linux音频驱动使能"><a href="#三、Linux音频驱动使能" class="headerlink" title="三、Linux音频驱动使能"></a>三、Linux音频驱动使能</h2><p>NXP 官方已经写好了 WM8960 驱动，因此我们直接配置内核使能 WM8960 驱动即可，按照如下所示步骤使能 WM8960 驱动。</p>
<h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1| 修改设备树"></a>1| 修改设备树</h3><p>前面分析原理图的时候已经说过了，WM8960 与 I.MX6ULL 之间有两个通信接口：I2C 和SAI，因此设备树中会涉及到 I2C 和 SAI 两个设备节点。其中 I2C 用于配置 WM8960，SAI 接口用于音频数据传输，我们依次来配置一下这两个接口。</p>
<h4 id="1-、wm8960-i2c-接口设备树"><a href="#1-、wm8960-i2c-接口设备树" class="headerlink" title="1 、wm8960 i2c  接口设备树"></a>1 、wm8960 i2c  接口设备树</h4><p>首先配置一下 I2C 接口，根据原理图我们知道 WM8960 连接到了 I.MX6ULL 的 I2C2 接口上，因此在设备树中的“i2c2”节点下需要添加 wm8960 信息。如果去添加肯定是要看设备树的绑定手册，打开Documentation&#x2F;devicetree&#x2F;bindings&#x2F;sound&#x2F;wm8960.txt，此文件仅仅用于描述如何在 I2C 节点下添加 WM8960 相关信息，此文档适用于所有的主控，不局限于 I.MX6ULL。</p>
<p><strong>有 2 个必要的属性：</strong></p>
<ul>
<li><strong>compatible</strong>：兼容属性，属性值要设置为“wlf,wm8960”。所以大家在 linux 内核里面全局搜索“wlf,wm8960”的话就会找到WM8960的I2C驱动文件，此文件为sound&#x2F;soc&#x2F;codecs&#x2F;wm8960.c。</li>
<li><strong>reg</strong> ：设置 WM8960 的 I2C 地址，在正点原子的 ALPHA 开发板中 WM8960 的 I2C 地址为0X1A。</li>
</ul>
<p><strong>还要几个其他的可选属性：</strong></p>
<ul>
<li><strong>wlf,shared-lrclk</strong> ：这是一个 bool 类型的属性，如果添加了此属性，WM8960 的 R24 寄存器的 LRCM 位(bit2)就会置 1。当 LRCM 为 1 的时候只有当 ADC 和 DAC 全部关闭以后 ADCLRC和 DACLRC 时钟才会关闭。</li>
<li><strong>wlf,capless</strong> ：这也是一个 bool 类型的属性，如果添加了此属性，OUT3 引脚将会使能，并且为了响应耳机插入响应事件，HP_L 和 HP_R 这两个引脚都会关闭。</li>
</ul>
<p>绑定文档给出的参考节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">codec: wm8960@<span class="hljs-number">1</span>a &#123;
    compatible = <span class="hljs-string">&quot;wlf,wm8960&quot;</span>;
    reg = &lt;<span class="hljs-number">0x1a</span>&gt;;
    wlf,shared-lrclk;
&#125;;</code></pre></div>

<p>根据wm8960.txt 这份绑定文档我们就可以在任意一个主控的 I2C 节点下添加wm8960 相关信息了，NXP 官方 I.MX6ULL EVK 开发板使用的也是 WM8960，因此在设备树中添加设备节点这些工作 NXP 已经帮我们做了。打开 imx6ull-lxg-emmc.dts，找到名为“i2c2”的节点，此节点下都是连接到 I2C2 总线上的设备，其中就包括了 wm8960，wm8960 节点信息如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> codec: wm8960@<span class="hljs-number">1</span>a &#123;
<span class="hljs-number">2</span> 		compatible = <span class="hljs-string">&quot;wlf,wm8960&quot;</span>;
<span class="hljs-number">3</span> 		reg = &lt;<span class="hljs-number">0x1a</span>&gt;;
<span class="hljs-number">4</span> 		clocks = &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;
<span class="hljs-number">5</span> 		clock-names = <span class="hljs-string">&quot;mclk&quot;</span>;
<span class="hljs-number">6</span> 		wlf,shared-lrclk;
<span class="hljs-number">7</span> &#125;;</code></pre></div>

<p>可以看出，示例代码中的内容基本和 wm8960.txt 这个绑定文档中的示例内容一致，只是多了第 4 和第 5 这两行，这两行用于描述时钟相关信息。第 4 行指定时钟源为 SAI2，第 5行指定时钟的名字为“mclk”。前面我们说过，为了更好的同步，一般都会额外提供一条 MCLK时钟。</p>
<p>至此，关于 wm8960 的 I2C 配置接口设备树就已经添加好了。</p>
<h4 id="2-、I-MX6ULL-SAI-音频接口设备树"><a href="#2-、I-MX6ULL-SAI-音频接口设备树" class="headerlink" title="2 、I.MX6ULL SAI 音频接口设备树"></a>2 、I.MX6ULL SAI 音频接口设备树</h4><p>接下来就是 I.MX6ULL 的 SAI 音频接口设备树相关内容的修改了，同样的，先查阅一下相应的绑定文档：Documentation&#x2F;devicetree&#x2F;bindings&#x2F;sound&#x2F;fsl-sai.txt。和我们前面讲过的 IIC 接口、ECSPI 等接口一样，在 imx6ull.dtsi 文件中会有关于 SAI 相关接口的描述，这部分是 NXP 原厂编写的，我们不需要做任何修改，SAI2 的设备子节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> sai2: sai@<span class="hljs-number">0202</span>c000 &#123;
<span class="hljs-number">2</span> 		compatible = <span class="hljs-string">&quot;fsl,imx6ul-sai&quot;</span>,
<span class="hljs-number">3</span> 		<span class="hljs-string">&quot;fsl,imx6sx-sai&quot;</span>;
<span class="hljs-number">4</span> 		reg = &lt;<span class="hljs-number">0x0202c000</span> <span class="hljs-number">0x4000</span>&gt;;
<span class="hljs-number">5</span> 		interrupts = &lt;GIC_SPI <span class="hljs-number">98</span> IRQ_TYPE_LEVEL_HIGH&gt;;
<span class="hljs-number">6</span> 		clocks = &lt;&amp;clks IMX6UL_CLK_SAI2_IPG&gt;,
<span class="hljs-number">7</span> 				 &lt;&amp;clks IMX6UL_CLK_DUMMY&gt;,
<span class="hljs-number">8</span> 				 &lt;&amp;clks IMX6UL_CLK_SAI2&gt;,
<span class="hljs-number">9</span> 				 &lt;&amp;clks <span class="hljs-number">0</span>&gt;, &lt;&amp;clks <span class="hljs-number">0</span>&gt;;
<span class="hljs-number">10</span> 		clock-names = <span class="hljs-string">&quot;bus&quot;</span>, <span class="hljs-string">&quot;mclk0&quot;</span>, <span class="hljs-string">&quot;mclk1&quot;</span>, <span class="hljs-string">&quot;mclk2&quot;</span>, <span class="hljs-string">&quot;mclk3&quot;</span>;
<span class="hljs-number">11</span> 		dma-names = <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-string">&quot;tx&quot;</span>;
<span class="hljs-number">12</span> 		dmas = &lt;&amp;sdma <span class="hljs-number">37</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>&gt;, &lt;&amp;sdma <span class="hljs-number">38</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>&gt;;
<span class="hljs-number">13</span> 		status = <span class="hljs-string">&quot;disabled&quot;</span>;
<span class="hljs-number">14</span> &#125;;</code></pre></div>

<p>直接搜索 compatible 属性中的两个兼容值，那么你就会找到 I.MX6ULL 的 SAI 接口驱动文件，路径为 sound&#x2F;soc&#x2F;fsl&#x2F;fsl_sai.c，此驱动文件不需要我们去研究，除非你在 NXP 上班，而你的工作恰好是给 NXP 的 I.MX 系列芯片编写 SAI 驱动的。</p>
<p>从第 13 行可以看出，SAI2 默认是关闭的，因此我们需要将其打开，也就是设置 status 属性的值为“okay”，这个工作肯定是在具体板子对应的.dts 文件中完成的，其实就是向 sai2 节点里面追加或者修改一些属性值。打开 imx6ull-lxg-emmc.dts 文件，找到如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;sai2 &#123;
<span class="hljs-number">2</span> 		pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">3</span> 		pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_sai2
<span class="hljs-number">4</span> 					 &amp;pinctrl_sai2_hp_det_b&gt;;
<span class="hljs-number">5</span> 		assigned-clocks = &lt;&amp;clks IMX6UL_CLK_SAI2_SEL&gt;,
<span class="hljs-number">6</span> 						  &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;
<span class="hljs-number">7</span> 		assigned-clock-parents = &lt;&amp;clks IMX6UL_CLK_PLL4_AUDIO_DIV&gt;;
<span class="hljs-number">8</span> 		assigned-clock-rates = &lt;<span class="hljs-number">0</span>&gt;, &lt;<span class="hljs-number">12288000</span>&gt;;
<span class="hljs-number">9</span> 		status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">10</span> &#125;;</code></pre></div>

<p>上述示例代码中的内容是 NXP 针对自己的 I.MX6ULL EVK 开发板而添加的，主要是对 sai2 节点做了三个方面的修改：SAI2 接口的 pinctrl、相应的时钟、修改 status 为“okay”。我们重点来看一下 pinctrl 的设置，因为关系到 SAI2 接口的 IO 设置，从 pinctrl-0 属性可以看出这里一共有两组 IO：pinctrl_sai2 和 pinctrl_sai2_hp_det_b，这两组 IO 内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_sai2: sai2grp &#123;
<span class="hljs-number">2</span> 		fsl,pins = &lt;
<span class="hljs-number">3</span> 			MX6UL_PAD_JTAG_TDI__SAI2_TX_BCLK <span class="hljs-number">0x17088</span>
<span class="hljs-number">4</span> 			MX6UL_PAD_JTAG_TDO__SAI2_TX_SYNC <span class="hljs-number">0x17088</span>
<span class="hljs-number">5</span> 			MX6UL_PAD_JTAG_TRST_B__SAI2_TX_DATA <span class="hljs-number">0x11088</span>
<span class="hljs-number">6</span> 			MX6UL_PAD_JTAG_TCK__SAI2_RX_DATA <span class="hljs-number">0x11088</span>
<span class="hljs-number">7</span> 			MX6UL_PAD_JTAG_TMS__SAI2_MCLK <span class="hljs-number">0x17088</span>
<span class="hljs-number">8</span> 		&gt;;
<span class="hljs-number">9</span> &#125;;
<span class="hljs-number">10</span>
<span class="hljs-number">11</span> pinctrl_sai2_hp_det_b: sai2_hp_det_grp &#123;
<span class="hljs-number">12</span> 		fsl,pins = &lt;
<span class="hljs-number">13</span> 			MX6ULL_PAD_SNVS_TAMPER4__GPIO5_IO04 <span class="hljs-number">0x17059</span>
<span class="hljs-number">14</span> 		&gt;;
<span class="hljs-number">15</span> &#125;;</code></pre></div>

<p>pinctrl_sai2 描述的是 SAI2 接口的 IO 配置，这个要根据自己板子的实际硬件情况修改，正点原子的 ALPHA 开发板上 SAI2 所使用的 IO 和 NXP 的 EVK 开发板一样，因此这里不需要做任何修改。</p>
<p>pinctrl_sai2_hp_det_b 描述的是耳机插入检测引脚，wm8960 支持耳机插入检测，这样当耳机插入以后就会通过耳机播放音乐，当耳机拔出来以后就会通过喇叭播放音乐。对于正点原子的 ALPHA 开发板，SAI 部分的设备树信息不需要做任何修改，直接使用 NXP官方写好的即可。</p>
<h4 id="3、I-MX6ULL-sound-节点"><a href="#3、I-MX6ULL-sound-节点" class="headerlink" title="3、I.MX6ULL sound 节点"></a>3、I.MX6ULL sound 节点</h4><p>最后我们需要在根节点“&#x2F;”下创建一个名为“sound”的子节点，笔者并没有在 linux 内核中找到此节点的绑定信息。只有一份在 I.MX 系列芯片中使用 WM8962 芯片的 sound 节点绑定文档，路径为：Documentation&#x2F;devicetree&#x2F;bindings&#x2F;sound&#x2F;imx-audio-wm8962.txt。虽然不是 wm8960的绑定文档，但是我们也可以参考 imx-audio-wm8962.txt。NXP 官方已经针对 EVK 开发板编写了 sound 节点，我们可以在此基础上针对我们所使用的平台来修改出对应的 sound 节点，修改完成以后的 sound 节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">sound &#123;
	compatible = <span class="hljs-string">&quot;fsl,imx6ul-evk-wm8960&quot;</span>,
		   		 <span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span>;
	model = <span class="hljs-string">&quot;wm8960-audio&quot;</span>;
	cpu-dai = &lt;&amp;sai2&gt;;
	audio-codec = &lt;&amp;codec&gt;;
	asrc-controller = &lt;&amp;asrc&gt;;
	codec-master;
	gpr = &lt;&amp;gpr <span class="hljs-number">4</span> <span class="hljs-number">0x100000</span> <span class="hljs-number">0x100000</span>&gt;;
	<span class="hljs-comment">/*</span>
<span class="hljs-comment">        * hp-det = &lt;hp-det-pin hp-det-polarity&gt;;</span>
<span class="hljs-comment">	 * hp-det-pin: JD1 JD2  or JD3</span>
<span class="hljs-comment">	 * hp-det-polarity = 0: hp detect high for headphone</span>
<span class="hljs-comment">	 * hp-det-polarity = 1: hp detect high for speaker</span>
<span class="hljs-comment">	 */</span>
	hp-det = &lt;<span class="hljs-number">3</span> <span class="hljs-number">0</span>&gt;;
	<span class="hljs-comment">/*hp-det-gpios = &lt;&amp;gpio5 4 0&gt;;</span>
<span class="hljs-comment">	mic-det-gpios = &lt;&amp;gpio5 4 0&gt;;*/</span>
	audio-routing =
		<span class="hljs-string">&quot;Headphone Jack&quot;</span>, <span class="hljs-string">&quot;HP_L&quot;</span>,
		<span class="hljs-string">&quot;Headphone Jack&quot;</span>, <span class="hljs-string">&quot;HP_R&quot;</span>,
		<span class="hljs-string">&quot;Ext Spk&quot;</span>, <span class="hljs-string">&quot;SPK_LP&quot;</span>,
		<span class="hljs-string">&quot;Ext Spk&quot;</span>, <span class="hljs-string">&quot;SPK_LN&quot;</span>,
		<span class="hljs-string">&quot;Ext Spk&quot;</span>, <span class="hljs-string">&quot;SPK_RP&quot;</span>,
		<span class="hljs-string">&quot;Ext Spk&quot;</span>, <span class="hljs-string">&quot;SPK_RN&quot;</span>,
		<span class="hljs-string">&quot;LINPUT2&quot;</span>, <span class="hljs-string">&quot;Mic Jack&quot;</span>,
		<span class="hljs-string">&quot;LINPUT3&quot;</span>, <span class="hljs-string">&quot;Mic Jack&quot;</span>,
		<span class="hljs-string">&quot;RINPUT1&quot;</span>, <span class="hljs-string">&quot;Main MIC&quot;</span>,
		<span class="hljs-string">&quot;RINPUT2&quot;</span>, <span class="hljs-string">&quot;Main MIC&quot;</span>,
		<span class="hljs-string">&quot;Mic Jack&quot;</span>, <span class="hljs-string">&quot;MICB&quot;</span>,
		<span class="hljs-string">&quot;Main MIC&quot;</span>, <span class="hljs-string">&quot;MICB&quot;</span>,
		<span class="hljs-string">&quot;CPU-Playback&quot;</span>, <span class="hljs-string">&quot;ASRC-Playback&quot;</span>,
		<span class="hljs-string">&quot;Playback&quot;</span>, <span class="hljs-string">&quot;CPU-Playback&quot;</span>,
		<span class="hljs-string">&quot;ASRC-Capture&quot;</span>, <span class="hljs-string">&quot;CPU-Capture&quot;</span>,
		<span class="hljs-string">&quot;CPU-Capture&quot;</span>, <span class="hljs-string">&quot;Capture&quot;</span>;
&#125;;</code></pre></div>

<p>简单看一下 sound 节点中几个重要的属性：</p>
<ul>
<li><p><strong>compatible</strong> ：非常重要，用于匹配相应的驱动文件，有两个属性值，在整个 linux 内核源码中搜索这两个属性值即可找到对应的驱动文件，这里找到的驱动文件为：sound&#x2F;soc&#x2F;fsl&#x2F;imx-wm8960.c。</p>
</li>
<li><p><strong>model</strong> ：最终用户看到的此声卡名字，这里设置为“wm8960-audio”。</p>
</li>
<li><p><strong>cpu-dai</strong>：CPU DAI(Digital Audio Interface)句柄，这里是 sai2 这个节点。</p>
</li>
<li><p><strong>audio-codec</strong>：音频解码芯片句柄，也就是 WM8960 芯片，这里为“codec”这个节点。</p>
</li>
<li><p><strong>asrc-controller</strong>：asrc 控制器，asrc 全称为 Asynchronous Sample Rate Converters，翻译过来就是异步采样频率转化器。</p>
</li>
<li><p><strong>hp-det</strong> ：耳机插入检测引脚设置，第一个参数为检测引脚，3 表示 JD3 为检测引脚。第二个参数设置检测电平，设置为 0 的时候，hp 检测到高电平表示耳机插入；设置为 1 的时候，hp 检测到高电平表示是喇叭，也就是耳机拔出了。</p>
</li>
<li><p><strong>audio-routing</strong>：音频器件一系列的连接设置，每个条目都是一对字符串，第一个字符串是连接的 sink，第二个是连接的 source(源)。</p>
</li>
</ul>
<h3 id="2-使能内核的-WM8960-驱动"><a href="#2-使能内核的-WM8960-驱动" class="headerlink" title="2| 使能内核的 WM8960  驱动"></a>2| 使能内核的 WM8960  驱动</h3><p>设备树配置完成以后就可以使能内核自带的 WM8960 驱动了，直接通过图形化界面配置即可，输入如下命令打开 linux 内核的图形化配置界面：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span></code></pre></div>

<h4 id="1-、取消-ALSA-模拟-OSS-API"><a href="#1-、取消-ALSA-模拟-OSS-API" class="headerlink" title="1 、取消 ALSA  模拟 OSS API"></a>1 、取消 ALSA  模拟 OSS API</h4><p>首先取消 ALSA 模拟 OSS，进入如下路径：</p>
<div class="hljs code-wrapper"><pre><code class="hljs clean">-&gt; Device Drivers
    -&gt; Sound card support (SOUND [=y])
        -&gt; Advanced Linux Sound Architecture (SND [=y])
            -&gt; &lt;&gt; OSS Mixer API <span class="hljs-comment">//不选择</span>
            -&gt; &lt;&gt; OSS PCM (digital audio) API <span class="hljs-comment">//不选择</span></code></pre></div>

<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907165744149.png" srcset="/img/loading.gif" lazyload alt="image-20200907165744149"></p>
<h4 id="2-、使能-I-MX6ULL-的-的-WM8960-驱动"><a href="#2-、使能-I-MX6ULL-的-的-WM8960-驱动" class="headerlink" title="2 、使能 I.MX6ULL 的 的 WM8960 驱动"></a>2 、使能 I.MX6ULL 的 的 WM8960 驱动</h4><p>接下来使能 WM8960 驱动，进入如下路径：</p>
<div class="hljs code-wrapper"><pre><code class="hljs livescript">-&gt; Device Drivers
    -&gt; Sound card support <span class="hljs-function"><span class="hljs-params">(SOUND [=y])</span></span>
<span class="hljs-function">        -&gt;</span> Advanced Linux Sound Architecture <span class="hljs-function"><span class="hljs-params">(SND [=y])</span></span>
<span class="hljs-function">            -&gt;</span> ALSA <span class="hljs-keyword">for</span> SoC audio support <span class="hljs-function"><span class="hljs-params">(SND_SOC [=y])</span></span>
<span class="hljs-function">            	-&gt;</span> SoC Audio <span class="hljs-keyword">for</span> Freescale CPUs
                    -&gt; &lt;*&gt; Asynchronous Sample Rate Converter (ASRC) module support <span class="hljs-regexp">//选中</span>
<span class="hljs-regexp">                    -&gt; &lt;*&gt; SoC Audio support for i.MX boards with wm8960 //</span>选中</code></pre></div>

<p>结果如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907165845744.png" srcset="/img/loading.gif" lazyload alt="image-20200907165845744"></p>
<p>驱动使能以后重新编译 linux 内核，编译完成以后使用新的 zImage 和.dtb 文件启动，如果设备树和驱动都使能的话系统启动过程中就会如图所示的 log 信息：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170423473.png" srcset="/img/loading.gif" lazyload alt="image-20200907170423473"></p>
<p>系统最终启动以后会打印出 ALSA 设备列表，现在的音频 CODEC 驱动基本都是 ALSA 架构的，本章的 WM8960 驱动也是根据 ALSA 架构编写的。因此在 ALSA 设备列表中就会找到“wm8960-audio”这个声卡，如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170550815.png" srcset="/img/loading.gif" lazyload alt="image-20200907170550815"></p>
<p>进入系统以后查看一下&#x2F;dev&#x2F;snd 目录，看看有没有如图 所示文件：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170616116.png" srcset="/img/loading.gif" lazyload alt="image-20200907170616116"></p>
<p>图中的这些文件就是ALSA音频驱动框架对应的设备文件，这些文件的作用如下：</p>
<ul>
<li>controlC0：用于声卡控制，C0 表示声卡 0。</li>
<li>pcmC0D0c 和 和 pcmC0D1c ：用于录音的 pcm 设备，其中的“COD0”和“C0D1”分别表示声卡 0 中的设备 0 和设备 1，最后面的“c”是 capture 的缩写，表示录音。</li>
<li>pcmC0D0p 和 和 pcmC0D1p：用于播放的 pcm 设备，其中的“COD0”和“C0D1”分别表示声卡 0 中的设备 0 和设备 1，最后面的“p”是 playback 的缩写，表示放音。</li>
<li>timer ：定时器。</li>
</ul>
<p>音频驱动使能以后还不能直接播放音乐或录音，我们还需要移植 alsa-lib 和 alsa-utils 这两个东西。</p>
<h2 id="四、alsa-lib-和-和-alsa-utils-移植"><a href="#四、alsa-lib-和-和-alsa-utils-移植" class="headerlink" title="四、alsa-lib 和 和 alsa-utils 移植"></a>四、alsa-lib 和 和 alsa-utils 移植</h2><p>首 选 下 载 alsa-lib 和 alsa-utils 源 码 ， 下 载 地 址 为 ： <a target="_blank" rel="noopener" href="http://www.alsa-project.org/main/index.php/Main_Page%E3%80%82">http://www.alsa-project.org/main/index.php/Main_Page。</a></p>
<p>当前最新版本为 1.2.2，如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170812231.png" srcset="/img/loading.gif" lazyload alt="image-20200907170812231"></p>
<h3 id="1-alsa-lib-移植"><a href="#1-alsa-lib-移植" class="headerlink" title="1| alsa-lib 移植"></a>1| alsa-lib 移植</h3><p>注意 alsa-lib 编译过程中会生成一些配置文件，而这些配置信息的路径都是绝对路径，因此为了保证 ubuntu 和开发板根文件系统中的路径一致！我们需要在 ubuntu 和开发板中各创建一个路径和名字完全一样的目录，这里我们都创建一个&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录，ubuntu 中创建命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/share 			//进入 ubuntu 的/usr/share 目录
sudo <span class="hljs-built_in">mkdir</span> arm-alsa  	//创建 arm-alsa 目录</code></pre></div>

<p>最后在开发板根文件系统中也创建一个&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> .../nfs/rootfs/						//进入根文件系统根目录
<span class="hljs-built_in">mkdir</span> ./usr/share/arm-alsa -p  		//开发板根文件系统创建 arm-alsa 目录</code></pre></div>

<p>这样 ubuntu 和开发板根文件系统都有一个“&#x2F;usr&#x2F;share&#x2F;arm-alsa”目录，我们交叉编译的时候就不怕存在引用绝对路径了，因为 ubuntu 和开发板中的配置文件路径都是一模一样的。由于 alsa-utils 要用到 alsa-lib 库，因此要先编译 alsa-lib 库。alsa-lib 就是 ALSA 相关库文件，应用程序通过调用 ALSA 库来对 ALSA 框架下的声卡进行操作。先创建一个名为“alsa-lib”的目录用来保存 alsa-lib 的编译结果，然后将 alsa-lib-1.2.2.tar.bz2 拷贝到 ubuntu 中并解压，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">tar -vxjf alsa-lib-1.2.2.tar.bz2 //解压 alsa-lib</code></pre></div>

<p>解压完成以后就会得到一个名为“alsa-lib-1.2.2”的文件夹，这个就是 alsa-lib 的源码。进入alsa-lib-1.2.2 目录，然后配置并编译，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> alsa-lib-1.2.2/   			//进入 alsa-lib 源码目录

./configure --host=arm-linux-gnueabihf --prefix=/home/firestaradmin/linux/tools/alsa-lib --with-configdir=/usr/share/arm-alsa 					//配置</code></pre></div>

<p>注意， “–with-configdir”用于设置 alsa-lib 编译出来的配置文件存放位置，这里设置为前面创建的“&#x2F;usr&#x2F;share&#x2F;arm-alsa”目录。</p>
<p>配置完成以后就可以编译了，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">make  //编译
sudo make install //安装</code></pre></div>

<p>可能会出现如图所示的错误提示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907171829579.png" srcset="/img/loading.gif" lazyload alt="image-20200907171829579"></p>
<p>图中提示 libatopology.la 编译失败，这是因为 sudo 会切换到 root 用户下，但是此时 root用户下的环境变量中没有交叉编译器路径，因此会提示找不到“arm-linux-gnueabihf-gcc”，从而导致 libatopology.la 编译失败。解决方法就是先切换到 root 用户，重新执行一下&#x2F;etc&#x2F;profile文件，然后直接 make install 即可，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">sudo -s  				//切换到 root 用户
<span class="hljs-built_in">source</span> /etc/profile 	//执行/etc/profile
make install  			//安装，此时已经工作在 root 下，因此不需要加“sudo”
su firestaradmin  		//编译完成以后回原来的用户</code></pre></div>

<p>编译完成以后前面创建的“alsa-lib”目录就会保存相应的编译结果，如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907172030992.png" srcset="/img/loading.gif" lazyload alt="image-20200907172030992"></p>
<p>ubuntu 中&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下的内容如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907172142141.png" srcset="/img/loading.gif" lazyload alt="image-20200907172142141"></p>
<p>将上上图中alsa-lib&#x2F;lib 目录下的所有文件拷贝到开发板根文件系统的&#x2F;usr&#x2F;lib 目录下，再将上图中&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下的所有文件拷贝到开发板的&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> alsa-lib 
sudo <span class="hljs-built_in">cp</span> lib/* /home/firestardmin/linux/nfs/rootfs/lib/ -af
<span class="hljs-built_in">cd</span> /usr/share/arm-alsa
sudo <span class="hljs-built_in">cp</span> * /home/firestardmin/linux/nfs/rootfs/usr/share/arm-alsa/ -raf</code></pre></div>

<h3 id="2-alsa-utils-移植"><a href="#2-alsa-utils-移植" class="headerlink" title="2| alsa-utils 移植"></a>2| alsa-utils 移植</h3><p>alsa-utils 是 ALSA 的一些小工具集合，我们可以通过这些小工具还测试我们的声卡。将 alsa-utils-1.2.2.tar.bz2 复制到 ubuntu 中并解压，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">tar -vxjf alsa-utils-1.2.2.tar.bz2  //解压</code></pre></div>

<p>解压成功以后会得到一个名为“alsa-utils-1.2.2”的文件夹，此文件夹就是 alsa-utils 源码。重新创建一个名为“alsa-utils”的目录用于存放 alsa-utils-1.2.2 的编译结果。按照如下命令编译alsa-utils：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> alsa-utils-1.2.2/ 

./configure --host=arm-linux-gnueabihf --prefix=/home/firestaradmin/linux/tools/alsa-utils --with-alsa-inc-prefix=/home/firestaradmin/linux/tools/alsa-lib/include/ --with-alsa-prefix=/home/firestaradmin/linux/tools/alsa-lib/lib/ --disable-alsamixer --disable-xmlto

make //编译

sudo make install</code></pre></div>

<p>注意！上面在配置 alsa-utils 的时候使用了“–disable-alsamixer”来禁止编译 alsamixer 这个工具，但是这个工具确非常重要，它是一个图形化的声卡控制工具，需要 ncurses 库的支持。</p>
<p>ncurses 库笔者已经交叉编译成功了，但是尝试了很多次设置，就是无法编译alsa-utils 中的 alsamixer 工具。网上也没有找到有效的解决方法，大家都是禁止编译 alsamixer的。所以这里就没法使用 alsamixer 这个工具了，但是可以使用 alsa-utils 提供的另外一个工具：amixer，alsamixer 其实就是 amixer 的图形化版本。两者的功能都是一样的，只是 alsamixer 使用起来更人性化一点。</p>
<p>上面utils编译时可能会出现</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span>: 无法获取<span class="hljs-string">&quot;t-ja.gmo&quot;</span> 的文件状态(<span class="hljs-built_in">stat</span>): 没有那个文件或目录
make[2]: *** [ja.gmo] 错误 1</code></pre></div>

<p>解决办法是自己创建一个空文件 ~&#x2F;alsa-utils-xxx&#x2F;alsaconf&#x2F;po&#x2F;t-ja.gmo 然后重新 make, 之后又提示另一个文件没有，用同样的办法创建空文件再次 make，就能成功了。</p>
<p>编译完成以后就会在前面创建的“alsa-utils”目录下生成 bin、sbin 和 share 三个文件夹，如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907174836127.png" srcset="/img/loading.gif" lazyload alt="image-20200907174836127"></p>
<p>将图中 bin、sbin 和 share 这三个目录中的所有文件分别拷贝到开发板根目录下的&#x2F;bin、&#x2F;sbin 和&#x2F;usr&#x2F;share&#x2F;alsa 目录下，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> alsa-utils
sudo <span class="hljs-built_in">cp</span> bin/* /home/firestaradmin/linux/nfs/rootfs/bin/ -rfa
sudo <span class="hljs-built_in">cp</span> sbin/* /home/firestaradmin/linux/nfs/rootfs/sbin/ -rfa
sudo <span class="hljs-built_in">cp</span> share/* /home/firestaradmin/linux/nfs/rootfs/usr/share/ -rfa</code></pre></div>

<p>打开开发板根文件系统中的&#x2F;etc&#x2F;profile 文件，在里面加入如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">export ALSA_CONFIG_PATH=<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/arm-alsa/</span>alsa.conf</code></pre></div>

<p>ALSA_CONFIG_PATH 用于指定 alsa 的配置文件，这个配置文件是 alsa-lib 编译出来的。</p>
<h2 id="五、声卡设置与测试"><a href="#五、声卡设置与测试" class="headerlink" title="五、声卡设置与测试"></a>五、声卡设置与测试</h2><h3 id="1-amixer-使用方法"><a href="#1-amixer-使用方法" class="headerlink" title="1| amixer 使用方法"></a>1| amixer 使用方法</h3><h4 id="1-、查看帮助信息"><a href="#1-、查看帮助信息" class="headerlink" title="1 、查看帮助信息"></a>1 、查看帮助信息</h4><p>声卡相关选型默认都是关闭的，比如耳机和喇叭的左右声道输出等。因此我们在使用之前一定要先设置好声卡，alsa-utils 自带了 amixer 这个声卡设置工具。输入如下命令即可查看 amixer的帮助信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ada">amixer <span class="hljs-comment">--help </span></code></pre></div>

<p>结果如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175325585.png" srcset="/img/loading.gif" lazyload alt="image-20200907175325585"></p>
<p>从图 可以看出，amixer 软件命令分为两组，scontrols、scontents、sset 和 sget 为一组。controls、contents、cset 和 cget 为另一组。这两组的基本功能都是一样的，只不过“s”开头的是 simple(简单)组，这一组命令是简化版，本教程最终使用“s”开头的命令设置声卡，因为少输入很多字符。</p>
<h4 id="2-、查看设置项"><a href="#2-、查看设置项" class="headerlink" title="2 、查看设置项"></a>2 、查看设置项</h4><p>我们要先看一下都有哪些设置项，先来看一下 scontrols 对应的设置项，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">amixer scontrols  <span class="hljs-regexp">//</span>查看所有设置项</code></pre></div>

<p>结果如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175501178.png" srcset="/img/loading.gif" lazyload alt="image-20200907175501178"></p>
<p>再来看一下 controls 对应的设置项，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">amixer controls  <span class="hljs-regexp">//</span>查看所有设置项</code></pre></div>

<p>结果如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175532792.png" srcset="/img/loading.gif" lazyload alt="image-20200907175532792"></p>
<p>图 由于篇幅原因只列出了一部分设置项，整体设置项目还是比较多的，很多设置项目我们都不知道是啥意思，毕竟不是从事音频专业的。这里我们只关注一些最常用的设置即可，比如设置耳机和喇叭音量、设置左右声道音量、设置输入音量等等。</p>
<h4 id="3-、查看设置值-值"><a href="#3-、查看设置值-值" class="headerlink" title="3 、查看设置值 值"></a>3 、查看设置值 值</h4><p>不同的设置项对应的设置值类型不同，先查看一下scontents对应的设置值，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">amixer scontents  <span class="hljs-regexp">//</span>查看设置值</code></pre></div>

<p>结果如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175630338.png" srcset="/img/loading.gif" lazyload alt="image-20200907175630338"></p>
<p>从图 可以看出“Headphone”项目就是设置耳机音量的，音量范围为 0-127，当前音量为 0。有些设置项是 bool 类型，只有 on 和 off 两种状态。关于 controls 对应的设置值大家自行输入“amixer controls”命令查看即可。</p>
<h4 id="4、设置声卡"><a href="#4、设置声卡" class="headerlink" title="4、设置声卡"></a>4、设置声卡</h4><p>知道了设置项和设置值，那么设置声卡就很简单了，直接使用下面命令即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">amixer</span> sset 设置项目 设置值</code></pre></div>

<p>或：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">amixer</span> cset 设置项目 设置值</code></pre></div>



<h4 id="5-、获取声卡设置值"><a href="#5-、获取声卡设置值" class="headerlink" title="5 、获取声卡设置值"></a>5 、获取声卡设置值</h4><p>如果要读取当前声卡某项设置值的话使用如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs smali">amixer<span class="hljs-built_in"> sget </span>设置项目</code></pre></div>

<p>或：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">amixer</span> cget 设置项目</code></pre></div>



<h3 id="2-音乐播放测试"><a href="#2-音乐播放测试" class="headerlink" title="2| 音乐播放测试"></a>2| 音乐播放测试</h3><h4 id="1-、使用-amixer-设置声卡"><a href="#1-、使用-amixer-设置声卡" class="headerlink" title="1 、使用 amixer  设置声卡"></a>1 、使用 amixer  设置声卡</h4><p>第一次使用声卡之前一定要先使用 amixer 设置声卡，打开耳机和喇叭，并且设置喇叭和耳<br>机音量，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">amixer</span> sset Headphone <span class="hljs-number">100</span>,<span class="hljs-number">100</span>
<span class="hljs-attribute">amixer</span> sset Speaker <span class="hljs-number">120</span>,<span class="hljs-number">120</span>
<span class="hljs-attribute">amixer</span> sset &#x27;Right Output Mixer PCM&#x27; <span class="hljs-literal">on</span>
<span class="hljs-attribute">amixer</span> sset &#x27;Left Output Mixer PCM&#x27; <span class="hljs-literal">on</span></code></pre></div>

<h4 id="2-、使用-aplay-播放-WAV-格式音乐"><a href="#2-、使用-aplay-播放-WAV-格式音乐" class="headerlink" title="2 、使用 aplay  播放 WAV  格式音乐"></a>2 、使用 aplay  播放 WAV  格式音乐</h4><p>声卡设置好以后就可以使用 aplay 软件播放 wav 格式的音乐测试一下，aplay 也是 alsa-utils提供的。可以在开发板根文件系统下创建一个名为“music”的目录来存放音频文件，然后找一首 wav 格式的音乐放到开发板根文件系统中，然后输入如下命令播放：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">aplay test.wav <span class="hljs-regexp">//</span>播放歌曲</code></pre></div>

<p>如果一切设置正常的话就会开始播放音乐，因为 ALPHA 开发板支持喇叭和耳机自动切换，因此如果不插耳机的话默认从喇叭播放音乐。插上耳机以后喇叭就会停止播放音乐，改为耳机播放音乐。</p>
<h3 id="3-MIC-录音测试"><a href="#3-MIC-录音测试" class="headerlink" title="3| MIC  录音测试"></a>3| MIC  录音测试</h3><p>ALPHA 开发板上有一个麦克风，如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907180428743.png" srcset="/img/loading.gif" lazyload alt="image-20200907180428743"></p>
<p>我们可以通过图 上的这个麦克风(MIC)来完成录音测试。</p>
<h4 id="1-、使用-amixer-设置声卡-1"><a href="#1-、使用-amixer-设置声卡-1" class="headerlink" title="1 、使用 amixer  设置声卡"></a>1 、使用 amixer  设置声卡</h4><p>同样的，第一次使用声卡录音之前要先使用 amixer 设置一下声卡，这里为了方便，我们在开发板根文件系统的&#x2F;music 目录下创建一个名为“mic_in_config.sh”的 shell 脚本，然后在里面输入声卡的设置命令。mic_in_config.sh 脚本内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span>
<span class="hljs-comment">#设置捕获的音量</span>
amixer cset name=<span class="hljs-string">&#x27;Capture Volume&#x27;</span> 90,90

<span class="hljs-comment">#PCM</span>
amixer sset <span class="hljs-string">&#x27;PCM Playback&#x27;</span> on
amixer sset <span class="hljs-string">&#x27;Playback&#x27;</span> 256
amixer sset <span class="hljs-string">&#x27;Right Output Mixer PCM&#x27;</span> on
amixer sset <span class="hljs-string">&#x27;Left Output Mixer PCM&#x27;</span> on

<span class="hljs-comment">#ADC PCM</span>
amixer sset <span class="hljs-string">&#x27;ADC PCM&#x27;</span> 200

<span class="hljs-comment">#耳机/喇叭（扬声器）设置播放音量，直流/交流</span>
<span class="hljs-comment">#Turn on Headphone</span>
amixer sset <span class="hljs-string">&#x27;Headphone Playback ZC&#x27;</span> on
<span class="hljs-comment">#Set the volume of your headphones(98% volume，127 is the MaxVolume)</span>
amixer sset Headphone 125,125
<span class="hljs-comment">#Turn on the speaker</span>
amixer sset <span class="hljs-string">&#x27;Speaker Playback ZC&#x27;</span> on
<span class="hljs-comment">#Set the volume of your Speaker(98% volume，127 is the MaxVolume)</span>
amixer sset Speaker 125,125
<span class="hljs-comment">#Set the volume of your Speaker AC(80% volume，100 is the MaxVolume)</span>
amixer sset <span class="hljs-string">&#x27;Speaker AC&#x27;</span> 4
<span class="hljs-comment">#Set the volume of your Speaker AC(80% volume，5 is the MaxVolume)</span>
amixer sset <span class="hljs-string">&#x27;Speaker DC&#x27;</span> 4

<span class="hljs-comment">#音频输入，左声道管理</span>
<span class="hljs-comment">#Turn on Left Input Mixer Boost</span>
amixer sset <span class="hljs-string">&#x27;Left Input Mixer Boost&#x27;</span> off
amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT1&#x27;</span> off
amixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT1&#x27;</span> 0
amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT2&#x27;</span> on
amixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT2&#x27;</span> 127
<span class="hljs-comment">#Turn off Left Boost Mixer LINPUT3</span>
amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT3&#x27;</span> off
amixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT3&#x27;</span> 0

<span class="hljs-comment">#音频输入，右声道管理，全部关闭</span>
<span class="hljs-comment">#Turn on Right Input Mixer Boost</span>
amixer sset <span class="hljs-string">&#x27;Right Input Mixer Boost&#x27;</span> on
amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT1&#x27;</span> off
amixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT2&#x27;</span> 0
amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT2&#x27;</span> on
amixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT2&#x27;</span> 127
amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT3&#x27;</span> off
amixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT3&#x27;</span> 0</code></pre></div>

<p>给予 mic_in_config.sh 可执行权限并运行，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 mic_in_config.sh 
./mic_in_config.sh</code></pre></div>

<h4 id="2-、使用-arecord-录制音频"><a href="#2-、使用-arecord-录制音频" class="headerlink" title="2 、使用 arecord  录制音频"></a>2 、使用 arecord  录制音频</h4><p>使用 arecord 来录制一段 10 秒中的音频，arecord 也是 alsa-utils 编译出来的，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">arecord -f <span class="hljs-built_in">cd</span> -d 10 record.wav</code></pre></div>

<p>-f 是设置录音质量，“-f cd”表示录音质量为 cd 级别。-d 是指定录音时间，单位是 s，这条指令就是录制一段 cd 级别 10s 的 wav 音频，音频名字为 record.wav。录制的时候大家就可以对着开发板上的 MIC 说话，直到录制完成。</p>
<p>录制完成以后使用 aplay 播放刚刚录制的 record.wav 音频，大家会发现只有左声道有声音，右声道没有任何声音，这是因为 ALPHA 开发板的 MIC 只接了左声道，因此录出来的音频只有左声道有数据。</p>
<h4 id="3-、单声道-MIC-录制立体声音频"><a href="#3-、单声道-MIC-录制立体声音频" class="headerlink" title="3 、单声道 MIC 录制立体声音频"></a>3 、单声道 MIC 录制立体声音频</h4><p>前面测出来 MIC 录出来的只有左声道有声音，那么我们能不能让只接到左声道的 MIC 录制出来的音频是双声道的呢？这个就要去看 WM8960 的数据手册了，看看能不能配置 WM8960的右声道 ADC 直接使用左声道的数据。这样左右声道就共同使用一个 MIC，录出来的音频就是双声道的，虽然两个声道的数据是一模一样的。打开 WM8960 数据手册，找到 R23 寄存器(地址为 0X17)，R23 寄存器的 bit3:2 是设置 ADC数据的，如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181151417.png" srcset="/img/loading.gif" lazyload alt="image-20200907181151417"></p>
<p>从图  可以看出，R23 的 bit3:2 控制着左右声道数据来自哪里，可选设置如下：<br>00 ：左声道数据使用左 ADC，右声道数据使用右 ADC，这个是默认模式。<br>01 ：左声道数据使用左 ADC，右声道数据使用左 ADC。<br>10 ：左声道数据使用右 ADC，右声道数据使用右 ADC。<br>11：左声道数据使用右 ADC，右声道数据使用左 ADC。</p>
<p>由于 ALPHA 开发板 MIC 接在了左声道，因此 WM8960 的 R23 寄存器 bit3:2 应该设置为01，也就是左右声道的数据都使用左 ADC。</p>
<p>打开 linux 内核里面的 wm8960.c 这个文件，找到 wm8960_reg_defaults 数组，此数组保存着 wm8960 的默认配置值，为&lt;寄存器地址，值&gt;这样的形式。R23 寄存器地址为 0X17，因此找到 0x17 组，默认情况下 0x17 对应的值为 0X01C0，我们将 bit3:2 改为 01 以后 0x17 寄存器的值就变为了 0x01C4，修改后的 wm8960_reg_defaults 寄存器如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reg_default</span> <span class="hljs-title">wm8960_reg_defaults</span>[] =</span> &#123;
<span class="hljs-number">2</span> 		&#123; <span class="hljs-number">0x0</span>, <span class="hljs-number">0x00a7</span> &#125;,
......
<span class="hljs-number">21</span> 		&#123; <span class="hljs-number">0x16</span>, <span class="hljs-number">0x00c3</span> &#125;,
<span class="hljs-number">22</span> 		<span class="hljs-comment">/*&#123; 0x17, 0x01c0 &#125;,*/</span>
<span class="hljs-number">23</span> 		&#123; <span class="hljs-number">0x17</span>, <span class="hljs-number">0x01c4</span> &#125;,
<span class="hljs-number">24</span> 		&#123; <span class="hljs-number">0x18</span>, <span class="hljs-number">0x0000</span> &#125;,
......
<span class="hljs-number">53</span> 		&#123; <span class="hljs-number">0x37</span>, <span class="hljs-number">0x00e9</span> &#125;,
<span class="hljs-number">54</span> 		&#125;;</code></pre></div>

<p>第 23 行就是将 R23 寄存器的值改为 0x01c4。修改完成以后重新编译 linux 内核，然后使用新的内核启动开发板，重新测试 MIC 录音，这个时候录出来的就应该是立体音了。</p>
<h3 id="4-LINE-IN-录音测试"><a href="#4-LINE-IN-录音测试" class="headerlink" title="4| LINE IN  录音测试"></a>4| LINE IN  录音测试</h3><p>如果在 MIC 录音实验中将 R23 的寄存器改为了 0X01C4，那么在进行 LINE IN 录音测试之前先改回原来的 0X01C0，因为 ALPHA 开发板的 LINE IN 接了双声道，不需要共用左声道数据。当然了，不修改也是可以直接做测试的！最后进行一下 Line in 测试，也就是线路输入测试，ALPHA 开发板上 Line in 接口如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181517384.png" srcset="/img/loading.gif" lazyload alt="image-20200907181517384"></p>
<p>注意，图  中的 Line in 不是用来连接话筒的！这里不能接话筒。使用一根 3.5mm 公对公音频线，一头连接到手机或者电脑，另外一头连接到图 中的 Line in 接口上。</p>
<h4 id="1-、使用-amixer-设置声卡-2"><a href="#1-、使用-amixer-设置声卡-2" class="headerlink" title="1 、使用 amixer  设置声卡"></a>1 、使用 amixer  设置声卡</h4><p>同样新建一个名为“line_in_config.sh”的 shell 脚本，在此脚本里面输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">1 <span class="hljs-comment">#!/bin/sh</span>
2 <span class="hljs-comment">#正点原子@ALIENTEK</span>
3 <span class="hljs-comment">#设置捕获的音量</span>
4 amixer cset name=<span class="hljs-string">&#x27;Capture Volume&#x27;</span> 100,100
5
6 <span class="hljs-comment">#PCM</span>
7 amixer sset <span class="hljs-string">&#x27;PCM Playback&#x27;</span> on
8 amixer sset <span class="hljs-string">&#x27;Playback&#x27;</span> 256
9 amixer sset <span class="hljs-string">&#x27;Right Output Mixer PCM&#x27;</span> on
10 amixer sset <span class="hljs-string">&#x27;Left Output Mixer PCM&#x27;</span> on
11
12 <span class="hljs-comment">#ADC PCM</span>
13 amixer sset <span class="hljs-string">&#x27;ADC PCM&#x27;</span> 200
14
15 <span class="hljs-comment">#录音前应该设置耳机或者扬声器的音量为 0（下面并没有设置）防止干扰</span>
16 <span class="hljs-comment">#耳机/喇叭（扬声器）设置播放音量，直流/交流</span>
17 <span class="hljs-comment">#Turn on Headphone</span>
18 amixer sset <span class="hljs-string">&#x27;Headphone Playback ZC&#x27;</span> on
19 <span class="hljs-comment">#Set the volume of your headphones(98% volume，127 is the MaxVolume)</span>
20 amixer sset Headphone 125,125
21 <span class="hljs-comment">#Turn on the speaker</span>
22 amixer sset <span class="hljs-string">&#x27;Speaker Playback ZC&#x27;</span> on
23 <span class="hljs-comment">#Set the volume of your Speaker(98% volume，127 is the MaxVolume)</span>
24 amixer sset Speaker 125,125
25 <span class="hljs-comment">#Set the volume of your Speaker AC(80% volume，100 is the MaxVolume)</span>
26 amixer sset <span class="hljs-string">&#x27;Speaker AC&#x27;</span> 4
27 <span class="hljs-comment">#Set the volume of your Speaker AC(80% volume，5 is the MaxVolume)</span>
28 amixer sset <span class="hljs-string">&#x27;Speaker DC&#x27;</span> 4
29
30 <span class="hljs-comment">#音频输入，左声道管理</span>
31 <span class="hljs-comment">#Turn off Left Input Mixer Boost</span>
32 amixer sset <span class="hljs-string">&#x27;Left Input Mixer Boost&#x27;</span> on
33 <span class="hljs-comment">#关闭其他通道输入</span>
34 amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT1&#x27;</span> off
35 amixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT1&#x27;</span> 0
36 <span class="hljs-comment">#关闭麦克风左声道输入</span>
37 amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT2&#x27;</span> on
38 amixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT2&#x27;</span> 127
39 <span class="hljs-comment">#Line_in 右声道输入关闭</span>
40 amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT3&#x27;</span> off
41 amixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT3&#x27;</span> 0
42
43
44 <span class="hljs-comment">#音频输入，右声道管理</span>
45 <span class="hljs-comment">#Turn on Right Input Mixer Boost</span>
46 amixer sset <span class="hljs-string">&#x27;Right Input Mixer Boost&#x27;</span> on
47 amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT1&#x27;</span> off
48 amixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT1&#x27;</span> 0
49 amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT2&#x27;</span> off
50 amixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT2&#x27;</span> 0
51
52 <span class="hljs-comment">#要想设置成音频输入，请打开 RINPUT3,看原理图可知</span>
53 <span class="hljs-comment">#其他的声道通过上面的配置可关闭，这样是为了避免干扰，需要的时候就打开</span>
54 <span class="hljs-comment">#RINPUT3 打开（关键点）</span>
55 amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT3&#x27;</span> on
56 amixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT3&#x27;</span> 127</code></pre></div>

<p>最后，给予 line_in_config.sh 可执行权限并运行，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs stata">chmod 777 line_in_config.<span class="hljs-keyword">sh</span> <span class="hljs-comment">//给予可执行权限</span>
./line_in_config.<span class="hljs-keyword">sh</span> <span class="hljs-comment">//运行</span></code></pre></div>

<h4 id="2-、使用-arecord-录制音频-1"><a href="#2-、使用-arecord-录制音频-1" class="headerlink" title="2 、使用 arecord  录制音频"></a>2 、使用 arecord  录制音频</h4><p>使用 arecord 来录制一段 10 秒中的音频，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs powershell">arecord <span class="hljs-operator">-f</span> <span class="hljs-built_in">cd</span> <span class="hljs-literal">-d</span> <span class="hljs-number">10</span> record.wav</code></pre></div>

<p>录制完成以后使用 aplay 播放刚刚录制的音频，由于 ALPHA 开发板上 LINE IN 是接了左右双声道，因此录制出来的音频是立体声的，不像 MIC 录出来的只有左声道。</p>
<h2 id="六、开机自动配置声卡"><a href="#六、开机自动配置声卡" class="headerlink" title="六、开机自动配置声卡"></a>六、开机自动配置声卡</h2><p>大家在使用的时候应该应该会发现开发板重启以后声卡的所有设置都会消失，必须重新设置声卡。也就是说我们对声卡的设置不能保存，本小节我们就来学习一下如何保存声卡的设置。</p>
<h3 id="1-、使用-alsactl-保存声卡设置"><a href="#1-、使用-alsactl-保存声卡设置" class="headerlink" title="1 、使用 alsactl  保存声卡设置"></a>1 、使用 alsactl  保存声卡设置</h3><p>声卡设置的保存通过 alsactl 工具来完成，此工具也是 alsa-utils 编译出来的。因为 alsactl 默认将声卡配置文件保存在&#x2F;var&#x2F;lib&#x2F;alsa 目录下，因此首先在开发板根文件系统下创建&#x2F;var&#x2F;lib&#x2F;alsa目录，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/var/</span>lib/alsa -p</code></pre></div>

<p>首先使用 amixer 设置声卡，然后输入如下命令保存声卡设置</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">alsactl -f <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/alsa/</span>asound.state store <span class="hljs-regexp">//</span>保存声卡设置</code></pre></div>

<p>-f 指定声卡配置文件，store 表示保存。关于 alsactl 的详细使用方法，输入“alsactl -h”即可。保存成功以后就会生成&#x2F;var&#x2F;lib&#x2F;alsa&#x2F;asound.state 这个文件，asound.state 里面就是关于声卡的各种设置信息，大家可以打开此文件查看一下里面的内容，如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181757589.png" srcset="/img/loading.gif" lazyload alt="image-20200907181757589"></p>
<p>如果要使用 asound.state 中的配置信息来配置声卡，执行如下命令即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs pf">alsactl -f /var/lib/alsa/asound.<span class="hljs-keyword">state</span> restore</code></pre></div>

<p>最后面的参数改为 restore 即可，也就是恢复的意思。</p>
<p>打开&#x2F;etc&#x2F;init.d&#x2F;rcS 文件，在最后面追加如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;/var/lib/alsa/asound.state&quot;</span> ]; then
<span class="hljs-number">2</span> 		echo <span class="hljs-string">&quot;ALSA: Restoring mixer setting......&quot;</span>
<span class="hljs-number">3</span> 		/sbin/alsactl -f /var/lib/alsa/asound.state restore &amp;
<span class="hljs-number">4</span> fi</code></pre></div>

<p>第 1 行判断&#x2F;var&#x2F;lib&#x2F;alsa&#x2F;asound.state 这个文件是否存在，存在的话就执行下面的。首先输出一行提示符：“ALSA: Restoring mixer setting……”，表示设置声卡，最后调用&#x2F;sbin&#x2F;alsactl 来执行声卡设置工作。<br>设置完成以后重启开发板，开发板开机就会自动设置声卡，会输入如图所示内容：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181902945.png" srcset="/img/loading.gif" lazyload alt="image-20200907181902945"></p>
<p>接使用 aplay 播放音乐测试声卡开机自动配置是否正确。</p>
<h2 id="七、mplayer-播放器移植与使用"><a href="#七、mplayer-播放器移植与使用" class="headerlink" title="七、mplayer  播放器移植与使用"></a>七、mplayer  播放器移植与使用</h2><p>至此，linux 下的 LCD 显示和音频都已经驱动起来了，那么肯定就会有朋友想播放视频。<br>本节我们就来学习一下如何移植 mplayer 这个强大的视频播放软件。mplayer 是一款开源的多媒<br>体播放器，可以用来播放音视频，mplayer 自带多种格式的解码器，不需要我们再另外安装。</p>
<h3 id="1-mplayer-移植"><a href="#1-mplayer-移植" class="headerlink" title="1| mplayer 移植"></a>1| mplayer 移植</h3><h4 id="1-、移植-zlib-库"><a href="#1-、移植-zlib-库" class="headerlink" title="1 、移植 zlib  库"></a>1 、移植 zlib  库</h4><p>mplayer 用到了 zlib 库，因此要先移植 zlib 库。zlib 源码下载地址为：<a target="_blank" rel="noopener" href="http://zlib.net/%EF%BC%8C%E5%BD%93%E5%89%8D%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%BA">http://zlib.net/，当前最新版本为</a> 1.2.11。我们已经下载下来放到了开发板光盘中，</p>
<div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">ar</span> -vxzf zlib-<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">11</span>.tar.gz  //解压</code></pre></div>

<p>解压完成以后得到一个名为“zlib-1.2.11”的 zlib 源码文件。另外新建一个名为“zlib”的文件夹来保存 zlib 的编译结果。进入 zlib 源码目录，然后配置并编译，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs groovy">cd zlib<span class="hljs-number">-1.2</span><span class="hljs-number">.11</span><span class="hljs-regexp">/ /</span>/进去 zlib 源码

CC=arm-linux-gnueabihf-gcc  LD=arm-linux-gnueabihf-ld  AD=arm-linux-gnueabihf-
<span class="hljs-keyword">as</span> .<span class="hljs-regexp">/configure --prefix=/</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/tools/</span>zlib <span class="hljs-comment">//配置</span>

make  <span class="hljs-comment">//编译</span>
make install</code></pre></div>

<p>编译完成以后的 zlib 目录内容如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182057667.png" srcset="/img/loading.gif" lazyload alt="image-20200907182057667"></p>
<p>将图中的lib目录下的zlib库文件拷贝到开发板根文件系统的&#x2F;lib目录下，命令为：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">sudo cp lib<span class="hljs-regexp">/* /</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/nfs/</span>rootfs<span class="hljs-regexp">/lib/</span> -rfa</code></pre></div>



<h4 id="2-、移植-mplayer"><a href="#2-、移植-mplayer" class="headerlink" title="2 、移植 mplayer"></a>2 、移植 mplayer</h4><p>mplayer 需要用到 alsa-lib 和 zlib，因此要先保证这两个已经交叉编译了。mplayer 源码下载地址为：<a target="_blank" rel="noopener" href="http://www.mplayerhq.hu/MPlayer/releases/%EF%BC%8C%E5%BD%93%E5%89%8D%E6%9C%80%E6%96%B0%E7%9A%84%E4%B8%BA">http://www.mplayerhq.hu/MPlayer/releases/，当前最新的为</a> 1.4 版本。将 MPlayer-1.4.tar.gz 拷贝到 ubuntu 中并解压，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs stylus">tar -vxzf MPlayer-<span class="hljs-number">1.4</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> <span class="hljs-comment">//解压</span></code></pre></div>

<p>解压完成以后得到一个名为“MPlayer-1.4”的 mplayer 源码文件。另外新建一个名为“mplayer”的文件夹来保存 mplayer 的编译结果。进入 mplayer 源码目录，然后配置并编译，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">cd</span> <span class="hljs-comment">MPlayer</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">4/</span>  <span class="hljs-comment">//进去</span> <span class="hljs-comment">mplayer</span> <span class="hljs-comment">源码</span>

<span class="hljs-string">.</span><span class="hljs-comment">/configure</span> --<span class="hljs-comment">cc=arm</span><span class="hljs-literal">-</span><span class="hljs-comment">linux</span><span class="hljs-literal">-</span><span class="hljs-comment">gnueabihf</span><span class="hljs-literal">-</span><span class="hljs-comment">gcc</span> --<span class="hljs-comment">host</span><span class="hljs-literal">-</span><span class="hljs-comment">cc=gcc</span> --<span class="hljs-comment">target=arm</span><span class="hljs-literal">-</span><span class="hljs-comment">linux</span><span class="hljs-literal">-</span><span class="hljs-comment">gnueabihf</span> --<span class="hljs-comment">disable</span><span class="hljs-literal">-</span><span class="hljs-comment">ossaudio</span> --<span class="hljs-comment">enable</span><span class="hljs-literal">-</span><span class="hljs-comment">alsa</span> --<span class="hljs-comment">prefix=/home/zuozhongkai/linux/IMX6ULL/tool/mplayer</span> --<span class="hljs-comment">extra</span><span class="hljs-literal">-</span><span class="hljs-comment">cflags=&quot;</span><span class="hljs-literal">-</span><span class="hljs-comment">I/home/zuozhongkai/linux/IMX6ULL/tool/zlib/include</span>  <span class="hljs-literal">-</span><span class="hljs-comment">I/home/zuozhongkai/linux/IMX6ULL/tool/alsa</span><span class="hljs-literal">-</span><span class="hljs-comment">lib/include&quot;</span>  --<span class="hljs-comment">extra</span><span class="hljs-literal">-</span><span class="hljs-comment">ldflags=&quot;</span><span class="hljs-literal">-</span><span class="hljs-comment">L/home/zuozhongkai/linux/IMX6ULL/tool/zlib/lib</span>  <span class="hljs-literal">-</span><span class="hljs-comment">Iz</span>  <span class="hljs-literal">-</span>
<span class="hljs-comment">L/home/zuozhongkai/linux/IMX6ULL/tool/alsa</span><span class="hljs-literal">-</span><span class="hljs-comment">lib/lib</span> <span class="hljs-literal">-</span><span class="hljs-comment">lasound&quot;</span> --<span class="hljs-comment">enable</span><span class="hljs-literal">-</span><span class="hljs-comment">fbdev</span> --<span class="hljs-comment">disable</span><span class="hljs-literal">-</span><span class="hljs-comment">mencoder</span>

<span class="hljs-comment">make</span>  <span class="hljs-comment">//编译</span></code></pre></div>

<p>–extra-cflags 指定 zlib 和 alsa-lib 的头文件路径，–extra-ldflags 指定 zlib 和 alsa-lib 的库文件路径。编译完成以后打开 config.mak 文件，找到“INSTALLSTRIP &#x3D; -s”这一行，取消掉后面的“-s”，否则“make install”命令会失败！结果如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182313324.png" srcset="/img/loading.gif" lazyload alt="image-20200907182313324"></p>
<p>修改完成以后使用“make install”安装，安装完成以后 mplayer 目录内容如图 所示</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182326254.png" srcset="/img/loading.gif" lazyload alt="image-20200907182326254"></p>
<p>图 中的 bin 目录下有一个叫做“mplayer”的可执行文件，这就是我们需要的 mplayer播放器！将其拷贝到开发板根文件系统的&#x2F;bin 目录下，命令为：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">sudo cp bin<span class="hljs-regexp">/mplayer /</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/nfs/</span>rootfs<span class="hljs-regexp">/bin/</span> -f</code></pre></div>

<p>至此，mplayer 移植就已经完成了，接下来就是使用 mplayer 播放音视频。</p>
<h3 id="2-mplayer-使用"><a href="#2-mplayer-使用" class="headerlink" title="2| mplayer  使用"></a>2| mplayer  使用</h3><h4 id="1-、mplayer-播放音频"><a href="#1-、mplayer-播放音频" class="headerlink" title="1 、mplayer  播放音频"></a>1 、mplayer  播放音频</h4><p>输入“mplayer -h”即可查看帮助信息。mplayer 播放歌曲很简单，不限歌曲格式，“mplayer+歌曲名”即可，比如：</p>
<div class="hljs code-wrapper"><pre><code class="hljs cmake">mplayer <span class="hljs-keyword">test</span>.flac</code></pre></div>

<p>播放过程如图 所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182411920.png" srcset="/img/loading.gif" lazyload alt="image-20200907182411920"></p>
<p>播放过程中我们可以通过键盘控制播放器，常用的控制方法如下：<br>9 ：增加音量。<br>0：减小音量。<br>左键：倒退 10 秒<br>右键：快进 10 秒<br>上键：倒退 1 分钟<br>下键：快进 1 分钟<br>空格：暂停和播放<br>如果 mplayer 音量已经调到最大了，但是耳机音量依旧很小的话请使用 amixer 调大声卡最<br>大音量。</p>
<h4 id="2-、视频播放测试"><a href="#2-、视频播放测试" class="headerlink" title="2 、视频播放测试"></a>2 、视频播放测试</h4><p>视频播放的方法和音频一样， “mplayer+视频名”即可，但是这样的话视频不是居中播放的，我们可以加入“-fs”参数让视频居中播放。注意！由于 I.MX6ULL 性能比较差，而且没有硬件视频解码，因此 6ULL 不能播放高分辨率、高码率和高帧率的视频，视频分辨率最好在 640*480 左右！输入如下命令播放视频：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">mplayer test.avi -fs <span class="hljs-regexp">//</span>居中播放视频</code></pre></div>

<p>如果你所使用的芯片性能比较差的话 mplayer 会给你提示，如图  所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182452001.png" srcset="/img/loading.gif" lazyload alt="image-20200907182452001"></p>
<p>关于 mplayer 的更多使用请自行上网搜索，这里就不再赘述了。</p>
<h2 id="七、alsamixer-简介"><a href="#七、alsamixer-简介" class="headerlink" title="七、alsamixer  简介"></a>七、alsamixer  简介</h2><p>前面在移植 alsa-utils 的时候说过 alsamixer是一个图形化的声卡设置工具，但是由于 ncurses库依赖的原因笔者并没有在 alsa-utils 移植的时候编译出 alsamixer，不得已放弃编译 alsa-utils 中的 alsamixer。但是笔者用了一个投机取巧的方法，那就是使用 buildroot 编译出 alsamixer，然后将其拷贝到开发板根文件系统中。因此，如果还没了解过buildroot的朋友就不需要看本小节了，直接使用 amixer 来配置声卡。从这里也可以看出 buildroot 的强大，再一次建议大家做产品的时候使用 buidroot 或 yocto 来构建根文件系统！alsamixer 是基于图形化的，直接输入“alsamixer”命令即可打开声卡配置界面，如图所示：</p>
<p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182600316.png" srcset="/img/loading.gif" lazyload alt="image-20200907182600316"></p>
<p>F1  键：查看帮助信息。<br>F2  键：查看系统信息。<br>F3  键：播放设置。<br>F4  键：录音设置。<br>F6  键：选择声卡，多声卡情况下。<br>Item ：设置项全名。</p>
<p>图  最下面一行就是具体的设置项，比如“Headphone”、“Headphone Playback ZC”等等，通过键盘上左右键选择设置项。按下上下键来调整大小，比如设置耳机音量大小等。有些项目会显示“MM”，表示静音，按下“M”键修改为“OO”状态打开，“M”键用于修改打开或关闭某些项目。关于 alsamixer 的介绍就到这里，用起来还是很简单的。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">21| Linux 电容触摸实验</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">23| Linux USB驱动实验</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
