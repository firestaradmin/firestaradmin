

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="字符设备驱动开发入门字符设备驱动是Linux 驱动开发中最基础的开始，本章会以一个虚拟的设备为例，讲解如何进行字符设备驱动开发，以及如何编写测试 APP 来测试驱动工作是否正常，为以后的学习打下坚实的基础。 一、字符设备驱动简介字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SP">
<meta property="og:type" content="article">
<meta property="og:title" content="1| 字符设备驱动开发入门">
<meta property="og:url" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="字符设备驱动开发入门字符设备驱动是Linux 驱动开发中最基础的开始，本章会以一个虚拟的设备为例，讲解如何进行字符设备驱动开发，以及如何编写测试 APP 来测试驱动工作是否正常，为以后的学习打下坚实的基础。 一、字符设备驱动简介字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820131839783.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820132050798.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820134453560.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820141213153.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820141458574.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820145926694.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820150054066.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820151835351.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152045899.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152529602.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152622765.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152702937.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152749421.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152847237.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153138996.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153332666.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153515594.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153622245.png">
<meta property="article:published_time" content="2020-09-09T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-09T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820131839783.png">
  
  
  <title>1| 字符设备驱动开发入门 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//at.alicdn.com/t/font_3219187_rorsfvmryjl.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="1| 字符设备驱动开发入门">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-10 00:00" pubdate>
        2020年9月10日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      23k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      190 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">1| 字符设备驱动开发入门</h1>
            
            <div class="markdown-body">
              <h1 id="字符设备驱动开发入门"><a href="#字符设备驱动开发入门" class="headerlink" title="字符设备驱动开发入门"></a>字符设备驱动开发入门</h1><p>字符设备驱动是Linux 驱动开发中最基础的开始，本章会以一个虚拟的设备为例，讲解如何进行字符设备驱动开发，以及如何编写测试 APP 来测试驱动工作是否正常，为以后的学习打下坚实的基础。</p>
<h2 id="一、字符设备驱动简介"><a href="#一、字符设备驱动简介" class="headerlink" title="一、字符设备驱动简介"></a>一、字符设备驱动简介</h2><p>字符设备是 Linux 驱动中最基本的一类设备驱动，<strong>字符设备就是一个一个字节，按照字节流进行读写操作的设备</strong>，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。</p>
<p>在详细的学习字符设备驱动架构之前，我们先来简单的了解一下 Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用如图  所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820131839783.png" srcset="/img/loading.gif" lazyload alt="image-20200820131839783"></p>
<p>在 Linux 中一切皆为文件，驱动加载成功以后会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。</p>
<p>比如现在有个叫做**&#x2F;dev&#x2F;led** 的驱动文件，此文件是 led 灯的驱动文件。应用程序使用 open 函数来打开文件&#x2F;dev&#x2F;led，使用完成以后使用 close 函数关闭&#x2F;dev&#x2F;led 这个文件。open和 close 就是打开和关闭 led 驱动的函数，如果要点亮或关闭 led，那么就使用 write 函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开 led 的控制参数。如果要获取led 灯的状态，就用 read 函数从驱动中读取相应的状态。</p>
<p><strong>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间</strong>。当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开&#x2F;dev&#x2F;led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。</p>
<p>open、close、write 和 read 等这些函数是由 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分。当我们调用 open 函数的时候流程如图  所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820132050798.png" srcset="/img/loading.gif" lazyload alt="image-20200820132050798"></p>
<p>其中关于 C 库以及如何通过系统调用“陷入”到内核空间这个我们不用去管，我们重点关注的是应用程序和具体的驱动，应用程序使用到的函数在具体驱动程序中都有与之对应的函数，比如应用程序中调用了 open 这个函数，那么在驱动程序中也得有一个名为 open 的函数。每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 include&#x2F;linux&#x2F;fs.h 中有个叫做 file_operations 的结构体，此结构体就是 Linux 内核驱动操作函数集合，内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1588</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span>
<span class="hljs-number">1589</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span>
<span class="hljs-number">1590</span> <span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);
<span class="hljs-number">1591</span> <span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);
<span class="hljs-number">1592</span> <span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);
<span class="hljs-number">1593</span> <span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);
<span class="hljs-number">1594</span> <span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);
<span class="hljs-number">1595</span> <span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);
<span class="hljs-number">1596</span> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;
<span class="hljs-number">1597</span> <span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);
<span class="hljs-number">1598</span> <span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);
<span class="hljs-number">1599</span> <span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);
<span class="hljs-number">1600</span> <span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);
<span class="hljs-number">1601</span> <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);
<span class="hljs-number">1602</span> <span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);
<span class="hljs-number">1603</span> <span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);
<span class="hljs-number">1604</span> <span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);
<span class="hljs-number">1605</span> <span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);
<span class="hljs-number">1606</span> <span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);
<span class="hljs-number">1607</span> <span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);
<span class="hljs-number">1608</span> <span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, 			<span class="hljs-type">int</span>);
<span class="hljs-number">1609</span> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;
<span class="hljs-number">1610</span> <span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);
<span class="hljs-number">1611</span> <span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);
<span class="hljs-number">1612</span> <span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, 		<span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);
<span class="hljs-number">1613</span> <span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, 			<span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);
<span class="hljs-number">1614</span> <span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);
<span class="hljs-number">1615</span> <span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset,
<span class="hljs-number">1616</span> <span class="hljs-type">loff_t</span> len);
<span class="hljs-number">1617</span> <span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);
<span class="hljs-number">1618</span> <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span>
<span class="hljs-number">1619</span> <span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);
<span class="hljs-number">1620</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-number">1621</span> &#125;;</code></pre></div>

<p>简单介绍一下 file_operation 结构体中比较重要的、常用的函数：<br>第 <strong>1589</strong> 行，owner 拥有该结构体的模块的指针，一般设置为 THIS_MODULE。<br>第 <strong>1590</strong> 行，llseek 函数用于修改文件当前的读写位置。<br>第 <strong>1591</strong> 行，read 函数用于读取设备文件。<br>第 <strong>1592</strong> 行，write 函数用于向设备文件写入(发送)数据。<br>第 <strong>1596</strong> 行，poll 是个轮询函数，用于查询设备是否可以进行非阻塞的读写。<br>第 <strong>1597</strong> 行，unlocked_ioctl 函数提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。<br>第 <strong>1598</strong> 行，compat_ioctl 函数与 unlocked_ioctl 函数功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是unlocked_ioctl。<br>第 <strong>1599</strong> 行，mmap 函数用于将将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。<br>第 <strong>1601</strong> 行，open 函数用于打开设备文件。<br>第 <strong>1603</strong> 行，release 函数用于释放(关闭)设备文件，与应用程序中的 close 函数对应。<br>第 <strong>1604</strong> 行，fasync 函数用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。<br>第 <strong>1605</strong> 行，aio_fsync 函数与 fasync 函数的功能类似，只是 aio_fsync 是异步刷新待处理的数据。</p>
<p>在字符设备驱动开发中最常用的就是上面这些函数，关于其他的函数大家可以查阅相关文档。我们在字符设备驱动开发中最主要的工作就是实现上面这些函数，不一定全部都要实现，但是像 open、release、write、read 等都是需要实现的，当然了，具体需要实现哪些函数还是要看具体的驱动要求。</p>
<h2 id="二、字符设备驱动开发步骤"><a href="#二、字符设备驱动开发步骤" class="headerlink" title="二、字符设备驱动开发步骤"></a>二、字符设备驱动开发步骤</h2><p>我们简单的介绍了一下字符设备驱动，那么字符设备驱动开发都有哪些步骤呢？我们在学习裸机或者 STM32 的时候关于驱动的开发就是初始化相应的外设寄存器，在 Linux 驱动开发中肯定也是要初始化相应的外设寄存器，这个是毫无疑问的。只是<strong>在 Linux 驱动开发中我们需要按照其规定的框架来编写驱动</strong>，所以说<strong>学 Linux 驱动开发重点是学习其驱动框架</strong>。</p>
<h3 id="1、-驱动-模块的加载和卸载"><a href="#1、-驱动-模块的加载和卸载" class="headerlink" title="1、 驱动 模块的加载和卸载"></a>1、 驱动 模块的加载和卸载</h3><p>Linux 驱动有两种运行方式，第一种就是将驱动编译进 Linux 内核中，这样当 Linux 内核启动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在Linux 内核启动以后使用“insmod”命令加载驱动模块。</p>
<p>在调试驱动的时候一般都选择将其编译为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。而且在调试的时候只需要加载或者卸载驱动模块即可，不需要重启整个系统。总之，将驱动编译为模块最大的好处就是方便开发，当驱动开发完成，确定没有问题以后就可以将驱动编译进Linux 内核中，当然也可以不编译进 Linux 内核中，具体看自己的需求。</p>
<p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和卸载注册函数如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">module_init(xxx_init); <span class="hljs-comment">//注册模块加载函数</span>
module_exit(xxx_exit); <span class="hljs-comment">//注册模块卸载函数</span></code></pre></div>

<p>module_init 函数用来向 Linux 内核注册一个模块加载函数，参数 xxx_init 就是需要注册的具体函数，<strong>当使用“insmod”命令加载驱动的时候，xxx_init 这个函数就会被调用</strong>。module_exit()函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，<strong>当使用“rmmod”命令卸载具体驱动的时候 xxx_exit 函数就会被调用</strong>。</p>
<p>字符设备驱动模块加载和卸载模板如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 驱动入口函数 */</span>
<span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
3 &#123;
<span class="hljs-number">4</span> 	<span class="hljs-comment">/* 入口函数具体内容 */</span>
<span class="hljs-number">5</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">6</span> &#125;
<span class="hljs-number">7</span>
<span class="hljs-number">8</span> <span class="hljs-comment">/* 驱动出口函数 */</span>
<span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
10 &#123;
<span class="hljs-number">11</span> 	<span class="hljs-comment">/* 出口函数具体内容 */</span>
<span class="hljs-number">12</span> &#125;
<span class="hljs-number">13</span>
<span class="hljs-number">14</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span>
<span class="hljs-number">15</span> module_init(xxx_init);
<span class="hljs-number">16</span> module_exit(xxx_exit);</code></pre></div>

<p><strong>第 2 行</strong>，定义了个名为 xxx_init 的驱动入口函数，并且使用了“__init”来修饰。<br><strong>第 9 行</strong>，定义了个名为 xxx_exit 的驱动出口函数，并且使用了“__exit”来修饰。<br><strong>第 15 行</strong>，调用函数 module_init 来声明 xxx_init 为驱动入口函数，当加载驱动的时候 xxx_init函数就会被调用。<br><strong>第16行</strong>，调用函数module_exit来声明xxx_exit为驱动出口函数，当卸载驱动的时候xxx_exit函数就会被调用。</p>
<hr>
<p>驱动编译完成以后扩展名为.ko，有两种命令可以加载驱动模块：<strong>insmod</strong>和<strong>modprobe</strong>，insmod是最简单的模块加载命令，此命令用于加载指定的.ko 模块，比如加载 drv.ko 这个驱动模块，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">insmod drv.ko</code></pre></div>

<p><strong>insmod 命令不能解决模块的依赖关系，比如 drv.ko 依赖 first.ko 这个模块，就必须先使用insmod 命令加载 first.ko 这个模块，然后再加载 drv.ko 这个模块。</strong>但是 modprobe 就不会存在这个问题，modprobe 会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中，因此modprobe 命令相比 insmod 要智能一些。</p>
<hr>
<p><strong>modprobe</strong> 命令主要智能在提供了模块的依赖性分析、错误检查、错误报告等功能，推荐使用modprobe 命令来加载驱动。modprobe 命令默认会去<code>lib/modules/&lt;kernel-version&gt;</code>目录中查找模块，比如本书使用的 Linux kernel 的版本号为 4.1.15，因此 modprobe 命令默认会到&#x2F;lib&#x2F;modules&#x2F;4.1.15 这个目录中查找相应的驱动模块，一般自己制作的根文件系统中是不会有这个目录的，所以需要自己手动创建。</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">modprobe</span> drv.ko</code></pre></div>



<hr>
<p>驱动模块的卸载使用命令“<strong>rmmod</strong>”即可，比如要卸载 drv.ko，使用如下命令即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">rmmod drv.ko</code></pre></div>

<p>也可以使用“modprobe -r”命令卸载驱动，比如要卸载 drv.ko，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">modprobe -r drv.ko</code></pre></div>

<p>使用 modprobe 命令可以卸载掉驱动模块所依赖的其他模块，前提是这些依赖模块已经没有被其他模块所使用，否则就不能使用 modprobe 来卸载驱动模块。<strong>所以对于模块的卸载，还是推荐使用 rmmod 命令。</strong></p>
<h3 id="2、字符设备注册与注销"><a href="#2、字符设备注册与注销" class="headerlink" title="2、字符设备注册与注销"></a>2、字符设备注册与注销</h3><p><strong>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备</strong>。字符设备的注册和注销函数原型如下所示:</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, </span>
<span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div>

<p><strong>register_chrdev 函数用于注册字符设备</strong>，此函数一共有三个参数，这三个参数的含义如下：</p>
<p><strong>major</strong> ：主设备号，Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分，关于设备号后面会详细讲解。<br><strong>name</strong>：设备名字，指向一串字符串。<br><strong>fops</strong> ：结构体 file_operations 类型指针，指向设备的操作函数集合变量。</p>
<p><strong>unregister_chrdev 函数用户注销字符设备</strong>，此函数有两个参数，这两个参数含义如下：</p>
<p><strong>major</strong> ：要注销的设备对应的主设备号。<br><strong>name</strong> ：要注销的设备对应的设备名。</p>
<p>一般字符设备的注册在驱动模块的入口函数 xxx_init 中进行，字符设备的注销在驱动模块的出口函数 xxx_exit 中进行。字符设备的注册和注销，内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span>;</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span> <span class="hljs-comment">/* 驱动入口函数 */</span>
<span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
5 &#123;
<span class="hljs-number">6</span> 	<span class="hljs-comment">/* 入口函数具体内容 */</span>
<span class="hljs-number">7</span> 	<span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;
<span class="hljs-number">8</span>
<span class="hljs-number">9</span> 	<span class="hljs-comment">/* 注册字符设备驱动 */</span>
<span class="hljs-number">10</span> 	retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);
<span class="hljs-number">11</span> 	<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;
<span class="hljs-number">12</span> 	<span class="hljs-comment">/*  字符设备注册失败, 自行处理 */</span>
<span class="hljs-number">13</span> 	&#125;
<span class="hljs-number">14</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">15</span> &#125;
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">/* 驱动出口函数 */</span>
<span class="hljs-number">18</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
19 &#123;
<span class="hljs-number">20</span> 	<span class="hljs-comment">/* 注销字符设备驱动 */</span>
<span class="hljs-number">21</span> 	unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);
<span class="hljs-number">22</span> &#125;
<span class="hljs-number">23</span>
<span class="hljs-number">24</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span>
<span class="hljs-number">25</span> module_init(xxx_init);
<span class="hljs-number">26</span> module_exit(xxx_exit);</code></pre></div>

<p><strong>第 1 行</strong>，定义了一个 file_operations 结构体变量 test_fops，test_fops 就是设备的操作函数集合，只是此时我们还没有初始化 test_fops 中的 open、release 等这些成员变量，所以这个操作函数集合还是空的。<br><strong>第 10 行</strong>，调用函数 register_chrdev 注册字符设备，主设备号为 200，设备名字为“chrtest”，设备操作函数集合就是第 1 行定义的 test_fops。</p>
<p><strong>第 21 行</strong>，调用函数 unregister_chrdev 注销主设备号为 200 的这个设备。</p>
<p>要注意的一点就是，选择没有被使用的主设备号，输入命令“cat &#x2F;proc&#x2F;devices”可以查看当前已经被使用掉的设备号，如图 所示(限于篇幅原因，只展示一部分)：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820134453560.png" srcset="/img/loading.gif" lazyload alt="image-20200820134453560"></p>
<p>在图中可以列出当前系统中所有的字符设备和块设备，其中第 1 列就是设备对应的主设备号。200 这个主设备号在我的开发板中并没有被使用，所以我这里就用了 200 这个主设备号。</p>
<h3 id="3、实现设备的具体操作函数"><a href="#3、实现设备的具体操作函数" class="headerlink" title="3、实现设备的具体操作函数"></a>3、实现设备的具体操作函数</h3><p><strong>file_operations 结构体就是设备的具体操作函数</strong>，在前面示例代码中我们定义了file_operations结构体类型的变量test_fops，但是还没对其进行初始化，也就是初始化其中的open、release、read 和 write 等具体的设备操作函数。</p>
<p>本节我们就完成变量 test_fops 的初始化，设置好针对 chrtest 设备的操作函数。在初始化 test_fops 之前我们要分析一下需求，也就是要对chrtest 这个设备进行哪些操作，只有确定了需求以后才知道我们应该实现哪些操作函数。</p>
<p>假设对 chrtest 这个设备有如下两个要求：</p>
<ul>
<li><p>1 、能够对 chrtest  进行打开和关闭操作</p>
<p>设备打开和关闭是最基本的要求，几乎所有的设备都得提供打开和关闭的功能。因此我们需要实现 file_operations 中的 open 和 release 这两个函数。</p>
</li>
<li><p>2 、对 chrtest  进行读写操作</p>
<p>假设 chrtest 这个设备控制着一段缓冲区(内存)，应用程序需要通过 read 和 write 这两个函数对 chrtest 的缓冲区进行读写操作。所以需要实现 file_operations 中的 read 和 write 这两个函数。</p>
</li>
</ul>
<p>需求很清晰了，修改前面的示例代码，在其中加入 test_fops 这个结构体变量的初始化操作，完成以后的内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*  打开设备 */</span>
<span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
3 &#123;
<span class="hljs-number">4</span> 		<span class="hljs-comment">/*  用户实现具体功能 */</span>
<span class="hljs-number">5</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">6</span> &#125;
<span class="hljs-number">7</span>
<span class="hljs-number">8</span> <span class="hljs-comment">/*  从设备读取 */</span>
<span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrtest_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, 									<span class="hljs-type">loff_t</span> *offt)</span>
10 &#123;
<span class="hljs-number">11</span> 		<span class="hljs-comment">/*  用户实现具体功能 */</span>
<span class="hljs-number">12</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">13</span> &#125;
<span class="hljs-number">14</span>
<span class="hljs-number">15</span> <span class="hljs-comment">/*  向设备写数据 */</span>
<span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrtest_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, </span>
<span class="hljs-params">                                <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
17 &#123;
<span class="hljs-number">18</span> 		<span class="hljs-comment">/*  用户实现具体功能 */</span>
<span class="hljs-number">19</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">20</span> &#125;
<span class="hljs-number">21</span>
<span class="hljs-number">22</span> <span class="hljs-comment">/*  关闭/ 释放设备 */</span>
<span class="hljs-number">23</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
24 &#123;
<span class="hljs-number">25</span> 		<span class="hljs-comment">/*  用户实现具体功能 */</span>
<span class="hljs-number">26</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">27</span> &#125;
<span class="hljs-number">28</span>
<span class="hljs-number">29</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;
<span class="hljs-number">30</span> 		.owner = THIS_MODULE,
<span class="hljs-number">31</span> 		.open = chrtest_open,
<span class="hljs-number">32</span> 		.read = chrtest_read,
<span class="hljs-number">33</span> 		.write = chrtest_write,
<span class="hljs-number">34</span> 		.release = chrtest_release,
<span class="hljs-number">35</span> &#125;;
<span class="hljs-number">36</span>
<span class="hljs-number">37</span> <span class="hljs-comment">/* 驱动入口函数 */</span>
<span class="hljs-number">38</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
39 &#123;
<span class="hljs-number">40</span> 		<span class="hljs-comment">/* 入口函数具体内容 */</span>
<span class="hljs-number">41</span> 		<span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;
<span class="hljs-number">42</span>
<span class="hljs-number">43</span> 		<span class="hljs-comment">/* 注册字符设备驱动 */</span>
<span class="hljs-number">44</span> 		retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);
<span class="hljs-number">45</span> 		<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;
<span class="hljs-number">46</span> 			<span class="hljs-comment">/* 字符设备注册失败,自行处理 */</span>
<span class="hljs-number">47</span> 		&#125;
<span class="hljs-number">48</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">49</span> &#125;
<span class="hljs-number">50</span>
<span class="hljs-number">51</span> <span class="hljs-comment">/* 驱动出口函数 */</span>
<span class="hljs-number">52</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
53 &#123;
<span class="hljs-number">54</span> 		<span class="hljs-comment">/* 注销字符设备驱动 */</span>
<span class="hljs-number">55</span> 		unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);
<span class="hljs-number">56</span> &#125;
<span class="hljs-number">57</span>
<span class="hljs-number">58</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span>
<span class="hljs-number">59</span> module_init(xxx_init);
<span class="hljs-number">60</span> module_exit(xxx_exit);</code></pre></div>

<p>在此示例代码中我们一开始编写了四个函数：chrtest_open、chrtest_read、chrtest_write和 chrtest_release。这四个函数就是 chrtest 设备的 open、read、write 和 release 操作函数。第 29行~35 行初始化 test_fops 的 open、read、write 和 release 这四个成员变量。</p>
<h3 id="4、添加LICENSE-和-作者信息"><a href="#4、添加LICENSE-和-作者信息" class="headerlink" title="4、添加LICENSE 和 作者信息"></a>4、添加LICENSE 和 作者信息</h3><p>最后我们需要在驱动中加入 LICENSE 信息和作者信息，其中 LICENSE 是必须添加的，否则的话编译的时候会报错，作者信息可以添加也可以不添加。LICENSE 和作者信息的添加使用如下两个函数：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">MODULE_LICENSE() <span class="hljs-comment">//添加模块 LICENSE 信息</span>
MODULE_AUTHOR() <span class="hljs-comment">//添加模块作者信息</span></code></pre></div>

<p>最后给示例代码加入 LICENSE 和作者信息，完成以后的内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 打开设备 */</span>
<span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
3 &#123;
<span class="hljs-number">4</span> 		<span class="hljs-comment">/* 用户实现具体功能 */</span>
<span class="hljs-number">5</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">6</span> &#125;
......
<span class="hljs-number">57</span>
<span class="hljs-number">58</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span>
<span class="hljs-number">59</span> module_init(xxx_init);
<span class="hljs-number">60</span> module_exit(xxx_exit);
<span class="hljs-number">61</span>
<span class="hljs-number">62</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-number">63</span> MODULE_AUTHOR(<span class="hljs-string">&quot;firestaradmin&quot;</span>);</code></pre></div>

<p>第 62 行，LICENSE 采用 GPL 协议。<br>第 63 行，添加作者名字。<br>至此，字符设备驱动开发的完整步骤就讲解完了，而且也编写好了一个完整的字符设备驱动模板，以后字符设备驱动开发都可以在此模板上进行。</p>
<h2 id="三、Linux-设备号"><a href="#三、Linux-设备号" class="headerlink" title="三、Linux 设备号"></a>三、Linux 设备号</h2><h3 id="1、设备号的组成"><a href="#1、设备号的组成" class="headerlink" title="1、设备号的组成"></a>1、设备号的组成</h3><p>为了方便管理，Linux 中每个设备都有一个设备号，<strong>设备号由主设备号和次设备号两部分组成</strong>，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。</p>
<p>Linux 提供了一个名为 <strong>dev_t</strong> 的数据类型表示设备号，dev_t 定义在文件 include&#x2F;linux&#x2F;types.h 里面，定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">12</span> <span class="hljs-keyword">typedef</span> __u32 <span class="hljs-type">__kernel_dev_t</span>;
......
<span class="hljs-number">15</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">__kernel_dev_t</span> <span class="hljs-type">dev_t</span>;</code></pre></div>

<p>可以看出 dev_t 是__u32 类型的，而__u32 定义在文件 include&#x2F;uapi&#x2F;asm-generic&#x2F;int-ll64.h 里<br>面，定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">26</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __u32;</code></pre></div>

<p>综上所述，<strong>dev_t 其实就是 unsigned int 类型</strong>，是一个 32 位的数据类型。这 32 位的数据构成了主设备号和次设备号两部分，<strong>其中高 12 位为主设备号，低 20 位为次设备号</strong>。因此 Linux系统中主设备号范围为 0~4095，所以大家在选择主设备号的时候一定不要超过这个范围。</p>
<hr>
<p>在文件<code>include/linux/kdev_t.h</code> 中提供了几个关于设备号的操作函数(本质是宏)，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORBITS 20</span>
<span class="hljs-number">7</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORMASK ((1U &lt;&lt; MINORBITS) - 1)</span>
<span class="hljs-number">8</span>
<span class="hljs-number">9</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span>
<span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))</span>
<span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi))</span></code></pre></div>

<p>第 6 行，宏 <strong>MINORBITS</strong> 表示次设备号位数，一共是 20 位。<br>第 7 行，宏 <strong>MINORMASK</strong> 表示次设备号掩码。<br>第 9 行，宏 <strong>MAJOR</strong> 用于从 dev_t 中获取主设备号，将 dev_t 右移 20 位即可。<br>第 10 行，宏 <strong>MINOR</strong> 用于从 dev_t 中获取次设备号，取 dev_t 的低 20 位的值即可。<br>第 11 行，宏 <strong>MKDEV</strong> 用于将给定的主设备号和次设备号的值组合成 dev_t 类型的设备号。</p>
<h3 id="2、设备号的分配"><a href="#2、设备号的分配" class="headerlink" title="2、设备号的分配"></a>2、设备号的分配</h3><h4 id="1-、静态分配设备号"><a href="#1-、静态分配设备号" class="headerlink" title="1 、静态分配设备号"></a>1 、静态分配设备号</h4><p>本小节讲的设备号分配主要是主设备号的分配。前面讲解字符设备驱动的时候说过了，注册字符设备的时候需要给设备指定一个设备号，这个设备号可以是驱动开发者静态的指定一个设备号，比如选择 200 这个主设备号。有一些常用的设备号已经被 Linux 内核开发者给分配掉了，具体分配的内容可以查看文档 Documentation&#x2F;devices.txt。</p>
<p>并不是说内核开发者已经分配掉的主设备号我们就不能用了，具体能不能用还得看我们的硬件平台运行过程中有没有使用这个主设备号，使用“cat &#x2F;proc&#x2F;devices”命令即可查看当前系统中所有已经使用了的设备号。</p>
<h4 id="2-、动态分配设备号"><a href="#2-、动态分配设备号" class="headerlink" title="2 、动态分配设备号"></a>2 、动态分配设备号</h4><p>静态分配设备号需要我们检查当前系统中所有被使用了的设备号，然后挑选一个没有使用的。而且静态分配设备号很容易带来冲突问题，<strong>Linux 社区推荐使用动态分配设备号</strong>，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。卸载驱动的时候释放掉这个设备号即可，设备号的申请函数如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, </span>
<span class="hljs-params">                        <span class="hljs-type">unsigned</span> baseminor, </span>
<span class="hljs-params">                        <span class="hljs-type">unsigned</span> count, </span>
<span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div>

<p>函数 <strong>alloc_chrdev_region</strong> 用于申请设备号，此函数有 4 个参数：</p>
<p><strong>dev</strong>：保存申请到的设备号。<br><strong>baseminor</strong> ：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般baseminor 为 0，也就是说次设备号从 0 开始。<br><strong>count</strong> ：要申请的设备号数量。<br><strong>name</strong>：设备名字。</p>
<p>注销字符设备之后要释放掉设备号，设备号释放函数如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span></code></pre></div>

<p>此函数有两个参数：<br><strong>from</strong>：要释放的设备号。<br><strong>count</strong> ：表示从 from 开始，要释放的设备号数量。</p>
<h2 id="四、chrdevbase字符设备驱动开发实验"><a href="#四、chrdevbase字符设备驱动开发实验" class="headerlink" title="四、chrdevbase字符设备驱动开发实验"></a>四、chrdevbase字符设备驱动开发实验</h2><p>字符设备驱动开发的基本步骤我们已经了解了，本节我们就以 chrdevbase 这个虚拟设备为例，完整的编写一个字符设备驱动模块。</p>
<p>chrdevbase 不是实际存在的一个设备，是笔者为了方便讲解字符设备的开发而引入的一个虚拟设备。chrdevbase 设备有两个缓冲区，一个为读缓冲区，一个为写缓冲区，这两个缓冲区的大小都为 100 字节。在应用程序中可以向 chrdevbase 设备的写缓冲区中写入数据，从读缓冲区中读取数据。chrdevbase 这个虚拟设备的功能很简单，但是它包含了字符设备的最基本功能。</p>
<h3 id="1、实验程序编写"><a href="#1、实验程序编写" class="headerlink" title="1、实验程序编写"></a>1、实验程序编写</h3><p>应用程序调用 open 函数打开 chrdevbase 这个设备，打开以后可以使用 write 函数向chrdevbase 的写缓冲区 writebuf 中写入数据(不超过 100 个字节)，也可以使用 read 函数读取读缓冲区 readbuf 中的数据操作，操作完成以后应用程序使用 close 函数关闭 chrdevbase 设备。</p>
<h4 id="1、建立VSCode工程"><a href="#1、建立VSCode工程" class="headerlink" title="1、建立VSCode工程"></a>1、建立VSCode工程</h4><p>在 Ubuntu 中创建一个目录用来存放 Linux 驱动程序，比如我创建了一个名为 linux_drivers的目录来存放所有的 Linux 驱动。在 linux_drivers 目录下新建一个名为 1_chrdevbase 的子目录来存放本实验所有文件.</p>
<p>之后在 1_chrdevbase 目录中新建 VSCode 工程，并且新建 chrdevbase.c 文件、chrdevbaseAPP.c、Makefile文件，完成以后1_chrdevbase 目录中的文件如图所示</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820141213153.png" srcset="/img/loading.gif" lazyload alt="image-20200820141213153"></p>
<h4 id="2、添加头文件路径"><a href="#2、添加头文件路径" class="headerlink" title="2、添加头文件路径"></a>2、添加头文件路径</h4><p>因为是编写Linux 驱动，因此会用到Linux 源码中的函数。我们需要在VSCode中添加Linux源码中的头文件路径。</p>
<p>打开 VSCode，按下“Crtl+Shift+P”打开 VSCode 的控制台，然后输入</p>
<p><code>C/C++: Edit configurations(JSON) </code></p>
<p>打开 C&#x2F;C++编辑配置文件，如图所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820141458574.png" srcset="/img/loading.gif" lazyload alt="image-20200820141458574"></p>
<p>打开以后会自动在.vscode 目录下生成一个名为 <strong>c_cpp_properties.json</strong> 的文件，此文件默认内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>
            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c11&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++17&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc-x64&quot;</span>
        <span class="hljs-punctuation">&#125;</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>

<p><strong>includePath</strong> 表示头文件路径，需要将 Linux 源码里面的头文件路径添加进来，也就是我们前面移植的 Linux 源码中的头文件路径。</p>
<p>添加头文件路径以后的 c_cpp_properties.json的文件内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">&quot;/home/firestaradmin/linux/IMX6U/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg/include&quot;</span><span class="hljs-punctuation">,</span> 
                <span class="hljs-string">&quot;/home/firestaradmin/linux/IMX6U/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg/arch/arm/include&quot;</span><span class="hljs-punctuation">,</span> 
                <span class="hljs-string">&quot;/home/firestaradmin/linux/IMX6U/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg/arch/arm/include/generated/&quot;</span>
            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c11&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++17&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc-x64&quot;</span>
        <span class="hljs-punctuation">&#125;</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>

<p><strong>第7~9行</strong>就是添加好的Linux头文件路径。分别是开发板所使用的Linux源码下的include、arch&#x2F;arm&#x2F;include 和 arch&#x2F;arm&#x2F;include&#x2F;generated 这三个目录的路径，注意，这里使用了绝对路径。</p>
<h4 id="3、编写实验程序"><a href="#3、编写实验程序" class="headerlink" title="3、编写实验程序"></a>3、编写实验程序</h4><p>工程建立好以后就可以开始编写驱动程序了，打开chrdevbase.c，然后在里面输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> CHRDEVBASE_MAJOR 200 <span class="hljs-comment">//主设备号</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CHRDEVBASE_NAME <span class="hljs-string">&quot;chrdevbase&quot;</span></span>

<span class="hljs-type">char</span> readbuf[<span class="hljs-number">100</span>];
<span class="hljs-type">char</span> writebuf[<span class="hljs-number">100</span>];
<span class="hljs-type">char</span> kernel_data[] = &#123;<span class="hljs-string">&quot;kernel data&quot;</span>&#125;;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 打开设备</span>
<span class="hljs-comment"> * @param - inode 	: 传递给驱动的inode</span>
<span class="hljs-comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span>
<span class="hljs-comment"> * 					  一般在open的时候将private_data指向设备结构体。</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrdevbase_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-comment">// printk(&quot;chrdevbase open!\r\n&quot;);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 从设备读取数据 </span>
<span class="hljs-comment"> * @param - filp 	: 要打开的设备文件(文件描述符)</span>
<span class="hljs-comment"> * @param - buf 	: 返回给用户空间的数据缓冲区</span>
<span class="hljs-comment"> * @param - cnt 	: 要读取的数据长度</span>
<span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span>
<span class="hljs-comment"> * @return 			: 读取的字节数，如果为负值，表示读取失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrdevbase_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	
	<span class="hljs-comment">/* 向用户空间发送数据 */</span>
	<span class="hljs-built_in">memcpy</span>(readbuf, kernel_data, <span class="hljs-keyword">sizeof</span>(kernel_data));
	ret = copy_to_user(buf, readbuf, cnt);
	<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;kernel senddata ok!\r\n&quot;</span>);
	&#125;<span class="hljs-keyword">else</span>&#123;
		printk(<span class="hljs-string">&quot;kernel senddata failed!\r\n&quot;</span>);
	&#125;
	
	<span class="hljs-comment">// printk(&quot;chrdevbase read!\r\n&quot;);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 向设备写数据 </span>
<span class="hljs-comment"> * @param - filp 	: 设备文件，表示打开的文件描述符</span>
<span class="hljs-comment"> * @param - buf 	: 要写给设备写入的数据</span>
<span class="hljs-comment"> * @param - cnt 	: 要写入的数据长度</span>
<span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span>
<span class="hljs-comment"> * @return 			: 写入的字节数，如果为负值，表示写入失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrdevbase_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-comment">/* 接收用户空间传递给内核的数据并且打印出来 */</span>
	ret = copy_from_user(writebuf, buf, cnt);
	<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;kernel recevdata:%s\r\n&quot;</span>, writebuf);
	&#125;<span class="hljs-keyword">else</span>&#123;
		printk(<span class="hljs-string">&quot;kernel recevdata failed!\r\n&quot;</span>);
	&#125;
	
	<span class="hljs-comment">// printk(&quot;chrdevbase write!\r\n&quot;);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 关闭/释放设备</span>
<span class="hljs-comment"> * @param - filp 	: 要关闭的设备文件(文件描述符)</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrdevbase_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-comment">// printk(&quot;chrdevbase release！\r\n&quot;);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">chrdevbase_fops</span> =</span> &#123;
    .owner = THIS_MODULE,
    .open = chrdevbase_open,
    .write = chrdevbase_write,
    .read = chrdevbase_read,
    .release = chrdevbase_release
&#125;;


<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">chrdevbase_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
    printk(<span class="hljs-string">&quot;chrdevbase_init\r\n&quot;</span>);

    <span class="hljs-comment">/* 注册字符设备 */</span>
    ret = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;chrdevbase_fops);
    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
        printk(<span class="hljs-string">&quot;chrdevbase_init failed！\r\n&quot;</span>);
    &#125;                        
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">chrdevbase_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
    printk(<span class="hljs-string">&quot;chrdevbase_exit\r\n&quot;</span>);
    <span class="hljs-comment">/* 卸载字符设备 */</span>
    unregister_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> *  模块入口与出口</span>
<span class="hljs-comment"> */</span>

module_init(chrdevbase_init);
module_exit(chrdevbase_exit);

MODULE_DESCRIPTION(<span class="hljs-string">&quot;Test for driver development&quot;</span>);
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>printk 相当于 printf 的孪生兄妹，printf运行在用户态，printk 运行在内核态。在内核中想要向控制台输出或显示一些内容，必须使用printk 这个函数。</p>
<hr>
<p><strong>chrdevbase_read</strong>通过函数 copy_to_user 将readbuf 中的数据复制到参数 buf 中。因为内核空间不能直接操作用户空间的内存，因此需要借助 copy_to_user 函数来完成内核空间的数据到用户空间的复制。copy_to_user 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title function_">copy_to_user</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *to, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *from, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span></code></pre></div>

<p><strong>参数 to</strong> 表示目的，<strong>参数 from</strong> 表示源，<strong>参数 n</strong> 表示要复制的数据长度。如果复制成功，返回值为 0，如果复制失败则返回负数。</p>
<hr>
<p><strong>chrdevbase_write</strong>通过函数 copy_from_user 将 buf 中的数据复制到写缓冲区 writebuf 中，因为用户空间内存不能直接访问内核空间的内存，所以需要借助函数 copy_from_user 将用户空间的数据复制到 writebuf 这个内核空间中。</p>
<hr>
<p><strong>chrdevbase_release</strong> 函数，应用程序调用 close 关闭设备文件的时候此函数会执行，一般会在此函数里面执行一些释放操作。如果在 open 函数中设置了 filp 的 private_data成员变量指向设备结构体，那么在 release 函数最终就要释放掉。</p>
<hr>
<h3 id="2、编写测试APP"><a href="#2、编写测试APP" class="headerlink" title="2、编写测试APP"></a>2、编写测试APP</h3><h4 id="1-、C-库文件操作基本函数"><a href="#1-、C-库文件操作基本函数" class="headerlink" title="1 、C  库文件操作基本函数"></a>1 、C  库文件操作基本函数</h4><p>编写测试 APP 就是编写 Linux 应用，需要用到 C 库里面和文件操作有关的一些函数，比如open、read、write 和 close 这四个函数。</p>
<hr>
<p><strong>①、open  函数</strong></p>
<p>open 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></code></pre></div>

<p>open 函数参数含义如下：</p>
<p><strong>pathname</strong>：要打开的设备或者文件名。<br><strong>flags</strong> ：文件打开模式，以下三种模式必选其一：</p>
<ul>
<li><p>O_RDONLY         只读模式<br>O_WRONLY         只写模式<br>O_RDWR             读写模式<br>因为我们要对 chrdevbase 这个设备进行读写操作，所以选择 O_RDWR。除了上述三种<br>模式以外还有其他的可选模式，通过逻辑或来选择多种模式：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820145926694.png" srcset="/img/loading.gif" lazyload alt="image-20200820145926694"></p>
</li>
</ul>
<p><strong>返回值</strong>：如果文件打开成功的话返回文件的文件描述符.</p>
<p>在 Ubuntu 中输入<code>man 2 open</code>即可查看 open 函数的详细内容，如图  所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820150054066.png" srcset="/img/loading.gif" lazyload alt="image-20200820150054066"></p>
<hr>
<p><strong>②、read  函数</strong></p>
<p>read 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></code></pre></div>

<p>read 函数参数含义如下：</p>
<p><strong>fd</strong>：要读取的文件描述符，读取文件之前要先用 open 函数打开文件，open 函数打开文件成功以后会得到文件描述符。<br><strong>buf</strong> ：数据读取到此 buf 中。<br><strong>count</strong> ：要读取的数据长度，也就是字节数。</p>
<p><strong>返回值</strong>：读取成功的话返回读取到的字节数；如果返回 0 表示读取到了文件末尾；如果返回负值，表示读取失败。</p>
<p>在 Ubuntu 中输入“man 2 read”命令即可查看 read 函数的详细内容。</p>
<hr>
<p><strong>③、write  函数</strong></p>
<p>write 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;</code></pre></div>

<p>write 函数参数含义如下：<br><strong>fd</strong>：要进行写操作的文件描述符，写文件之前要先用 open 函数打开文件，open 函数打开文<br>件成功以后会得到文件描述符。<br><strong>buf</strong> ：要写入的数据。<br><strong>count</strong> ：要写入的数据长度，也就是字节数。<br><strong>返回值</strong>：写入成功的话返回写入的字节数；如果返回 0 表示没有写入任何数据；如果返回负值，表示写入失败。</p>
<p>在 Ubuntu 中输入“man 2 write”命令即可查看 write 函数的详细内容。</p>
<hr>
<p><strong>④、close  函数</strong></p>
<p>close 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;</code></pre></div>

<p>close 函数参数含义如下：<br><strong>fd</strong>：要关闭的文件描述符。<br><strong>返回值</strong>：0 表示关闭成功，负值表示关闭失败。</p>
<p>在 Ubuntu 中输入“man 2 close”命令即可查看 close 函数的详细内容。</p>
<h4 id="2、编写测试-APP-程序"><a href="#2、编写测试-APP-程序" class="headerlink" title="2、编写测试 APP  程序"></a>2、编写测试 APP  程序</h4><p>驱动编写好以后是需要测试的，一般编写一个简单的测试 APP，测试 APP 运行在用户空间。测试 APP 很简单通过输入相应的指令来对 chrdevbase 设备执行读或者写操作。打开 chrdevbaseApp.c 文件，在此文件中输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> *  usage:</span>
<span class="hljs-comment"> *  ./chrdevbaseAPP     &lt;openFileName&gt;      &lt;1:read|2:write&gt;   </span>
<span class="hljs-comment"> *  ./chrdevbaseAPP     /dev/chrdevbase     1               //读</span>
<span class="hljs-comment"> *  ./chrdevbaseAPP     /dev/chrdevbase     2               //写</span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description : main 主程序</span>
<span class="hljs-comment"> * @param - argc : argv 数组元素个数</span>
<span class="hljs-comment"> * @param - argv : 具体参数</span>
<span class="hljs-comment"> * @return : 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
&#123;
    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;
    <span class="hljs-type">char</span> *filename;
    <span class="hljs-type">char</span> readbuf[<span class="hljs-number">100</span>], writebuf[<span class="hljs-number">100</span>];
    <span class="hljs-type">char</span> user_data[] = &#123;<span class="hljs-string">&quot;write test!&quot;</span>&#125;;
    filename = argv[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)
    &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:\r\n./chrdevbaseAPP     &lt;openFileName&gt;      &lt;1:read|2:write&gt;   \r\n&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MyAPP start!\r\n&quot;</span>);
    <span class="hljs-comment">/* 打开 */</span>
    fd =  open(filename, O_RDWR);
    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;

    <span class="hljs-keyword">if</span>(atoi(argv[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//read</span>
        <span class="hljs-comment">/* 读取 */</span>
        ret = read(fd, readbuf, <span class="hljs-number">50</span>);
        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read file %s failed!\r\n&quot;</span>, filename);
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read file %s success!\r\n&quot;</span>, filename);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read value:\r\n%s\r\n&quot;</span>, readbuf);
        &#125;
    &#125;
    <span class="hljs-keyword">if</span>(atoi(argv[<span class="hljs-number">2</span>]) == <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//write</span>
        <span class="hljs-comment">/* 写入 */</span>
        <span class="hljs-built_in">memcpy</span>(writebuf, user_data, <span class="hljs-keyword">sizeof</span>(user_data));
        ret = write(fd, writebuf, <span class="hljs-number">50</span>);
        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s failed!\r\n&quot;</span>, filename);
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s success!\r\n&quot;</span>, filename);
        &#125;
    &#125;
    <span class="hljs-comment">/* 关闭 */</span>
    ret = close(fd);
    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close file %s failed！\r\n&quot;</span>, filename);
    &#125;
&#125;</code></pre></div>

<p>程序开始判断运行测试 APP 的时候输入的参数是不是为 3 个，main 函数的 argc 参数表示参数数量，argv[]保存着具体的参数，如果参数不为 3 个的话就表示测试 APP 用法错误，然后给出提示。</p>
<p>比如，现在要从 chrdevbase 设备中读取数据，需要输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">/chrdevbaseAPP /dev/chrdevbase 1</code></pre></div>

<p>上述命令一共有三个参数“.&#x2F;chrdevbaseApp”、“&#x2F;dev&#x2F;chrdevbase”和“1”，这三个参数分别对应 argv[0]、argv[1]和 argv[2]。</p>
<h3 id="3、编译驱动程序和测试-APP"><a href="#3、编译驱动程序和测试-APP" class="headerlink" title="3、编译驱动程序和测试 APP"></a>3、编译驱动程序和测试 APP</h3><h4 id="1-、编译驱动程序"><a href="#1-、编译驱动程序" class="headerlink" title="1 、编译驱动程序"></a>1 、编译驱动程序</h4><p>首先编译驱动程序，也就是 chrdevbase.c 这个文件，我们需要将其编译为.ko 模块，创建Makefile 文件，然后在其中输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs makefile">KERNEL_DIR := /home/firestaradmin/linux/IMX6UL/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg
CURRENT_PATH := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span>
obj-m := chrdevbase.o

<span class="hljs-section">build: kernel_modules</span>

<span class="hljs-section">kernel_modules:  </span>
	<span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNEL_DIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> modules
<span class="hljs-section">clean: </span>
	<span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNEL_DIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> clean</code></pre></div>

<p><strong>KERNELDIR</strong> 表示开发板所使用的 Linux 内核源码目录，使用绝对路径，大家根据自己的实际情况填写即可。</p>
<p><strong>CURRENT_PATH</strong> 表示当前路径，直接通过运行“pwd”命令来获取当前所处路径。</p>
<p><strong>obj-m</strong> 表示将 chrdevbase.c 这个文件编译为 chrdevbase.ko 模块。</p>
<p><strong>$(MAKE) -C $(KERNEL_DIR) M&#x3D;$(CURRENT_PATH) modules</strong>具体的编译命令，后面的 modules 表示编译模块，**-C 表示将当前的工作目录切换到指定目录中<strong>，也就是 KERNERLDIR 目录。M 表示模块源码目录，“make modules”命令中</strong>加入 M&#x3D;dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件**。</p>
<p>Makefile 编写好以后输入“make”命令编译驱动模块，编译过程如图  所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820151835351.png" srcset="/img/loading.gif" lazyload alt="image-20200820151835351"></p>
<p>编译成功以后就会生成一个叫做 chrdevbaes.ko 的文件，此文件就是 chrdevbase 设备的驱动模块。至此，chrdevbase 设备的驱动就编译成功。</p>
<h4 id="2、编译测试-APP"><a href="#2、编译测试-APP" class="headerlink" title="2、编译测试 APP"></a>2、编译测试 APP</h4><p>测试 APP 比较简单，只有一个文件，因此就不需要编写 Makefile 了，直接输入命令编译。因为测试 APP 是要在 ARM 开发板上运行的，所以需要使用 arm-linux-gnueabihf-gcc 来编译，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-gcc chrdevbaseApp.c -o chrdevbaseApp</code></pre></div>

<p>编译完成以后会生成一个叫做 chrdevbaseApp 的可执行程序，输入如下命令查看chrdevbaseAPP 这个程序的文件信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">file chrdevbaseApp</code></pre></div>

<p>结果如图 所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152045899.png" srcset="/img/loading.gif" lazyload alt="image-20200820152045899"></p>
<p>从图可以看出，chrdevbaseAPP 这个可执行文件是 32 位 LSB 格式，ARM 版本的，因此 chrdevbaseAPP 只能在 ARM 芯片下运行。</p>
<h3 id="4、运行测试"><a href="#4、运行测试" class="headerlink" title="4、运行测试"></a>4、运行测试</h3><h4 id="1、加载模块驱动"><a href="#1、加载模块驱动" class="headerlink" title="1、加载模块驱动"></a>1、加载模块驱动</h4><p>通过 NFS 将 Ubuntu 中的 rootfs(制作好的根文件系统)目录挂载为根文件系统，所以可以很方便的将chrdevbase.ko 和 chrdevbaseAPP 复制到rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15 目录中.</p>
<p>输入如下命令加载 chrdevbase.ko 驱动文件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">insmod chrdevbase.ko</code></pre></div>

<p>或</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">modprobe chrdevbase.ko</code></pre></div>

<p>如果使用 modprobe 加载驱动的话，可能会出现如图 所示的提示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152529602.png" srcset="/img/loading.gif" lazyload alt="image-20200820152529602"></p>
<p>从图可以看出，modprobe 提示无法打开“modules.dep”这个文件，因此驱动挂载失败了。我们不用手动创建 modules.dep 这个文件，直接输入 depmod 命令即可自动生成modules.dep，有些根文件系统可能没有 depmod 这个命令，如果没有这个命令就只能重新配置busybox，使能此命令，然后重新编译 busybox。</p>
<p>输入“depmod”命令以后会自动生成 modules.alias、modules.symbols 和 modules.dep 这三个文件，如图所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152622765.png" srcset="/img/loading.gif" lazyload alt="image-20200820152622765"></p>
<p>重新使用 modprobe 加载 chrdevbase.ko，结果如图所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152702937.png" srcset="/img/loading.gif" lazyload alt="image-20200820152702937"></p>
<p>从图可以看到“chrdevbase init！”这一行，这一行正是 chrdevbase.c 中模块入口函数 chrdevbase_init 输出的信息，说明模块加载成功！<br>输入“lsmod”命令即可查看当前系统中存在的模块，结果如图 所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152749421.png" srcset="/img/loading.gif" lazyload alt="image-20200820152749421"></p>
<p>从图可以看出，当前系统只有“chrdevbase”这一个模块。输入如下命令查看当前系统中有没有 chrdevbase 这个设备：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /proc/devices</code></pre></div>

<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152847237.png" srcset="/img/loading.gif" lazyload alt="image-20200820152847237"></p>
<p>从图 可以看出，当前系统存在 chrdevbase 这个设备，主设备号为 200，跟我们设置的主设备号一致。</p>
<h4 id="2-、创建设备节点文件"><a href="#2-、创建设备节点文件" class="headerlink" title="2 、创建设备节点文件"></a>2 、创建设备节点文件</h4><p>驱动加载成功需要在&#x2F;dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操作这个设备节点文件来完成对具体设备的操作。输入如下命令创建&#x2F;dev&#x2F;chrdevbase 这个设备节点文件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mknod</span> /dev/chrdevbase c 200 0</code></pre></div>

<p>其中“mknod”是创建节点命令，“&#x2F;dev&#x2F;chrdevbase”是要创建的节点文件，“c”表示这是个字符设备，“200”是设备的主设备号，“0”是设备的次设备号。</p>
<p>创建完成以后就会存在&#x2F;dev&#x2F;chrdevbase 这个文件，可以使用<code>ls /dev/chrdevbase -l</code>命令查看，结果如图所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153138996.png" srcset="/img/loading.gif" lazyload alt="image-20200820153138996"></p>
<p>如果 chrdevbaseAPP 想要读写 chrdevbase 设备，直接对&#x2F;dev&#x2F;chrdevbase 进行读写操作即可。相当于&#x2F;dev&#x2F;chrdevbase 这个文件是 chrdevbase 设备在用户空间中的实现。前面一直说 Linux 下一切皆文件，包括设备也是文件，现在大家应该是有这个概念了吧？</p>
<h4 id="3、chrdevbase设备操作测试"><a href="#3、chrdevbase设备操作测试" class="headerlink" title="3、chrdevbase设备操作测试"></a>3、chrdevbase设备操作测试</h4><p>使用 chrdevbaseApp 软件操作 chrdevbase 这个设备，看看读写是否正常，首先进行读操作，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">./chrdevbaseAPP /dev/chrdevbase 1</code></pre></div>

<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153332666.png" srcset="/img/loading.gif" lazyload alt="image-20200820153332666"></p>
<p>从图可以看出，首先输出“kernel senddata ok!”这一行信息，这是驱动程序中chrdevbase_read 函数输出的信息，因为 chrdevbaseAPP 使用 read 函数从 chrdevbase 设备读取数据，因此 chrdevbase_read 函数就会执行。chrdevbase_read 函数向 chrdevbaseAPP 发送“kerneldata!”数据，chrdevbaseAPP 接收到以后就打印出来，“read data:kernel data!”就是 chrdevbaseAPP打印出来的接收到的数据。说明对 chrdevbase 的读操作正常，接下来测试对 chrdevbase 设备的写操作，输入如下命令</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">./chrdevbaseAPP /dev/chrdevbase 2</code></pre></div>

<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153515594.png" srcset="/img/loading.gif" lazyload alt="image-20200820153515594"></p>
<p> chrdevbase 的写操作正常，既然读写都没问题，说明我们编写的 chrdevbase 驱动是没有问题的。</p>
<h4 id="4、卸载驱动模块"><a href="#4、卸载驱动模块" class="headerlink" title="4、卸载驱动模块"></a>4、卸载驱动模块</h4><p>如果不再使用某个设备的话可以将其驱动卸载掉，比如输入如下命令卸载掉 chrdevbase 这个设备：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">rmmod chrdevbase.ko</code></pre></div>

<p>卸载以后使用 lsmod 命令查看 chrdevbase 这个模块还存不存在，结果如图  所示：</p>
<p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153622245.png" srcset="/img/loading.gif" lazyload alt="image-20200820153622245"></p>
<p>从图可以看出，模块成功推出，此时系统已经没有任何模块了，chrdevbase 这个模块也不存在了，<br>说明模块卸载成功。至此，chrdevbase 这个设备的整个驱动就验证完成了，驱动工作正常。本章我们详细的讲解了字符设备驱动的开发步骤，并且以一个虚拟的 chrdevbase 设备为例，带领大家完成了第一个字符设备驱动的开发，掌握了字符设备驱动的开发框架以及测试方法，以后的字符设备驱动实验基本都以此为蓝本。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/7%E3%80%81Linux%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">7| Linux按键输入驱动实验</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/2%E3%80%81LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">2| LED灯驱动开发实验记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
