

<!DOCTYPE html>
<html lang="zh-cn" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="uboot移植一、获取ubootuboot官网的源码，对某一芯片的支持肯定没有原厂完善，所以一般选择原厂的uboot源码。 这里我们以 NXP 官方的 uboot 移植到正点原子的 I.MX6ULL 开发板上为例。 uboot官网下载http:&#x2F;&#x2F;www.denx.de&#x2F;wiki&#x2F;U-Boot&#x2F; 选择源码  ftp下载     选择要下载的版本  从你的板子参考厂商获取修改过的uboot 首先 u">
<meta property="og:type" content="article">
<meta property="og:title" content="7| uboot移植">
<meta property="og:url" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="uboot移植一、获取ubootuboot官网的源码，对某一芯片的支持肯定没有原厂完善，所以一般选择原厂的uboot源码。 这里我们以 NXP 官方的 uboot 移植到正点原子的 I.MX6ULL 开发板上为例。 uboot官网下载http:&#x2F;&#x2F;www.denx.de&#x2F;wiki&#x2F;U-Boot&#x2F; 选择源码  ftp下载     选择要下载的版本  从你的板子参考厂商获取修改过的uboot 首先 u">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174610893.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174626000.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174641016.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817175657019.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817183254084.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817183701255.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817192750821.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818200355231.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818200505813.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818201707668.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818203813549.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818211726560.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818212327169.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818221858986.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818223729557.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818224125442.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818224138597.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818224533045.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818235039839.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112010754.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112039004.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112102964.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112413619.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112518396.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112728189.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819114151182.png">
<meta property="article:published_time" content="2020-09-05T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-05T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="uboot">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174610893.png">
  
  
  <title>7| uboot移植 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="7| uboot移植">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-06 00:00" pubdate>
        2020年9月6日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      30k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      251 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">7| uboot移植</h1>
            
            <div class="markdown-body">
              <h1 id="uboot移植"><a href="#uboot移植" class="headerlink" title="uboot移植"></a>uboot移植</h1><h2 id="一、获取uboot"><a href="#一、获取uboot" class="headerlink" title="一、获取uboot"></a>一、获取uboot</h2><p>uboot官网的源码，对某一芯片的支持肯定没有原厂完善，所以一般选择原厂的uboot源码。</p>
<p>这里我们以 NXP 官方的 uboot 移植到正点原子的 I.MX6ULL 开发板上为例。</p>
<h3 id="uboot官网下载"><a href="#uboot官网下载" class="headerlink" title="uboot官网下载"></a>uboot官网下载</h3><p><code>http://www.denx.de/wiki/U-Boot/</code></p>
<p>选择源码</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174610893.png" srcset="/img/loading.gif" lazyload alt="image-20200817174610893"></p>
<p>ftp下载</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174626000.png" srcset="/img/loading.gif" lazyload alt="image-20200817174626000">    选择要下载的版本</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174641016.png" srcset="/img/loading.gif" lazyload alt="image-20200817174641016"></p>
<h3 id="从你的板子参考厂商获取修改过的uboot"><a href="#从你的板子参考厂商获取修改过的uboot" class="headerlink" title="从你的板子参考厂商获取修改过的uboot"></a>从你的板子参考厂商获取修改过的uboot</h3><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817175657019.png" srcset="/img/loading.gif" lazyload alt="image-20200817175657019"></p>
<p>首先 uboot 官方的基本是不会用的，因为支持太弱了。最常用的就是半导体厂商或者开发板厂商的 uboot，如果你用的半导体厂商的评估板，那么就使用半导体厂商的 uboot，如果你是购买的第三方开发板，比如正点原子的 I.MX6ULL 开发板，那么就使用正点原子提供的 uboot 源码（也是在半导体厂商的 uboot 上修改的）。当然了，你也可以在购买了第三方开发板以后使用半导体厂商提供的 uboot，只不过有些外设驱动可能不支持，需要自己移植，这个就是我们常说的 uboot 移植</p>
<p>uboot 的移植并不是说我们完完全全的从零开始将 uboot 移植到我们现在所使用的开发板或者开发平台上。这个对于我们来说基本是不可能的，这个工作一般是半导体厂商做的，半导<br>体厂商负责将 uboot 移植到他们的芯片上，因此半导体厂商都会自己做一个开发板，这个开发板就叫做原厂开发板。半导体厂商会将 uboot 移植到他们自己的原厂开发板上，测试好以后就会将这个 uboot 发布出去，这就是大家常说的原厂 BSP 包。</p>
<h2 id="二、uboot初次编译"><a href="#二、uboot初次编译" class="headerlink" title="二、uboot初次编译"></a>二、uboot初次编译</h2><p>首先在 Ubuntu 中安装 ncurses 库，否则编译会报错，安装命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">sudo apt-get install libncurses5-dev</code></pre></div>

<h3 id="1-解压uboot源码"><a href="#1-解压uboot源码" class="headerlink" title="1.解压uboot源码"></a>1.解压uboot源码</h3><p>获取uboot源码后，解压uboot得到这样一个目录</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817183254084.png" srcset="/img/loading.gif" lazyload alt="image-20200817183254084"></p>
<h3 id="2-配置源码"><a href="#2-配置源码" class="headerlink" title="2.配置源码"></a>2.配置源码</h3><p>在目录下configs里找到默认的配置文件</p>
<p>如IMX6uLL的官方开发板EVK的配置文件为</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817183701255.png" srcset="/img/loading.gif" lazyload alt="image-20200817183701255"></p>
<p>使用<code>make xxx_defconfig</code>命令即可配置 uboot，比如：**(注意要在uboot根目录输入命令)**</p>
<div class="code-wrapper"><pre><code class="hljs sh">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_evk_emmc_defconfig</code></pre></div>

<h3 id="3-编译源码"><a href="#3-编译源码" class="headerlink" title="3.编译源码"></a>3.编译源码</h3><p>编译 NXP  官方开发板对应的 uboot:</p>
<div class="code-wrapper"><pre><code class="hljs sh">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</code></pre></div>

<ul>
<li><code>V=1</code> 查看完整的编译信息</li>
<li><code>-j12</code>12核编译</li>
</ul>
<hr>
<p>这里每次输入那么长，很麻烦，可以直接在Makefile里给<code>ARCH</code> 和<code>CORSS_COMPILE </code>赋值, 或者可以写个SHELL脚本</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817192750821.png" srcset="/img/loading.gif" lazyload alt="image-20200817192750821"></p>
<p>这样我们就可以使用如下简短的命令来编译 uboot 了：</p>
<div class="code-wrapper"><pre><code class="hljs sh">make mx6ull_14x14_evk_emmc_defconfig
make V=1 -j16</code></pre></div>



<h3 id="4-烧写未修改过的uboot测试"><a href="#4-烧写未修改过的uboot测试" class="headerlink" title="4.烧写未修改过的uboot测试"></a>4.烧写未修改过的uboot测试</h3><p><code>sudo fdisk -l</code>查看当前储存设备。</p>
<p>将 imxdownload 软件拷贝到 uboot 源码根目录下然后使用 imxdownload 软件将 u-boot.bin烧写到 SD 卡中，烧写命令如下：<br><code>chmod 777 imxdownload</code> 给予 imxdownload 可执行权限<br><code>./imxdownload u-boot.bin /dev/sdb </code> 烧写 u-boot.bin 到 SD 卡中</p>
<h2 id="三、移植uboot"><a href="#三、移植uboot" class="headerlink" title="三、移植uboot"></a>三、移植uboot</h2><h3 id="1-添加开发板默认配置文件"><a href="#1-添加开发板默认配置文件" class="headerlink" title="1.添加开发板默认配置文件"></a>1.添加开发板默认配置文件</h3><p>先在 configs 目录下创建默认配置文件，复制 mx6ull_14x14_evk_emmc_defconfig，然后重<br>命名为 mx6ull_alientek_emmc_defconfig，命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> configs
<span class="hljs-built_in">cp</span> mx6ull_14x14_evk_emmc_defconfig mx6ull_lxg_emmc_defconfig</code></pre></div>

<p>然后将文件 mx6ull_lxg_emmc_defconfig 中的内容改成下面的：<br>示例代码 33.2.1.1 mx6ull_alientek_emmc_defconfig 文件</p>
<div class="code-wrapper"><pre><code class="hljs c">CONFIG_SYS_EXTRA_OPTIONS=<span class="hljs-string">&quot;IMX_CONFIG=board/freescale/mx6ull_lxg_emmc/imximage.cfg,MX6ULL_EVK_EMMC_REWORK&quot;</span>
CONFIG_ARM=y
CONFIG_ARCH_MX6=y
CONFIG_TARGET_MX6ULL_LXG_EMMC=y
CONFIG_CMD_GPIO=y</code></pre></div>

<p>mx6ull_lxg_emmc_defconfig 基本和 mx6ull_14x14_evk_emmc_defconfig 中<br>的内容一样，只是第 1 行和第 4 行做了修改。</p>
<h3 id="2-添加开发板对应头文件"><a href="#2-添加开发板对应头文件" class="headerlink" title="2.添加开发板对应头文件"></a>2.添加开发板对应头文件</h3><p>在目录include&#x2F;configs 下添加 I.MX6ULL-ALPHA 开发板对应的头文件</p>
<p>复制<code>include/configs/mx6ullevk.h</code>，并重命名为 <code>mx6ull_lxg_emmc.h</code>，命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> include/configs/mx6ullevk.h include/configs/mx6ull_lxg_emmc.h</code></pre></div>

<p>拷贝完成以后编辑文件，将：</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MX6ULLEVK_CONFIG_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> __MX6ULLEVK_CONFIG_H</span></code></pre></div>

<p>改为：</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MX6ULL_LXG_EMMC_CONFIG_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> __MX6ULL_LXG_EMMC_CONFIG_H</span></code></pre></div>

<p>mx6ull_lxg_emmc.h 里面有很多宏定义，这些宏定义基本用于配置 uboot，也有一些I.MX6ULL 的配置项目。如果我们自己要想使能或者禁止 uboot 的某些功能，那就在mx6ull_lxg_emmc.h 里面做修改即可。</p>
<h3 id="3-添加开发板对应的板级文件夹"><a href="#3-添加开发板对应的板级文件夹" class="headerlink" title="3.添加开发板对应的板级文件夹"></a>3.添加开发板对应的板级文件夹</h3><p>uboot 中每个板子都有一个对应的文件夹来存放板级文件，比如开发板上外设驱动文件等等。</p>
<p>NXP 的 I.MX 系列芯片的所有板级文件夹都存放在<code>board/freescale</code>目录下，在这个目录下有个名为 <code>mx6ullevk</code> 的文件夹，这个文件夹就是 NXP 官方 I.MX6ULL EVK 开发板的板级文件夹。复制 <code>mx6ullevk</code>，将其重命名为 <code>mx6ull_lxg_emmc</code>，命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> board/freescale/
<span class="hljs-built_in">cp</span> mx6ullevk/ -r mx6ull_lxg_emmc</code></pre></div>

<p>进 入 mx6ull_alientek_emmc 目录中，将其中的 mx6ullevk.c 文件重命名为<code>mx6ull_lxg_emmc.c</code></p>
<div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> mx6ull_lxg_emmc
<span class="hljs-built_in">mv</span> mx6ullevk.c mx6ull_lxg_emmc.c</code></pre></div>

<p>我们还需要对<code> mx6ull_lxg_emmc</code>目录下的文件做一些修改：</p>
<ul>
<li><p><strong>修改 mx6ull_lxg_emmc  目录下的 Makefile 如下</strong></p>
<div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># (C) Copyright 2015 Freescale Semiconductor, Inc.</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># SPDX-License-Identifier:	GPL-2.0+</span>
<span class="hljs-comment">#</span>

obj-y  := mx6ull_lxg_emmc.o

extra-<span class="hljs-variable">$(CONFIG_USE_PLUGIN)</span> :=  plugin.bin
<span class="hljs-variable">$(obj)</span>/plugin.bin: <span class="hljs-variable">$(obj)</span>/plugin.o
	<span class="hljs-variable">$(OBJCOPY)</span> -O binary --gap-fill 0xff <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$@</span>
</code></pre></div>


</li>
<li><p><strong>修改 mx6ull_lxg_emmc  目录下的 imximage.cfg</strong> </p>
<p>将 imximage.cfg 中的下面一句：<br><code>PLUGIN board/freescale/mx6ullevk/plugin.bin 0x00907000</code><br>改为：<br><code>PLUGIN board/freescale/mx6ull_lxg_emmc /plugin.bin 0x00907000</code></p>
</li>
<li><p><strong>修改 mx6ull_alientek_emmc  目录下的 Kconfig</strong> </p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> TARGET_MX6ULL_LXG_EMMC

config SYS_BOARD
	<span class="hljs-keyword">default</span> <span class="hljs-string">&quot;mx6ull_lxg_emmc&quot;</span>

config SYS_VENDOR
	<span class="hljs-keyword">default</span> <span class="hljs-string">&quot;freescale&quot;</span>

config SYS_SOC
	<span class="hljs-keyword">default</span> <span class="hljs-string">&quot;mx6&quot;</span>

config SYS_CONFIG_NAME
	<span class="hljs-keyword">default</span> <span class="hljs-string">&quot;mx6ull_lxg_emmc&quot;</span>

endif
</code></pre></div>
</li>
<li><p><strong>修改 mx6ull_alientek_emmc  目录下的 MAINTAINERS</strong> </p>
<p>修改 MAINTAINERS 文件，修改后的内容如下</p>
<div class="code-wrapper"><pre><code class="hljs dts">MX6ULLEVK BOARD
<span class="hljs-symbol">M:</span>	Peng Fan <span class="hljs-params">&lt;peng.fan@nxp.com&gt;</span>
<span class="hljs-symbol">S:</span>	Maintained
<span class="hljs-symbol">F:</span>	board<span class="hljs-keyword">/freescale/</span>mx6ull_lxg_emmc/
<span class="hljs-symbol">F:</span>	include<span class="hljs-keyword">/configs/</span>mx6ull_lxg_emmc.h
<span class="hljs-symbol">F:</span>	configs/mx6ull_lxg_defconfig</code></pre></div></li>
</ul>
<h3 id="4-修改U-Boot图形界面配置文件"><a href="#4-修改U-Boot图形界面配置文件" class="headerlink" title="4.修改U-Boot图形界面配置文件"></a>4.修改U-Boot图形界面配置文件</h3><p>uboot 是支持图形界面配置，关于 uboot 的图形界面配置下一章会详细的讲解。修改文件<code>arch/arm/cpu/armv7/mx6/Kconfig</code>(如果用的 I.MX6UL 的话，应该修改 <code>arch/arm/Kconfig </code>这个文<br>件)</p>
<ul>
<li>在 207 行加入如下内容：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs csharp">config TARGET_MX6ULL_LXG_EMMC
	<span class="hljs-built_in">bool</span> <span class="hljs-string">&quot;Support mx6ull_lxg_emmc&quot;</span>
	<span class="hljs-keyword">select</span> MX6ULL
	<span class="hljs-keyword">select</span> DM
	<span class="hljs-keyword">select</span> DM_THERMAL</code></pre></div>

<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818200355231.png" srcset="/img/loading.gif" lazyload alt="image-20200818200355231"></p>
<ul>
<li>在最后一行的 endif 的前一行添加如下内容:</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> <span class="hljs-string">&quot;board/freescale/mx6ull_lxg_emmc/Kconfig&quot;</span></code></pre></div>

<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818200505813.png" srcset="/img/loading.gif" lazyload alt="image-20200818200505813"></p>
<hr>
<p>到此为止，I.MX6U-ALPHA 开发板就已经添加到 uboot 中了，接下来就是编译这个新添加<br>的开发板。</p>
<h3 id="5-使用新添加的板子配置编译uboot"><a href="#5-使用新添加的板子配置编译uboot" class="headerlink" title="5.使用新添加的板子配置编译uboot"></a>5.使用新添加的板子配置编译uboot</h3><p>在uboot根目录下新建一个名为 <code>mx6ull_lxg_emmc.sh</code> 的 shell 脚本，在这个shell脚本里面输入如下内容：</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash">!/bin/bash</span>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_lxg_emmc_defconfig
make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</code></pre></div>

<p>第3行我们使用的默认配置文件就是之前新建的 <code>mx6ull_alientek_emmc_defconfig</code>这个配置文件。</p>
<p>给予 <code>mx6ull_lxg_emmc.sh</code> 可执行权限，然后运行脚本来完成编译，命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 mx6ull_alientek_emmc.sh 
./mx6ull_alientek_emmc.sh</code></pre></div>

<p>等待编译完成，编译完成以后输入如下命令，查看一下之前添加的<code>mx6ull_lxg_emmc.h</code>这个头文件有没有被引用, 输入命令：</p>
<div class="code-wrapper"><pre><code class="hljs sh">grep -nR <span class="hljs-string">&quot;`mx6ull_lxg_emmc.h&quot;</span></code></pre></div>

<p>如果有很多文件都引用了<code>mx6ull_lxg_emmc.h</code>这个头文件，那就说明新板子添加成功，</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818201707668.png" srcset="/img/loading.gif" lazyload alt="image-20200818201707668"></p>
<p>编译完成以后就使用 imxdownload 将新编译出来的 u-boot.bin 烧写到 SD 卡中测试</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818203813549.png" srcset="/img/loading.gif" lazyload alt="image-20200818203813549"></p>
<p>从图中第一行的编译时间可以看出，这是我们刚刚编译的uboot，此时的 Board 还是“MX6ULL 14x14 EVK”，因为我们参考的 NXP官方的 I.MX6ULL 开发板来添加自己的开发板。接了 LCD 屏幕的话会发现 LCD 屏幕并没有显示 NXP 的 logo，而且从图可以看出此时的网络同样也没识别出来。如果你的开发板和官方的有些区别，默认uboot中的LCD 驱动和网络驱动是有问题的，需要修改。</p>
<h3 id="6-LCD驱动修改"><a href="#6-LCD驱动修改" class="headerlink" title="6.LCD驱动修改"></a>6.LCD驱动修改</h3><p>一般 uboot 中修改驱动基本都是在 xxx.h 和 xxx.c 这两个文件中进行的，xxx 为板子名称，比如 mx6ull_lxg_emmc.h 和 mx6ull_lxg_emmc.c 这两个文件。<br>一般修改 LCD 驱动重点注意以下几点：<br><strong>①、LCD 所使用的 GPIO，查看 uboot 中 LCD 的 IO 配置是否正确。</strong><br><strong>②、LCD 背光引脚 GPIO 的配置。</strong><br><strong>③、LCD 配置参数是否正确。</strong></p>
<p>这里以正点原子的 I.MX6U-ALPHA 开发板 为例：</p>
<p>LCD 原理图和 NXP 官方 I.MX6ULL 开发板一致，也就是 LCD 的 IO 和背光 IO 都一样的，所以 IO 部分就不用修改了。需要修改的只有 LCD 参数，打开文件 mx6ull_lxg_emmc.c，找到如下所示内容：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">display_info_t</span> <span class="hljs-title">const</span> <span class="hljs-title">displays</span>[] =</span> &#123;&#123;
	.bus = MX6UL_LCDIF1_BASE_ADDR,
	.addr = <span class="hljs-number">0</span>,
	.pixfmt = <span class="hljs-number">24</span>,
	.detect = <span class="hljs-literal">NULL</span>,
	.enable	= do_enable_parallel_lcd,
	.mode	= &#123;
		.name			= <span class="hljs-string">&quot;TFT43AB&quot;</span>,
		.xres           = <span class="hljs-number">480</span>,
		.yres           = <span class="hljs-number">272</span>,
		.pixclock       = <span class="hljs-number">108695</span>,
		.left_margin    = <span class="hljs-number">8</span>,
		.right_margin   = <span class="hljs-number">4</span>,
		.upper_margin   = <span class="hljs-number">2</span>,
		.lower_margin   = <span class="hljs-number">4</span>,
		.hsync_len      = <span class="hljs-number">41</span>,
		.vsync_len      = <span class="hljs-number">10</span>,
		.sync           = <span class="hljs-number">0</span>,
		.vmode          = FB_VMODE_NONINTERLACED
&#125; &#125; &#125;;</code></pre></div>

<p>示例代码中定义了一个变量 displays, 类型为 display_info_t，这个结构体是 LCD信息结构体，其中包括了 LCD 的分辨率，像素格式，LCD 的各个参数等。</p>
<p>display_info_t 定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;imx-common&#x2F;video.h 中，定义如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">display_info_t</span> &#123;</span>
	<span class="hljs-type">int</span>	bus;
	<span class="hljs-type">int</span>	addr;
	<span class="hljs-type">int</span>	pixfmt;
	<span class="hljs-type">int</span>	(*detect)(<span class="hljs-keyword">struct</span> <span class="hljs-type">display_info_t</span> <span class="hljs-type">const</span> *dev);
	<span class="hljs-type">void</span>	(*enable)(<span class="hljs-keyword">struct</span> <span class="hljs-type">display_info_t</span> <span class="hljs-type">const</span> *dev);
	<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">fb_videomode</span> <span class="hljs-title">mode</span>;</span>
&#125;;</code></pre></div>

<p><code>pixfmt </code>是像素格式，也就是一个像素点是多少位，如果是 RGB565 的话就是 16 位，如果是 888 的话就是 24 位，一般使用 RGB888。</p>
<p>结构体 display_info_t 还有个 <code>mode</code> 成员变量，此成员变量也是个结构体，为 <code>fb_videomode</code>，定义在文件 include&#x2F;linux&#x2F;fb.h 中，定义如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_videomode</span> &#123;</span>
	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;	<span class="hljs-comment">/* optional */</span>
	u32 refresh;		<span class="hljs-comment">/* optional */</span>
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
&#125;;</code></pre></div>

<p>结构体 <code>fb_videomode</code> 里面的成员变量为 LCD 的参数，这些成员变量函数如下：</p>
<ul>
<li>name ：LCD 名字，要和环境变量中的 panel 相等。</li>
<li>xres 、yres ：LCD X 轴和 Y 轴像素数量。</li>
<li>pixclock：像素时钟，每个像素时钟周期的长度，单位为皮秒。</li>
<li>left_margin ：HBP，水平同步后肩。</li>
<li>right_margin ：HFP，水平同步前肩。</li>
<li>upper_margin：VBP，垂直同步后肩。</li>
<li>lower_margin：VFP，垂直同步前肩。</li>
<li>hsync_len ：HSPW，行同步脉宽。</li>
<li>vsync_len：VSPW，垂直同步脉宽。</li>
<li>vmode ：大多数使用 FB_VMODE_NONINTERLACED，也就是不使用隔行扫描。</li>
</ul>
<p>可以看出，这些参数与裸机驱动 RGB LCD 的时候参数基本一样，唯一不同的像素时钟 pixclock 的含义不同，以正点原子的 7 寸 1024x600 分辨率的屏幕(ATK7016)为例，屏幕要求的像素时钟为 51.2MHz，因此：<br>pixclock&#x3D;(1&#x2F;51200000)*10^12&#x3D;19531</p>
<p>在根据其他的屏幕参数，可以得出 ATK7016 屏幕的配置参数如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">display_info_t</span> <span class="hljs-title">const</span> <span class="hljs-title">displays</span>[] =</span> &#123;&#123;
	.bus = MX6UL_LCDIF1_BASE_ADDR,
	.addr = <span class="hljs-number">0</span>,
	.pixfmt = <span class="hljs-number">24</span>,
	.detect = <span class="hljs-literal">NULL</span>,
	.enable	= do_enable_parallel_lcd,
	.mode	= &#123;
		.name			= <span class="hljs-string">&quot;TFT7016&quot;</span>,
		.xres           = <span class="hljs-number">1024</span>,
		.yres           = <span class="hljs-number">600</span>,
		.pixclock       = <span class="hljs-number">19531</span>,
		.left_margin    = <span class="hljs-number">140</span>,
		.right_margin   = <span class="hljs-number">160</span>,
		.upper_margin   = <span class="hljs-number">20</span>,
		.lower_margin   = <span class="hljs-number">12</span>,
		.hsync_len      = <span class="hljs-number">20</span>,
		.vsync_len      = <span class="hljs-number">3</span>,
		.sync           = <span class="hljs-number">0</span>,
		.vmode          = FB_VMODE_NONINTERLACED
&#125; &#125; &#125;;</code></pre></div>

<p>使用示例代码中的屏幕参数替换掉 mx6ull_lxg_emmc.c 中 uboot 默认的屏幕参数。</p>
<p>打开 mx6ull_lxg_emmc.h，找到所有如下语句：</p>
<div class="code-wrapper"><pre><code class="hljs c">panel=TFT43AB</code></pre></div>

<p>将其改为：</p>
<div class="code-wrapper"><pre><code class="hljs c">panel=TFT7016</code></pre></div>

<p>也就是设置 panel 为 TFT7016，panel 的值要与display_info_t结构体变量中的.name 成员变量的值<br>一致。修改完成以后重新编译一遍 uboot 并烧写到 SD 中启动。</p>
<p>重启以后 LCD 驱动一般就会工作正常了，LCD 上回显示 NXP 的 logo。但是有可能会遇到LCD 并没有工作，还是黑屏，这是什么原因呢？在 uboot 命令模式输入“print”来查看环境变量 panel 的值，会发现 panel 的值是 TFT43AB(或其他的，反正不是 TFT7016)</p>
<p>这是因为之前有将环境变量保存到 EMMC 中，uboot 启动以后会先从 EMMC 中读取环境变量，如果EMMC 中没有环境变量的话才会使用 mx6ull_alientek_emmc.h 中的默认环境变量。如果 EMMC 中的环境变量panel 不等于 TFT7016，那么 LCD 显示肯定不正常，我们只需要在uboot 中修改 panel 的值为 TFT7016 即可，在 uboot 的命令模式下输入如下命令：</p>
<div class="code-wrapper"><pre><code class="hljs sh">setenv panel TFT7016
saveenv</code></pre></div>

<p>上述命令修改环境变量 panel 为 TFT7016，然后保存，重启 uboot，此时 LCD 驱动就工作正常了。如果 LCD 还是没有正常工作的，那就要检查自己哪里有没有改错，或者还有哪里没有修改。</p>
<h3 id="7-网络驱动修改"><a href="#7-网络驱动修改" class="headerlink" title="7.网络驱动修改"></a>7.网络驱动修改</h3><h4 id="1、网络硬件介绍"><a href="#1、网络硬件介绍" class="headerlink" title="1、网络硬件介绍"></a>1、网络硬件介绍</h4><p>I.MX6UL&#x2F;ULL 内部有个以太网 MAC 外设，也就是 ENET，需要外接一个 PHY 芯片来实现网络通信功能，也就是内部 MAC+外部 PHY 芯片的方案。</p>
<p>大家可能听过 DM9000 这个网络芯片，在一些没有内部 MAC 的 CPU 中，比如三星的 2440，4412 等，就会采用 DM9000 来实现联网功能。DM9000 提供了一个类似 SRAM 的访问接口，主控 CPU 通过这个接口即可与DM9000 进行通信，DM9000 就是一个 MAC+PHY 芯片。这个方案就相当于外部 MAC+外部PHY，那么 I.MX6U 这样的内部 MAC+PHY 芯片与 DM9000 方案比有什么优势吗？首先就是通信效率和速度，一般 SOC 内部的 MAC 是带有一个专用 DMA 的，专门用于处理网络数据包，采用 SRAM 来读写 DM9000 的速度是压根就没法和内部 MAC+外部 PHY 芯片的速度比。采用外部 DM9000 完全是无奈之举，谁让2440，4412 这些芯片内部没有以太网外设呢，现在又想用有线网络，没有办法只能找个 DM9000 的方案。</p>
<p>I.MX6UL&#x2F;ULL 有两个网络接口 ENET1 和 ENET2，正点原子的 I.MX6U-ALPHA 开发板提供了这两个网络接口，其中 ENET1 和 ENET2 都使用 LAN8720A 作为 PHY 芯片。NXP 官方的I.MX6ULL EVK 开发板使用 KSZ8081 这颗 PHY 芯片，LAN8720A 相比 KSZ8081 具有体积小、外围器件少、价格便宜等优点。</p>
<p>换了PHY芯片，这个时候官方的驱动就不适用啦，需要修改驱动，使网络工作正常。</p>
<p>正点原子I.MX6U-ALPHA 开发板 ENET1 的网络原理图如图：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818211726560.png" srcset="/img/loading.gif" lazyload alt="image-20200818211726560"></p>
<p>ENET1 的网络 PHY 芯片为 LAN8720A，通过 RMII 接口与 I.MX6ULL 相连，正点原子I.MX6U-ALPHA 开发板的 ENET1 引脚与 NXP 官方的 I.MX6ULL EVK 开发板基本一样，唯独复位引脚不同。从图可以看出，正点原子 I.MX6U-ALPHA 开发板的 ENET1 复位引脚ENET1_RST 接到了 I.M6ULL 的 SNVS_TAMPER7 这个引脚上。</p>
<p>LAN8720A 内部是有寄存器的，I.MX6ULL 会读取 LAN8720 内部寄存器来判断当前的物理链接状态、连接速度(10M 还是 100M)和双工状态(半双工还是全双工)。I.MX6ULL 通过 MDIO接口来读取 PHY 芯片的内部寄存器，MDIO 接口有两个引脚，ENET_MDC 和 ENET_MDIO，ENET_MDC 提供时钟，ENET_MDIO 进行数据传输。一个 MIDO 接口可以管理 32 个 PHY 芯片，同一个 MDIO 接口下的这些 PHY 使用不同的器件地址来做区分，MIDO 接口通过不同的器件地址即可访问到相应的 PHY 芯片。I.MX6U-ALPHA 开发板 ENET1 上连接的 <strong>LAN8720A器件地址为 0X0</strong>，所示我们要修改 ENET1 网络驱动的话重点就三点：</p>
<ul>
<li>①、ENET1 复位引脚初始化。</li>
<li>②、LAN8720A 的器件 ID。</li>
<li>③、LAN8720 驱动</li>
</ul>
<p>再来看一下 开发板上的 ENET2 的原理图，如图所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818212327169.png" srcset="/img/loading.gif" lazyload alt="image-20200818212327169"></p>
<p>关于 ENET2 网络驱动的修改也注意一下三点：<br>①、ENET2 的复位引脚，从图可以看出，ENET2 的复位引脚 ENET2_RST 接到了I.MX6ULL 的 SNVS_TAMPER8 上。<br>②、ENET2 所使用的 PHY 芯片器件地址，从图可以看出，<strong>PHY 器件地址为 0X1</strong>。<br>③、LAN8720 驱动，ENET1 和 ENET2 都使用的 LAN8720，所以驱动肯定是一样的。</p>
<h4 id="2、网络-PHY-地址修改"><a href="#2、网络-PHY-地址修改" class="headerlink" title="2、网络 PHY  地址修改"></a>2、网络 PHY  地址修改</h4><p>首先修改 uboot 中的 ENET1 和 ENET2 的 PHY 地址和驱动，打开<code>mx6ull_alientek_emmc.h</code>这个文件，找到如下代码：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMD_NET</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_PING</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_DHCP</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_MII</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_MII</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_ENET_DEV		1</span>

<span class="hljs-meta">#<span class="hljs-keyword">if</span> (CONFIG_FEC_ENET_DEV == 0)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IMX_FEC_BASE			ENET_BASE_ADDR</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC_PHYADDR          0x2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_XCV_TYPE             RMII</span>
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> (CONFIG_FEC_ENET_DEV == 1)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IMX_FEC_BASE			ENET2_BASE_ADDR</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC_PHYADDR			0x1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_XCV_TYPE				RMII</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_ETHPRIME			<span class="hljs-string">&quot;FEC&quot;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_PHYLIB</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_PHY_MICREL</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>

<p>**宏<code>CONFIG_FEC_ENET_DEV</code>**用于选择使用哪个网口，默认为 1，也就是选择ENET2。</p>
<p>**宏<code>IMX_FEC_BASE</code>**为该ENET接口的寄存器基地址。</p>
<p>第一个**<code>CONFIG_FEC_MXC_PHYADDR</code>宏**为 ENET1 的 PHY 地址，默认是 0X2，第二个为 ENET2 的 PHY 地址，默认为 0x1。</p>
<p>根据前面的分析可知，正点原子的 I.MX6U-ALPHA 开发板 ENET1 的 PHY 地址为0X0，ENET2 的 PHY 地址为 0X1，所以需要将第第一个**<code>CONFIG_FEC_MXC_PHYADDR</code>宏**改为 0x0 。</p>
<p><strong>宏<code> CONFIG_PHY_MICREL</code><strong>用于使能 uboot 中 Micrel 公司的 PHY驱动，KSZ8081 这颗 PHY 芯片就是 Micrel 公司生产的，不过 Micrel 已经被 Microchip 收购了。如果要使用 LAN8720A，那么就得将</strong><code>CONFIG_PHY_MICREL</code></strong> 改为 **<code>CONFIG_PHY_SMSC</code>**，也就是使能 uboot 中的 SMSC 公司中的 PHY 驱动，因为 LAN8720A 就是 SMSC 公司生产的。所以示例代码有三处要修改：</p>
<p><strong>①、修改 ENET1 网络 PHY 的地址。</strong><br><strong>②、修改 ENET2 网络 PHY 的地址。</strong><br><strong>③、使能 SMSC 公司的 PHY 驱动。</strong><br>修改后的网络 PHY 地址参数如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMD_NET</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_PING</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_DHCP</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_MII</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_MII</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_ENET_DEV		1</span>

<span class="hljs-meta">#<span class="hljs-keyword">if</span> (CONFIG_FEC_ENET_DEV == 0)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IMX_FEC_BASE			ENET_BASE_ADDR</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC_PHYADDR          0x0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_XCV_TYPE             RMII</span>
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> (CONFIG_FEC_ENET_DEV == 1)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IMX_FEC_BASE			ENET2_BASE_ADDR</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC_PHYADDR			0x1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_XCV_TYPE				RMII</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_ETHPRIME			<span class="hljs-string">&quot;FEC&quot;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_PHYLIB</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_PHY_SMSC</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>

<h4 id="3-、删除-uboot-中-中-74LV595-的驱动代码"><a href="#3-、删除-uboot-中-中-74LV595-的驱动代码" class="headerlink" title="3 、删除 uboot 中 中 74LV595 的驱动代码"></a>3 、删除 uboot 中 中 74LV595 的驱动代码</h4><p>uboot 中网络 PHY 芯片地址修改完成以后就是网络复位引脚的驱动修改了，打开<code>mx6ull_lxg_emmc.c</code>找到如下代码：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOX_SDI IMX_GPIO_NR(5, 10)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IOX_STCP IMX_GPIO_NR(5, 7)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IOX_SHCP IMX_GPIO_NR(5, 11)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IOX_OE IMX_GPIO_NR(5, 8)</span></code></pre></div>

<p>以上示例代码中以 IOX 开头的宏定义是 74LV595 的相关 GPIO，因为 NXP 官方I.MX6ULL EVK 开发板使用 74LV595 来扩展 IO，两个网络的复位引脚就是由 74LV595 来控制的。正点原子的 I.MX6U-ALPHA 开发板并没有使用 74LV595，因此我们将示例代码中的代码删除掉，替换为如下所示代码：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENET1_RESET IMX_GPIO_NR(5, 7)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ENET2_RESET IMX_GPIO_NR(5, 8)</span></code></pre></div>

<p>ENET1 的复位引脚连接到 SNVS_TAMPER7 上，对应 GPIO5_IO07，ENET2 的复位引脚连接到 SNVS_TAMPER8 上，对应 GPIO5_IO08。</p>
<p>继续在 <code>mx6ull_lxg_emmc.c</code> 中找到如下代码：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> iox_pads[] = &#123;
	<span class="hljs-comment">/* IOX_SDI */</span>
	MX6_PAD_BOOT_MODE0__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
	<span class="hljs-comment">/* IOX_SHCP */</span>
	MX6_PAD_BOOT_MODE1__GPIO5_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),
	<span class="hljs-comment">/* IOX_STCP */</span>
	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),
	<span class="hljs-comment">/* IOX_nOE */</span>
	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
&#125;;</code></pre></div>

<p>同理，示例代码是 74LV595 的 IO 配置参数结构体，将其删除掉。继续在mx6ull_lxg_emmc.c 中找到函数 iox74lv_init，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iox74lv_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> i;

	gpio_direction_output(IOX_OE, <span class="hljs-number">0</span>);

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">7</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
		gpio_direction_output(IOX_SHCP, <span class="hljs-number">0</span>);
		gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="hljs-number">0</span>]);
		udelay(<span class="hljs-number">500</span>);
		gpio_direction_output(IOX_SHCP, <span class="hljs-number">1</span>);
		udelay(<span class="hljs-number">500</span>);
	&#125;
	......
    ......
	<span class="hljs-comment">/*</span>
<span class="hljs-comment">	 * shift register will be output to pins</span>
<span class="hljs-comment">	 */</span>
	gpio_direction_output(IOX_STCP, <span class="hljs-number">1</span>);
&#125;;

<span class="hljs-type">void</span> <span class="hljs-title function_">iox74lv_set</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>
&#123;
	<span class="hljs-type">int</span> i;

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">7</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
		gpio_direction_output(IOX_SHCP, <span class="hljs-number">0</span>);

		<span class="hljs-keyword">if</span> (i == index)
			gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="hljs-number">0</span>]);
		<span class="hljs-keyword">else</span>
			gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="hljs-number">1</span>]);
		udelay(<span class="hljs-number">500</span>);
		gpio_direction_output(IOX_SHCP, <span class="hljs-number">1</span>);
		udelay(<span class="hljs-number">500</span>);
	&#125;
	......
    ......
	<span class="hljs-comment">/*</span>
<span class="hljs-comment">	  * shift register will be output to pins</span>
<span class="hljs-comment">	  */</span>
	gpio_direction_output(IOX_STCP, <span class="hljs-number">1</span>);
&#125;;</code></pre></div>

<p>iox74lv_init 函数是 74LV595 的初始化函数，iox74lv_set 函数用于控制 74LV595 的 IO 输出电平，将这两个函数全部删除掉！</p>
<p>继续在 mx6ull_lxg_emmc.c 中找到 board_init 函数，此函数是板子初始化函数，会被board_init_r 调用，board_init 函数内容如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">board_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	......
	imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));
	iox74lv_init();
	......
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>board_init 会调用 imx_iomux_v3_setup_multiple_pads 和 iox74lv_init 这两个函数来初始化74lv595 的 GPIO，<strong>将这两行删除掉</strong>。</p>
<p>至此，mx6ull_alientek_emmc.c 中关于 74LV595 芯片的驱动代码都删除掉了，接下来就是添加 I.MX6U-ALPHA 开发板两个网络复位引脚了。</p>
<h4 id="4-、添加-I-MX6U-ALPHA-开发板网络复位引脚驱动"><a href="#4-、添加-I-MX6U-ALPHA-开发板网络复位引脚驱动" class="headerlink" title="4 、添加 I.MX6U-ALPHA 开发板网络复位引脚驱动"></a>4 、添加 I.MX6U-ALPHA 开发板网络复位引脚驱动</h4><p>在 mx6ull_lxg_emmc.c 中找到如下所示代码：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> fec1_pads[] = &#123;
	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
......
	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> fec2_pads[] = &#123;
	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
......
	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
&#125;;</code></pre></div>

<p>结构体数组 fec1_pads 和 fec2_pads 是 ENET1 和 ENET2 这两个网口的 IO 配置参数，在这两个数组中添加两个网口的复位 IO 配置参数，完成以后如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> fec1_pads[] = &#123;
	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
......
	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
    MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),
&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> fec2_pads[] = &#123;
	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
......
	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
    MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
&#125;;</code></pre></div>

<p>添加的两行分别是 ENET1 和 ENET2 的复位 IO 配置参数。继续在文件 mx6ull_lxg_emmc.c 中找到函数 setup_iomux_fec，此函数默认代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">setup_iomux_fec</span><span class="hljs-params">(<span class="hljs-type">int</span> fec_id)</span>
&#123;
	<span class="hljs-keyword">if</span> (fec_id == <span class="hljs-number">0</span>)
		imx_iomux_v3_setup_multiple_pads(fec1_pads,
						 ARRAY_SIZE(fec1_pads));
	<span class="hljs-keyword">else</span>
		imx_iomux_v3_setup_multiple_pads(fec2_pads,
						 ARRAY_SIZE(fec2_pads));
&#125;</code></pre></div>

<p>函数 setup_iomux_fec 就是根据 fec1_pads 和 fec2_pads 这两个网络 IO 配置数组来初始化I.MX6ULL 的网络 IO。我们需要在其中添加网络复位 IO 的初始化代码，并且复位一下 PHY 芯片，修改后的setup_iomux_fec 函数如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">setup_iomux_fec</span><span class="hljs-params">(<span class="hljs-type">int</span> fec_id)</span>
&#123;
	<span class="hljs-keyword">if</span> (fec_id == <span class="hljs-number">0</span>)
    &#123;
        imx_iomux_v3_setup_multiple_pads(fec1_pads,
                                         ARRAY_SIZE(fec1_pads));
        gpio_direction_output(ENET1_RESET, <span class="hljs-number">1</span>);
        gpio_set_value(ENET1_RESET, <span class="hljs-number">0</span>);
        mdelay(<span class="hljs-number">20</span>);
        gpio_set_value(ENET1_RESET, <span class="hljs-number">1</span>);
    &#125;
	<span class="hljs-keyword">else</span>
    &#123;
        imx_iomux_v3_setup_multiple_pads(fec2_pads,
                                         ARRAY_SIZE(fec2_pads));
        gpio_direction_output(ENET2_RESET, <span class="hljs-number">1</span>);
        gpio_set_value(ENET2_RESET, <span class="hljs-number">0</span>);
        mdelay(<span class="hljs-number">20</span>);
        gpio_set_value(ENET2_RESET, <span class="hljs-number">1</span>);
    &#125;
&#125;</code></pre></div>

<p>示例代码分别对应 ENET1 和 ENET2 的复位 IO 初始化，将这两个 IO 设置为输出并且硬件复位一下 LAN8720A，这个硬件复位很重要！否则可能导致 uboot 无法识别 LAN8720A。</p>
<h4 id="5-、修改-drivers-x2F-net-x2F-phy-x2F-phy-c-文件中的函数-genphy-update-link"><a href="#5-、修改-drivers-x2F-net-x2F-phy-x2F-phy-c-文件中的函数-genphy-update-link" class="headerlink" title="5 、修改 drivers&#x2F;net&#x2F;phy&#x2F;phy.c  文件中的函数 genphy_update_link"></a>5 、修改 drivers&#x2F;net&#x2F;phy&#x2F;phy.c  文件中的函数 genphy_update_link</h4><p>大功基本上告成，还差最后一步，uboot 中的 LAN8720A 驱动有点问题，打开文件drivers&#x2F;net&#x2F;phy&#x2F;phy.c，找到函数 genphy_update_link，这是个通用 PHY 驱动函数，此函数用于更新 PHY 的连接状态和速度。使用 LAN8720A 的时候需要在此函数中添加一些代码，修改后的函数 genphy_update_link 如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">genphy_update_link</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> phy_device *phydev)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mii_reg;

    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PHY_SMSC</span>
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> lan8720_flag = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> bmcr_reg = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (lan8720_flag == <span class="hljs-number">0</span>) &#123;
        bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
        phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);
        <span class="hljs-keyword">while</span>(phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) &amp; <span class="hljs-number">0X8000</span>) &#123;
            udelay(<span class="hljs-number">100</span>);
        &#125;
        phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);
        lan8720_flag = <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
    
	<span class="hljs-comment">/*</span>
<span class="hljs-comment">	 * Wait if the link is up, and autonegotiation is in progress</span>
<span class="hljs-comment">	 * (ie - we&#x27;re capable and it&#x27;s not done)</span>
<span class="hljs-comment">	 */</span>
	mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
......
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>前面**#ifdef**里就是新添加的代码，为条件编译代码段，只有使用 SMSC 公司的 PHY 这段代码才会执行(目前只测试了 LAN8720A，SMSC 公司其他的芯片还未测试)。</p>
<p><code>bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);</code>读取LAN8720A 的 BMCR 寄存器(寄存器地址为 0)，此寄存器为 LAN8720A 的配置寄存器，这里先读取此寄存器的默认值并保存起来。</p>
<p><code> phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);</code>向寄存器 BMCR 寄存器写入BMCR_RESET(值为0X8000)，因为 BMCR 的 bit15 是软件复位控制位，因此此行就是软件复位LAN8720A，复位完成以后此位会自动清零。</p>
<p>接下来while等待 LAN8720A 软件复位完成，也就是判断 BMCR的 bit15 位是否为 1，为 1 的话表示还没有复位完成。</p>
<p><code>phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);</code>重新向 BMCR 寄存器写入以前<br>的值，也就是之前读出的那个值。</p>
<p>至此网络的复位引脚驱动修改完成，重新编译 uboot，然后将 u-boot.bin 烧写到 SD 卡中并启动，uboot 启动信息如图所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818221858986.png" srcset="/img/loading.gif" lazyload alt="image-20200818221858986"></p>
<p>可以看到“Net： FEC1”这一行，提示当前使用的 FEC1 这个网口，也就是 ENET2。</p>
<h4 id="6、uboot网络环境变量的配置"><a href="#6、uboot网络环境变量的配置" class="headerlink" title="6、uboot网络环境变量的配置"></a>6、uboot网络环境变量的配置</h4><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> ipaddr <span class="hljs-number">192.168.0.120</span>  //开发板 IP 地址
<span class="hljs-attribute">setenv</span> ethaddr <span class="hljs-number">00</span>:<span class="hljs-number">04</span>:<span class="hljs-number">9</span>f:<span class="hljs-number">04</span>:d2:<span class="hljs-number">35</span> //开发板网卡 MAC 地址
<span class="hljs-attribute">setenv</span> gatewayip <span class="hljs-number">192.168.0.1</span> //开发板默认网关
<span class="hljs-attribute">setenv</span> netmask <span class="hljs-number">255.255.255.0</span>  //开发板子网掩码
<span class="hljs-attribute">setenv</span> serverip <span class="hljs-number">192.168.0.111</span>  //服务器地址，也就是 Ubuntu 地址
<span class="hljs-attribute">saveenv</span> //保存环境变量</code></pre></div>

<p>以上请根据自己的网络环境具体配置。</p>
<p>设置好环境变量以后就可以在 uboot 中使用网络了，用网线将 I.MX6U-ALPHA 上的 ENET2与电脑或者路由器连接起来，保证开发板和电脑在同一个网段内，通过 ping 命令来测试一下网络连接，命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.0.111</span></code></pre></div>

<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818223729557.png" srcset="/img/loading.gif" lazyload alt="image-20200818223729557"></p>
<p>从图可以看出，有“host 192.168.1.250 is alive”这句，说明 ping 主机成功，说明ENET2网络工作正常。再来测试一下ENET1的网络是否正常工作，打开mx6ull_lxg_emmc.h，将 CONFIG_FEC_ENET_DEV 改为 0，然后重新编译一下 uboot 并烧写到 SD 卡中重启。重启开发板</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818224125442.png" srcset="/img/loading.gif" lazyload alt="image-20200818224125442"></p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818224138597.png" srcset="/img/loading.gif" lazyload alt="image-20200818224138597"></p>
<p>从图可以看出，ping 主机也成功，说明 ENET1 网络也工作正常，至此，I.MX6U-ALPHA 开发板的两个网络都工作正常了.</p>
<h3 id="8、其他需要修改的地方"><a href="#8、其他需要修改的地方" class="headerlink" title="8、其他需要修改的地方"></a>8、其他需要修改的地方</h3><p>在 uboot 启动信息中会有“Board: MX6ULL 14x14 EVK”这一句，也就是说板子名字为“MX6ULL 14x14 EVK”，要将其改为我们所使用的板子名字，比如“MX6ULL LXG EMMC”或者“MX6ULL LXG NAND”。打开文件 mx6ull_lxg_emmc.c，找到函数checkboard，将其改为如下所示内容：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">checkboard</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-keyword">if</span> (is_mx6ull_9x9_evk())
		<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Board: MX6ULL 9x9 EVK\n&quot;</span>);
	<span class="hljs-keyword">else</span>
		<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Board: MX6ULL LXG EMMC\n&quot;</span>);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>修改完成以后重新编译 uboot 并烧写到 SD 卡中验证，uboot 启动信息如图所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818224533045.png" srcset="/img/loading.gif" lazyload alt="image-20200818224533045"></p>
<p>从图可以看出，Board 变成了“MX6ULL LXG EMMC”。至此 uboot 的驱动部分就修改完成了，uboot 移植也完成了，uboot 的最终目的就是启动 Linux 内核，所以需要通过启动 Linux 内核来判断 uboot 移植是否成功。在启动 Linux 内核之前我们先来学习两个重要的环境变量 bootcmd 和 bootargs。</p>
<h2 id="四、uboot下的环境变量"><a href="#四、uboot下的环境变量" class="headerlink" title="四、uboot下的环境变量"></a>四、uboot下的环境变量</h2><p>uboot 中有两个非常重要的环境变量 bootcmd 和 bootargs，接下来看一下这两个环境变量。</p>
<p>bootcmd 和 bootagrs 是采用类似 shell 脚本语言编写的，里面有很多的变量引用，这些变量其实都是环境变量，有很多是NXP自己定义的。文 件 mx6ull_lxg_emmc.h 中的宏<code>CONFIG_EXTRA_ENV_SETTINGS</code>保存着这些环境变量的默认值，内容如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SYS_BOOT_NAND)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_EXTRA_ENV_SETTINGS \</span>
<span class="hljs-meta">	CONFIG_MFG_ENV_SETTINGS \</span>
<span class="hljs-meta">	<span class="hljs-string">&quot;panel=TFT7016\0&quot;</span> \</span>
<span class="hljs-meta">	<span class="hljs-string">&quot;fdt_addr=0x83000000\0&quot;</span> \</span>
<span class="hljs-meta">	<span class="hljs-string">&quot;fdt_high=0xffffffff\0&quot;</span>	  \</span>
<span class="hljs-meta">......</span>
		<span class="hljs-string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;\0&quot;</span>

<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_EXTRA_ENV_SETTINGS \</span>
<span class="hljs-meta">	CONFIG_MFG_ENV_SETTINGS \</span>
<span class="hljs-meta">	<span class="hljs-string">&quot;script=boot.scr\0&quot;</span> \</span>
<span class="hljs-meta">	<span class="hljs-string">&quot;image=zImage\0&quot;</span> \</span>
<span class="hljs-meta">	<span class="hljs-string">&quot;console=ttymxc0\0&quot;</span> \</span>
<span class="hljs-meta">	<span class="hljs-string">&quot;fdt_high=0xffffffff\0&quot;</span> \</span>
<span class="hljs-meta">	<span class="hljs-string">&quot;initrd_high=0xffffffff\0&quot;</span> \</span>
<span class="hljs-meta">	<span class="hljs-string">&quot;fdt_file=undefined\0&quot;</span> \</span>
<span class="hljs-meta">......</span>
		<span class="hljs-string">&quot;findfdt=&quot;</span>\
			<span class="hljs-string">&quot;if test $fdt_file = undefined; then &quot;</span> \
				<span class="hljs-string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \
					<span class="hljs-string">&quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot;</span> \
				<span class="hljs-string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \
					<span class="hljs-string">&quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot;</span> \
				<span class="hljs-string">&quot;if test $fdt_file = undefined; then &quot;</span> \
					<span class="hljs-string">&quot;echo WARNING: Could not determine dtb to use; fi; &quot;</span> \
			<span class="hljs-string">&quot;fi;\0&quot;</span> \</code></pre></div>

<p><strong>宏 CONFIG_EXTRA_ENV_SETTINGS</strong> 是个条件编译语句，使用 NAND 和 EMMC 的时候<strong>宏 CONFIG_EXTRA_ENV_SETTINGS</strong> 的值是不同的。</p>
<p>板子第一次运行 uboot 的时候都会使用默认值来设置环境变量。打开文件 <strong>include&#x2F;env_default.h</strong>，在此文件中有如下所示内容：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">env_t</span> environment __PPCENV__ = &#123;
	ENV_CRC,	<span class="hljs-comment">/* CRC Sum */</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYS_REDUNDAND_ENVIRONMENT</span>
	<span class="hljs-number">1</span>,		<span class="hljs-comment">/* Flags: valid */</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
	&#123;
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(DEFAULT_ENV_INSTANCE_STATIC)</span>
<span class="hljs-type">static</span> <span class="hljs-type">char</span> default_environment[] = &#123;
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">const</span> uchar default_environment[] = &#123;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>	CONFIG_ENV_CALLBACK_LIST_DEFAULT</span>
	ENV_CALLBACK_VAR <span class="hljs-string">&quot;=&quot;</span> CONFIG_ENV_CALLBACK_LIST_DEFAULT <span class="hljs-string">&quot;\0&quot;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>	CONFIG_ENV_FLAGS_LIST_DEFAULT</span>
	ENV_FLAGS_VAR <span class="hljs-string">&quot;=&quot;</span> CONFIG_ENV_FLAGS_LIST_DEFAULT <span class="hljs-string">&quot;\0&quot;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>	CONFIG_BOOTARGS</span>
	<span class="hljs-string">&quot;bootargs=&quot;</span>	CONFIG_BOOTARGS			<span class="hljs-string">&quot;\0&quot;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>	CONFIG_BOOTCOMMAND</span>
	<span class="hljs-string">&quot;bootcmd=&quot;</span>	CONFIG_BOOTCOMMAND		<span class="hljs-string">&quot;\0&quot;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>	CONFIG_RAMBOOTCOMMAND</span>
	<span class="hljs-string">&quot;ramboot=&quot;</span>	CONFIG_RAMBOOTCOMMAND		<span class="hljs-string">&quot;\0&quot;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>	CONFIG_NFSBOOTCOMMAND</span>
	<span class="hljs-string">&quot;nfsboot=&quot;</span>	CONFIG_NFSBOOTCOMMAND		<span class="hljs-string">&quot;\0&quot;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_BOOTDELAY) &amp;&amp; (CONFIG_BOOTDELAY &gt;= 0)</span>
	<span class="hljs-string">&quot;bootdelay=&quot;</span>	__stringify(CONFIG_BOOTDELAY)	<span class="hljs-string">&quot;\0&quot;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
........
........
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
        
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>	CONFIG_EXTRA_ENV_SETTINGS</span>
	CONFIG_EXTRA_ENV_SETTINGS
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
        
	<span class="hljs-string">&quot;\0&quot;</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEFAULT_ENV_INSTANCE_EMBEDDED</span>
	&#125;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
&#125;;</code></pre></div>

<p>从示例代码的第 1 行可以看出，environment 是个 env_t 类型的变量，env_t 类型如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">environment_s</span> &#123;</span>
	<span class="hljs-type">uint32_t</span>	crc;		<span class="hljs-comment">/* CRC32 over data bytes	*/</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYS_REDUNDAND_ENVIRONMENT</span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>	flags;		<span class="hljs-comment">/* active/obsolete flags	*/</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>	data[ENV_SIZE]; <span class="hljs-comment">/* Environment data		*/</span>
&#125; <span class="hljs-type">env_t</span></code></pre></div>

<p><strong>env_t</strong>结构体中的<strong>crc</strong>为CRC值，<strong>flags</strong>是标志位，<strong>data</strong>数组就是环境变量值。因此，environment就是用来保存默认环境变量的.</p>
<h3 id="1、环境变量-bootcmd"><a href="#1、环境变量-bootcmd" class="headerlink" title="1、环境变量 bootcmd"></a>1、环境变量 bootcmd</h3><h5 id="bootcmd默认宏定义设置的解析"><a href="#bootcmd默认宏定义设置的解析" class="headerlink" title="bootcmd默认宏定义设置的解析"></a>bootcmd默认宏定义设置的解析</h5><p>bootcmd 保存着 uboot 默认命令，uboot 倒计时结束以后就会执行 bootcmd 中的命令。</p>
<p>这些命令一般都是用来启动 Linux 内核的，比如读取 EMMC 或者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。可以在 uboot 启动以后进入命令行设置 bootcmd 环境变量的值。如果 EMMC 或者 NAND 中没有保存 bootcmd 的值，那么 uboot 就会使用默认的值</p>
<p>在上一个示例代码中指定了很多环境变量的默认值，比如bootcmd 的 默 认 值 就 是CONFIG_BOOTCOMMAND，bootargs 的默认值就是CONFIG_BOOTARGS 。 我们可以在mx6ull_lxg_emmc.h文件中通过设置宏CONFIG_BOOTCOMMAND 来 设 置 bootcmd 的 默 认 值 ， NXP 官 方 设 置 的CONFIG_BOOTCOMMAND 值如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_BOOTCOMMAND \</span>
<span class="hljs-meta">	   <span class="hljs-string">&quot;run findfdt;&quot;</span> \</span>
<span class="hljs-meta">	   <span class="hljs-string">&quot;mmc dev $&#123;mmcdev&#125;;&quot;</span> \</span>
<span class="hljs-meta">	   <span class="hljs-string">&quot;mmc dev $&#123;mmcdev&#125;; if mmc rescan; then &quot;</span> \</span>
<span class="hljs-meta">		   <span class="hljs-string">&quot;if run loadbootscript; then &quot;</span> \</span>
<span class="hljs-meta">			   <span class="hljs-string">&quot;run bootscript; &quot;</span> \</span>
<span class="hljs-meta">		   <span class="hljs-string">&quot;else &quot;</span> \</span>
<span class="hljs-meta">			   <span class="hljs-string">&quot;if run loadimage; then &quot;</span> \</span>
<span class="hljs-meta">				   <span class="hljs-string">&quot;run mmcboot; &quot;</span> \</span>
<span class="hljs-meta">			   <span class="hljs-string">&quot;else run netboot; &quot;</span> \</span>
<span class="hljs-meta">			   <span class="hljs-string">&quot;fi; &quot;</span> \</span>
<span class="hljs-meta">		   <span class="hljs-string">&quot;fi; &quot;</span> \</span>
<span class="hljs-meta">	   <span class="hljs-string">&quot;else run netboot; fi&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>

<p>看起来很复杂的样子！因为 uboot 使用了类似 shell 脚本语言的方式来编写的，我们一行一行来分析。</p>
<ul>
<li><p>第二行 <code>run findfdt；</code>使用的是 uboot 的 run 命令来运行 findfdt，findfdt 是 NXP 自行添加的环境变量。findfdt 是用来查找开发板对应的设备树文件(.dtb)。IMX6ULL EVK 的设备树文件为 imx6ull-14x14-evk.dtb，findfdt 内容如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;findfdt=&quot;</span>\
          <span class="hljs-string">&quot;if test $fdt_file = undefined; then &quot;</span> \
		<span class="hljs-string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \
			<span class="hljs-string">&quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot;</span> \
		<span class="hljs-string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \
			<span class="hljs-string">&quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot;</span> \
		<span class="hljs-string">&quot;if test $fdt_file = undefined; then &quot;</span> \
			<span class="hljs-string">&quot;echo WARNING: Could not determine dtb to use; fi; &quot;</span> \
	<span class="hljs-string">&quot;fi;\0&quot;</span> \</code></pre></div>

<p><strong>findfdt</strong> 里面用到的变量有 <code>fdt_file</code>，<code>board_name</code>，<code>board_rev</code>，这三个变量内容如下：</p>
<p><strong>fdt_file&#x3D;undefined，board_name&#x3D;EVK，board_rev&#x3D;14X14</strong></p>
<p><strong>findfdt</strong> 做的事情就是判断这些变量值从而得出所需的.dtb 文件名。此时 fdt_file 为 undefined，所以根据 board_name 和board_rev 来判断实际所需的.dtb 文件。</p>
<p>根据当前变量值，板子的设备树文件就是 imx6ull-14x14-evk.dtb，因此 run findfdt 的结果就是设置 fdt_file 为 imx6ull-14x14-evk.dtb。</p>
</li>
<li><p><code>mmc dev $&#123;mmcdev&#125;</code>用于切换 mmc 设备，mmcdev 为 1，因此这行代码就是：<code>mmc dev 1</code>，也就是切换到 EMMC 上。</p>
</li>
<li><p><code>&quot;mmc dev $&#123;mmcdev&#125;; if mmc rescan; then &quot; </code>先执行 mmc dev ${mmcdev}切换到 EMMC 上，然后使用命令 mmc rescan 扫描看有没有 SD 卡或者 EMMC 存在，如果没有的话就直接跳到<code>run netboot;&quot;</code>执行 run netboot，<strong>netboot</strong>也是一个自定义的环境变量，这个变量是从网络启动 Linux 的。如果 mmc 设备存在的话就从mmc 设备启动。</p>
</li>
<li><p>第五行<code>&quot;if run loadbootscript; then &quot;</code>运行 loadbootscript 环境变量，此环境变量内容如下：</p>
<p><code>loadbootscript=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;</code></p>
<p>其中 mmcdev&#x3D;1，mmcpart&#x3D;1，loadaddr&#x3D;0x80800000，script&#x3D; boot.scr，因此展开以后就是：</p>
<p><code>loadbootscript=fatload mmc 1:1 0x80800000 boot.scr;</code></p>
<p>loadbootscript 就是从 mmc1 的分区 1 中读取文件 boot.src 到 DRAM 的 0X80800000 处。但是 mmc1 的分区 1 中没有 boot.src 这个文件，可以使用命令“ls mmc 1:1”查看一下 mmc1 分区1 中的所有文件，看看有没有 boot.src 这个文件。</p>
<p>之后的一行<code>&quot;run bootscript; &quot;</code>如果加载 boot.src 文件成功的话就运行 bootscript 环境变量，bootscript 的内容如下：<br><code>bootscript=echo Running bootscript from mmc ...;</code><br><code>source</code><br>因为 boot.src 文件不存在，所以 bootscript 也就不会运行。</p>
</li>
<li><p>&#96;&#96;&#96;<br> “else “ <br> “if run loadimage; then “ <br>     “run mmcboot; “ <br> “else run netboot; “ <br> “fi; “ <br> “fi; “ \</p>
<div class="code-wrapper"><pre><code class="hljs routeros">
  如果 loadbootscript 没有找到 boot.src 的话就运行环境变量`<span class="hljs-built_in">run</span> loadimage`，环境变量loadimage 内容如下：
  `<span class="hljs-attribute">loadimage</span>=fatload mmc <span class="hljs-variable">$&#123;mmcdev&#125;</span>:<span class="hljs-variable">$&#123;mmcpart&#125;</span> <span class="hljs-variable">$&#123;loadaddr&#125;</span> <span class="hljs-variable">$&#123;image&#125;</span>`
  其中 <span class="hljs-attribute">mmcdev</span>=1，mmcpart=1，loadaddr=0x80800000，image = zImage，展开以后就是：
  `<span class="hljs-attribute">loadimage</span>=fatload mmc 1:1 0x80800000 zImage`
  可以看出 loadimage 就是从 mmc1 的分区中读取 zImage 到内存的 0X80800000 处，而 mmc1
  的分区 1 中存在 zImage。

- `<span class="hljs-string">&quot;run mmcboot; &quot;</span>`，加载 linux 镜像文件 zImage 成功以后就运行环境变量 mmcboot，否则的话运行netboot 环境变量。mmcboot 环境变量如下：

  ```c
  	<span class="hljs-string">&quot;mmcboot=echo Booting from mmc ...; &quot;</span> \
  		<span class="hljs-string">&quot;run mmcargs; &quot;</span> \
  		<span class="hljs-string">&quot;if test <span class="hljs-variable">$&#123;boot_fdt&#125;</span> = yes || test <span class="hljs-variable">$&#123;boot_fdt&#125;</span> = try; then &quot;</span> \
  			<span class="hljs-string">&quot;if run loadfdt; then &quot;</span> \
  				<span class="hljs-string">&quot;bootz <span class="hljs-variable">$&#123;loadaddr&#125;</span> - <span class="hljs-variable">$&#123;fdt_addr&#125;</span>; &quot;</span> \
  			<span class="hljs-string">&quot;else &quot;</span> \
  				<span class="hljs-string">&quot;if test <span class="hljs-variable">$&#123;boot_fdt&#125;</span> = try; then &quot;</span> \
  					<span class="hljs-string">&quot;bootz; &quot;</span> \
  				<span class="hljs-string">&quot;else &quot;</span> \
  					<span class="hljs-string">&quot;echo WARN: Cannot load the DT; &quot;</span> \
  				<span class="hljs-string">&quot;fi; &quot;</span> \
  			<span class="hljs-string">&quot;fi; &quot;</span> \
  		<span class="hljs-string">&quot;else &quot;</span> \
  			<span class="hljs-string">&quot;bootz; &quot;</span> \
  		<span class="hljs-string">&quot;fi;\0&quot;</span> \</code></pre></div></li>
</ul>
<p>Linux 内核启动，如此复杂的设置就是为了从 EMMC 中读取 zImage 镜像文件和设备树文件。经过分析，浓缩出来的仅仅是 4 行精华：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">mmc</span> dev <span class="hljs-number">1</span>  //切换到 EMMC
<span class="hljs-attribute">fatload</span> mmc <span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">0</span>x80800000 zImage //读取 zImage 到 <span class="hljs-number">0</span>x80800000 处
<span class="hljs-attribute">fatload</span> mmc <span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">0</span>x83000000 imx6ull-<span class="hljs-number">14</span>x14-evk.dtb //读取设备树到 <span class="hljs-number">0</span>x83000000 处
<span class="hljs-attribute">bootz</span> <span class="hljs-number">0</span>x80800000 - <span class="hljs-number">0</span>x83000000 //启动 Linux</code></pre></div>

<p>NXP 官方将 CONFIG_BOOTCOMMAND 写的这么复杂只有一个目的：为了兼容多个板子，所以写了个很复杂的脚本。当我们明确知道我们所使用的板子的时候就可以大幅简化宏CONFIG_BOOTCOMMAND 的 设 置 ，比 如 我 们 要 从 EMMC 启 动 ， 那 么 宏CONFIG_BOOTCOMMAND 就可简化为：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_BOOTCOMMAND \</span>
<span class="hljs-meta"><span class="hljs-string">&quot;mmc dev 1;&quot;</span> \</span>
<span class="hljs-meta"><span class="hljs-string">&quot;fatload mmc 1:1 0x80800000 zImage;&quot;</span> \</span>
<span class="hljs-meta"><span class="hljs-string">&quot;fatload mmc 1:1 0x83000000 imx6ull-alientek-emmc.dtb;&quot;</span> \</span>
<span class="hljs-meta"><span class="hljs-string">&quot;bootz 0x80800000 - 0x83000000;&quot;</span></span></code></pre></div>

<p>或者可以直接在 uboot 中设置 bootcmd 的值，这个值就是保存到 EMMC 中的，命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs sh">setenv bootcmd <span class="hljs-string">&#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-lxg-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span></code></pre></div>

<h5 id="bootcmd设置栗子"><a href="#bootcmd设置栗子" class="headerlink" title="bootcmd设置栗子"></a>bootcmd设置栗子</h5><h6 id="从EMMC启-动"><a href="#从EMMC启-动" class="headerlink" title="从EMMC启 动"></a>从EMMC启 动</h6><div class="code-wrapper"><pre><code class="hljs sh">setenv bootcmd <span class="hljs-string">&#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-lxg-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span></code></pre></div>

<h6 id="从SD卡-启动"><a href="#从SD卡-启动" class="headerlink" title="从SD卡 启动"></a>从SD卡 启动</h6><div class="code-wrapper"><pre><code class="hljs sh">setenv bootcmd <span class="hljs-string">&#x27;mmc dev 0; fatload mmc 0:1 80800000 zImage; fatload mmc 0:1 83000000 imx6ull-lxg-emmc.dtb; bootz 80800000 – 83000000;&#x27;</span></code></pre></div>

<hr>
<h4 id="2、bootargs环境变量"><a href="#2、bootargs环境变量" class="headerlink" title="2、bootargs环境变量"></a>2、bootargs环境变量</h4><h5 id="bootargs默认宏定义设置的解析"><a href="#bootargs默认宏定义设置的解析" class="headerlink" title="bootargs默认宏定义设置的解析"></a>bootargs默认宏定义设置的解析</h5><p>bootargs 保存着 uboot 传递给 Linux 内核的参数，是由 <strong>mmcargs</strong> 设置的，mmcargs 环境变量如下：<br><code>mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</code></p>
<p>其中 console&#x3D;ttymxc0，baudrate&#x3D;115200，mmcroot&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw，因此将<br>mmcargs 展开以后就是：</p>
<p><code>mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw</code></p>
<p>可以看出环境变量 mmcargs 就是设置 bootargs 的值为：</p>
<p><code>“console= ttymxc0, 115200 root=/dev/mmcblk1p2 rootwait rw”</code></p>
<p>bootargs 就是设置了很多的参数的值。</p>
<p>例：</p>
<div class="code-wrapper"><pre><code class="hljs sh">setenv bootartgs <span class="hljs-string">&#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span></code></pre></div>

<p><strong>1 、console</strong></p>
<p>console 用来设置 linux 终端(或者叫控制台)，也就是通过什么设备来和 Linux 进行交互，是串口还是 LCD 屏幕？如果是串口的话应该是串口几等等。一般设置串口作为 Linux 终端，这样我们就可以在电脑上通过 SecureCRT 来和 linux 交互了。这里设置 console 为 ttymxc0，因为 linux启动以后 I.MX6ULL 的串口 1 在 linux 下的设备文件就是&#x2F;dev&#x2F;ttymxc0，在 Linux 下，一切皆文件。ttymxc0 后面有个“,115200”，这是设置串口的波特率，<strong>console&#x3D;ttymxc0,115200</strong> 综合起来就是设置 ttymxc0（也就是串口 1）作为 Linux 的终端，并且串口波特率设置为 115200。</p>
<p><strong>2 、root</strong></p>
<p>root 用来设置根文件系统的位置，<strong>root&#x3D;&#x2F;dev&#x2F;mmcblk1p2</strong> 用于指明根文件系统存放在mmcblk1 设备的分区 2 中。root 后面有<strong>“rootwait rw”</strong>，rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话mmc 设备还没初始化完成就挂载根文件系统会出错的。<strong>rw</strong> 表示根文件系统是可以读写的</p>
<p><strong>3 、rootfstype</strong></p>
<p>此选项一般配置 root 一起使用，rootfstype 用于指定根文件系统类型，如果根文件系统为ext 格式的话此选项无所谓。如果根文件系统是 yaffs、jffs 或 ubifs 的话就需要设置此选项，指定根文件系统的类型。</p>
<p>bootargs 常设置的选项就这三个</p>
<hr>
<h5 id="bootargs设置栗子"><a href="#bootargs设置栗子" class="headerlink" title="bootargs设置栗子"></a>bootargs设置栗子</h5><h6 id="挂载根文件至mmc设备："><a href="#挂载根文件至mmc设备：" class="headerlink" title="挂载根文件至mmc设备："></a>挂载根文件至mmc设备：</h6><p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs sh">setenv bootargs <span class="hljs-string">&#x27;console=ttymxc0,115200 root=/dev/mmcblk0p2 rootwait rw&#x27;</span></code></pre></div>

<hr>
<h6 id="挂载根文件至nfs网络下："><a href="#挂载根文件至nfs网络下：" class="headerlink" title="挂载根文件至nfs网络下："></a>挂载根文件至nfs网络下：</h6><p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs sh">setenv bootargs <span class="hljs-string">&#x27;console=ttymxc0,115200 root=/dev/nfs rw nfsroot=192.168.0.111:/home/firestaradmin/linux/nfs/rootfs ip=192.168.0.112:192.168.0.111:192.168.0.1:255.255.255.0::eth0:off&#x27;</span></code></pre></div>

<p>在 Linux 内核源码里面有相应的文档讲解如何设置，文档为Documentation&#x2F;filesystems&#x2F;nfs&#x2F;nfsroot.txt，格式如下：</p>
<div class="code-wrapper"><pre><code class="hljs ruby">root=<span class="hljs-regexp">/dev/nfs</span> nfsroot=[&lt;server-ip&gt;<span class="hljs-symbol">:</span>]&lt;root-dir&gt;[,&lt;nfs-options&gt;] 
ip=&lt;client-ip&gt;<span class="hljs-symbol">:&lt;server-ip&gt;</span><span class="hljs-symbol">:&lt;gw-ip&gt;</span><span class="hljs-symbol">:&lt;netmask&gt;</span>:
&lt;hostname&gt;<span class="hljs-symbol">:&lt;device&gt;</span><span class="hljs-symbol">:&lt;autoconf&gt;</span><span class="hljs-symbol">:&lt;dns0-ip&gt;</span><span class="hljs-symbol">:&lt;dns1-ip&gt;</span></code></pre></div>

<p><server-ip>：   服务器 IP 地址，也就是存放根文件系统主机的 IP 地址，那就是Ubuntu 的 IP地址，比如我的 Ubuntu 主机 IP 地址为 192.168.1.250。</server-ip></p>
<p><root-dir> ：   根文件系统的存放路径，比如我的就是&#x2F;home&#x2F;firestaradmin&#x2F;linux&#x2F;nfs&#x2F;rootfs。</root-dir></p>
<p><nfs-options>：  NFS 的其他可选选项，一般不设置。</nfs-options></p>
<p><client-ip> ：   客户端 IP 地址，也就是我们开发板的 IP 地址，Linux 内核启动以后就会使用此 IP 地址来配置开发板。</client-ip></p>
<p><server-ip> ：   服务器 IP 地址，前面已经说了。</server-ip></p>
<p><gw-ip> ：     网关地址，我的就是 192.168.1.1。</gw-ip></p>
<p><netmask>：    子网掩码，我的就是 255.255.255.0。</netmask></p>
<p><hostname>：   客户机的名字，一般不设置，此值可以空着。</hostname></p>
<p><device> ：     设备名，也就是网卡名，一般是 eth0，eth1….，正点原子的 I.MX6U-ALPHA 开发板的 ENET2 为 eth0，ENET1 为 eth1。如果你的电脑只有一个网卡，那么基本只能是 eth0。这里我们使用 ENET2，所以网卡名就是 eth0。</device></p>
<p><autoconf> ：   自动配置，一般不使用，所以设置为 off。</autoconf></p>
<p><dns0-ip> ：   DNS0 服务器 IP 地址，不使用。</dns0-ip></p>
<p><dns1-ip> ：   DNS1 服务器 IP 地址，不使用。</dns1-ip></p>
<hr>
<h6 id="Pc机Ubuntn-的nfs配置："><a href="#Pc机Ubuntn-的nfs配置：" class="headerlink" title="Pc机Ubuntn 的nfs配置："></a>Pc机Ubuntn 的nfs配置：</h6><p>安装NFS服务：</p>
<div class="code-wrapper"><pre><code class="hljs sh">sudo apt-get install nfs-kernel-server rpcbind</code></pre></div>

<p>配置NFS文件：</p>
<p>​    <strong>打开 nfs 配置文件&#x2F;etc&#x2F;exports：</strong></p>
<p>​    <strong>打开&#x2F;etc&#x2F;exports 以后在文件后面添加如下所示内容：</strong></p>
<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/home/</span>firestaradmin<span class="hljs-regexp">/linux/</span>nfs *(rw,sync,no_root_squash)</code></pre></div>

<p>重启 NFS 服务，使用命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">sudo /etc/init.d/nfs-kernel-server restart</code></pre></div>

<h2 id="uboot图形化配置"><a href="#uboot图形化配置" class="headerlink" title="uboot图形化配置"></a>uboot图形化配置</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>在前两章中我们知道 uboot 可以通过 mx6ull_lxg_emmc_defconfig 来配置，或者通过文件mx6ull_lxg_emmc.h 来配置 uboot。还有另外一种配置 uboot 的方法，就是图形化配置.</p>
<p>uboot 或 Linux 内核可以通过输入“<strong>make menuconfig</strong>”来打开图形化配置界面，menuconfig是一套图形化的配置工具，需要 ncurses 库支持。ncurses 库提供了一系列的 API 函数供调用者生成基于文本的图形界面，因此需要先在 Ubuntu 中安装 ncurses 库，命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs sh">sudo apt-get install build-essential
sudo apt-get install libncurses5-dev</code></pre></div>

<p>menuconfig 重点会用到uboot根目录的两个文件：<code>.config</code> 和 <code>Kconfig</code>，<code>.config </code>文件前面已经说了，这个文件保存着 uboot 的配置项，使用 menuconfig 配置完 uboot 以后肯定要更新.config 文件。Kconfig文件是图形界面的描述文件，也就是描述界面应该有什么内容，很多目录下都会有 Kconfig 文件。</p>
<p>在打开图形化配置界面之前，要先使用“make xxx_defconfig”对 uboot 进行一次默认配置，只需要一次即可。如果使用“make clean”清理了工程的话就那就需要重新使用“make xxx_defconfig”再对 uboot 进行一次配置。进入 uboot 根目录，输入如下命令：</p>
<div class="code-wrapper"><pre><code class="hljs sh">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_lxg_emmc_defconfig
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</code></pre></div>

<p>如果已经在 uboot 的顶层 Makefile 中定义了 ARCH 和 CROSS_COMPILE 的值，那么上述命令可以简化为：</p>
<div class="code-wrapper"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> mx6ull_lxg_emmc_defconfig
<span class="hljs-built_in">make</span> menuconfig</code></pre></div>

<p>打开后的图形化界面如图 34.1.1 所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818235039839.png" srcset="/img/loading.gif" lazyload alt="image-20200818235039839"></p>
<h3 id="使能-dns-命令"><a href="#使能-dns-命令" class="headerlink" title="使能 dns 命令"></a>使能 dns 命令</h3><p>我们就以如何使能 dns 命令为例，讲解一下如何通过图形化界面来配置 uboot。进入“Command line interface —&gt;”这个配置项，此配置项用于配置 uboot 的命令，进入以后如图所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112010754.png" srcset="/img/loading.gif" lazyload alt="image-20200819112010754"></p>
<p>从图 34.1.2 可以看出，有很多配置项，这些配置项也有子配置项，</p>
<p>选择“Network commands—&gt;”，进入网络相关命令配置项，如图所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112039004.png" srcset="/img/loading.gif" lazyload alt="image-20200819112039004"></p>
<p>从图可以看出，uboot 中有很多和网络有关的命令，比如 bootp、tftpboot、dhcp 等等。选中 dns，然后按下键盘上的“Y”键，此时 dns 前面的“[ ]”变成了“[ * ]”，如图所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112102964.png" srcset="/img/loading.gif" lazyload alt="image-20200819112102964"></p>
<p>每个选项有 3 种编译选项：</p>
<ul>
<li>编译进 uboot 中(也就是编译进 u-boot.bin 中)</li>
<li>取消编译(也就是不编译这个功能模块)</li>
<li>编译为模块</li>
</ul>
<p>按下“Y”键表示编译进 uboot 中，此时“[ ]”变成了“[ * ]”；</p>
<p>按下“N”表示不编译，“[ ]”默认表示不编译；</p>
<p>有些功能模块是支持编译为模块的，这个一般在 Linux 内核里面很常用，uboot 下面不使用，如果要将某个功能编译为模块，那就按下“M”，此时“[ ]”就会变为“&lt; M &gt;”。</p>
<p>细心的朋友应该会发现，在 mx6ull_lxg_emmc.h 里面我们配置使能了 dhcp 和 ping 命令，但是在图 中 dhcp 和 ping 前面的“[ ]”并不是“[ * ]”，也就是说不编译 dhcp 和 ping命令，这不是冲突了吗？实际情况是 dhcp 和 ping 命令是会编译的。之所以在图中没有体现出来时因为我们是直接在mx6ull_lxg_emmc.h 中定义的宏 CONFIG_CMD_PING 和CONFIG_CMD_DHCP，而 menuconfig 是通过读取.config 文件来判断使能了哪些功能，.config里面并没有宏CONFIG_CMD_PING ,CONFIG_CMD_DHCP，所以menuconfig就会识别出错。</p>
<p>选中 dns，然后按下“H”或者“?”键可以打开 dns 命令的提示信息，如图所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112413619.png" srcset="/img/loading.gif" lazyload alt="image-20200819112413619"></p>
<hr>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112518396.png" srcset="/img/loading.gif" lazyload alt="image-20200819112518396"></p>
<p>保存会询问是否保存新的配置文件，通过键盘的←或→键来选择“Yes”项，然后按下键盘上的回车键确认保存。至此，我们就完成了通过图形界面使能了 uboot 的 dns 命令，打开.config文件，会发现多了“CONFIG_CMD_DNS&#x3D;y”这一行，如图所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112728189.png" srcset="/img/loading.gif" lazyload alt="image-20200819112728189"></p>
<p>使用如下命令编译 uboot：</p>
<p><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</code></p>
<p>千万不能使用如下命令：</p>
<p><code>./mx6ull_lxg_emmc.sh</code></p>
<p>因为 mx6ull_lxg_emmc.sh 在编译之前会清理工程，会删除掉.config 文件！通过图形化界面配置所有配置项都会被删除，结果就是竹篮打水一场空。编译完成以后烧写到 SD 卡中，重启开发板进入 uboot 命令模式，输入“?”查看是否有“dns”命令，一般肯定有的。测试一下 dns 命令工作是否正常，使用 dns 命令来查看一下百度官网“<a target="_blank" rel="noopener" href="http://www.baidu.com”的/">www.baidu.com”的</a> IP 地址。要先设置一下 dns 服务器的 IP 地址，也就是设置环境变量 dnsip的值，命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs sh">setenv dnsip 114.114.114.114
saveenv</code></pre></div>

<p>设置好以后就可以使用 dns 命令查看百度官网的 IP 地址了，输入命令：<br><code>dns www.baidu.com</code><br>结果如图所示：</p>
<p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819114151182.png" srcset="/img/loading.gif" lazyload alt="image-20200819114151182"></p>
<p>从图可以看出，“<a target="_blank" rel="noopener" href="http://www.baidu.com”的/">www.baidu.com”的</a> IP 地址，说明 dns 命令工作正常。这个就是通过图形化命令来配置 uboot，一般用来使能一些命令还是很方便的，这样就不需要到处找命令的配置宏是什么，然后在到配置文件里面去定义。</p>
<h3 id="menuconfig-图形化配置原理"><a href="#menuconfig-图形化配置原理" class="headerlink" title="menuconfig 图形化配置原理"></a>menuconfig 图形化配置原理</h3><p>参考正点原子I.MX6U驱动开发指南的第34.2节。</p>
<h3 id="Kconfig-语法简介"><a href="#Kconfig-语法简介" class="headerlink" title="Kconfig  语法简介"></a>Kconfig  语法简介</h3><p>参考正点原子I.MX6U驱动开发指南的第34.2节。</p>
<h3 id="添加自定义菜单"><a href="#添加自定义菜单" class="headerlink" title="添加自定义菜单"></a>添加自定义菜单</h3><p>参考正点原子I.MX6U驱动开发指南的第34.3节。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/">环境搭建系统移植篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/uboot/">uboot</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">8| linux内核移植</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/05/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/6.IMX6U%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/">
                        <span class="hidden-mobile">6| 裸机程序编译运行</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
