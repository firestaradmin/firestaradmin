

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux 并发与竞争Linux是一个多任务操作系统，肯定会存在多个任务共同操作同一段内存或者设备的情况，多个任务甚至中断都能访问的资源叫做共享资源，就和共享单车一样。 在驱动开发中要注意对共享资源的保护，也就是要处理对共享资源的并发访问。比如共享单车，大家按照谁扫谁骑走的原则来共用这个单车，如果没有这个并发访问共享单车的原则存在，只怕到时候为了一辆单车要打起来了。在 Linux 驱动编写过程中对">
<meta property="og:type" content="article">
<meta property="og:title" content="6| Linux 并发与竞争">
<meta property="og:url" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Linux 并发与竞争Linux是一个多任务操作系统，肯定会存在多个任务共同操作同一段内存或者设备的情况，多个任务甚至中断都能访问的资源叫做共享资源，就和共享单车一样。 在驱动开发中要注意对共享资源的保护，也就是要处理对共享资源的并发访问。比如共享单车，大家按照谁扫谁骑走的原则来共用这个单车，如果没有这个并发访问共享单车的原则存在，只怕到时候为了一辆单车要打起来了。在 Linux 驱动编写过程中对">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822122404451.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822122434573.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822124306210.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822125245285.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822125304199.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822125441574.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200823150509236.png">
<meta property="article:published_time" content="2020-09-10T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-10T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822122404451.png">
  
  
  <title>6| Linux 并发与竞争 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="6| Linux 并发与竞争">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-11 00:00" pubdate>
        2020年9月11日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      37k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      312 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">6| Linux 并发与竞争</h1>
            
            <div class="markdown-body">
              <h1 id="Linux-并发与竞争"><a href="#Linux-并发与竞争" class="headerlink" title="Linux 并发与竞争"></a>Linux 并发与竞争</h1><p>Linux是一个多任务操作系统，肯定会存在多个任务共同操作同一段内存或者设备的情况，多个任务甚至中断都能访问的资源叫做共享资源，就和共享单车一样。</p>
<p>在驱动开发中要注意对共享资源的保护，也就是要处理对共享资源的并发访问。比如共享单车，大家按照谁扫谁骑走的原则来共用这个单车，如果没有这个并发访问共享单车的原则存在，只怕到时候为了一辆单车要打起来了。在 Linux 驱动编写过程中对于并发控制的管理非常重要，本章我们就来学习一下如何在 Linux 驱动中处理并发。</p>
<h2 id="1-并发与竞争"><a href="#1-并发与竞争" class="headerlink" title="1|并发与竞争"></a>1|并发与竞争</h2><h3 id="1、并发与竞争简介"><a href="#1、并发与竞争简介" class="headerlink" title="1、并发与竞争简介"></a>1、并发与竞争简介</h3><p>并发就是多个“用户”同时访问同一个共享资源，比如你们公司有一台打印机，你们公司的所有人都可以使用。现在小李和小王要同时使用这一台打印机，都要打印一份文件。</p>
<p>这两份文档肯定是各自打印出来的，不能相互影响。当两个人同时打印的话如果打印机不做处理的话可能会出现小李的文档打印了一行，然后开始打印小王的文档，这样打印出来的文档就错乱了。</p>
<p>这是绝对不允许的。如果有多人同时向打印机发送了多份文档，打印机必须保证一次只能打印一份文档，只有打印完成以后才能打印其他的文档。</p>
<p><strong>Linux 系统是个多任务操作系统，会存在多个任务同时访问同一片内存区域，这些任务可能会相互覆盖这段内存中的数据，造成内存数据混乱。</strong>针对这个问题必须要做处理，严重的话可能会导致系统崩溃。现在的 Linux 系统并发产生的原因很复杂，总结一下有下面几个主要原因：</p>
<ul>
<li><strong>①、多线程并发访问</strong>，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。</li>
<li><strong>②、抢占式并发访问</strong>，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。</li>
<li><strong>③、中断程序并发访问</strong>，这个无需多说，学过 STM32 的同学应该知道，硬件中断的权利可是很大的。</li>
<li><strong>④、SMP(多核)核间并发访问</strong>，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并发访问。</li>
</ul>
<p>并发访问带来的问题就是竞争，学过FreeRTOS和UCOS的同学应该知道临界区这个概念，所谓的临界区就是共享数据段，对于临界区必须保证一次只有一个线程访问，也就是要保证临界区是原子访问的，注意这里的“原子”不是正点原子的“原子”。我们都知道，原子是化学反应不可再分的基本微粒，这里的原子访问就表示这一个访问是一个步骤，不能再进行拆分。如果多个线程同时操作临界区就表示存在竞争，我们在编写驱动的时候一定要注意避免并发和防止竞争访问。很多 Linux 驱动初学者往往不注意这一点，在驱动程序中埋下了隐患，这类问题往往又很不容易查找，导致驱动调试难度加大、费时费力。所以我们一般在编写驱动的时候就要考虑到并发与竞争，而不是驱动都编写完了然后再处理并发与竞争。</p>
<h3 id="2、保护内容是什么"><a href="#2、保护内容是什么" class="headerlink" title="2、保护内容是什么"></a>2、保护内容是什么</h3><p>前面一直说要防止并发访问共享资源，换句话说就是要保护共享资源，防止进行并发访问。那么问题来了，什么是共享资源？现实生活中的公共电话、共享单车这些是共享资源，我们都很容易理解，那么在程序中什么是共享资源？也就是保护的内容是什么？我们保护的不是代码，而是数据！某个线程的局部变量不需要保护，我们要保护的是多个线程都会访问的共享数据。一个整形的全局变量 a 是数据，一份要打印的文档也是数据，虽然我们知道了要对共享数据进行保护，那么怎么判断哪些共享数据要保护呢？找到要保护的数据才是重点，而这个也是难点，因为驱动程序各不相同，那么数据也千变万化，一般像全局变量，设备结构体这些肯定是要保护的，至于其他的数据就要根据实际的驱动程序而定了。</p>
<p>当我们发现驱动程序中存在并发和竞争的时候一定要处理掉，接下来我们依次来学习一下Linux 内核提供的几种并发和竞争的处理方法。 </p>
<h2 id="2-原子操作"><a href="#2-原子操作" class="headerlink" title="2|原子操作"></a>2|原子操作</h2><h3 id="1、原子操作简介"><a href="#1、原子操作简介" class="headerlink" title="1、原子操作简介"></a>1、原子操作简介</h3><p>首先看一下原子操作，<strong>原子操作就是指不能再进一步分割的操作</strong>，一般原子操作用于变量或者位操作。假如现在要对无符号整形变量 a 赋值，值为 3，对于 C 语言来讲很简单，直接就是：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">a = <span class="hljs-number">3</span>;</code></pre></div>

<p>但是 C 语言要先编译为成汇编指令，ARM 架构不支持直接对寄存器进行读写操作，比如要借助寄存器 R0、R1 等来完成赋值操作。假设变量 a 的地址为 0X3000000，“a&#x3D;3”这一行 C语言可能会被编译为如下所示的汇编代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs assembly">1 ldr r0, =0X30000000 /* 变量 a 地址 */
2 ldr r1, = 3 /* 要写入的值 */
3 str r1, [r0] /* 将 3 写入到 a 变量中 */</code></pre></div>

<p>示例代码  只是一个简单的举例说明，实际的结果要比示例代码复杂的多。从上述代码可以看出，C 语言里面简简单单的一句“a&#x3D;3”，编译成汇编文件以后变成了 3 句，那么程序在执行的时候肯定是按照示例代码 中的汇编语句一条一条的执行。假设现在线程 A要向 a 变量写入 10 这个值，而线程 B 也要向 a 变量写入 20 这个值，我们理想中的执行顺序如图所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822122404451.png" srcset="/img/loading.gif" lazyload alt="image-20200822122404451"></p>
<p>按照图  所示的流程，确实可以实现线程 A 将 a 变量设置为 10，线程 B 将 a 变量设置为 20。但是实际上的执行流程可能如下图所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822122434573.png" srcset="/img/loading.gif" lazyload alt="image-20200822122434573"></p>
<p>按照图 所示的流程，线程 A 最终将变量 a 设置为了 20，而并不是要求的 10！线程B 没有问题。这就是一个最简单的设置变量值的并发与竞争的例子，要解决这个问题就要保证示例代码  中的三行汇编指令作为一个整体运行，也就是作为一个原子存在。</p>
<p>Linux 内核提供了两组原子操作 API 函数，一组是对整形变量进行操作的，一组是对位进行操作的，我们接下来看一下这些 API 函数。</p>
<h3 id="2、原子整形操作API函数"><a href="#2、原子整形操作API函数" class="headerlink" title="2、原子整形操作API函数"></a>2、原子整形操作API函数</h3><p>Linux 内核定义了叫做 <strong>atomic_t</strong> 的结构体来完成整形数据的原子操作，在使用中用原子变量来代替整形变量，此结构体定义在 <strong>include&#x2F;linux&#x2F;types.h</strong> 文件中，定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">175</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>
<span class="hljs-number">176</span> 	<span class="hljs-type">int</span> counter;
<span class="hljs-number">177</span> &#125; <span class="hljs-type">atomic_t</span>;</code></pre></div>

<p>如果要使用原子操作 API 函数，首先要先定义一个 atomic_t 的变量，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">atomic_t</span> a; <span class="hljs-comment">//定义 a</span></code></pre></div>

<p>也可以在定义原子变量的时候给原子变量赋初值，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">atomic_t</span> b = ATOMIC_INIT(<span class="hljs-number">0</span>); <span class="hljs-comment">//定义原子变量 b 并赋初值为 0</span></code></pre></div>

<p>可以通过宏 ATOMIC_INIT 向原子变量赋初值。</p>
<p>原子变量有了，接下来就是对原子变量进行操作，比如读、写、增加、减少等等，Linux 内核提供了大量的原子操作 API 函数，如表所示：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ATOMIC_INIT(int i)</td>
<td align="left">定义原子变量的时候对其初始化</td>
</tr>
<tr>
<td align="left">int atomic_read(atomic_t *v)</td>
<td align="left">读取 v 的值，并且返回。</td>
</tr>
<tr>
<td align="left">void atomic_set(atomic_t *v, int i)</td>
<td align="left">向 v 写入 i 值。</td>
</tr>
<tr>
<td align="left">void atomic_add(int i, atomic_t *v)</td>
<td align="left">给 v 加上 i 值。</td>
</tr>
<tr>
<td align="left">void atomic_sub(int i, atomic_t *v)</td>
<td align="left">从 v 减去 i 值。</td>
</tr>
<tr>
<td align="left">void atomic_inc(atomic_t *v)</td>
<td align="left">给 v 加 1，也就是自增。</td>
</tr>
<tr>
<td align="left">void atomic_dec(atomic_t *v)</td>
<td align="left">从 v 减 1，也就是自减</td>
</tr>
<tr>
<td align="left">int atomic_dec_return(atomic_t *v)</td>
<td align="left">从 v 减 1，并且返回 v 的值。</td>
</tr>
<tr>
<td align="left">int atomic_inc_return(atomic_t *v)</td>
<td align="left">给 v 加 1，并且返回 v 的值。</td>
</tr>
<tr>
<td align="left">int atomic_sub_and_test(int i, atomic_t *v)</td>
<td align="left">从 v 减 i，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td align="left">int atomic_dec_and_test(atomic_t *v)</td>
<td align="left">从 v 减 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td align="left">int atomic_inc_and_test(atomic_t *v)</td>
<td align="left">给 v 加 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td align="left">int atomic_add_negative(int i, atomic_t *v)</td>
<td align="left">给 v 加 i，如果结果为负就返回真，否则返回假</td>
</tr>
</tbody></table>
<p>如果使用 64 位的 SOC 的话，就要用到 64 位的原子变量，Linux 内核也定义了 64 位原子结构体，如下所示</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>
	<span class="hljs-type">long</span> <span class="hljs-type">long</span> counter;
&#125; <span class="hljs-type">atomic64_t</span>;</code></pre></div>

<p>相应的也提供了 64 位原子变量的操作 API 函数，这里我们就不详细讲解了，和表 中的 API 函数用法一样，只是将“atomic_”前缀换为“atomic64_”，将 int 换为 long long。如果使用的是 64 位的 SOC，那么就要使用 64 位的原子操作函数。Cortex-A7 是 32 位的架构，所以本文档只使用表 47.2.2.1 中的 32 位原子操作函数。原子变量和相应的 API 函数使用起来很简单，参考如下示例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">atomic_t</span> v = ATOMIC_INIT(<span class="hljs-number">0</span>); <span class="hljs-comment">/* 定义并初始化原子变零 v=0 */</span>
<span class="hljs-type">atomic_set</span>(<span class="hljs-number">10</span>); 		<span class="hljs-comment">/* 设置 v=10 */</span>
<span class="hljs-type">atomic_read</span>(&amp;v); 		<span class="hljs-comment">/* 读取 v 的值，肯定是 10 */</span>
<span class="hljs-type">atomic_inc</span>(&amp;v); 		<span class="hljs-comment">/* v 的值加 1，v=11 */</span></code></pre></div>

<h3 id="3、原子位操作-API-函数"><a href="#3、原子位操作-API-函数" class="headerlink" title="3、原子位操作 API  函数"></a>3、原子位操作 API  函数</h3><p>位操作也是很常用的操作，Linux 内核也提供了一系列的原子位操作 API 函数，只不过原子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作，API 函数如表  所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位 置 1。</td>
</tr>
<tr>
<td>void clear_bit(int nr,void *p)</td>
<td>将 p 地址的第 nr 位 清零。</td>
</tr>
<tr>
<td>void change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位 进行翻转。</td>
</tr>
<tr>
<td>int test_bit(int nr, void *p)</td>
<td>获取 p 地址的第 nr 位 的值。</td>
</tr>
<tr>
<td>int test_and_set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位 置 1，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_clear_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位 清零，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位 翻转，并且返回 nr 位原来的值。</td>
</tr>
</tbody></table>
<h2 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3|自旋锁"></a>3|自旋锁</h2><h3 id="1、自旋锁简介"><a href="#1、自旋锁简介" class="headerlink" title="1、自旋锁简介"></a>1、自旋锁简介</h3><p>原子操作只能对整形变量或者位进行保护，但是，在实际的使用环境中怎么可能只有整形变量或位这么简单的临界区。举个最简单的例子，设备结构体变量就不是整型变量，我们对于结构体中成员变量的操作也要保证原子性，在线程 A 对结构体变量使用期间，应该禁止其他的线程来访问此结构体变量，这些工作原子操作都不能胜任，需要本节要讲的锁机制，在 Linux内核中就是<strong>自旋锁</strong>。</p>
<p><strong>当一个线程要访问某个共享资源的时候首先要先获取相应的锁，锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁</strong>。对于自旋锁而言，如果自旋锁正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线程 B 不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁可用。比如现在有个公用电话亭，一次肯定只能进去一个人打电话，现在电话亭里面有人正在打电话，相当于获得了自旋锁。此时你到了电话亭门口，因为里面有人，所以你不能进去打电话，相当于没有获取自旋锁，这个时候你肯定是站在原地等待，你可能因为无聊的等待而转圈圈消遣时光，反正就是哪里也不能去，要一直等到里面的人打完电话出来。终于，里面的人打完电话出来了，相当于释放了自旋锁，这个时候你就可以使用电话亭打电话了，相当于获取到了自旋锁。</p>
<p>自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以用，可以访问共享资源。把自旋锁比作一个变量 a，变量 a&#x3D;1 的时候表示共享资源可用，当 a&#x3D;0的时候表示共享资源不可用。现在线程 A 要访问共享资源，发现 a&#x3D;0(自旋锁被其他线程持有)，那么线程 A 就会不断的查询 a 的值，直到 a&#x3D;1。从这里我们可以看到<strong>自旋锁的一个缺点</strong>：那就是等待自旋锁的线程会一直处于自旋状态，这样会浪费处理器时间，降低系统性能，所以自旋锁的持有时间不能太长。所以自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了，这个我们后面会讲解。</p>
<p>Linux 内核使用结构体 spinlock_t 表示自旋锁，结构体定义如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">64</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span>
<span class="hljs-number">65</span> 		<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>
<span class="hljs-number">66</span> 			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raw_spinlock</span> <span class="hljs-title">rlock</span>;</span>
<span class="hljs-number">67</span>
<span class="hljs-number">68</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="hljs-number">69</span> <span class="hljs-meta"># <span class="hljs-keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span>
<span class="hljs-number">70</span> 			<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>
<span class="hljs-number">71</span> 				u8 __padding[LOCK_PADSIZE];
<span class="hljs-number">72</span> 				<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lockdep_map</span> <span class="hljs-title">dep_map</span>;</span>
<span class="hljs-number">73</span> 			&#125;;
<span class="hljs-number">74</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-number">75</span> 		&#125;;
<span class="hljs-number">76</span> &#125; <span class="hljs-type">spinlock_t</span>;</code></pre></div>

<p>在使用自旋锁之前，肯定要先定义一个自旋锁变量，定义方法如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">spinlock_t</span> lock; <span class="hljs-comment">//定义自旋锁</span></code></pre></div>

<p>定义好自旋锁变量以后就可以使用相应的 API 函数来操作自旋锁。</p>
<h3 id="2、自旋锁-API-函数"><a href="#2、自旋锁-API-函数" class="headerlink" title="2、自旋锁 API  函数"></a>2、自旋锁 API  函数</h3><p>最基本的自旋锁 API 函数如表 所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化一个自选变量。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非 0，否则返回 0。</td>
</tr>
</tbody></table>
<p>(<strong>建议使用下面的 spin_lock_irqsave&#x2F; spin_unlock_irqrestore 函数来获取锁释放锁</strong>)</p>
<p>表中的自旋锁API函数适用于SMP或支持抢占的单CPU下线程之间的并发访问，也就是用于线程与线程之间，被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数，否则的话会可能会导致死锁现象的发生。</p>
<p>自旋锁会自动禁止抢占，也就说当线程 A得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，好了，死锁发生了！</p>
<p>表  中的 API 函数用于线程之间的并发访问，如果此时中断也要插一脚，中断也想访问共享资源，那该怎么办呢？首先可以肯定的是，中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)，否则可能导致锁死现象的发生，如图 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822124306210.png" srcset="/img/loading.gif" lazyload alt="image-20200822124306210"></p>
<p>在图  中，线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 functionA 函数的时候中断发生了，中断抢走了 CPU 使用权。右边的中断服务函数也要获取 lock 这个锁，但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程 A 是不可能执行的，线程 A 说“你先放手”，中断说“你先放手”，场面就这么僵持着，死锁发生！</p>
<p>最好的解决方法就是获取锁之前关闭本地中断，Linux 内核提供了相应的 API 函数，如表</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_irq(spinlock_t *lock)</td>
<td>禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irq(spinlock_t *lock)</td>
<td>激活本地中断，并释放自旋锁。</td>
</tr>
<tr>
<td>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁。</td>
</tr>
</tbody></table>
<p>使用 spin_lock_irq&#x2F;spin_unlock_irq 的时候需要用户能够确定加锁之前的中断状态，但实际上内核很庞大，运行也是“千变万化”，我们是很难确定某个时刻的中断状态，因此不推荐使用spin_lock_irq&#x2F;spin_unlock_irq。</p>
<p><strong>建议使用 spin_lock_irqsave&#x2F; spin_unlock_irqrestore</strong>，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。一般在线程中使用 spin_lock_irqsave&#x2F;spin_unlock_irqrestore，在中断中使用 spin_lock&#x2F;spin_unlock，示例代码如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> DEFINE_SPINLOCK(lock) <span class="hljs-comment">/* 定义并初始化一个锁 */</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span> <span class="hljs-comment">/* 线程 A */</span>
<span class="hljs-number">4</span> <span class="hljs-type">void</span> <span class="hljs-title function_">functionA</span> <span class="hljs-params">()</span>&#123;
<span class="hljs-number">5</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags; <span class="hljs-comment">/* 中断状态 */</span>
<span class="hljs-number">6</span> 		spin_lock_irqsave(&amp;lock, flags) <span class="hljs-comment">/* 获取锁 */</span>
<span class="hljs-number">7</span> 		<span class="hljs-comment">/* 临界区 */</span>
<span class="hljs-number">8</span> 		spin_unlock_irqrestore(&amp;lock, flags)  <span class="hljs-comment">/* 释放锁 */</span>
<span class="hljs-number">9</span> &#125;
<span class="hljs-number">10</span>
<span class="hljs-number">11</span> <span class="hljs-comment">/* 中断服务函数 */</span>
<span class="hljs-number">12</span> <span class="hljs-type">void</span> <span class="hljs-title function_">irq</span><span class="hljs-params">()</span> &#123;
<span class="hljs-number">13</span> 		spin_lock(&amp;lock) <span class="hljs-comment">/* 获取锁 */</span>
<span class="hljs-number">14</span> 		<span class="hljs-comment">/* 临界区 */</span>
<span class="hljs-number">15</span> 		spin_unlock(&amp;lock) <span class="hljs-comment">/* 释放锁 */</span>
<span class="hljs-number">16</span> &#125;</code></pre></div>

<p><strong>下半部(BH)</strong> 也会竞争共享资源，有些资料也会将下半部叫做底半部。关于下半部后面的章节会讲解，如果要在下半部里面使用自旋锁，可以使用表  中的 API 函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_bh(spinlock_t *lock)</td>
<td>关闭下半部，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_bh(spinlock_t *lock)</td>
<td>打开下半部，并释放自旋锁。</td>
</tr>
</tbody></table>
<h3 id="3、其他类型的锁"><a href="#3、其他类型的锁" class="headerlink" title="3、其他类型的锁"></a>3、其他类型的锁</h3><p>在自旋锁的基础上还衍生出了其他特定场合使用的锁，这些锁在驱动中其实用的不多，更多的是在 Linux 内核中使用，本节我们简单来了解一下这些衍生出来的锁。</p>
<h4 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h4><p>现在有个学生信息表，此表存放着学生的年龄、家庭住址、班级等信息，此表可以随时被修改和读取。此表肯定是数据，那么必须要对其进行保护，如果我们现在使用自旋锁对其进行保护。每次只能一个读操作或者写操作，但是，实际上此表是可以并发读取的。只需要保证在修改此表的时候没人读取，或者在其他人读取此表的时候没有人修改此表就行了。也就是此表的读和写不能同时进行，但是可以多人并发的读取此表。</p>
<p>像这样，<strong>当某个数据结构符合读&#x2F;写或生产者&#x2F;消费者模型的时候就可以使用读写自旋锁</strong>。读写自旋锁为读和写操作提供了不同的锁，一次只能允许一个写操作，也就是只能一个线程持有写锁，而且不能进行读操作。但是当没有写操作的时候允许一个或多个线程持有读锁，可以进行并发的读操作。Linux 内核使用 rwlock_t 结构体表示读写锁，结构体定义如下(删除了条件编译)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>
	<span class="hljs-type">arch_rwlock_t</span> raw_lock;
&#125; <span class="hljs-type">rwlock_t</span>;</code></pre></div>

<p>读写锁操作 API 函数分为两部分，一个是给读使用的，一个是给写使用的，这些 API 函数如表 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822125245285.png" srcset="/img/loading.gif" lazyload alt="image-20200822125245285"></p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822125304199.png" srcset="/img/loading.gif" lazyload alt="image-20200822125304199"></p>
<h4 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h4><p>顺序锁在读写锁的基础上衍生而来的，使用读写锁的时候读操作和写操作不能同时进行。使用顺序锁的话可以允许在写的时候进行读操作，也就是实现同时读写，但是不允许同时进行并发的写操作。虽然顺序锁的读和写操作可以同时进行，但是如果在读的过程中发生了写操作，最好重新进行读取，保证数据完整性。顺序锁保护的资源不能是指针，因为如果在写操作的时候可能会导致指针无效，而这个时候恰巧有读操作访问指针的话就可能导致意外发生，比如读取野指针导致系统崩溃。Linux 内核使用 seqlock_t 结构体表示顺序锁，结构体定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seqcount</span> <span class="hljs-title">seqcount</span>;</span>
    <span class="hljs-type">spinlock_t</span> lock;
&#125; <span class="hljs-type">seqlock_t</span>;</code></pre></div>

<p>关于顺序锁的 API 函数如表 47.3.3.2 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822125441574.png" srcset="/img/loading.gif" lazyload alt="image-20200822125441574"></p>
<h3 id="4、自旋锁使用注意事项"><a href="#4、自旋锁使用注意事项" class="headerlink" title="4、自旋锁使用注意事项"></a>4、自旋锁使用注意事项</h3><p>综合前面关于自旋锁的信息，我们需要在使用自旋锁的时候要注意一下几点：</p>
<ul>
<li>①、因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如稍后要讲的信号量和互斥体。</li>
<li>②、自旋锁保护的临界区内不能调用任何可能导致线程休眠的 API 函数，否则的话可能导致死锁。</li>
<li>③、不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了！</li>
<li>④、在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管你用的是单核的还是多核的 SOC，都将其当做多核 SOC 来编写驱动程序。</li>
</ul>
<h2 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4|信号量"></a>4|信号量</h2><h3 id="1、信号量简介"><a href="#1、信号量简介" class="headerlink" title="1、信号量简介"></a>1、信号量简介</h3><p>大家如果有学习过 FreeRTOS 或者 UCOS 的话就应该对信号量很熟悉，因为<strong>信号量是同步的一种方式</strong>。Linux 内核也提供了信号量机制，信号量常常用于控制对共享资源的访问。</p>
<p>举一个很常见的例子，某个停车场有 100 个停车位，这 100 个停车位大家都可以用，对于大家来说这100 个停车位就是共享资源。假设现在这个停车场正常运行，你要把车停到这个这个停车场肯定要先看一下现在停了多少车了？还有没有停车位？当前停车数量就是一个信号量，具体的停车数量就是这个信号量值，当这个值到 100 的时候说明停车场满了。停车场满的时你可以等一会看看有没有其他的车开出停车场，当有车开出停车场的时候停车数量就会减一，也就是说信号量减一，此时你就可以把车停进去了，你把车停进去以后停车数量就会加一，也就是信号量加一。</p>
<p>这就是一个典型的使用信号量进行共享资源管理的案例，在这个案例中使用的就是<strong>计数型信号量</strong>。</p>
<p>相比于自旋锁，信号量可以使线程进入休眠状态，比如 A 与 B、C 合租了一套房子，这个房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着，等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继续回房间睡觉，这个时候相当于信号量。</p>
<p>可以看出，使用信号量会提高处理器的使用效率，毕竟不用一直傻乎乎的在那里“自旋”等待。但是，信号量的开销要比自旋锁大，因为信号量使线程进入休眠状态以后会切换线程，切换线程就会有开销。总结一下信号量的特点：</p>
<ul>
<li>①、因为信号量可以使等待资源线程进入休眠状态，因此适用于那些占用资源比较久的场合。</li>
<li>②、因此信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。</li>
<li>③、如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。</li>
</ul>
<p>信号量有一个信号量值，相当于一个房子有 10 把钥匙，这 10 把钥匙就相当于信号量值为10。因此，可以通过信号量来控制访问共享资源的访问数量，如果要想进房间，那就要先获取一把钥匙，信号量值减 1，直到 10 把钥匙都被拿走，信号量值为 0，这个时候就不允许任何人进入房间了，因为没钥匙了。如果有人从房间出来，那他要归还他所持有的那把钥匙，信号量值加 1，此时有 1 把钥匙了，那么可以允许进去一个人。相当于通过信号量控制访问资源的线程数，在初始化的时候将信号量值设置的大于 1，那么这个信号量就是<strong>计数型信号量</strong>，<strong>计数型信号量不能用于互斥访问</strong>，因为它允许多个线程同时访问共享资源。如果要互斥的访问共享资源那么信号量的值就不能大于 1，此时的信号量就是一个<strong>二值信号量</strong>。</p>
<h3 id="2、信号量-API-函数"><a href="#2、信号量-API-函数" class="headerlink" title="2、信号量 API  函数"></a>2、信号量 API  函数</h3><p>Linux 内核使用 <strong>semaphore 结构体</strong>表示信号量，结构体内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span>
    <span class="hljs-type">raw_spinlock_t</span> lock;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">wait_list</span>;</span>
&#125;;</code></pre></div>

<p>要想使用信号量就得先定义，然后初始化信号量。有关信号量的 API 函数如表所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEAMPHORE(name)</td>
<td align="left">定义一个信号量，并且设置信号量的值为 1。</td>
</tr>
<tr>
<td>void sema_init(struct semaphore *sem, int val)</td>
<td align="left">初始化信号量 sem，设置信号量值为 val</td>
</tr>
<tr>
<td>void down(struct semaphore *sem)</td>
<td align="left">获取信号量，因为会导致休眠，因此不能在中断中使用。</td>
</tr>
<tr>
<td>int down_trylock(struct semaphore *sem)</td>
<td align="left">尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0，并且不会进入休眠.</td>
</tr>
<tr>
<td>int down_interruptible(struct semaphore *sem)</td>
<td align="left">获取信号量，和 down 类似，只是使用 down 进入休眠状态的线程不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的。</td>
</tr>
<tr>
<td>void up(struct semaphore *sem)</td>
<td align="left">释放信号量</td>
</tr>
</tbody></table>
<p>信号量的使用如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">sem</span>;</span> <span class="hljs-comment">/* 定义信号量 */</span>

sema_init(&amp;sem, <span class="hljs-number">1</span>)； <span class="hljs-comment">/* 初始化信号量 */</span>
    
down(&amp;sem); <span class="hljs-comment">/* 申请信号量 */</span>
<span class="hljs-comment">/* 临界区 */</span>
up(&amp;sem); <span class="hljs-comment">/* 释放信号量 */</span></code></pre></div>





<h2 id="5-互斥体"><a href="#5-互斥体" class="headerlink" title="5|互斥体"></a>5|互斥体</h2><h3 id="1、互斥体简介"><a href="#1、互斥体简介" class="headerlink" title="1、互斥体简介"></a>1、互斥体简介</h3><p>在 FreeRTOS 和 UCOS 中也有互斥体，将信号量的值设置为 1 就可以使用信号量进行互斥访问了，虽然可以通过信号量实现互斥，但是 Linux 提供了一个比信号量更专业的机制来进行互斥，它就是<strong>互斥体—mutex</strong>。<strong>互斥访问表示一次只有一个线程可以访问共享资源</strong>，不能递归申请互斥体。在我们编写 Linux 驱动的时候遇到需要互斥访问的地方建议使用 mutex。Linux 内核使用 mutex 结构体表示互斥体，定义如下(省略条件编译部分)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> &#123;</span>
    <span class="hljs-comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span>
    <span class="hljs-type">atomic_t</span> count;
    <span class="hljs-type">spinlock_t</span> wait_lock;
&#125;;</code></pre></div>

<p>在使用 mutex 之前要先定义一个 mutex 变量。在使用 mutex 的时候要注意如下几点：</p>
<ul>
<li>①、mutex 可以导致休眠，因此不能在中断中使用 mutex，<strong>中断中只能使用自旋锁</strong>。</li>
<li>②、和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。</li>
<li>③、因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁。</li>
</ul>
<h3 id="2、互斥体-API-函数"><a href="#2、互斥体-API-函数" class="headerlink" title="2、互斥体 API  函数"></a>2、互斥体 API  函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name)</td>
<td>定义并初始化一个 mutex 变量。</td>
</tr>
<tr>
<td>void mutex_init(mutex *lock)</td>
<td>初始化 mutex</td>
</tr>
<tr>
<td>void mutex_lock(struct mutex *lock)</td>
<td>获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</td>
</tr>
<tr>
<td>void mutex_unlock(struct mutex *lock)</td>
<td>释放 mutex，也就给 mutex 解锁。</td>
</tr>
<tr>
<td>int mutex_trylock(struct mutex *lock)</td>
<td>尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。</td>
</tr>
<tr>
<td>int mutex_is_locked(struct mutex *lock)</td>
<td>判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</td>
</tr>
<tr>
<td>int mutex_lock_interruptible(struct mutex *lock)</td>
<td>使用此函数获取信号量失败进入休眠以后可以被信号打断。</td>
</tr>
</tbody></table>
<p>互斥体的使用如下所示：</p>
<p>关于 Linux 中的并发和竞争就讲解到这里，Linux 内核还有很多其他的处理并发和竞争的机制，本章我们主要讲解了常用的原子操作、自旋锁、信号量和互斥体。以后我们在编写 Linux驱动的时候就会频繁的使用到这几种机制，希望大家能够深入理解这几个常用的机制。</p>
<h1 id="Linux并发与竞争实验"><a href="#Linux并发与竞争实验" class="headerlink" title="Linux并发与竞争实验"></a>Linux并发与竞争实验</h1><p>在上一章中我们学习了 Linux 下的并发与竞争，并且学习了四种常用的处理并发和竞争的机制：原子操作、自旋锁、信号量和互斥体。本章我们就通过四个实验来学习如何在驱动中使用这四种机制。</p>
<h2 id="1-原子操作实验"><a href="#1-原子操作实验" class="headerlink" title="1|原子操作实验"></a>1|原子操作实验</h2><p>本例程我们在前面的 gpioled.c 文件基础上完成。在本节使用中我们使用原子操作来实现对 LED 这个设备的互斥访问，也就是一次只允许一个应用程序可以使用 LED 灯。</p>
<h3 id="LED-驱动修改"><a href="#LED-驱动修改" class="headerlink" title="LED  驱动修改"></a>LED  驱动修改</h3><p>实验在实验驱动文件 gpioled.c 的基础上修改而来。新建名为“7_atomic”的文件夹，然后在 7_atomic 文件夹里面创建 vscode 工程，工作区命名为“atomic”。将 5_gpioled实验中的 gpioled.c 复制到 7_atomic 文件夹中，并且重命名为 atomic.c。</p>
<p>本节实验重点就是使用atomic 来实现一次只能允许一个应用访问 LED，所以我们只需要在 atomic.c 文件源码的基础上加上添加 atomic 相关代码即可，完成以后的 atomic.c 文件内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>


<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>
	LED_OFF = <span class="hljs-number">0</span>,
	LED_ON = !LED_OFF
&#125;<span class="hljs-type">led_switch_t</span>;


<span class="hljs-comment">/* 设备号个数 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span>

<span class="hljs-comment">/* gpioled设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span>	
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>
	<span class="hljs-type">dev_t</span> devid;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>
	<span class="hljs-type">int</span> major;
	<span class="hljs-type">int</span> minor;
	<span class="hljs-type">char</span> *devname;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span>	<span class="hljs-comment">//设备树节点</span>
	<span class="hljs-type">int</span> led_gpio;			<span class="hljs-comment">//led所使用的GPIO编号</span>
	<span class="hljs-type">atomic_t</span> lock;			<span class="hljs-comment">//原子变量</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span>


<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>
&#123;
	<span class="hljs-comment">//int val = 0;</span>
	<span class="hljs-keyword">if</span>(sw == LED_ON)
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-keyword">else</span>
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);
	&#125;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-comment">/* 通过判断原子变量的值来检查 LED 有没有被别的应用使用 */</span>
	<span class="hljs-comment">/* 原子变量为1说明没有被使用 */</span>
	<span class="hljs-keyword">if</span> (!atomic_dec_and_test(&amp;gpioled.lock))&#123;
		<span class="hljs-type">atomic_inc</span>(&amp;gpioled.lock);	<span class="hljs-comment">/*  小于 0  的话就加 1, 使其原子变量等于 0 */</span>
		<span class="hljs-keyword">return</span> -EBUSY;				<span class="hljs-comment">/* LED  被使用，返回忙 */</span>
	&#125;

	filp-&gt;private_data = &amp;gpioled;	<span class="hljs-comment">/* 设置私有数据 */</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;	/* 以访问私有数据 */</span>
	<span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	ret = copy_from_user(userDataBuf, buf, cnt);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)
	&#123;
		printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;
	led_switch(userDataBuf[<span class="hljs-number">0</span>]);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;
	<span class="hljs-comment">/* 关闭驱动文件的时候释放原子变量 */</span>
	<span class="hljs-type">atomic_inc</span>(&amp;dev-&gt;lock);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;







<span class="hljs-comment">/* 设备操作集合 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.write = gpioled_write,
	.read = gpioled_read,
	.open = gpioled_open,
	.release = gpioled_release

&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;


	<span class="hljs-comment">/* 初始化原子变量 */</span>
	<span class="hljs-type">atomic_set</span>(&amp;gpioled.lock, <span class="hljs-number">1</span>);	<span class="hljs-comment">/* 原子变量初始值为 1 */</span>

	<span class="hljs-comment">/* 注册设备号 */</span>
	gpioled.devname = <span class="hljs-string">&quot;atomicled&quot;</span>;
	gpioled.major = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(gpioled.major)&#123;
		gpioled.devid = MKDEV(gpioled.major, gpioled.minor);
		ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	<span class="hljs-keyword">else</span>&#123;
		ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	gpioled.major = MAJOR(gpioled.devid);
	gpioled.minor = MINOR(gpioled.devid);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_devid;
	&#125;
	printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);

	<span class="hljs-comment">/* 添加字符设备 */</span>
	gpioled.cdev.owner = gpioled_fops.owner;
	cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);
	ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_cdev;
	&#125;
	<span class="hljs-comment">/* 创建设备节点 */</span>
	<span class="hljs-comment">/* 	1.创建类 */</span>
	gpioled.class = class_create(THIS_MODULE, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;
		printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.class);
		<span class="hljs-keyword">goto</span> fail_class;
	&#125;
	<span class="hljs-comment">/*	2.创建设备*/</span>
	gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;
		printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.device);
		<span class="hljs-keyword">goto</span> fail_device;
	&#125;
	

	<span class="hljs-comment">/* 获取设备节点 */</span>
	gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);
	<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;
		printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_findnd;
	&#125;

	<span class="hljs-comment">/* 获取LED对应的GPIO */</span>
	gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;
		result = -EINVAL;
		printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);
		<span class="hljs-keyword">goto</span> fail_get_gpio;
	&#125;

	printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);

	<span class="hljs-comment">/* 申请IO */</span>
	ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_request_gpio;
	&#125;

	<span class="hljs-comment">/* 使用IO */</span>
	ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_gpio_failed;
	&#125;

	<span class="hljs-comment">/* 设置GPIO电平 */</span>
	printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);	<span class="hljs-comment">/* 默认开灯 */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

fail_gpio_failed:
	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
fail_request_gpio:
fail_get_gpio:
fail_findnd:
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
fail_device:
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
fail_class:
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
fail_register_cdev:
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);
fail_register_devid:
	<span class="hljs-keyword">return</span> result;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-comment">/* 关灯 */</span>
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);	

	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);

&#125;

<span class="hljs-comment">/* 驱动入口和出口 */</span>
module_init(gpioled_init);
module_exit(gpioled_exit);

<span class="hljs-comment">/* 许可 */</span>
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-comment">/* 作者信息 */</span>
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>添加了原子变量 lock，用来实现一次只能允许一个应用访问 LED 灯，led_init 驱动入口函数会将 lock 的值设置为 1。</p>
<p>每次调用 open 函数打开驱动设备的时候先申请 lock，如果申请成功的话就表示LED灯还没有被其他的应用使用，如果申请失败就表示LED灯正在被其他的应用程序使用。每次打开驱动设备的时候先使用atomic_dec_and_test 函数将 lock 减 1，如果 atomic_dec_and_test函数返回值为真就表示 lock 当前值为 0，说明设备可以使用。如果 atomic_dec_and_test 函数返回值为假，就表示 lock 当前值为负数(lock 值默认是 1)，lock 值为负数的可能性只有一个，那就是其他设备正在使用 LED。其他设备正在使用 LED 灯，那么就只能退出了，在退出之前调用函数 atomic_inc 将 lock 加 1，因为此时 lock 的值被减成了负数，必须要对其加 1，将 lock 的值变为 0。</p>
<p><strong>LED 灯使用完毕</strong>，应用程序调用 close 函数关闭的驱动文件，<strong>gpioled_release 函数执行</strong>，调用atomic_inc 释放 lcok，也就是将 lock 加 1。</p>
<p>驱动初始化函数初始化原子变量 lock，初始值设置为 1，这样每次就只允许一个应用使用 LED灯。</p>
<hr>
<h3 id="APP编写"><a href="#APP编写" class="headerlink" title="APP编写"></a>APP编写</h3><p>新建名为 atomicApp.c 的测试 APP，在里面输入如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>


<span class="hljs-comment">/*</span>
<span class="hljs-comment"> *  usage:</span>
<span class="hljs-comment"> *  ./ledAPP     &lt;openFileName&gt;     &lt;0:OFF|1:ON&gt;   </span>
<span class="hljs-comment"> *  ./ledAPP     /dev/gpioled           0               //关灯</span>
<span class="hljs-comment"> *  ./ledAPP     /dev/gpioled           1               //开灯</span>
<span class="hljs-comment"> */</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
&#123;
    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;
    <span class="hljs-type">char</span> *filename;
    <span class="hljs-type">char</span> writebuf [<span class="hljs-number">1</span>]; 
    filename = argv[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)
    &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:\r\n./ledAPP     &lt;openFileName&gt;     &lt;0:OFF|1:ON&gt;  \r\n&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;

    <span class="hljs-comment">/* 打开 */</span>
    fd =  open(filename, O_WRONLY);
    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;

    writebuf[<span class="hljs-number">0</span>] = atoi(argv[<span class="hljs-number">2</span>]);
    ret = write(fd, writebuf, <span class="hljs-keyword">sizeof</span>(writebuf));
    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s failed!\r\n&quot;</span>, filename);
        close(fd);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
    <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s success!\r\n&quot;</span>, filename);
    &#125;

    <span class="hljs-comment">/* 模拟占用 25S LED */</span>
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;
        sleep(<span class="hljs-number">5</span>);
        cnt++;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;App running times:%d s.\r\n&quot;</span>, cnt * <span class="hljs-number">5</span>);
        <span class="hljs-keyword">if</span>(cnt &gt;= <span class="hljs-number">5</span>) <span class="hljs-keyword">break</span>;
    &#125;

    <span class="hljs-comment">/* 关闭 */</span>
    ret = close(fd);
    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close file %s failed！\r\n&quot;</span>, filename);
    &#125;
&#125;</code></pre></div>

<p>atomicApp.c 中的内容就是在 ledAPP.c 的基础上修改而来的，重点是加入了模拟占用 25 秒 LED 的代码。测试 APP 在获取到 LED 灯驱动的使用权以后会使用 25S，在使用的这段时间如果有其他的应用也去获取 LED 灯使用权的话肯定会失败！</p>
<h3 id="运行测试："><a href="#运行测试：" class="headerlink" title="运行测试："></a>运行测试：</h3><p>将编译出来的 atomic.ko 和 atomicApp 这两个文件拷贝到 rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15目录中，重启开发板，进入到目录 lib&#x2F;modules&#x2F;4.1.15 中，输入如下命令加载 atomic.ko 驱动模块：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">depmod <span class="hljs-comment">//第一次加载驱动的时候需要运行此命令</span>
modprobe atomic.ko  <span class="hljs-comment">//加载驱动</span></code></pre></div>

<p>驱动加载成功以后就可以使用 atomicApp 软件来测试驱动是否工作正常，输入如下命令以后台运行模式打开 LED 灯，“&amp;”表示在后台运行 atomicApp 这个软件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">./atomicApp /dev/atomicled 1&amp; //打开 LED 灯</code></pre></div>

<p>然后在app程序结束前，再次输入：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomicApp /</span>dev<span class="hljs-regexp">/atomicled 0 /</span><span class="hljs-regexp">/关闭 LED 灯</span></code></pre></div>

<p>会发现提示 error can’t open file.</p>
<h2 id="2-自旋锁实验"><a href="#2-自旋锁实验" class="headerlink" title="2|自旋锁实验"></a>2|自旋锁实验</h2><p>上一节我们使用原子变量实现了一次只能有一个应用程序访问 LED 灯，本节我们使用自旋锁来实现此功能。在使用自旋锁之前，先回顾一下自旋锁的使用注意事项：</p>
<ul>
<li>①、自旋锁保护的临界区要尽可能的短，因此在 open 函数中申请自旋锁，然后在 release 函数中释放自旋锁的方法就不可取。我们可以使用一个变量来表示设备的使用情况，如果设备被使用了那么变量就加一，设备被释放以后变量就减 1，我们只需要使用自旋锁保护这个变量即可。</li>
<li>②、考虑驱动的兼容性，合理的选择 API 函数。</li>
</ul>
<p>综上所述，在本节例程中，我们通过定义一个变量 dev_stats 表示设备的使用情况，dev_stats为 0 的时候表示设备没有被使用，dev_stats 大于 0 的时候表示设备被使用。驱动 open 函数中先判断 dev_stats 是否为 0，也就是判断设备是否可用，如果为 0 的话就使用设备，并且将 dev_stats加 1，表示设备被使用了。使用完以后在 release 函数中将 dev_stats 减 1，表示设备没有被使用了。因此真正实现设备互斥访问的是变量 dev_stats，但是我们要使用自旋锁对 dev_stats 来做保护。</p>
<h3 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a>驱动程序编写</h3><p>本节实验在第上一节实验驱动文件 atomic.c 的基础上修改而来。新建名为“8_spinlock”的文件夹，然后在 8_spinlock 文件夹里面创建 vscode 工程，工作区命名为“spinlock”。将 7_atomic实验中的 atomic.c 复制到 8_spinlock 文件夹中，并且重命名为 spinlock.c。将原来使用 atomic 的地方换为 spinlock 即可，其他代码不需要修改，完成以后的 spinlock.c 文件内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>


<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>
	LED_OFF = <span class="hljs-number">0</span>,
	LED_ON = !LED_OFF
&#125;<span class="hljs-type">led_switch_t</span>;


<span class="hljs-comment">/* 设备号个数 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span>

<span class="hljs-comment">/* gpioled设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span>	
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>
	<span class="hljs-type">dev_t</span> devid;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>
	<span class="hljs-type">int</span> major;
	<span class="hljs-type">int</span> minor;
	<span class="hljs-type">char</span> *devname;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span>	<span class="hljs-comment">//设备树节点</span>
	<span class="hljs-type">int</span> led_gpio;			<span class="hljs-comment">//led所使用的GPIO编号</span>
	<span class="hljs-type">int</span> dev_status;			<span class="hljs-comment">//设备状态|0:设备未使用|&gt;0:设备被使用</span>
	<span class="hljs-type">spinlock_t</span> lock;		<span class="hljs-comment">//自旋锁</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span>


<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>
&#123;
	<span class="hljs-comment">//int val = 0;</span>
	<span class="hljs-keyword">if</span>(sw == LED_ON)
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-keyword">else</span>
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);
	&#125;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;
	filp-&gt;private_data = &amp;gpioled; <span class="hljs-comment">/* 设置私有数据 */</span>

	spin_lock_irqsave(&amp;gpioled.lock, flags); <span class="hljs-comment">/*  上锁 */</span>
	<span class="hljs-keyword">if</span> (gpioled.dev_status) &#123; <span class="hljs-comment">/*  如果设备被使用了 */</span>
		spin_unlock_irqrestore(&amp;gpioled.lock, flags); <span class="hljs-comment">/*  解锁 */</span>
		<span class="hljs-keyword">return</span> -EBUSY;
	&#125;
	gpioled.dev_status++; <span class="hljs-comment">/*  如果设备没有打开，那么就标记已经打开了 */</span>
	spin_unlock_irqrestore(&amp;gpioled.lock, flags);<span class="hljs-comment">/*  解锁 */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;	/* 以访问私有数据 */</span>
	<span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	ret = copy_from_user(userDataBuf, buf, cnt);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)
	&#123;
		printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;
	led_switch(userDataBuf[<span class="hljs-number">0</span>]);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;

	<span class="hljs-comment">/* 关闭驱动文件的时候将 dev_stats 减 1 */</span>
	spin_lock_irqsave(&amp;dev-&gt;lock, flags); <span class="hljs-comment">/*  上锁 */</span>
	<span class="hljs-keyword">if</span> (dev-&gt;dev_status) &#123;
		dev-&gt;dev_status--;
	&#125;
	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);<span class="hljs-comment">/*  解锁 */</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;







<span class="hljs-comment">/* 设备操作集合 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.write = gpioled_write,
	.read = gpioled_read,
	.open = gpioled_open,
	.release = gpioled_release

&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;


	<span class="hljs-comment">/* 初始化自旋锁 */</span>
	spin_lock_init(&amp;gpioled.lock);	

	<span class="hljs-comment">/* 注册设备号 */</span>
	gpioled.devname = <span class="hljs-string">&quot;spinlock_led&quot;</span>;
	gpioled.major = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(gpioled.major)&#123;
		gpioled.devid = MKDEV(gpioled.major, gpioled.minor);
		ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	<span class="hljs-keyword">else</span>&#123;
		ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	gpioled.major = MAJOR(gpioled.devid);
	gpioled.minor = MINOR(gpioled.devid);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_devid;
	&#125;
	printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);

	<span class="hljs-comment">/* 添加字符设备 */</span>
	gpioled.cdev.owner = gpioled_fops.owner;
	cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);
	ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_cdev;
	&#125;
	<span class="hljs-comment">/* 创建设备节点 */</span>
	<span class="hljs-comment">/* 	1.创建类 */</span>
	gpioled.class = class_create(THIS_MODULE, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;
		printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.class);
		<span class="hljs-keyword">goto</span> fail_class;
	&#125;
	<span class="hljs-comment">/*	2.创建设备*/</span>
	gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;
		printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.device);
		<span class="hljs-keyword">goto</span> fail_device;
	&#125;
	

	<span class="hljs-comment">/* 获取设备节点 */</span>
	gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);
	<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;
		printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_findnd;
	&#125;

	<span class="hljs-comment">/* 获取LED对应的GPIO */</span>
	gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;
		result = -EINVAL;
		printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);
		<span class="hljs-keyword">goto</span> fail_get_gpio;
	&#125;

	printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);

	<span class="hljs-comment">/* 申请IO */</span>
	ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_request_gpio;
	&#125;

	<span class="hljs-comment">/* 使用IO */</span>
	ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_gpio_failed;
	&#125;

	<span class="hljs-comment">/* 设置GPIO电平 */</span>
	printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);	<span class="hljs-comment">/* 默认开灯 */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

fail_gpio_failed:
	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
fail_request_gpio:
fail_get_gpio:
fail_findnd:
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
fail_device:
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
fail_class:
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
fail_register_cdev:
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);
fail_register_devid:
	<span class="hljs-keyword">return</span> result;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-comment">/* 关灯 */</span>
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);	

	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);

&#125;

<span class="hljs-comment">/* 驱动入口和出口 */</span>
module_init(gpioled_init);
module_exit(gpioled_exit);

<span class="hljs-comment">/* 许可 */</span>
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-comment">/* 作者信息 */</span>
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>dev_stats 表示设备状态，如果为 0 的话表示设备还没有被使用，如果大于 0 的话就表示设备已经被使用了。定义自旋锁变量 lock。使用自旋锁实现对设备的互斥访问，</p>
<p>调用 spin_lock_irqsave 函数获取锁，为了考虑到驱动兼容性，这里并没有使用 spin_lock 函数来获取锁。判断dev_stats 是否大于 0，如果是的话表示设备已经被使用了，那么就调用spin_unlock_irqrestore函数释放锁，并且返回-EBUSY。如果设备没有被使用的话就将 dev_stats 加 1，表示设备要被使用了，然后调用 spin_unlock_irqrestore 函数释放锁。自旋锁的工作就是保护dev_stats 变量，真正实现对设备互斥访问的是 dev_stats。</p>
<p>在 release 函数中将 dev_stats 减 1，表示设备被释放了，可以被其他的应用程序使用。将 dev_stats 减 1 的时候需要自旋锁对其进行保护。</p>
<p>在驱动入口函数 led_init 中调用 spin_lock_init 函数初始化自旋锁。</p>
<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>编译运行。</p>
<p>驱动加载成功以后就可以使用 spinlockApp 软件测试驱动是否工作正常，测试方法和 前面测试小节中一样，先输入如下命令让 spinlockAPP 软件模拟占用 25S 的 LED 灯：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomicApp /</span>dev<span class="hljs-regexp">/spinlock_led 1&amp; /</span><span class="hljs-regexp">/打开 LED 灯</span></code></pre></div>

<p>紧接着再输入如下命令关闭 LED 灯：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomicApp /</span>dev<span class="hljs-regexp">/spinlock_led 0 /</span><span class="hljs-regexp">/关闭 LED 灯</span></code></pre></div>

<p>看一下能不能关闭 LED 灯，驱动正常工作的话并不会马上关闭 LED 灯，会提示你“open failed!”，必须等待第一个 atomicApp 软件运行完成(25S 计时结束)才可以再次操作 LED 灯。</p>
<h2 id="3-信号量实验"><a href="#3-信号量实验" class="headerlink" title="3|信号量实验"></a>3|信号量实验</h2><p>本节我们来使用信号量实现了一次只能有一个应用程序访问 LED 灯，信号量可以导致休眠，因此信号量保护的临界区没有运行时间限制，可以在驱动的 open 函数申请信号量，然后在release 函数中释放信号量。但是<strong>信号量不能用在中断中</strong>，本节实验我们不会在中断中使用信号量。</p>
<h3 id="LED-驱动修改-1"><a href="#LED-驱动修改-1" class="headerlink" title="LED  驱动修改"></a>LED  驱动修改</h3><p>本节实验在实验驱动文件 spinlock.c 的基础上修改而来。新建名为“9_semaphore”的文件夹，然后在 9_semaphore 文件夹里面创建 vscode 工程，工作区命名为“semaphore”。将8_spinlock 实验中的 spinlock.c 复制到 9_semaphore 文件夹中，并且重命名为 semaphore.c。将原来使用到自旋锁的地方换为信号量即可，其他的内容基本不变，完成以后的 semaphore.c 文件内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>
	LED_OFF = <span class="hljs-number">0</span>,
	LED_ON = !LED_OFF
&#125;<span class="hljs-type">led_switch_t</span>;


<span class="hljs-comment">/* 设备号个数 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span>

<span class="hljs-comment">/* gpioled设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span>	
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>
	<span class="hljs-type">dev_t</span> devid;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>
	<span class="hljs-type">int</span> major;
	<span class="hljs-type">int</span> minor;
	<span class="hljs-type">char</span> *devname;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span>	<span class="hljs-comment">//设备树节点</span>
	<span class="hljs-type">int</span> led_gpio;			<span class="hljs-comment">//led所使用的GPIO编号</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">sem</span>;</span> 	<span class="hljs-comment">//信号量</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span>


<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>
&#123;
	<span class="hljs-comment">//int val = 0;</span>
	<span class="hljs-keyword">if</span>(sw == LED_ON)
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-keyword">else</span>
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);
	&#125;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;

	filp-&gt;private_data = &amp;gpioled; <span class="hljs-comment">/* 设置私有数据 */</span>

	<span class="hljs-comment">/*  获取信号量, 进入休眠状态的进程可以被信号打断 */</span>
	<span class="hljs-keyword">if</span> (down_interruptible(&amp;gpioled.sem)) &#123;
		<span class="hljs-keyword">return</span> -ERESTARTSYS;
	&#125;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
	down(&amp;gpioled.sem); <span class="hljs-comment">/*  不能被信号打断 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;	/* 以访问私有数据 */</span>
	<span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	ret = copy_from_user(userDataBuf, buf, cnt);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)
	&#123;
		printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;
	led_switch(userDataBuf[<span class="hljs-number">0</span>]);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;

	up(&amp;dev-&gt;sem); <span class="hljs-comment">/*  释放信号量，信号量值加 1 */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;







<span class="hljs-comment">/* 设备操作集合 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.write = gpioled_write,
	.read = gpioled_read,
	.open = gpioled_open,
	.release = gpioled_release

&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;


	<span class="hljs-comment">/* 初始化信号量 */</span>
	sema_init(&amp;gpioled.sem, <span class="hljs-number">1</span>);

	<span class="hljs-comment">/* 注册设备号 */</span>
	gpioled.devname = <span class="hljs-string">&quot;semaphore_led&quot;</span>;
	gpioled.major = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(gpioled.major)&#123;
		gpioled.devid = MKDEV(gpioled.major, gpioled.minor);
		ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	<span class="hljs-keyword">else</span>&#123;
		ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	gpioled.major = MAJOR(gpioled.devid);
	gpioled.minor = MINOR(gpioled.devid);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_devid;
	&#125;
	printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);

	<span class="hljs-comment">/* 添加字符设备 */</span>
	gpioled.cdev.owner = gpioled_fops.owner;
	cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);
	ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_cdev;
	&#125;
	<span class="hljs-comment">/* 创建设备节点 */</span>
	<span class="hljs-comment">/* 	1.创建类 */</span>
	gpioled.class = class_create(THIS_MODULE, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;
		printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.class);
		<span class="hljs-keyword">goto</span> fail_class;
	&#125;
	<span class="hljs-comment">/*	2.创建设备*/</span>
	gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;
		printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.device);
		<span class="hljs-keyword">goto</span> fail_device;
	&#125;
	

	<span class="hljs-comment">/* 获取设备节点 */</span>
	gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);
	<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;
		printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_findnd;
	&#125;

	<span class="hljs-comment">/* 获取LED对应的GPIO */</span>
	gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;
		result = -EINVAL;
		printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);
		<span class="hljs-keyword">goto</span> fail_get_gpio;
	&#125;

	printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);

	<span class="hljs-comment">/* 申请IO */</span>
	ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_request_gpio;
	&#125;

	<span class="hljs-comment">/* 使用IO */</span>
	ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_gpio_failed;
	&#125;

	<span class="hljs-comment">/* 设置GPIO电平 */</span>
	printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);	<span class="hljs-comment">/* 默认开灯 */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

fail_gpio_failed:
	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
fail_request_gpio:
fail_get_gpio:
fail_findnd:
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
fail_device:
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
fail_class:
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
fail_register_cdev:
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);
fail_register_devid:
	<span class="hljs-keyword">return</span> result;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-comment">/* 关灯 */</span>
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);	

	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);

&#125;

<span class="hljs-comment">/* 驱动入口和出口 */</span>
module_init(gpioled_init);
module_exit(gpioled_exit);

<span class="hljs-comment">/* 许可 */</span>
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-comment">/* 作者信息 */</span>
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>要使用信号量必须添加&lt;linux&#x2F;semaphore.h&gt;头文件。</p>
<p>在设备结构体中添加一个信号量成员变量 sem。然后在open函数中申请信号量，可以使用down函数，也可以使用down_interruptible函数。如果信号量值大于等于 1 就表示可用，那么应用程序就会开始使用 LED 灯。<strong>如果信号量值为 0 就表示应用程序不能使用 LED 灯，此时应用程序就会进入到休眠状态。等到信号量值大于 1 的时候应用程序就会唤醒，申请信号量，获取 LED 灯使用权</strong>。</p>
<p>在 release 函数中调用 up 函数释放信号量，这样其他因为没有得到信号量而进入休眠状态的应用程序就会唤醒，获取信号量。</p>
<p>在驱动入口函数中调用 sema_init 函数初始化信号量 sem 的值为 1，相当于 sem是个二值信号量。</p>
<h3 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h3><p>编译后，加载运行。</p>
<p>测试方法和前面小节中一样，先输入如下命令让 软件模拟占用 25S 的 LED 灯：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomic /</span>dev<span class="hljs-regexp">/semaphore_led 1&amp; /</span><span class="hljs-regexp">/打开 LED 灯</span></code></pre></div>

<p>紧接着再输入如下命令关闭 LED 灯：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomic /</span>dev<span class="hljs-regexp">/semaphore_led 0&amp; /</span><span class="hljs-regexp">/打开 LED 灯</span></code></pre></div>

<p>注意两个命令都是运行在后台，第一条命令先获取到信号量，因此可以操作 LED 灯，将LED 灯打开，并且占有 25S。第二条命令因为获取信号量失败而进入休眠状态，等待第一条命令运行完毕并释放信号量以后才拥有 LED 灯使用权，将 LED 灯关闭，运行结果如图 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200823150509236.png" srcset="/img/loading.gif" lazyload alt="image-20200823150509236"></p>
<h2 id="4-互斥体实验"><a href="#4-互斥体实验" class="headerlink" title="4|互斥体实验"></a>4|互斥体实验</h2><p>前面我们使用原子操作、自旋锁和信号量实现了对 LED 灯的互斥访问，但是最适合互斥的就是互斥体 mutex 了。本节我们来学习一下如何使用 mutex 实现对 LED 灯的互斥访问。</p>
<h3 id="LED驱动修改"><a href="#LED驱动修改" class="headerlink" title="LED驱动修改"></a>LED驱动修改</h3><p>本节实验在第上一节实验驱动文件 semaphore.c 的基础上修改而来。新建名为“10_mutex”的文件夹，然后在10_mutex文件夹里面创建vscode工程，工作区命名为“mutex”。将9_semaphore实验中的semaphore.c 复制到 10_mutex 文件夹中，并且重命名为 mutex.c。将原来使用到信号量的地方换为mutex即可，其他的内容基本不变，完成以后的mutex.c文件内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>


<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>
	LED_OFF = <span class="hljs-number">0</span>,
	LED_ON = !LED_OFF
&#125;<span class="hljs-type">led_switch_t</span>;


<span class="hljs-comment">/* 设备号个数 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span>

<span class="hljs-comment">/* gpioled设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span>	
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>
	<span class="hljs-type">dev_t</span> devid;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>
	<span class="hljs-type">int</span> major;
	<span class="hljs-type">int</span> minor;
	<span class="hljs-type">char</span> *devname;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span>	<span class="hljs-comment">//设备树节点</span>
	<span class="hljs-type">int</span> led_gpio;			<span class="hljs-comment">//led所使用的GPIO编号</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">lock</span>;</span> 		<span class="hljs-comment">/*  互斥体 */</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span>


<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>
&#123;
	<span class="hljs-comment">//int val = 0;</span>
	<span class="hljs-keyword">if</span>(sw == LED_ON)
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-keyword">else</span>
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);
	&#125;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;

	filp-&gt;private_data = &amp;gpioled; <span class="hljs-comment">/* 设置私有数据 */</span>

	<span class="hljs-comment">/* 获取互斥体,可以被信号打断 */</span>
	<span class="hljs-keyword">if</span> (mutex_lock_interruptible(&amp;gpioled.lock)) &#123;
		<span class="hljs-keyword">return</span> -ERESTARTSYS;
	&#125;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
	mutex_lock(&amp;gpioled.lock); <span class="hljs-comment">/*  不能被信号打断 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;	/* 以访问私有数据 */</span>
	<span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	ret = copy_from_user(userDataBuf, buf, cnt);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)
	&#123;
		printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;
	led_switch(userDataBuf[<span class="hljs-number">0</span>]);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;
	<span class="hljs-comment">/* 释放互斥锁 */</span>
	mutex_unlock(&amp;dev-&gt;lock);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;







<span class="hljs-comment">/* 设备操作集合 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.write = gpioled_write,
	.read = gpioled_read,
	.open = gpioled_open,
	.release = gpioled_release

&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;


	<span class="hljs-comment">/* 初始化互斥体 */</span>
	mutex_init(&amp;gpioled.lock);

	<span class="hljs-comment">/* 注册设备号 */</span>
	gpioled.devname = <span class="hljs-string">&quot;mutex_led&quot;</span>;
	gpioled.major = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(gpioled.major)&#123;
		gpioled.devid = MKDEV(gpioled.major, gpioled.minor);
		ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	<span class="hljs-keyword">else</span>&#123;
		ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	gpioled.major = MAJOR(gpioled.devid);
	gpioled.minor = MINOR(gpioled.devid);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_devid;
	&#125;
	printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);

	<span class="hljs-comment">/* 添加字符设备 */</span>
	gpioled.cdev.owner = gpioled_fops.owner;
	cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);
	ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_cdev;
	&#125;
	<span class="hljs-comment">/* 创建设备节点 */</span>
	<span class="hljs-comment">/* 	1.创建类 */</span>
	gpioled.class = class_create(THIS_MODULE, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;
		printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.class);
		<span class="hljs-keyword">goto</span> fail_class;
	&#125;
	<span class="hljs-comment">/*	2.创建设备*/</span>
	gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;
		printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.device);
		<span class="hljs-keyword">goto</span> fail_device;
	&#125;
	

	<span class="hljs-comment">/* 获取设备节点 */</span>
	gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);
	<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;
		printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_findnd;
	&#125;

	<span class="hljs-comment">/* 获取LED对应的GPIO */</span>
	gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;
		result = -EINVAL;
		printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);
		<span class="hljs-keyword">goto</span> fail_get_gpio;
	&#125;

	printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);

	<span class="hljs-comment">/* 申请IO */</span>
	ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_request_gpio;
	&#125;

	<span class="hljs-comment">/* 使用IO */</span>
	ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_gpio_failed;
	&#125;

	<span class="hljs-comment">/* 设置GPIO电平 */</span>
	printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);	<span class="hljs-comment">/* 默认开灯 */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

fail_gpio_failed:
	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
fail_request_gpio:
fail_get_gpio:
fail_findnd:
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
fail_device:
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
fail_class:
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
fail_register_cdev:
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);
fail_register_devid:
	<span class="hljs-keyword">return</span> result;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-comment">/* 关灯 */</span>
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);	

	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);

&#125;

<span class="hljs-comment">/* 驱动入口和出口 */</span>
module_init(gpioled_init);
module_exit(gpioled_exit);

<span class="hljs-comment">/* 许可 */</span>
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-comment">/* 作者信息 */</span>
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<h3 id="运行测试-2"><a href="#运行测试-2" class="headerlink" title="运行测试"></a>运行测试</h3><p>驱动加载成功以后就可以使用 mutexApp 软件测试驱动是否工作正常，测试方法和前面测试信号量的方法一样。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/7%E3%80%81Linux%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">7| Linux按键输入驱动实验</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">
                        <span class="hidden-mobile">1| 字符设备驱动开发入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
