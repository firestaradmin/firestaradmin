

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="pinctrl 和 gpio 子系统实验上次我们编写了基于设备树的 LED 驱动，但是驱动的本质还是没变，都是配置 LED 灯所使用的 GPIO 寄存器，驱动开发方式和裸机基本没啥区别。 Linux 是一个庞大而完善的系统，尤其是驱动框架，像 GPIO 这种最基本的驱动不可能采用“原始”的裸机驱动开发方式，否则就相当于你买了一辆车，结果每天推着车去上班。Linux 内核提供了 pinctrl 和">
<meta property="og:type" content="article">
<meta property="og:title" content="5| pinctrl 和 gpio 子系统实验">
<meta property="og:url" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="pinctrl 和 gpio 子系统实验上次我们编写了基于设备树的 LED 驱动，但是驱动的本质还是没变，都是配置 LED 灯所使用的 GPIO 寄存器，驱动开发方式和裸机基本没啥区别。 Linux 是一个庞大而完善的系统，尤其是驱动框架，像 GPIO 这种最基本的驱动不可能采用“原始”的裸机驱动开发方式，否则就相当于你买了一辆车，结果每天推着车去上班。Linux 内核提供了 pinctrl 和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821224427783.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821224659447.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821230014797.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821231652016.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200822120341272.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200822121423644.png">
<meta property="article:published_time" content="2020-09-10T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-10T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta property="article:tag" content="dts设备树">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821224427783.png">
  
  
  <title>5| pinctrl 和 gpio 子系统实验 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//at.alicdn.com/t/font_3219187_rorsfvmryjl.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="5| pinctrl 和 gpio 子系统实验">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-11 00:00" pubdate>
        2020年9月11日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      23k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      189 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">5| pinctrl 和 gpio 子系统实验</h1>
            
            <div class="markdown-body">
              <h1 id="pinctrl-和-gpio-子系统实验"><a href="#pinctrl-和-gpio-子系统实验" class="headerlink" title="pinctrl 和 gpio 子系统实验"></a>pinctrl 和 gpio 子系统实验</h1><p>上次我们编写了基于设备树的 LED 驱动，但是驱动的本质还是没变，都是配置 LED 灯所使用的 GPIO 寄存器，驱动开发方式和裸机基本没啥区别。</p>
<p>Linux 是一个庞大而完善的系统，尤其是驱动框架，像 GPIO 这种最基本的驱动不可能采用“原始”的裸机驱动开发方式，否则就相当于你买了一辆车，结果每天推着车去上班。Linux 内核提供了 pinctrl 和 gpio 子系统用于GPIO 驱动，本章我们就来学习一下如何<strong>借助 pinctrl 和 gpio 子系统来简化 GPIO 驱动开发。</strong></p>
<h2 id="一、pinctrl-子系统"><a href="#一、pinctrl-子系统" class="headerlink" title="一、pinctrl 子系统"></a>一、pinctrl 子系统</h2><h3 id="1-pinctrl-子系统简介"><a href="#1-pinctrl-子系统简介" class="headerlink" title="1| pinctrl  子系统简介"></a>1| pinctrl  子系统简介</h3><p>Linux驱动讲究<strong>驱动分离与分层</strong>，pinctrl和gpio子系统就是驱动分离与分层思想下的产物，驱动分离与分层其实就是按照面向对象编程的设计思想而设计的设备驱动框架，关于驱动的分离与分层我们后面会讲。</p>
<p>本来 pinctrl 和 gpio 子系统应该放到驱动分离与分层章节后面讲解，但是不管什么外设驱动，GPIO 驱动基本都是必须的，而 pinctrl 和 gpio 子系统又是 GPIO 驱动必须使用的，所以就将 pintrcl 和 gpio 子系统这一章节提前了。</p>
<hr>
<p>我们先来回顾一下上一章是怎么初始化 LED 灯所使用的 GPIO，步骤如下：<br>①、修改设备树，添加相应的节点，节点里面重点是设置 reg 属性，reg 属性包括了 GPIO相关寄存器。</p>
<p>② 、 获 取 reg 属 性 中 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 和(IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03 这两个寄存器地址，并且初始化这两个寄存器，这两个寄存器用于设置 GPIO1_IO03 这个 PIN 的复用功能、上下拉、速度等。</p>
<p>③、在②里面将 GPIO1_IO03 这个 PIN 复用为了 GPIO 功能，因此需要设置 GPIO1_IO03这个 GPIO 相关的寄存器，也就是 GPIO1_DR 和 GPIO1_GDIR 这两个寄存器。</p>
<p>总结一下，②中完成对 GPIO1_IO03 这个 PIN 的初始化，设置这个 PIN 的复用功能、上下<br>拉等，比如将 GPIO_IO03 这个 PIN 设置为 GPIO 功能。③中完成对 GPIO 的初始化，设置 GPIO为输入&#x2F;输出等。如果使用过 STM32 的话应该都记得，STM32 也是要先设置某个 PIN 的复用功能、速度、上下拉等，然后再设置 PIN 所对应的 GPIO。其实对于大多数的 32 位 SOC 而言，引脚的设置基本都是这两方面，因此 Linux 内核针对 PIN 的配置推出了 pinctrl 子系统，对于 GPIO的配置推出了 gpio 子系统。本节我们来学习 pinctrl 子系统，下一节再学习 gpio 子系统。</p>
<p>大多数 SOC 的 pin 都是支持复用的，比如 I.MX6ULL 的 GPIO1_IO03 既可以作为普通的GPIO 使用，也可以作为 I2C1 的 SDA 等等。此外我们还需要配置 pin 的电气特性，比如上&#x2F;下拉、速度、驱动能力等等。**传统的配置 pin 的方式就是直接操作相应的寄存器，但是这种配置方式比较繁琐、而且容易出问题(比如 pin 功能冲突)**。pinctrl 子系统就是为了解决这个问题而引入的，pinctrl 子系统主要工作内容如下：</p>
<p>①、获取设备树中 pin 信息。<br>②、根据获取到的 pin 信息来设置 pin 的复用功能<br>③、根据获取到的 pin 信息来设置 pin 的电气特性，比如上&#x2F;下拉、速度、驱动能力等。</p>
<p>对于我们使用者来讲，只需要在设备树里面设置好某个 pin 的相关属性即可，其他的初始化工作均由 pinctrl 子系统来完成，pinctrl 子系统源码目录为 drivers&#x2F;pinctrl。</p>
<h3 id="2-I-MX6ULL-的-的-pinctrl-子系统驱动"><a href="#2-I-MX6ULL-的-的-pinctrl-子系统驱动" class="headerlink" title="2|I.MX6ULL 的 的 pinctrl  子系统驱动"></a>2|I.MX6ULL 的 的 pinctrl  子系统驱动</h3><h4 id="PIN-配置信息详解"><a href="#PIN-配置信息详解" class="headerlink" title="PIN 配置信息详解"></a>PIN 配置信息详解</h4><p>要使用 pinctrl 子系统，我们需要在设备树里面设置 PIN 的配置信息，毕竟 pinctrl 子系统要根据你提供的信息来配置 PIN 功能，一般会在设备树里面创建一个节点来描述 PIN 的配置信息。打开 imx6ull.dtsi 文件，找到一个叫做 iomuxc 的节点，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">iomuxc: iomuxc@<span class="hljs-number">020e0000</span> &#123;
    compatible = <span class="hljs-string">&quot;fsl,imx6ul-iomuxc&quot;</span>;
    reg = &lt;<span class="hljs-number">0x020e0000</span> <span class="hljs-number">0x4000</span>&gt;;
&#125;;</code></pre></div>

<p>iomuxc 节点就是 I.MX6ULL 的 IOMUXC 外设对应的节点，看起来内容很少，没看出什么跟 PIN 的配置有关的内容啊，别急！打开 imx6ull-lxg-emmc.dts，找到如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">&amp;iomuxc &#123;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;
	imx6ul-evk &#123;
		pinctrl_hog_1: hoggrp<span class="hljs-number">-1</span> &#123;
			fsl,pins = &lt;
				MX6UL_PAD_UART1_RTS_B__GPIO1_IO19	<span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 CD */</span>
				MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT	<span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 VSELECT */</span>
				MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        <span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 RESET */</span>
			&gt;;
		&#125;;
......
......
		pinctrl_i2c1: i2c1grp &#123;
			fsl,pins = &lt;
				MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="hljs-number">0x4001b8b0</span>
				MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="hljs-number">0x4001b8b0</span>
			&gt;;
		&#125;;
......
		pinctrl_usdhc1: usdhc1grp &#123;
			fsl,pins = &lt;
				MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="hljs-number">0x17059</span>
				MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="hljs-number">0x10071</span>
				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="hljs-number">0x17059</span>
				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="hljs-number">0x17059</span>
				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="hljs-number">0x17059</span>
				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="hljs-number">0x17059</span>
			&gt;;
		&#125;;
.....
		pinctrl_wdog: wdoggrp &#123;
			fsl,pins = &lt;
				MX6UL_PAD_LCD_RESET__WDOG1_WDOG_ANY    <span class="hljs-number">0x30b0</span>
			&gt;;
		&#125;;
	&#125;;
&#125;;</code></pre></div>

<p>示例代码就是向 iomuxc 节点追加数据，不同的外设使用的 PIN 不同、其配置也不同，因此一个萝卜一个坑，将某个外设所使用的所有 PIN 都组织在一个子节点里面。</p>
<p>示例代码中 pinctrl_i2c1子节点就是和i2c1有关的 PIN 集合。pinctrl_usdhc1子节点是 usdhc1这个外设所使用的 PIN，pinctrl_wdog 子节点是 wdog 外设所使用的 PIN。如果需要在 iomuxc 中添加我们自定义外设的 PIN，那么需要新建一个子节点，然后将这个自定义外设的所有 PIN 配置信息都放到这个子节点中。</p>
<p>将前面两个实例代码结合起来就可以得到完成的 iomuxc 节点，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> iomuxc: iomuxc@<span class="hljs-number">020e0000</span> &#123;
<span class="hljs-number">2</span> 		compatible = <span class="hljs-string">&quot;fsl,imx6ul-iomuxc&quot;</span>;
<span class="hljs-number">3</span> 		reg = &lt;<span class="hljs-number">0x020e0000</span> <span class="hljs-number">0x4000</span>&gt;;
<span class="hljs-number">4</span> 		pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">5</span> 		pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;
<span class="hljs-number">6</span> 		imx6ul-evk &#123;
<span class="hljs-number">7</span> 			pinctrl_hog_1: hoggrp<span class="hljs-number">-1</span> &#123;
<span class="hljs-number">8</span> 			fsl,pins = &lt;
<span class="hljs-number">9</span> 				MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 <span class="hljs-number">0x17059</span>
<span class="hljs-number">10</span> 				MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT <span class="hljs-number">0x17059</span>
<span class="hljs-number">11</span> 				MX6UL_PAD_GPIO1_IO09__GPIO1_IO09 <span class="hljs-number">0x17059</span>
<span class="hljs-number">12</span> 				MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID <span class="hljs-number">0x13058</span>
<span class="hljs-number">13</span> 				&gt;;
......
<span class="hljs-number">16</span> 			&#125;;
<span class="hljs-number">17</span> 		&#125;;
<span class="hljs-number">18</span> &#125;;</code></pre></div>

<p>第 2 行，compatible 属性值为“fsl,imx6ul-iomuxc”，前面讲解设备树的时候说过，Linux 内核会根据 compatbile 属性值来查找对应的驱动文件，所以我们在 Linux 内核源码中全局搜索字符串“fsl,imx6ul-iomuxc”就会找到 I.MX6ULL 这颗 SOC 的 pinctrl 驱动文件。稍后我们会讲解这个 pinctrl 驱动文件。</p>
<p>第 9~12行，pinctrl_hog_1子节点所使用的PIN 配置信息，我们就以第 9行UART1_RTS_B<br>这个 PIN 为例，讲解一下如何添加 PIN 的配置信息，UART1_RTS_B 的配置信息如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 <span class="hljs-number">0x17059</span></code></pre></div>

<p>首先说明一下，UART1_RTS_B 这个 PIN 是作为 SD 卡的检测引脚，也就是通过此 PIN 就可 以 检 测 到 SD 卡 是 否 有 插 入 。 </p>
<p>UART1_RTS_B 的 配 置 信 息 分 为 两 部 分 ：<strong>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19</strong> 和 **0x17059 **我们重点来看一下这两部分是什么含义，前面说了，对于一个 PIN的配置主要包括两方面，一个是设置这个 PIN 的复用功能，另一个就是设置这个 PIN 的电气特性。所以我们可以大胆的猜测 UART1_RTS_B 的这两部分配置信息一个是设置 UART1_RTS_B 的复用功能，一个是用来设置 UART1_RTS_B 的电气特性。</p>
<p>首先来看一下 <strong>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19</strong>，这是一个宏定义，定义在文件<br>arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ul-pinfunc.h 中，imx6ull.dtsi 会引用 imx6ull-pinfunc.h 这个头文件，而imx6ull-pinfunc.h 又会引用 imx6ul-pinfunc.h 这个头文件（绕啊绕！）。从这里可以看出，可以在设备树中引用 C 语言中.h 文件中的内容。</p>
<p>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 的宏定义内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">190</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__UART1_DCE_RTS 0x0090 0x031C 0x0620 0x0 0x3</span>
<span class="hljs-number">191</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__UART1_DTE_CTS 0x0090 0x031C 0x0000 0x0 0x0</span>
<span class="hljs-number">192</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__ENET1_TX_ER 0x0090 0x031C 0x0000 0x1 0x0</span>
<span class="hljs-number">193</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__USDHC1_CD_B 0x0090 0x031C 0x0668 0x2 0x1</span>
<span class="hljs-number">194</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__CSI_DATA05 0x0090 0x031C 0x04CC 0x3 0x1</span>
<span class="hljs-number">195</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__ENET2_1588_EVENT1_OUT 0x0090 0x031C 0x0000 0x4 0x0</span>
    <span class="hljs-comment">/*MX6UL_PAD_UART1_RTS_B__GPIO1_IO19*/</span>
<span class="hljs-number">196</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 0x0090 0x031C 0x0000 0x5 0x0</span>
    
<span class="hljs-number">197</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__USDHC2_CD_B 0x0090 0x031C 0x0674 0x8 0x2</span></code></pre></div>

<p>示例代码 中一共有 8 个以“MX6UL_PAD_UART1_RTS_B”开头的宏定义，大家仔细观察应该就能发现，这 8 个宏定义分别对应 UART1_RTS_B 这个 PIN 的 8 个复用 IO。查阅《I.MX6ULL 参考手册》可以知 UART1_RTS_B 的可选复用 IO 如图 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821224427783.png" srcset="/img/loading.gif" lazyload alt="image-20200821224427783"></p>
<p>示 例 代 码 196 行 的 宏 定 义 MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 表 示 将UART1_RTS_B 这个 IO 复用为 GPIO1_IO19。此宏定义后面跟着 5 个数字，也就是这个宏定义的具体值，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">0x0090</span> <span class="hljs-number">0x031C</span> <span class="hljs-number">0x0000</span> <span class="hljs-number">0x5</span> <span class="hljs-number">0x0</span></code></pre></div>

<p>这 5 个值的含义如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-section">&lt;mux_reg conf_reg input_reg mux_mode input_val&gt;</span></code></pre></div>

<p>综上所述可知：<br><strong>0x0090</strong> ：mux_reg 寄存器偏移地址，设备树中的 iomuxc 节点就是 IOMUXC 外设对应的节点 ， 根 据 其 reg 属 性 可 知 <strong>IOMUXC 外 设 寄 存 器 起 始 地 址 为 0x020e0000</strong> 。 因 此<strong>0x020e0000+0x0090&#x3D;0x020e0090</strong>，<strong>IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B 寄存器地址正 好 是 0x020e0090</strong> ， 大 家 可 以 在 《 IMX6ULL 参 考 手 册 》 中 找 到IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B 这个寄存器的位域图，如图 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821224659447.png" srcset="/img/loading.gif" lazyload alt="image-20200821224659447"></p>
<p>因此可知，0x020e0000+mux_reg 就是 PIN 的复用寄存器地址。</p>
<ul>
<li><p><strong>0x031C：conf_reg</strong> 寄存器偏移地址，和 mux_reg 一样，<strong>0x020e0000+0x031c&#x3D;0x020e031c</strong>，这个就是<strong>寄存器IOMUXC_SW_PAD_CTL_PAD_UART1_RTS_B</strong> 的地址。</p>
</li>
<li><p><strong>0x0000</strong> ：<strong>input_reg</strong> 寄存器偏移地址，有些外设有 input_reg 寄存器，有 input_reg 寄存器的外设需要配置 input_reg 寄存器。没有的话就不需要设置，UART1_RTS_B 这个 PIN 在做GPIO1_IO19 的时候是没有 input_reg 寄存器，因此这里 intput_reg 是无效的。</p>
</li>
<li><p><strong>0x5</strong> ： <strong>mux_reg</strong> 寄存器值 ， 在这里就相当于设置<br>IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B 寄存器为 0x5，也即是设置 UART1_RTS_B 这个 PIN 复用为 GPIO1_IO19。</p>
</li>
<li><p><strong>0x0</strong>：<strong>input_val</strong> 寄存器值，在这里无效。</p>
</li>
</ul>
<p>这就是宏 MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 的含义，看的比较仔细的同学应该会发现并没有 conf_reg 寄存器的值，config_reg 寄存器是设置一个 PIN 的电气特性的，这么重要的寄存器怎么没有值呢？回到示例代码中，第 9 行的内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 <span class="hljs-number">0x17059</span></code></pre></div>

<p>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 我们上面已经分析了，就剩下了一个 0x17059，反应快的同学应该已经猜出来了，0x17059 就是 conf_reg 寄存器值！此值由用户自行设置，通过此值来设置一个 IO 的上&#x2F;下拉、驱动能力和速度等。在这里就相当于设置寄存器IOMUXC_SW_PAD_CTL_PAD_UART1_RTS_B 的值为 0x17059。</p>
<hr>
<h4 id="PIN-驱动程序讲解"><a href="#PIN-驱动程序讲解" class="headerlink" title="PIN 驱动程序讲解"></a>PIN 驱动程序讲解</h4><p>本节会涉及到 Linux 驱动分层与分离、平台设备驱动等还未讲解的知识，所以本小节教程可以不用看，不会影响后续的实验。如果对 Linux 内核的 pinctrl 子系统实现原理感兴趣的话可以看本小节。</p>
<p>所有的东西都已经准备好了，包括寄存器地址和寄存器值，Linux 内核相应的驱动文件就会根据这些值来做相应的初始化。接下来就找一下哪个驱动文件来做这一件事情，iomuxc 节点中 compatible 属性的值为“fsl,imx6ul-iomuxc”，在 Linux 内核中全局搜索“fsl,imx6ul-iomuxc”字符串就会找到对应的驱动文件。在文件drivers&#x2F;pinctrl&#x2F;freescale&#x2F;pinctrl-imx6ul.c中有如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">326</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">imx6ul_pinctrl_of_match</span>[] =</span> &#123;
<span class="hljs-number">327</span> 	&#123; .compatible = <span class="hljs-string">&quot;fsl,imx6ul-iomuxc&quot;</span>, .data =
						&amp;imx6ul_pinctrl_info, &#125;,
<span class="hljs-number">328</span> 	&#123; .compatible = <span class="hljs-string">&quot;fsl,imx6ull-iomuxc-snvs&quot;</span>, .data =
						&amp;imx6ull_snvs_pinctrl_info, &#125;,
<span class="hljs-number">329</span> 	&#123; <span class="hljs-comment">/* sentinel */</span> &#125;
<span class="hljs-number">330</span> &#125;;
<span class="hljs-number">331</span>
<span class="hljs-number">332</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6ul_pinctrl_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span>
333 &#123;
<span class="hljs-number">334</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">match</span>;</span>
<span class="hljs-number">335</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx_pinctrl_soc_info</span> *<span class="hljs-title">pinctrl_info</span>;</span>
<span class="hljs-number">336</span>
<span class="hljs-number">337</span> 	match = of_match_device(imx6ul_pinctrl_of_match, &amp;pdev-&gt;dev);
<span class="hljs-number">338</span>
<span class="hljs-number">339</span> 	<span class="hljs-keyword">if</span> (!match)
<span class="hljs-number">340</span> 		<span class="hljs-keyword">return</span> -ENODEV;
<span class="hljs-number">341</span>
<span class="hljs-number">342</span> 	pinctrl_info = (<span class="hljs-keyword">struct</span> imx_pinctrl_soc_info *) match-&gt;data;
<span class="hljs-number">343</span>
<span class="hljs-number">344</span> 	<span class="hljs-keyword">return</span> imx_pinctrl_probe(pdev, pinctrl_info);
<span class="hljs-number">345</span> &#125;
<span class="hljs-number">346</span>
<span class="hljs-number">347</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">imx6ul_pinctrl_driver</span> =</span> &#123;
<span class="hljs-number">348</span> 	.driver = &#123;
<span class="hljs-number">349</span> 		.name = <span class="hljs-string">&quot;imx6ul-pinctrl&quot;</span>,
<span class="hljs-number">350</span> 		.owner = THIS_MODULE,
<span class="hljs-number">351</span> 		.of_match_table = of_match_ptr(imx6ul_pinctrl_of_match),
<span class="hljs-number">352</span> 	&#125;,
<span class="hljs-number">353</span> 	.probe = imx6ul_pinctrl_probe,
<span class="hljs-number">354</span> 	.remove = imx_pinctrl_remove,
<span class="hljs-number">355</span> &#125;;</code></pre></div>

<p><strong>第326~330行</strong>，of_device_id结构体数组，前面讲解设备树的时候说过了，of_device_id里面保存着这个驱动文件的兼容性值，设备树中的 compatible 属性值会和 of_device_id 中的所有兼容性字符串比较，查看是否可以使用此驱动。imx6ul_pinctrl_of_match 结构体数组一共有两个兼容性字符串，分别为“fsl,imx6ul-iomuxc”和“fsl,imx6ull-iomuxc-snvs”，因此iomuxc 节点与此驱动匹配，所以 pinctrl-imx6ul.c 会完成 I.MX6ULL 的 PIN 配置工作。</p>
<p><strong>第 347~355 行</strong>，platform_driver 是平台设备驱动，这个是我们后面章节要讲解的内容，platform_driver 是个结构体，有个 probe 成员变量。在这里大家只需要知道，当设备和驱动匹配成功以后 platform_driver 的 probe 成员变量所代表的函数就会执行，在 353 行设置probe 成员变量为 imx6ul_pinctrl_probe 函数，因此在本章实验中 imx6ul_pinctrl_probe这个函数就会执行，可以认为 imx6ul_pinctrl_probe 函数就是 I.MX6ULL 这个 SOC的 PIN 配置入口函数。以此为入口，如图 所示的函数调用路径：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821230014797.png" srcset="/img/loading.gif" lazyload alt="image-20200821230014797"></p>
<p>在图  中函数 imx_pinctrl_parse_groups 负责获取设备树中关于 PIN 的配置信息，也就是我们前面分析的那 6 个 u32 类型的值。</p>
<p><strong>后续具体参考正点原子IMX6U驱动开发指南45.1.2.2节</strong></p>
<h3 id="3-设备树中添加-pinctrl-节点模板"><a href="#3-设备树中添加-pinctrl-节点模板" class="headerlink" title="3|  设备树中添加 pinctrl  节点模板"></a>3|  设备树中添加 pinctrl  节点模板</h3><p>我们已经对 pinctrl 有了比较深入的了解，接下来我们学习一下如何在设备树中添加某个外设 的 PIN 信 息 。 关 于 I.MX 系 列 SOC 的 pinctrl 设 备 树 绑 定 信 息 可 以 参 考 文 档Documentation&#x2F;devicetree&#x2F;bindings&#x2F;pinctrl&#x2F;fsl,imx-pinctrl.txt。</p>
<p>这里我们虚拟一个名为“test”的设备，test 使用了 GPIO1_IO00 这个 PIN 的 GPIO 功能，pinctrl 节点添加过程如下：</p>
<h4 id="1-、创建对应的节点"><a href="#1-、创建对应的节点" class="headerlink" title="1 、创建对应的节点"></a>1 、创建对应的节点</h4><p>同一个外设的 PIN 都放到一个节点里面，打开 imx6ull-lxg-emmc.dts，在 iomuxc 节点中的“imx6ul-evk”子节点下添加“pinctrl_test”节点，注意！节点前缀一定要为“pinctrl_”。添加完成以后如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_test: testgrp &#123;
<span class="hljs-number">2</span> 	<span class="hljs-comment">/* 具体的 PIN 信息 */</span>
<span class="hljs-number">3</span> &#125;;</code></pre></div>

<h4 id="2-、添加“-fsl-pins-”属性"><a href="#2-、添加“-fsl-pins-”属性" class="headerlink" title="2 、添加“ fsl ,pins ”属性"></a>2 、添加“ fsl ,pins ”属性</h4><p>设备树是通过属性来保存信息的，因此我们需要添加一个属性，属性名字一定要为<strong>“fsl,pins”</strong>，因为对于 I.MX 系列 SOC 而言，pinctrl 驱动程序是通过读取“fsl,pins”属性值来获取 PIN 的配置信息，完成以后如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_test: testgrp &#123;
<span class="hljs-number">2</span> 	fsl,pins = &lt;
<span class="hljs-number">3</span> 	<span class="hljs-comment">/* 设备所使用的 PIN 配置信息 */</span>
<span class="hljs-number">4</span> 	&gt;;
<span class="hljs-number">5</span> &#125;;</code></pre></div>

<h4 id="3-、在“fsl-pins-”属性中添加-PIN-配置信息"><a href="#3-、在“fsl-pins-”属性中添加-PIN-配置信息" class="headerlink" title="3 、在“fsl,pins ”属性中添加 PIN  配置信息"></a>3 、在“fsl,pins ”属性中添加 PIN  配置信息</h4><p>最后在“fsl,pins”属性中添加具体的 PIN 配置信息，完成以后如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_test: testgrp &#123;
<span class="hljs-number">2</span> 	fsl,pins = &lt;
<span class="hljs-number">3</span> 	MX6UL_PAD_GPIO1_IO00__GPIO1_IO00 config <span class="hljs-comment">/*config 是具体设置值*/</span>
<span class="hljs-number">4</span> 	&gt;;
<span class="hljs-number">5</span> &#125;;</code></pre></div>

<p>至此，我们已经在 imx6ull-alientek-emmc.dts 文件中添加好了 test 设备所使用的 PIN 配置信息。</p>
<h2 id="二、gpio-子系统"><a href="#二、gpio-子系统" class="headerlink" title="二、gpio 子系统"></a>二、gpio 子系统</h2><h3 id="1-GPIO-子系统简介"><a href="#1-GPIO-子系统简介" class="headerlink" title="1|GPIO 子系统简介"></a>1|GPIO 子系统简介</h3><p>上一小节讲解了 pinctrl 子系统，<strong>pinctrl 子系统重点是设置 PIN(有的 SOC 叫做 PAD)的复用和电气属性</strong>，如果 pinctrl 子系统将一个 PIN 复用为 GPIO 的话，那么接下来就要用到 gpio 子系统了。</p>
<p>gpio 子系统顾名思义，就是<strong>用于初始化 GPIO 并且提供相应的 API 函数，比如设置 GPIO为输入输出，读取 GPIO 的值等</strong>。gpio 子系统的主要目的就是方便驱动开发者使用 gpio，驱动开发者在设备树中添加 gpio 相关信息，然后就可以在驱动程序中使用 gpio 子系统提供的 API函数来操作 GPIO，Linux 内核向驱动开发者屏蔽掉了 GPIO 的设置过程，极大的方便了驱动开发者使用 GPIO。</p>
<h3 id="2-I-MX6ULL的的-gpio子系统驱动"><a href="#2-I-MX6ULL的的-gpio子系统驱动" class="headerlink" title="2|I.MX6ULL的的 gpio子系统驱动"></a>2|I.MX6ULL的的 gpio子系统驱动</h3><h4 id="1-、设备树中的-gpio-信息"><a href="#1-、设备树中的-gpio-信息" class="headerlink" title="1 、设备树中的 gpio  信息"></a>1 、设备树中的 gpio  信息</h4><p>I.MX6ULL-ALPHA 开发板上的 <strong>UART1_RTS_B</strong> 做为 SD 卡的检测引脚，<strong>UART1_RTS_B</strong> 复用为 <strong>GPIO1_IO19</strong>，通过读取这个 GPIO 的高低电平就可以知道 SD 卡有没有插入。首先肯定是将 UART1_RTS_B 这个 PIN 复用为 GPIO1_IO19，并且设置电气属性，也就是上一小节讲的pinctrl 节点。打开 imx6ull-lxg-emmc.dts， UART1_RTS_B 这个 PIN 的 pincrtl 设置如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">316</span> pinctrl_hog_1: hoggrp<span class="hljs-number">-1</span> &#123;
<span class="hljs-number">317</span> 	fsl,pins = &lt;
<span class="hljs-number">318</span> 		MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 <span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 CD */</span>
......
<span class="hljs-number">322</span> 	&gt;;
<span class="hljs-number">323</span> &#125;;</code></pre></div>

<p><strong>第 318 行</strong>，设置 UART1_RTS_B 这个 PIN 为 GPIO1_IO19。pinctrl 配置好以后就是设置 gpio 了，SD 卡驱动程序通过读取 GPIO1_IO19 的值来判断 SD卡有没有插入，但是 SD 卡驱动程序怎么知道 CD 引脚连接的 GPIO1_IO19 呢？肯定是需要设备树告诉驱动啊！在设备树中 SD 卡节点下添加一个属性来描述 SD 卡的 CD 引脚就行了，SD卡驱动直接读取这个属性值就知道 SD 卡的 CD 引脚使用的是哪个 GPIO 了。</p>
<p>SD 卡连接在I.MX6ULL 的 usdhc1 接口上，在 imx6ull-lxg-emmc.dts 中找到名为“usdhc1”的节点，这个节点就是 SD 卡设备节点，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">760</span> &amp;usdhc1 &#123;
<span class="hljs-number">761</span> 	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;state_100mhz&quot;</span>, <span class="hljs-string">&quot;state_200mhz&quot;</span>;
<span class="hljs-number">762</span> 	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_usdhc1&gt;;
<span class="hljs-number">763</span> 	pinctrl<span class="hljs-number">-1</span> = &lt;&amp;pinctrl_usdhc1_100mhz&gt;;
<span class="hljs-number">764</span> 	pinctrl<span class="hljs-number">-2</span> = &lt;&amp;pinctrl_usdhc1_200mhz&gt;;
<span class="hljs-number">765</span> 	<span class="hljs-comment">/* pinctrl-3 = &lt;&amp;pinctrl_hog_1&gt;; */</span>
<span class="hljs-number">766</span> 	cd-gpios = &lt;&amp;gpio1 <span class="hljs-number">19</span> GPIO_ACTIVE_LOW&gt;;
<span class="hljs-number">767</span> 	keep-power-in-suspend;
<span class="hljs-number">768</span> 	enable-sdio-wakeup;
<span class="hljs-number">769</span> 	vmmc-supply = &lt;&amp;reg_sd1_vmmc&gt;;
<span class="hljs-number">770</span> 	status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">771</span> &#125;;</code></pre></div>

<p><strong>第 765 行</strong>，此行本来没有，是作者添加的，usdhc1 节点作为 SD 卡设备总节点，usdhc1 节点需要描述 SD 卡所有的信息，因为驱动要使用。本行就是描述 SD 卡的 CD 引脚 pinctrl 信息所在的子节点，因为SD 卡驱动需要根据 pincrtl节点信息来设置 CD引脚的复用功能等。</p>
<p><strong>762~764行</strong>的 pinctrl-0~2 都是 SD 卡其他 PIN 的 pincrtl 节点信息。但是大家会发现，其实在 usdhc1 节点中并没有“pinctrl-3 &#x3D; &lt;&amp;pinctrl_hog_1&gt;”这一行，也就是说并没有指定 CD 引脚的 pinctrl 信息，那么 SD 卡驱动就没法设置 CD 引脚的复用功能啊？这个不用担心，因为在“iomuxc”节点下引用了 pinctrl_hog_1 这个节点，所以 Linux 内核中的 iomuxc 驱动就会自动初始化 pinctrl_hog_1节点下的所有 PIN。</p>
<p><strong>第 766 行</strong>，属性“cd-gpios”描述了 SD 卡的 CD 引脚使用的哪个 IO。属性值一共有三个，我们来看一下这三个属性值的含义，“&amp;gpio1”表示 CD 引脚所使用的 IO 属于 GPIO1 组，“19”表示 GPIO1 组的第 19 号 IO，通过这两个值 SD 卡驱动程序就知道 CD 引脚使用了GPIO1_IO19<br>这 GPIO。“GPIO_ACTIVE_LOW”表示低电平有效，如果改为“GPIO_ACTIVE_HIGH”就表示高电平有效。</p>
<p>根据上面这些信息，SD 卡驱动程序就可以使用 GPIO1_IO19 来检测 SD 卡的 CD 信号了，<br>打开 imx6ull.dtsi，在里面找到如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">504</span> gpio1: gpio@<span class="hljs-number">0209</span>c000 &#123;
<span class="hljs-number">505</span> 	compatible = <span class="hljs-string">&quot;fsl,imx6ul-gpio&quot;</span>, <span class="hljs-string">&quot;fsl,imx35-gpio&quot;</span>;
<span class="hljs-number">506</span> 	reg = &lt;<span class="hljs-number">0x0209c000</span> <span class="hljs-number">0x4000</span>&gt;;
<span class="hljs-number">507</span> 	interrupts = &lt;GIC_SPI <span class="hljs-number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;,
<span class="hljs-number">508</span> 				 &lt;GIC_SPI <span class="hljs-number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;
<span class="hljs-number">509</span> 	gpio-controller;
<span class="hljs-number">510</span> 	<span class="hljs-meta">#gpio-cells = <span class="hljs-string">&lt;2&gt;</span>;</span>
<span class="hljs-number">511</span> 	interrupt-controller;
<span class="hljs-number">512</span> 	<span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;2&gt;</span>;</span>
<span class="hljs-number">513</span> &#125;;</code></pre></div>

<p>gpio1 节点信息描述了 GPIO1 控制器的所有信息，重点就是 GPIO1 外设寄存器基地址以及兼 容 属 性 。 关 于 I.MX 系 列 SOC 的 GPIO 控 制 器 绑 定 信 息 请 查 看 文 档Documentation&#x2F;devicetree&#x2F;bindings&#x2F;gpio&#x2F; fsl-imx-gpio.txt。</p>
<p><strong>第 505 行</strong>，设置 gpio1 节点的 compatible 属性有两个，分别为“fsl,imx6ul-gpio”和“fsl,imx35-gpio”，在 Linux 内核中搜索这两个字符串就可以找到 I.MX6UL 的 GPIO 驱动程序。<br><strong>第 506 行</strong>，的 reg 属性设置了 GPIO1 控制器的寄存器基地址为 0X0209C000，大家可以打开《I.MX6ULL 参考手册》找到“Chapter 28:General Purpose Input&#x2F;Output(GPIO)”章节第28.5 小节，有如图 45.2.2.1 所示的寄存器地址表：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821231652016.png" srcset="/img/loading.gif" lazyload alt="image-20200821231652016"></p>
<p>从图 45.2.2.1 可以看出，GPIO1 控制器的基地址就是 0X0209C000。<br><strong>第 509 行</strong>，“gpio-controller”表示 gpio1 节点是个 GPIO 控制器。<br><strong>第 510 行</strong>，“#gpio-cells”属性和“#address-cells”类似，#gpio-cells 应该为 2，表示一共有两个 cell，第一个 cell 为 GPIO 编号，比如“&amp;gpio1 3”就表示 GPIO1_IO03。第二个 cell 表示GPIO 极 性 ， 如 果 为 0(GPIO_ACTIVE_HIGH) 的 话 表 示 高 电 平 有 效 ， 如 果 为1(GPIO_ACTIVE_LOW)的话表示低电平有效。</p>
<h4 id="2-、GPIO-驱动程序简介"><a href="#2-、GPIO-驱动程序简介" class="headerlink" title="2 、GPIO 驱动程序简介"></a>2 、GPIO 驱动程序简介</h4><p>本小节会涉及到 Linux 驱动分层与分离、平台设备驱动等还未讲解的知识，所以本小节教程可以不用看，不会影响后续的实验。如果对 Linux 内核的 GPIO 子系统实现原理感兴趣的话<br>可以看本小节。</p>
<p><strong>具体参考正点原子IMX6U驱动开发指南45.2.2节</strong></p>
<hr>
<h3 id="3-gpio-子系统-API-函数"><a href="#3-gpio-子系统-API-函数" class="headerlink" title="3|gpio  子系统 API  函数"></a>3|gpio  子系统 API  函数</h3><p>对于驱动开发人员，设置好设备树以后就可以使用 gpio 子系统提供的 API 函数来操作指定的 GPIO，gpio 子系统向驱动开发人员屏蔽了具体的读写寄存器过程。这就是驱动分层与分离的好处，大家各司其职，做好自己的本职工作即可。</p>
<p>gpio 子系统提供的常用的 API 函数有下面几个：</p>
<h4 id="gpio-request-函数"><a href="#gpio-request-函数" class="headerlink" title="gpio_request  函数"></a>gpio_request  函数</h4><p>gpio_request 函数用于申请一个 GPIO 管脚，在使用一个 GPIO 之前一定要使用gpio_request进行申请，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_request</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> gpio, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *label)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要申请的 gpio 标号，使用 of_get_named_gpio 函数从设备树获取指定 GPIO 属性信息，此函数会返回这个 GPIO 的标号。<br><strong>label</strong>：给 gpio 设置个名字。<br><strong>返回值</strong>：0，申请成功；其他值，申请失败。</p>
<hr>
<h4 id="gpio-free-函数"><a href="#gpio-free-函数" class="headerlink" title="gpio_free  函数"></a>gpio_free  函数</h4><p>如果不使用某个 GPIO 了，那么就可以调用 gpio_free 函数进行释放。函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">gpio_free</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> gpio)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要释放的 gpio 标号。<br><strong>返回值</strong>：无。</p>
<hr>
<h4 id="gpio-direction-input-函数"><a href="#gpio-direction-input-函数" class="headerlink" title="gpio_direction_input  函数"></a>gpio_direction_input  函数</h4><p>此函数用于设置某个 GPIO 为输入，函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_direction_input</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> gpio)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要设置为输入的 GPIO 标号。<br><strong>返回值</strong>：0，设置成功；负值，设置失败。</p>
<hr>
<h4 id="gpio-direction-output-函数"><a href="#gpio-direction-output-函数" class="headerlink" title="gpio_direction_output  函数"></a>gpio_direction_output  函数</h4><p>此函数用于设置某个 GPIO 为输出，并且设置默认输出值，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_direction_output</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> gpio, <span class="hljs-type">int</span> value)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要设置为输出的 GPIO 标号。<br><strong>value</strong> ：GPIO 默认输出值。<br><strong>返回值</strong>：0，设置成功；负值，设置失败。</p>
<hr>
<h4 id="gpio-get-value-函数"><a href="#gpio-get-value-函数" class="headerlink" title="gpio_get_value  函数"></a>gpio_get_value  函数</h4><p>此函数用于获取某个 GPIO 的值(0 或 1)，此函数是个宏，定义所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> gpio_get_value __gpio_get_value </span>
<span class="hljs-type">int</span> __gpio_get_value(<span class="hljs-type">unsigned</span> gpio)</code></pre></div>

<p>函数参数和返回值含义如下：</p>
<p><strong>gpio</strong>：要获取的 GPIO 标号。<br><strong>返回值</strong>：非负值，得到的 GPIO 值；负值，获取失败。</p>
<hr>
<h4 id="gpio-set-value-函数"><a href="#gpio-set-value-函数" class="headerlink" title="gpio_set_value  函数"></a>gpio_set_value  函数</h4><p>此函数用于设置某个 GPIO 的值，此函数是个宏，定义如下</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> gpio_set_value __gpio_set_value</span>
<span class="hljs-type">void</span> __gpio_set_value(<span class="hljs-type">unsigned</span> gpio, <span class="hljs-type">int</span> value)</code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要设置的 GPIO 标号。<br><strong>value</strong> ：要设置的值。<br><strong>返回值</strong>：无</p>
<p>关于 gpio 子系统常用的 API 函数就讲这些，这些是我们用的最多的。</p>
<hr>
<h3 id="4-设备树中添加-gpio-节点模板"><a href="#4-设备树中添加-gpio-节点模板" class="headerlink" title="4|设备树中添加 gpio  节点模板"></a>4|设备树中添加 gpio  节点模板</h3><p>继续完成前面的 test 设备，我们已经讲解了如何创建 test 设备的 pinctrl 节点。本节我们来学习一下如何创建 test 设备的 GPIO 节点。</p>
<h4 id="1-、创建-test-设备节点"><a href="#1-、创建-test-设备节点" class="headerlink" title="1 、创建 test  设备节点"></a>1 、创建 test  设备节点</h4><p>在根节点“&#x2F;”下创建 test 设备子节点，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> test &#123;
<span class="hljs-number">2</span> <span class="hljs-comment">/* 节点内容 */</span>
<span class="hljs-number">3</span> &#125;;</code></pre></div>

<h4 id="2-、添加-pinctrl-信息"><a href="#2-、添加-pinctrl-信息" class="headerlink" title="2 、添加 pinctrl  信息"></a>2 、添加 pinctrl  信息</h4><p>前面我们创建了 pinctrl_test 节点，此节点描述了 test 设备所使用的 GPIO1_IO00 这个 PIN 的信息，我们要将这节点添加到 test 设备节点中，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> test &#123;
<span class="hljs-number">2</span> 	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">3</span> 	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_test&gt;;
<span class="hljs-number">4</span> 	<span class="hljs-comment">/* 其他节点内容 */</span>
<span class="hljs-number">5</span> &#125;;</code></pre></div>

<p><strong>第 2 行</strong>，添加 pinctrl-names 属性，此属性描述 pinctrl 名字为“default”。<br><strong>第 3 行</strong>，添加 pinctrl-0 节点，此节点引用前面创建的 pinctrl_test 节点，表示 tset 设备的所使用的 PIN 信息保存在 pinctrl_test 节点中。</p>
<h4 id="3-、添加-GPIO-属性信息"><a href="#3-、添加-GPIO-属性信息" class="headerlink" title="3 、添加 GPIO  属性信息"></a>3 、添加 GPIO  属性信息</h4><p>我们最后需要在 test 节点中添加 GPIO 属性信息，表明 test 所使用的 GPIO 是哪个引脚，添加完成以后如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> test &#123;
<span class="hljs-number">2</span> 	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">3</span> 	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_test&gt;;
<span class="hljs-number">4</span> 	gpio = &lt;&amp;gpio1 <span class="hljs-number">0</span> GPIO_ACTIVE_LOW&gt;;
<span class="hljs-number">5</span> &#125;;</code></pre></div>

<p><strong>第 4 行</strong>，test 设备所使用的 gpio。</p>
<p>关于 pinctrl 子系统和 gpio 子系统就讲解到这里，接下来就使用 pinctrl 和 gpio 子系统来驱动I.MX6ULL-ALPHA 开发板上的 LED 灯。</p>
<h3 id="5-与-gpio-相关的-OF-函数"><a href="#5-与-gpio-相关的-OF-函数" class="headerlink" title="5|  与 gpio  相关的 OF  函数"></a>5|  与 gpio  相关的 OF  函数</h3><p>在前面示例代码中，我们定义了一个名为“gpio”的属性，gpio 属性描述了 test 这个设备所使用的 GPIO。</p>
<p>在驱动程序中需要读取 gpio 属性内容，Linux 内核提供了几个与 GPIO 有关的 OF 函数，常用的几个 OF 函数如下所示：</p>
<h4 id="of-gpio-named-count-函数"><a href="#of-gpio-named-count-函数" class="headerlink" title="of_gpio_named_count  函数"></a>of_gpio_named_count  函数</h4><p>of_gpio_named_count 函数用于<strong>获取设备树某个属性里面定义了几个 GPIO 信息</strong>，要注意的是空的 GPIO 信息也会被统计到，比如：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">gpios = &lt;	<span class="hljs-number">0</span> 
            &amp;gpio1 <span class="hljs-number">1</span> <span class="hljs-number">2</span>
            <span class="hljs-number">0</span>
            &amp;gpio2 <span class="hljs-number">3</span> <span class="hljs-number">4</span>&gt;;</code></pre></div>

<p>上述代码的“gpios”节点一共定义了 4 个 GPIO，但是有 2 个是空的，没有实际的含义。通过 of_gpio_named_count 函数统计出来的 GPIO 数量就是 4 个，此函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_gpio_named_count</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>propname</strong>：要统计的 GPIO 属性。<br><strong>返回值</strong>：正值，统计到的 GPIO 数量；负值，失败。</p>
<hr>
<h4 id="of-gpio-count-函数"><a href="#of-gpio-count-函数" class="headerlink" title="of_gpio_count  函数"></a>of_gpio_count  函数</h4><p>和 of_gpio_named_count 函数一样，但是不同的地方在于，此函数统计的是“gpios”这个属性的 GPIO 数量，而 of_gpio_named_count 函数可以统计任意属性的 GPIO 信息，函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_gpio_count</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>返回值</strong>：正值，统计到的 GPIO 数量；负值，失败。</p>
<hr>
<h4 id="of-get-named-gpio-函数"><a href="#of-get-named-gpio-函数" class="headerlink" title="of_get_named_gpio  函数"></a>of_get_named_gpio  函数</h4><p>此函数获取 GPIO 编号，因为 Linux 内核中关于 GPIO 的 API 函数都要使用 GPIO 编号，此函数会将设备树中类似&lt;&amp;gpio5 7 GPIO_ACTIVE_LOW&gt;的属性信息转换为对应的 GPIO 编号，此函数在驱动中使用很频繁！函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_get_named_gpio</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node 	*np,</span>
<span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>			*propname,</span>
<span class="hljs-params">                      <span class="hljs-type">int</span> 					index)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>propname</strong>：包含要获取 GPIO 信息的属性名。</p>
<p><strong>index</strong> ：GPIO 索引，因为一个属性里面可能包含多个 GPIO，此参数指定要获取哪个 GPIO的编号，如果只有一个 GPIO 信息的话此参数为 0。<br><strong>返回值</strong>：正值，获取到的 GPIO 编号；负值，失败。</p>
<h2 id="三、硬件原理图"><a href="#三、硬件原理图" class="headerlink" title="三、硬件原理图"></a>三、硬件原理图</h2><p>参考前面的LED原理图</p>
<h2 id="四、GPIO-LED实验"><a href="#四、GPIO-LED实验" class="headerlink" title="四、GPIO-LED实验"></a>四、GPIO-LED实验</h2><p>本章实验我们继续研究 LED 灯，在前面实验中我们通过设备树向 dtsled.c 文件传递相应的寄存器物理地址，然后在驱动文件中配置寄存器。本章实验我们使用 pinctrl 和 gpio 子系统来完成 LED 灯驱动。</p>
<h3 id="1-修改设备树文件"><a href="#1-修改设备树文件" class="headerlink" title="1|修改设备树文件"></a>1|修改设备树文件</h3><h4 id="1、添加pinctrl节点"><a href="#1、添加pinctrl节点" class="headerlink" title="1、添加pinctrl节点"></a>1、添加pinctrl节点</h4><p>I.MX6U-ALPHA 开发板上的 LED 灯使用了 GPIO1_IO03 这个 PIN，打开 imx6ull-lxg-emmc.dts，在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为“pinctrl_led”的子节点，节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_led: ledgrp &#123;
<span class="hljs-number">2</span> 		fsl,pins = &lt;
<span class="hljs-number">3</span> 			MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 <span class="hljs-number">0x10B0</span> <span class="hljs-comment">/* LED0 */</span>
<span class="hljs-number">4</span> 		&gt;;
<span class="hljs-number">5</span> &#125;;</code></pre></div>

<p>第 3 行，将 GPIO1_IO03 这个 PIN 复用为 GPIO1_IO03，电气属性值为 0X10B0。</p>
<h4 id="2-、添加-LED-设备节点"><a href="#2-、添加-LED-设备节点" class="headerlink" title="2 、添加 LED  设备节点"></a>2 、添加 LED  设备节点</h4><p>在根节点“&#x2F;”下创建 LED 灯节点，节点名为“gpioled”，节点内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> gpioled &#123;
<span class="hljs-number">2</span> 	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">3</span> 	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">4</span> 	compatible = <span class="hljs-string">&quot;atkalpha-gpioled&quot;</span>;
<span class="hljs-number">5</span> 	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">6</span> 	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_led&gt;;
<span class="hljs-number">7</span> 	led-gpio = &lt;&amp;gpio1 <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;;
<span class="hljs-number">8</span> 	status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">9</span> &#125;</code></pre></div>

<p><strong>第 6 行</strong>，pinctrl-0 属性设置 LED 灯所使用的 PIN 对应的 pinctrl 节点。<br><strong>第 7 行</strong>，led-gpio 属性指定了 LED 灯所使用的 GPIO，在这里就是 GPIO1 的 IO03，低电平有效。稍后编写驱动程序的时候会获取 led-gpio 属性的内容来得到 GPIO 编号，因为 gpio 子系统的 API 操作函数需要 GPIO 编号。</p>
<h4 id="3-、检查-PIN-是否被其他外设使用"><a href="#3-、检查-PIN-是否被其他外设使用" class="headerlink" title="3 、检查 PIN  是否被其他外设使用"></a>3 、检查 PIN  是否被其他外设使用</h4><p><strong>这一点非常重要！！！</strong></p>
<p>很多初次接触设备树的驱动开发人员很容易因为这个小问题栽了大跟头！因为我们所使用的设备树基本都是在半导体厂商提供的设备树文件基础上修改而来的，而半导体厂商提供的设备树是根据自己官方开发板编写的，很多 PIN 的配置和我们所使用的开发板不一样。比如 A 这个引脚在官方开发板接的是 I2C 的 SDA，而我们所使用的硬件可能将 A 这个引脚接到了其他的外设，比如 LED 灯上，接不同的外设，A 这个引脚的配置就不同。一个引脚一次只能实现一个功能，如果A引脚在设备树中配置为了I2C的SDA信号，那么A引脚就不能再配置为GPIO，否则的话驱动程序在申请 GPIO 的时候就会失败。检查 PIN 有没有被其他外设使用包括两个方面：</p>
<p>①、检查 pinctrl 设置。<br>②、如果这个 PIN 配置为 GPIO 的话，检查这个 GPIO 有没有被别的外设使用。</p>
<p>在本章实验中 LED 灯使用的 PIN 为 GPIO1_IO03，因此先检查 GPIO_IO03 这个 PIN 有没有被其他的 pinctrl 节点使用，在 imx6ull-lxg-emmc.dts 中找到如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">480</span> pinctrl_tsc: tscgrp &#123;
<span class="hljs-number">481</span> 	fsl,pins = &lt;
<span class="hljs-number">482</span> 		MX6UL_PAD_GPIO1_IO01__GPIO1_IO01 <span class="hljs-number">0xb0</span>
<span class="hljs-number">483</span> 		MX6UL_PAD_GPIO1_IO02__GPIO1_IO02 <span class="hljs-number">0xb0</span>
<span class="hljs-number">484</span> 		MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 <span class="hljs-number">0xb0</span>
<span class="hljs-number">485</span> 		MX6UL_PAD_GPIO1_IO04__GPIO1_IO04 <span class="hljs-number">0xb0</span>
<span class="hljs-number">486</span> 	&gt;;
<span class="hljs-number">487</span> &#125;;</code></pre></div>

<p>pinctrl_tsc 节点是 TSC(电阻触摸屏接口)的 pinctrl 节点，从第 484 行可以看出，默认情况下GPIO1_IO03 作为了 TSC 外设的 PIN。所以我们需要将第 484 行屏蔽掉！和 C 语言一样，在要屏蔽的内容前后加上“&#x2F;*”和“*&#x2F;”符号即可。其实在 I.MX6U-ALPHA 开发板上并没有用到 TSC接口，所以第 482~485 行的内容可以全部屏蔽掉。因为本章实验我们将 GPIO1_IO03 这个 PIN 配置为了 GPIO，所以还需要查找一下有没有其他的外设使用了 GPIO1_IO03，在 imx6ull-lxg-emmc.dts 中搜索“gpio1 3”，找到如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">723</span> &amp;tsc &#123;
<span class="hljs-number">724</span> 	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">725</span> 	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_tsc&gt;;
<span class="hljs-number">726</span> 	xnur-gpio = &lt;&amp;gpio1 <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;;
<span class="hljs-number">727</span> 	measure-delay-time = &lt;<span class="hljs-number">0xffff</span>&gt;;
<span class="hljs-number">728</span> 	pre-charge-time = &lt;<span class="hljs-number">0xfff</span>&gt;;
<span class="hljs-number">729</span> 	status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">730</span> &#125;;</code></pre></div>

<p>tsc 是 TSC 的外设节点，从 726 行可以看出，tsc 外设也使用了 GPIO1_IO03，同样我们需要将这一行屏蔽掉。然后在继续搜索“gpio1 3”，看看除了本章的 LED 灯以外还有没有其他的地方也使用了 GPIO1_IO03，找到一个屏蔽一个。</p>
<p>设备树编写完成以后使用“make dtbs”命令重新编译设备树，然后使用新编译出来的imx6ull-lxg-emmc.dtb 文件启动 Linux 系统。启动成功以后进入“&#x2F;proc&#x2F;device-tree”目录中查看“gpioled”节点是否存在，如果存在的话就说明设备树基本修改成功(具体还要驱动验证)，结果如图所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200822120341272.png" srcset="/img/loading.gif" lazyload alt="image-20200822120341272"></p>
<h3 id="2-LED-灯驱动程序编写"><a href="#2-LED-灯驱动程序编写" class="headerlink" title="2| LED  灯驱动程序编写"></a>2| LED  灯驱动程序编写</h3><p>设备树准备好以后就可以编写驱动程序了，本章实验在前面实验驱动文件 dtsled.c 的基础上修改而来。新建名为“5_gpioled”文件夹，然后在 5_gpioled 文件夹里面创建 vscode 工程，工作区命名为“gpioled”。工程创建好以后新建 gpioled.c 文件，在 gpioled.c 里面输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>


<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>
	LED_OFF = <span class="hljs-number">0</span>,
	LED_ON = !LED_OFF
&#125;<span class="hljs-type">led_switch_t</span>;



<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span>
<span class="hljs-comment">/* gpioled设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span>	
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>
	<span class="hljs-type">dev_t</span> devid;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>
	<span class="hljs-type">int</span> major;
	<span class="hljs-type">int</span> minor;
	<span class="hljs-type">char</span> *devname;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span>	<span class="hljs-comment">//设备树节点</span>
	<span class="hljs-type">int</span> led_gpio;			<span class="hljs-comment">//GPIO编号</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span>


<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>
&#123;
	<span class="hljs-comment">//int val = 0;</span>
	<span class="hljs-keyword">if</span>(sw == LED_ON)
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-keyword">else</span>
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>
		gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);
	&#125;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	
	<span class="hljs-comment">//filp-&gt;private_data = &amp;gpioled;	/* 设置私有数据 */</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;	/* 以访问私有数据 */</span>
	<span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	ret = copy_from_user(userDataBuf, buf, cnt);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)
	&#123;
		printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;
	led_switch(userDataBuf[<span class="hljs-number">0</span>]);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;







<span class="hljs-comment">/* 设备操作集合 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.write = gpioled_write,
	.open = gpioled_open,
	.release = gpioled_release

&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;


	<span class="hljs-comment">/* 注册设备号 */</span>
	gpioled.devname = <span class="hljs-string">&quot;gpioled&quot;</span>;
	gpioled.major = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(gpioled.major)&#123;
		gpioled.devid = MKDEV(gpioled.major, gpioled.minor);
		ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	<span class="hljs-keyword">else</span>&#123;
		ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);
	&#125;
	gpioled.major = MAJOR(gpioled.devid);
	gpioled.minor = MINOR(gpioled.devid);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_devid;
	&#125;
	printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);

	<span class="hljs-comment">/* 添加字符设备 */</span>
	gpioled.cdev.owner = gpioled_fops.owner;
	cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);
	ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_cdev;
	&#125;
	<span class="hljs-comment">/* 创建设备节点 */</span>
	<span class="hljs-comment">/* 	1.创建类 */</span>
	gpioled.class = class_create(THIS_MODULE, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;
		printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.class);
		<span class="hljs-keyword">goto</span> fail_class;
	&#125;
	<span class="hljs-comment">/*	2.创建设备*/</span>
	gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);
	<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;
		printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);
		result = PTR_ERR(gpioled.device);
		<span class="hljs-keyword">goto</span> fail_device;
	&#125;
	

	<span class="hljs-comment">/* 获取设备节点 */</span>
	gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);
	<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;
		printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_findnd;
	&#125;

	<span class="hljs-comment">/* 获取LED对应的GPIO */</span>
	gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;
		result = -EINVAL;
		printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);
		<span class="hljs-keyword">goto</span> fail_get_gpio;
	&#125;

	printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);

	<span class="hljs-comment">/* 申请IO */</span>
	ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_request_gpio;
	&#125;

	<span class="hljs-comment">/* 使用IO */</span>
	ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);
	<span class="hljs-keyword">if</span>(ret)&#123;
		printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_gpio_failed;
	&#125;

	<span class="hljs-comment">/* 设置GPIO电平 */</span>
	printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);	<span class="hljs-comment">/* 默认开灯 */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

fail_gpio_failed:
	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
fail_request_gpio:
fail_get_gpio:
fail_findnd:
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
fail_device:
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
fail_class:
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
fail_register_cdev:
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);
fail_register_devid:
	<span class="hljs-keyword">return</span> result;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-comment">/* 关灯 */</span>
	gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);	

	<span class="hljs-comment">/* 释放IO */</span>
	gpio_free(gpioled.led_gpio);
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(gpioled.class, gpioled.devid);
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(gpioled.class);
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;gpioled.cdev);
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);

&#125;

<span class="hljs-comment">/* 驱动入口和出口 */</span>
module_init(gpioled_init);
module_exit(gpioled_exit);

<span class="hljs-comment">/* 许可 */</span>
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-comment">/* 作者信息 */</span>
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3|编写测试 APP"></a>3|编写测试 APP</h3><p>本章直接使用前面的测试 APP，将上一章的 ledApp.c 文件复制到本章实验工程下即可。</p>
<h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4|运行测试"></a>4|运行测试</h3><p>编译运行，和前面一样。</p>
<p>加载驱动后，如图：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200822121423644.png" srcset="/img/loading.gif" lazyload alt="image-20200822121423644"></p>
<p>可以看到成功获取了GPIO编号，说明驱动没问题，然后测试一下开关灯。</p>
<h3 id><a href="#" class="headerlink" title></a></h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                      <a class="hover-with-bg" href="/tags/dts%E8%AE%BE%E5%A4%87%E6%A0%91/">dts设备树</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">9| Linux 中断实验</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/">
                        <span class="hidden-mobile">4| Linux  设备树</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
