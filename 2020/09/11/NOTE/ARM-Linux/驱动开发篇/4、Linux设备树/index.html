

<!DOCTYPE html>
<html lang="zh-cn" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux  设备树什么是“设备树”，本章我们就来详细的谈一谈设备树。掌握设备树是 Linux 驱动开发人员必备的技能！因为在新版本的 Linux 中，ARM 相关的驱动全部采用了设备树(也有支持老式驱动的，比较少)，最新出的 CPU 其驱动开发也基本都是基于设备树的，比如 ST 新出的 STM32MP157、NXP的I.MX8系列等。 我们所使用的Linux版本为4.1.15，其支持设备树，所以">
<meta property="og:type" content="article">
<meta property="og:title" content="4| Linux  设备树">
<meta property="og:url" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Linux  设备树什么是“设备树”，本章我们就来详细的谈一谈设备树。掌握设备树是 Linux 驱动开发人员必备的技能！因为在新版本的 Linux 中，ARM 相关的驱动全部采用了设备树(也有支持老式驱动的，比较少)，最新出的 CPU 其驱动开发也基本都是基于设备树的，比如 ST 新出的 STM32MP157、NXP的I.MX8系列等。 我们所使用的Linux版本为4.1.15，其支持设备树，所以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820184958257.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820192141947.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820192517802.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202310685.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202617800.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202310685.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202737979.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203103001.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203119368.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203214452.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203540965.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820211529586.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820211703146.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200821114222276.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200821114301406.png">
<meta property="article:published_time" content="2020-09-10T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-10T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta property="article:tag" content="dts设备树">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820184958257.png">
  
  
  <title>4| Linux  设备树 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="4| Linux  设备树">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-11 00:00" pubdate>
        2020年9月11日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      48k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      399 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">4| Linux  设备树</h1>
            
            <div class="markdown-body">
              <h1 id="Linux-设备树"><a href="#Linux-设备树" class="headerlink" title="Linux  设备树"></a>Linux  设备树</h1><p>什么是“设备树”，本章我们就来详细的谈一谈设备树。掌握设备树是 Linux 驱动开发人员必备的技能！因为在新版本的 Linux 中，ARM 相关的驱动全部采用了设备树(也有支持老式驱动的，比较少)，最新出的 CPU 其驱动开发也基本都是基于设备树的，比如 ST 新出的 STM32MP157、NXP的I.MX8系列等。</p>
<p>我们所使用的Linux版本为4.1.15，其支持设备树，所以正点原子I.MX6U-ALPHA 开发板的所有 Linux 驱动都是基于设备树的。本章我们就来了解一下设备树的起源、重点学习一下设备树语法。</p>
<h2 id="一、什么是设备树？"><a href="#一、什么是设备树？" class="headerlink" title="一、什么是设备树？"></a>一、什么是设备树？</h2><p>**设备树(Device Tree)**，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等，如图所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820184958257.png" srcset="/img/loading.gif" lazyload alt="image-20200820184958257"></p>
<p>在图中，树的主干就是系统总线，IIC 控制器、GPIO 控制器、SPI 控制器等都是接到系统主线上的分支。IIC 控制器有分为 IIC1 和 IIC2 两种，其中 IIC1 上接了 FT5206 和 AT24C02这两个 IIC 设备，IIC2 上只接了 MPU6050 这个设备。</p>
<p>DTS 文件的主要功能就是按照图所示的结构来描述板子上的设备信息，DTS 文件描述设备信息是有相应的语法规则要求的，稍后我们会详细的讲解 DTS 语法规则。</p>
<p>在 3.x 版本(具体哪个版本我也无从考证)以前的 Linux 内核中 ARM 架构并没有采用设备树。在没有设备树的时候 Linux 是如何描述 ARM 架构中的板级信息呢？在 Linux 内核源码中大量的 arch&#x2F;arm&#x2F;mach-xxx 和 arch&#x2F;arm&#x2F;plat-xxx 文件夹，这些文件夹里面的文件就是对应平台下的板级信息。比如在 arch&#x2F;arm&#x2F;mach-smdk2440.c 中有如下内容(有缩减)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">90</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3c2410fb_display</span> <span class="hljs-title">smdk2440_lcd_cfg</span> __<span class="hljs-title">initdata</span> =</span> &#123;
<span class="hljs-number">91</span>
<span class="hljs-number">92</span> .lcdcon5 = S3C2410_LCDCON5_FRM565 |
<span class="hljs-number">93</span> S3C2410_LCDCON5_INVVLINE |
<span class="hljs-number">94</span> S3C2410_LCDCON5_INVVFRAME |
<span class="hljs-number">95</span> S3C2410_LCDCON5_PWREN |
<span class="hljs-number">96</span> S3C2410_LCDCON5_HWSWP,
......
<span class="hljs-number">113</span> &#125;;
<span class="hljs-number">114</span>
<span class="hljs-number">115</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3c2410fb_mach_info</span> <span class="hljs-title">smdk2440_fb_info</span> __<span class="hljs-title">initdata</span> =</span> &#123;
<span class="hljs-number">116</span> .displays = &amp;smdk2440_lcd_cfg,
<span class="hljs-number">117</span> .num_displays = <span class="hljs-number">1</span>,
<span class="hljs-number">118</span> .default_display = <span class="hljs-number">0</span>,
......
<span class="hljs-number">133</span> &#125;;
<span class="hljs-number">134</span>
<span class="hljs-number">135</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">smdk2440_devices</span>[] __<span class="hljs-title">initdata</span> =</span> &#123;
<span class="hljs-number">136</span> &amp;s3c_device_ohci,
<span class="hljs-number">137</span> &amp;s3c_device_lcd,
<span class="hljs-number">138</span> &amp;s3c_device_wdt,
<span class="hljs-number">139</span> &amp;s3c_device_i2c0,
<span class="hljs-number">140</span> &amp;s3c_device_iis,
<span class="hljs-number">141</span> &#125;;</code></pre></div>

<p>上述代码中的结构体变量 smdk2440_fb_info 就是描述 SMDK2440 这个开发板上的 LCD 信息的，结构体指针数组 smdk2440_devices 描述的 SMDK2440 这个开发板上的所有平台相关信息。这个仅仅是使用 2440 这个芯片的 SMDK2440 开发板下的 LCD 信息，SMDK2440 开发板还有很多的其他外设硬件和平台硬件信息。使用 2440 这个芯片的板子有很多，每个板子都有描述相应板级信息的文件，这仅仅只是一个 2440。随着智能手机的发展，每年新出的 ARM 架构芯片少说都在数十、数百款，Linux 内核下板级信息文件将会成指数级增长！这些板级信息文件都是.c 或.h 文件，都会被硬编码进 Linux 内核中，导致 Linux 内核“虚胖”。</p>
<p>就好比你喜欢吃自助餐，然后花了 100 多到一家宣传看着很不错的自助餐厅，结果你想吃的牛排、海鲜、烤肉基本没多少，全都是一些凉菜、炒面、西瓜、饮料等小吃，相信你此时肯定会脱口而出一句“F<em>k!”、<br>“骗子！”。</em></p>
<p>同样的，当 Linux 之父 linus 看到 ARM 社区向 Linux 内核添加了大量“无用”、冗余的板级信息文件，不禁的发出了一句<strong>“This whole ARM thing is a f*cking pain in the ass”</strong>。从此以后 ARM 社区就引入了 PowerPC 等架构已经采用的设备树(Flattened Device Tree)，将这些描述板级硬件信息的内容都从 Linux 内中分离开来，用一个专属的文件格式来描述，这个专属的文件就叫做设备树，文件扩展名为.dts。</p>
<p>一个 SOC 可以作出很多不同的板子，这些不同的板子肯定是有共同的信息，<strong>将这些共同的信息提取出来作为一个通用的文件，其他的.dts 文件直接引用这个通用文件即可，这个通用文件就是.dtsi 文件</strong>，类似于 C 语言中的头文件。一般.dts 描述板级信息(也就是开发板上有哪些 IIC 设备、SPI 设备等)，.dtsi 描述 SOC 级信息(也就是 SOC 有几个 CPU、主频是多少、各个外设控制器信息等)。</p>
<p>这个就是设备树的由来，简而言之就是，Linux 内核中 ARM 架构下有太多的冗余的垃圾板级信息文件，导致 linus 震怒，然后 ARM 社区引入了设备树。</p>
<h2 id="二、DTS-、DTB-和-和-DTC"><a href="#二、DTS-、DTB-和-和-DTC" class="headerlink" title="二、DTS 、DTB 和 和 DTC"></a>二、DTS 、DTB 和 和 DTC</h2><p>上一小节说了，设备树源文件扩展名为.dts，但是我们在前面移植 Linux 的时候却一直在使用.dtb 文件，那么 DTS 和 DTB 这两个文件是什么关系呢？DTS 是设备树源码文件，DTB 是将DTS 编译以后得到的二进制文件。将.c 文件编译为.o 需要用到 gcc 编译器，那么将.dts 编译为.dtb需要什么工具呢？需要用到 DTC 工具！DTC 工具源码在 Linux 内核的 scripts&#x2F;dtc 目录下，scripts&#x2F;dtc&#x2F;Makefile 文件内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs makefile">1 hostprogs-y := dtc
2 always := $(hostprogs-y)
3
4 dtc-objs:= dtc.o flattree.o fstree.o data.o livetree.o treesource.o \
5 srcpos.o checks.o util.o
6 dtc-objs += dtc-lexer.lex.o dtc-parser.tab.o
......</code></pre></div>

<p>可以看出， DTC 工具依赖于 dtc.c、flattree.c、fstree.c 等文件，最终编译并链接出 DTC 这个主机文件。如果要编译 DTS 文件的话只需要进入到 Linux 源码根目录下，然后执行如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">make</span> <span class="hljs-keyword">all</span>
或者：
<span class="hljs-keyword">make</span> dtbs</code></pre></div>

<p>“make all”命令是编译 Linux 源码中的所有东西，包括 zImage，.ko 驱动模块以及设备树，如果只是编译设备树的话建议使用“make dtbs”命令。</p>
<p>基于 ARM 架构的 SOC 有很多种，一种 SOC 又可以制作出很多款板子，每个板子都有一个对应的 DTS 文件，那么如何确定编译哪一个 DTS 文件呢？我们就以 I.MX6ULL 这款芯片对应的板子为例来看一下，打开 arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;Makefile，有如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs makefile">381 dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6UL)</span> += \
382 imx6ul-14x14-ddr3-arm2.dtb \
383 imx6ul-14x14-ddr3-arm2-emmc.dtb \
......
400 dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6ULL)</span> += \
401 imx6ull-14x14-ddr3-arm2.dtb \
402 imx6ull-14x14-ddr3-arm2-adc.dtb \
403 imx6ull-14x14-ddr3-arm2-cs42888.dtb \
404 imx6ull-14x14-ddr3-arm2-ecspi.dtb \
405 imx6ull-14x14-ddr3-arm2-emmc.dtb \
406 imx6ull-14x14-ddr3-arm2-epdc.dtb \
407 imx6ull-14x14-ddr3-arm2-flexcan2.dtb \
408 imx6ull-14x14-ddr3-arm2-gpmi-weim.dtb \
409 imx6ull-14x14-ddr3-arm2-lcdif.dtb \
410 imx6ull-14x14-ddr3-arm2-ldo.dtb \
411 imx6ull-14x14-ddr3-arm2-qspi.dtb \
412 imx6ull-14x14-ddr3-arm2-qspi-all.dtb \
413 imx6ull-14x14-ddr3-arm2-tsc.dtb \
414 imx6ull-14x14-ddr3-arm2-uart2.dtb \
415 imx6ull-14x14-ddr3-arm2-usb.dtb \
416 imx6ull-14x14-ddr3-arm2-wm8958.dtb \
417 imx6ull-14x14-evk.dtb \
418 imx6ull-14x14-evk-btwifi.dtb \
419 imx6ull-14x14-evk-emmc.dtb \
420 imx6ull-14x14-evk-gpmi-weim.dtb \
421 imx6ull-14x14-evk-usb-certi.dtb \
422 imx6ull-lxg-emmc.dtb \
423 imx6ull-lxg-nand.dtb \
424 imx6ull-9x9-evk.dtb \
425 imx6ull-9x9-evk-btwifi.dtb \
426 imx6ull-9x9-evk-ldo.dtb
427 dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6SLL)</span> += \
428 imx6sll-lpddr2-arm2.dtb \
429 imx6sll-lpddr3-arm2.dtb \
......</code></pre></div>

<p>可以看出，当选中 I.MX6ULL 这个 SOC 以后(CONFIG_SOC_IMX6ULL&#x3D;y)，所有使用到I.MX6ULL 这个 SOC 的板子对应的.dts 文件都会被编译为.dtb。如果我们使用 I.MX6ULL 新做了一个板子，只需要新建一个此板子对应的.dts 文件，然后将对应的.dtb 文件名添加到 dtb-$(CONFIG_SOC_IMX6ULL)下，这样在编译设备树的时候就会将对应的.dts 编译为二进制的.dtb文件。</p>
<p>示例代码 中第 422 和 423 行就是我们在给正点原子的 I.MX6U-ALPHA 开发板移植Linux 系统的时候添加的设备树。</p>
<h2 id="三、DTS-语法"><a href="#三、DTS-语法" class="headerlink" title="三、DTS  语法"></a>三、DTS  语法</h2><p>虽然我们基本上不会从头到尾重写一个.dts 文件，大多时候是直接在 SOC 厂商提供的.dts文件上进行修改。但是 DTS 文件语法我们还是需要详细的学习一遍，因为我们肯定需要修改.dts文件。大家不要看到要学习新的语法就觉得会很复杂，DTS 语法非常的人性化，是一种 ASCII文本文件，不管是阅读还是修改都很方便。</p>
<p>本节我们就以 imx6ull-lxg-emmc.dts 这个文件为例来讲解一下 DTS 语法。</p>
<p>关于设备树详细的语法规则请参考《 Devicetree  SpecificationV0.2.pdf 》 和《Power_ePAPR_APPROVED_v1.12.pdf》这两份文档</p>
<h3 id="1-dtsi-头文件"><a href="#1-dtsi-头文件" class="headerlink" title="1|.dtsi  头文件"></a>1|.dtsi  头文件</h3><p>和 C 语言一样，设备树也支持头文件，设备树的头文件扩展名为.dtsi。在 imx6ull-lxg-emmc.dts 中有如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/input/input.h&gt;</span></span>
<span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ull.dtsi&quot;</span></span></code></pre></div>

<p>第 12 行，使用“#include”来引用“input.h”这个.h 头文件。<br>第 13 行，使用“#include”来引用“imx6ull.dtsi”这个.dtsi 头文件。</p>
<p>看到这里，大家可能会疑惑，不是说设备树的扩展名是.dtsi 吗？为什么也可以直接引用 C语言中的.h 头文件呢？这里并没有错，.dts 文件引用 C 语言中的.h 文件，甚至也可以引用.dts 文件，打开 imx6ull-14x14-evk-gpmi-weim.dts 这个文件，此文件中有如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span>#include <span class="hljs-string">&quot;imx6ull-14x14-evk.dts&quot;</span></code></pre></div>

<p>可以看出，示例代码中直接引用了.dts 文件，因此在.dts 设备树文件中，可以通过“#include”来引用.h、.dtsi 和.dts 文件。只是，我们在编写设备树头文件的时候最好选择.dtsi 后缀。般.dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范围，比如 UART、IIC 等等。比如imx6ull.dtsi 就是描述 I.MX6ULL 这颗 SOC 内部外设情况信息的，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/clock/imx6ul-clock.h&gt;</span></span>
<span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/gpio/gpio.h&gt;</span></span>
<span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/interrupt-controller/arm-gic.h&gt;</span></span>
<span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ull-pinfunc.h&quot;</span></span>
<span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ull-pinfunc-snvs.h&quot;</span></span>
<span class="hljs-number">15</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;skeleton.dtsi&quot;</span></span>
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> / &#123;
<span class="hljs-number">18</span> aliases &#123;
<span class="hljs-number">19</span> can0 = &amp;flexcan1;
......
<span class="hljs-number">48</span> &#125;;
<span class="hljs-number">49</span>
<span class="hljs-number">50</span> cpus &#123;
<span class="hljs-number">51</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">52</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
<span class="hljs-number">53</span>
<span class="hljs-number">54</span> cpu0: cpu@<span class="hljs-number">0</span> &#123;
<span class="hljs-number">55</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;
<span class="hljs-number">56</span> device_type = <span class="hljs-string">&quot;cpu&quot;</span>;
......
<span class="hljs-number">89</span> &#125;;
<span class="hljs-number">90</span> &#125;;
<span class="hljs-number">91</span>
<span class="hljs-number">92</span> intc: interrupt-controller@<span class="hljs-number">00</span>a01000 &#123;
<span class="hljs-number">93</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;
<span class="hljs-number">94</span> <span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;3&gt;</span>;</span>
<span class="hljs-number">95</span> interrupt-controller;
<span class="hljs-number">96</span> reg = &lt;<span class="hljs-number">0x00a01000</span> <span class="hljs-number">0x1000</span>&gt;,
<span class="hljs-number">97</span> &lt;<span class="hljs-number">0x00a02000</span> <span class="hljs-number">0x100</span>&gt;;
<span class="hljs-number">98</span> &#125;;
<span class="hljs-number">99</span>
<span class="hljs-number">100</span> clocks &#123;
<span class="hljs-number">101</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">102</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
<span class="hljs-number">103</span>
<span class="hljs-number">104</span> ckil: clock@<span class="hljs-number">0</span> &#123;
<span class="hljs-number">105</span> compatible = <span class="hljs-string">&quot;fixed-clock&quot;</span>;
<span class="hljs-number">106</span> reg = &lt;<span class="hljs-number">0</span>&gt;;
<span class="hljs-number">107</span> <span class="hljs-meta">#clock-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
<span class="hljs-number">108</span> clock-frequency = &lt;<span class="hljs-number">32768</span>&gt;;
<span class="hljs-number">109</span> clock-output-names = <span class="hljs-string">&quot;ckil&quot;</span>;
<span class="hljs-number">110</span> &#125;;
......
<span class="hljs-number">135</span> &#125;;
<span class="hljs-number">136</span>
<span class="hljs-number">137</span> soc &#123;
<span class="hljs-number">138</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">139</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">140</span> compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;
<span class="hljs-number">141</span> interrupt-parent = &lt;&amp;gpc&gt;;
<span class="hljs-number">142</span> ranges;
<span class="hljs-number">143</span>
<span class="hljs-number">144</span> busfreq &#123;
<span class="hljs-number">145</span> compatible = <span class="hljs-string">&quot;fsl,imx_busfreq&quot;</span>;
......
<span class="hljs-number">162</span> &#125;;
<span class="hljs-number">197</span>
<span class="hljs-number">198</span> gpmi: gpmi-nand@<span class="hljs-number">01806000</span>&#123;
<span class="hljs-number">199</span> compatible = <span class="hljs-string">&quot;fsl,imx6ull-gpmi-nand&quot;</span>, <span class="hljs-string">&quot;fsl, imx6ul-gpmi-</span>
<span class="hljs-string">nand&quot;</span>;
<span class="hljs-number">200</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">201</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">202</span> reg = &lt;<span class="hljs-number">0x01806000</span> <span class="hljs-number">0x2000</span>&gt;, &lt;<span class="hljs-number">0x01808000</span> <span class="hljs-number">0x4000</span>&gt;;
......
<span class="hljs-number">216</span> &#125;;
......
<span class="hljs-number">1177</span> &#125;;
<span class="hljs-number">1178</span> &#125;;</code></pre></div>



<h3 id="2-设备节点"><a href="#2-设备节点" class="headerlink" title="2|设备节点"></a>2|设备节点</h3><p>设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，叫做设备节点，每个节点都通过一些属性信息来描述节点信息，属性就是键—值对。以下是从imx6ull.dtsi 文件中缩减出来的设备树文件内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> / &#123;
<span class="hljs-number">2</span> 		aliases &#123;
<span class="hljs-number">3</span> 				can0 = &amp;flexcan1;
<span class="hljs-number">4</span> 		&#125;;
<span class="hljs-number">5</span>
<span class="hljs-number">6</span> 		cpus &#123;
<span class="hljs-number">7</span> 				<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">8</span> 				<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
<span class="hljs-number">9</span>
<span class="hljs-number">10</span> 				cpu0: cpu@<span class="hljs-number">0</span> &#123;
<span class="hljs-number">11</span> 						compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;
<span class="hljs-number">12</span> 						device_type = <span class="hljs-string">&quot;cpu&quot;</span>;
<span class="hljs-number">13</span>	 					reg = &lt;<span class="hljs-number">0</span>&gt;;
<span class="hljs-number">14</span> 				&#125;;
<span class="hljs-number">15</span> 		&#125;;
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> 		intc: interrupt-controller@<span class="hljs-number">00</span>a01000 &#123;
<span class="hljs-number">18</span> 				compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;
<span class="hljs-number">19</span> 				<span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;3&gt;</span>;</span>
<span class="hljs-number">20</span> 				interrupt-controller;
<span class="hljs-number">21</span> 				reg = &lt;<span class="hljs-number">0x00a01000</span> <span class="hljs-number">0x1000</span>&gt;,
<span class="hljs-number">22</span> 						&lt;<span class="hljs-number">0x00a02000</span> <span class="hljs-number">0x100</span>&gt;;
<span class="hljs-number">23</span> 		&#125;;
<span class="hljs-number">24</span> &#125;</code></pre></div>

<p>第 1 行， “&#x2F;”是根节点，每个设备树文件只有一个根节点。细心的同学应该会发现，imx6ull.dtsi和 imx6ull-alientek-emmc.dts 这两个文件都有一个“&#x2F;”根节点，这样不会出错吗？不会的，因为这两个“&#x2F;”根节点的内容会合并成一个根节点。第 2、6 和 17 行，aliases、cpus 和 intc 是三个子节点，在设备树中节点命名格式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span><span class="hljs-title">-name</span>@unit-address</code></pre></div>

<p>其中<strong>“node-name”</strong>是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。<strong>“unit-address”</strong>一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”、“interrupt-controller@00a01000”。</p>
<p>但是我们在示例代码第0行我们看到的节点命名却如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">cpu0:</span>cpu<span class="hljs-subst">@0</span></code></pre></div>

<p>上述命令并不是“node-name@unit-address”这样的格式，而是用“：”隔开成了两部分，“：”前面的是节点标签(label)，“：”后面的才是节点名字，格式如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs crmsh">label: <span class="hljs-keyword">node</span><span class="hljs-title">-name</span>@unit-address</code></pre></div>

<p>引入 label 的目的就是为了方便访问节点，可以直接通过&amp;label 来访问这个节点，比如通过&amp;cpu0 就可以访问“cpu@0”这个节点，而不需要输入完整的节点名字。再比如节点 “intc:interrupt-controller@00a01000”，节点 label 是 intc，而节点名字就很长了，为“interrupt-controller@00a01000”。很明显通过&amp;intc 来访问“interrupt-controller@00a01000”这个节点要方便很多！</p>
<p>第 10 行，cpu0 也是一个节点，只是 cpu0 是 cpus 的子节点。每个节点都有不同属性，不同的属性又有不同的内容，属性都是键值对，值可以为空或任意的字节流。设备树源码中常用的几种数据形式如下所示：</p>
<p><strong>①、字符串</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;arm,cortex-a7&quot;</span><span class="hljs-comment">;</span></code></pre></div>

<p>上述代码设置 compatible 属性的值为字符串“arm,cortex-a7”。<br><strong>②、32  位无符号整数</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">reg</span> <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0</span>&gt;<span class="hljs-comment">;</span></code></pre></div>

<p>上述代码设置 reg 属性的值为 0，reg 的值也可以设置为一组值，比如：</p>
<div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">reg</span> <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0</span> <span class="hljs-number">0</span>x123456 <span class="hljs-number">100</span>&gt;<span class="hljs-comment">;</span></code></pre></div>

<p><strong>③、字符串列表</strong><br>属性值也可以为字符串列表，字符串和字符串之间采用“,”隔开，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx6ull-gpmi-nand&quot;</span>, <span class="hljs-string">&quot;fsl, imx6ul-gpmi-nand&quot;</span><span class="hljs-comment">;</span></code></pre></div>

<p>上述代码设置属性 compatible 的值为“fsl,imx6ull-gpmi-nand”和“fsl, imx6ul-gpmi-nand”。</p>
<h3 id="3-标准属性"><a href="#3-标准属性" class="headerlink" title="3|标准属性"></a>3|标准属性</h3><p>节点是由一堆的属性组成，节点都是具体的设备，不同的设备需要的属性不同，用户可以自定义属性。除了用户自定义属性，有很多属性是标准属性，Linux 下的很多外设驱动都会使用这些标准属性，本节我们就来学习一下几个常用的标准属性。</p>
<h4 id="1-、compatible-属性"><a href="#1-、compatible-属性" class="headerlink" title="1 、compatible  属性"></a><strong>1 、compatible  属性</strong></h4><p><strong>compatible</strong> 属性也叫做<strong>“兼容性”属性</strong>，这是非常重要的一个属性！compatible 属性的值是一个字符串列表，compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序，compatible 属性的值格式如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;manufacturer,model&quot;</span></code></pre></div>

<p>其中 <strong>manufacturer</strong> 表示厂商，<strong>model</strong> 一般是模块对应的驱动名字。</p>
<p>比如 imx6ull-lxg-emmc.dts 中 sound 节点是 I.MX6U-ALPHA 开发板的音频设备节点，I.MX6U-ALPHA 开发板上的音频芯片采用的欧胜(WOLFSON)出品的 WM8960，sound 节点的 compatible 属性值如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx6ul-evk-wm8960&quot;</span>,<span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span><span class="hljs-comment">;</span></code></pre></div>

<p>属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960”，其中<strong>“fsl”</strong>表示厂商是飞思卡尔，<strong>“imx6ul-evk-wm8960”</strong>和“<strong>imx-audio-wm8960”</strong>表示驱动模块名字。</p>
<p>sound这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。一般驱动程序文件都会有一个OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。</p>
<p>比如在文件 imx-wm8960.c 中有如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">632</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">imx_wm8960_dt_ids</span>[] =</span> &#123;
<span class="hljs-number">633</span> 	&#123; .compatible = <span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span>, &#125;,
<span class="hljs-number">634</span> 	&#123; <span class="hljs-comment">/* sentinel */</span> &#125;
<span class="hljs-number">635</span> &#125;;
<span class="hljs-number">636</span> MODULE_DEVICE_TABLE(of, imx_wm8960_dt_ids);
<span class="hljs-number">637</span>
<span class="hljs-number">638</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">imx_wm8960_driver</span> =</span> &#123;
<span class="hljs-number">639</span> 	.driver = &#123;
<span class="hljs-number">640</span> 		.name = <span class="hljs-string">&quot;imx-wm8960&quot;</span>,
<span class="hljs-number">641</span> 		.pm = &amp;snd_soc_pm_ops,
<span class="hljs-number">642</span> 		.of_match_table = imx_wm8960_dt_ids,
<span class="hljs-number">643</span> 	&#125;,
<span class="hljs-number">644</span> 	.probe = imx_wm8960_probe,
<span class="hljs-number">645</span> 	.remove = imx_wm8960_remove,
<span class="hljs-number">646</span> &#125;;</code></pre></div>

<p><strong>第 632~635 行</strong>的数组 imx_wm8960_dt_ids 就是 imx-wm8960.c 这个驱动文件的匹配表，此匹配表只有一个匹配值“fsl,imx-audio-wm8960”。如果在设备树中有哪个节点的 compatible 属性值与此相等，那么这个节点就会使用此驱动文件。<br><strong>第 642 行</strong>，wm8960 采用了 platform_driver 驱动模式，关于 platform_driver 驱动后面会讲解。此行设置.of_match_table 为 imx_wm8960_dt_ids，也就是设置这个platform_driver 所使用的OF 匹配表。</p>
<hr>
<h4 id="2-、model-属性"><a href="#2-、model-属性" class="headerlink" title="2 、model  属性"></a><strong>2 、model  属性</strong></h4><p>model 属性值也是一个字符串，一般 model 属性<strong>描述设备模块信息</strong>，比如名字什么的，比如：</p>
<div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">model</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wm8960-audio&quot;</span><span class="hljs-comment">;</span></code></pre></div>

<hr>
<h4 id="3-、status-属性"><a href="#3-、status-属性" class="headerlink" title="3 、status  属性"></a><strong>3 、status  属性</strong></h4><p>status 属性看名字就知道是和<strong>设备状态</strong>有关的，status 属性值也是字符串，字符串是设备的状态信息，可选的状态如表 43.3.3.1 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820192141947.png" srcset="/img/loading.gif" lazyload alt="image-20200820192141947"></p>
<hr>
<h4 id="4-、-address-cells-和-size-cells-属性"><a href="#4-、-address-cells-和-size-cells-属性" class="headerlink" title="4 、#address-cells  和#size-cells  属性"></a><strong>4 、#address-cells  和#size-cells  属性</strong></h4><p>这两个属性的值都是无符号 32 位整形，#address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备中，用于<strong>描述子节点的地址信息</strong>。</p>
<p>#address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)</p>
<p>#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。</p>
<p>#address-cells 和#size-cells 表明了子节点应该如何编写 reg 属性值，<strong>一般 reg 属性都是和地址有关的内容</strong>，和地址相关的信息有两种：<strong>起始地址</strong>和<strong>地址长度</strong>，reg 属性的格式一为：</p>
<div class="hljs code-wrapper"><pre><code class="hljs gcode">reg = &lt;address<span class="hljs-number">1</span> <span class="hljs-keyword">le</span><span class="hljs-symbol">ngth1</span> address<span class="hljs-number">2</span> <span class="hljs-keyword">le</span><span class="hljs-symbol">ngth2</span> address<span class="hljs-number">3</span> <span class="hljs-keyword">le</span><span class="hljs-symbol">ngth3</span>……&gt;</code></pre></div>

<p><strong>每个“address length”组合表示一个地址范围</strong>，其中 <strong>address 是起始地址</strong>，<strong>length 是地址长度</strong>，#address-cells 表明 address 这个数据所占用的字长，#size-cells 表明 length 这个数据所占用的字长，比如:</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820192517802.png" srcset="/img/loading.gif" lazyload alt="image-20200820192517802"></p>
<p><strong>第 3，4 行</strong>，节点 spi4 的#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;0&gt;，说明 spi4 的子节点 reg 属性中起始地址所占用的字长为 1，地址长度所占用的字长为 0。</p>
<p><strong>第 8 行</strong>，子节点 gpio_spi: gpio_spi@0 的 reg 属性值为 &lt;0&gt;，因为父节点设置了#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;0&gt;，因此 addres&#x3D;0，没有 length 的值，相当于设置了起始地址，而没有设置地址长度。</p>
<p><strong>第 14，15 行</strong>，设置 aips3: aips-bus@02200000 节点#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，说明 aips3: aips-bus@02200000 节点起始地址长度所占用的字长为 1，地址长度所占用的字长也为 1。</p>
<p><strong>第 19 行</strong>，子节点 dcp: dcp@02280000 的 reg 属性值为&lt;0x02280000 0x4000&gt;，因为父节点设置了#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，所以 address&#x3D; 0x02280000，length&#x3D; 0x4000，相当于设置了起始地址为 0x02280000，地址长度为 0x40000。</p>
<hr>
<h4 id="5-、reg-属性"><a href="#5-、reg-属性" class="headerlink" title="5 、reg  属性"></a><strong>5 、reg  属性</strong></h4><p>reg 属性前面已经提到过了，reg 属性的值一般是(address，length)对。reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息，比如在 imx6ull.dtsi 中有如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">323</span> uart1: serial@<span class="hljs-number">02020000</span> &#123;
<span class="hljs-number">324</span>		compatible = <span class="hljs-string">&quot;fsl,imx6ul-uart&quot;</span>,
<span class="hljs-number">325</span> 				 <span class="hljs-string">&quot;fsl,imx6q-uart&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-uart&quot;</span>;
<span class="hljs-number">326</span> 	reg = &lt;<span class="hljs-number">0x02020000</span> <span class="hljs-number">0x4000</span>&gt;;
<span class="hljs-number">327</span> 	interrupts = &lt;GIC_SPI <span class="hljs-number">26</span> IRQ_TYPE_LEVEL_HIGH&gt;;
<span class="hljs-number">328</span> 	clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,
<span class="hljs-number">329</span> 			 &lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;
<span class="hljs-number">330</span> 	clock-names = <span class="hljs-string">&quot;ipg&quot;</span>, <span class="hljs-string">&quot;per&quot;</span>;
<span class="hljs-number">331</span> 	status = <span class="hljs-string">&quot;disabled&quot;</span>;
<span class="hljs-number">332</span> &#125;;</code></pre></div>

<p>上述代码是节点 uart1，uart1 节点描述了 I.MX6ULL 的 UART1 相关信息，重点是第 326 行的 reg 属性。</p>
<p>其中 uart1 的父节点 aips1: aips-bus@02000000 设置了#address-cells &#x3D; &lt;1&gt;、#size-cells &#x3D; &lt;1&gt;，因此 reg 属性中 address&#x3D;0x02020000，length&#x3D;0x4000。</p>
<p>查阅《I.MX6ULL 参考手册》可知，I.MX6ULL 的 UART1 寄存器首地址为 0x02020000，但是 UART1 的地址长度(范围)并没有 0x4000 这么多，这里我们重点是获取 UART1 寄存器首地址。</p>
<hr>
<h4 id="6-、ranges-属性"><a href="#6-、ranges-属性" class="headerlink" title="6 、ranges  属性"></a><strong>6 、ranges  属性</strong></h4><p>ranges属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字矩阵，ranges 是一个地址映射&#x2F;转换表，ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成：</p>
<p><strong>child-bus-address</strong>：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址所占用的字长。<br><strong>parent-bus-address</strong> ：父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物理地址所占用的字长。<br><strong>length</strong> ：子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长。</p>
<p>如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换，对于我们所使用的 I.MX6ULL 来说，子地址空间和父地址空间完全相同，因此会在 imx6ull.dtsi中找到大量的值为空的 ranges 属性，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">137</span> soc &#123;
<span class="hljs-number">138</span> 	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">139</span> 	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">140</span> 	compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;
<span class="hljs-number">141</span> 	interrupt-parent = &lt;&amp;gpc&gt;;
<span class="hljs-number">142</span> 	ranges;
		......
<span class="hljs-number">1177</span> &#125;</code></pre></div>

<p><strong>第 142 行定义了 ranges 属性</strong>，但是 ranges 属性值为空。ranges 属性不为空的示例代码如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> 	soc &#123;
<span class="hljs-number">2</span> 	compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;
<span class="hljs-number">3</span> 	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">4</span> 	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">5</span> 	ranges = &lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0xe0000000</span> <span class="hljs-number">0x00100000</span>&gt;;
<span class="hljs-number">6</span>
<span class="hljs-number">7</span> 	serial &#123;
<span class="hljs-number">8</span> 		device_type = <span class="hljs-string">&quot;serial&quot;</span>;
<span class="hljs-number">9</span> 		compatible = <span class="hljs-string">&quot;ns16550&quot;</span>;
<span class="hljs-number">10</span> 		reg = &lt;<span class="hljs-number">0x4600</span> <span class="hljs-number">0x100</span>&gt;;
<span class="hljs-number">11</span> 		clock-frequency = &lt;<span class="hljs-number">0</span>&gt;;
<span class="hljs-number">12</span> 		interrupts = &lt;<span class="hljs-number">0xA</span> <span class="hljs-number">0x8</span>&gt;;
<span class="hljs-number">13</span> 		interrupt-parent = &lt;&amp;ipic&gt;;
<span class="hljs-number">14</span> 	&#125;;
<span class="hljs-number">15</span> &#125;;</code></pre></div>

<p><strong>第 5 行</strong>，节点 soc 定义的 ranges 属性，值为&lt;0x0 0xe0000000 0x00100000&gt;，此属性值指定了一个 1024KB(0x00100000)的地址范围，子地址空间的物理起始地址为 0x0，父地址空间的物理起始地址为 0xe0000000。<br><strong>第 10 行</strong>，serial 是串口设备节点，reg 属性定义了 serial 设备寄存器的起始地址为 0x4600，寄存器长度为 0x100。经过地址转换，serial 设备可以从 0xe0004600 开始进行读写操作，0xe0004600&#x3D;0x4600+0xe0000000。</p>
<hr>
<h4 id="7-、name-属性"><a href="#7-、name-属性" class="headerlink" title="7 、name  属性"></a><strong>7 、name  属性</strong></h4><p>name 属性值为字符串，name 属性<strong>用于记录节点名字</strong>，name 属性已经被弃用，不推荐使用name 属性，一些老的设备树文件可能会使用此属性。</p>
<hr>
<h4 id="8-、device-type-属性"><a href="#8-、device-type-属性" class="headerlink" title="8 、device_type  属性"></a><strong>8 、device_type  属性</strong></h4><p>device_type 属性值为字符串，IEEE 1275 会用到此属性，用于<strong>描述设备的 FCode</strong>，但是设备树没有 FCode，所以此属性也<strong>被抛弃</strong>了。此属性<strong>只能用于 cpu 节点或者 memory 节点</strong>。imx6ull.dtsi 的 cpu0 节点用到了此属性，内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">54</span> cpu0: cpu@<span class="hljs-number">0</span> &#123;
<span class="hljs-number">55</span> 		compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;
<span class="hljs-number">56</span> 		device_type = <span class="hljs-string">&quot;cpu&quot;</span>;
<span class="hljs-number">57</span> 		reg = &lt;<span class="hljs-number">0</span>&gt;;
		......
<span class="hljs-number">89</span> &#125;;</code></pre></div>

<p>关于标准属性就讲解这么多，其他的比如中断、IIC、SPI 等使用的标准属性等到具体的例程再讲解</p>
<h3 id="4-根节点-compatible-属性"><a href="#4-根节点-compatible-属性" class="headerlink" title="4|根节点 compatible 属性"></a>4|根节点 compatible 属性</h3><p>每个节点都有 compatible 属性，根节点“&#x2F;”也不例外，imx6ull-lxg-emmc.dts 文件中根节点的 compatible 属性内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">14</span> / &#123;
<span class="hljs-number">15</span> 		model = <span class="hljs-string">&quot;Freescale i.MX6 ULL 14x14 EVK Board&quot;</span>;
<span class="hljs-number">16</span> 		compatible = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;
		......
<span class="hljs-number">148</span> &#125;</code></pre></div>

<p>可以看出，compatible 有两个值：“fsl,imx6ull-14x14-evk”和“fsl,imx6ull”。前面我们说了，设备节点的 compatible 属性值是为了匹配 Linux 内核中的驱动程序，那么根节点中的 compatible属性是为了做什么工作的？ 通过根节点的 compatible 属性可以知道我们所使用的设备，一般第一个值描述了所使用的硬件设备名字，比如这里使用的是“imx6ull-14x14-evk”这个设备，第二个值描述了设备所使用的 SOC，比如这里使用的是“imx6ull”这颗 SOC。Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。接下来我们就来学习一下 Linux 内核在使用设备树前后是如何判断是否支持某款设备的。</p>
<h4 id="1、使用设备树之前设备匹配方法"><a href="#1、使用设备树之前设备匹配方法" class="headerlink" title="1、使用设备树之前设备匹配方法"></a>1、使用设备树之前设备匹配方法</h4><p>在没有使用设备树以前，uboot 会向 Linux 内核传递一个叫做 machine id 的值，machine id也就是设备 ID，告诉 Linux 内核自己是个什么设备，看看 Linux 内核是否支持。Linux 内核是支持很多设备的，针对每一个设备(板子)，Linux内核都用<strong>MACHINE_START</strong>和<strong>MACHINE_END</strong>来定义一个 machine_desc 结构体来描述这个设备，比如在文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-mx35_3ds.c 中有如下定义：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">613</span> MACHINE_START(MX35_3DS, <span class="hljs-string">&quot;Freescale MX35PDK&quot;</span>)
<span class="hljs-number">614</span> 	<span class="hljs-comment">/* Maintainer: Freescale Semiconductor, Inc */</span>
<span class="hljs-number">615</span> 	.atag_offset = <span class="hljs-number">0x100</span>,
<span class="hljs-number">616</span> 	.map_io = mx35_map_io,
<span class="hljs-number">617</span> 	.init_early = imx35_init_early,
<span class="hljs-number">618</span> 	.init_irq = mx35_init_irq,
<span class="hljs-number">619</span> 	.init_time = mx35pdk_timer_init,
<span class="hljs-number">620</span> 	.init_machine = mx35_3ds_init,
<span class="hljs-number">621</span> 	.reserve = mx35_3ds_reserve,
<span class="hljs-number">622</span> 	.restart = mxc_restart,
<span class="hljs-number">623</span> MACHINE_END</code></pre></div>

<p>其中 MACHINE_START 和MACHINE_END 定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h 中</p>
<p>根据 MACHINE_START 和 MACHINE_END 的宏定义，将示例代码展开后如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_desc</span> __<span class="hljs-title">mach_desc_MX35_3DS</span> \</span>
<span class="hljs-class">2 		__<span class="hljs-title">used</span> \</span>
<span class="hljs-class">3 		__<span class="hljs-title">attribute__</span>((__<span class="hljs-title">section__</span>(&quot;.<span class="hljs-title">arch</span>.<span class="hljs-title">info</span>.<span class="hljs-title">init</span>&quot;))) =</span> &#123;
<span class="hljs-number">4</span> 		.nr = MACH_TYPE_MX35_3DS,
<span class="hljs-number">5</span> 		.name = <span class="hljs-string">&quot;Freescale MX35PDK&quot;</span>,
<span class="hljs-number">6</span> 		<span class="hljs-comment">/* Maintainer: Freescale Semiconductor, Inc */</span>
<span class="hljs-number">7</span> 		.atag_offset = <span class="hljs-number">0x100</span>,
<span class="hljs-number">8</span> 		.map_io = mx35_map_io,
<span class="hljs-number">9</span> 		.init_early = imx35_init_early,
<span class="hljs-number">10</span> 		.init_irq = mx35_init_irq,
<span class="hljs-number">11</span> 		.init_time = mx35pdk_timer_init,
<span class="hljs-number">12</span> 		.init_machine = mx35_3ds_init,
<span class="hljs-number">13</span> 		.reserve = mx35_3ds_reserve,
<span class="hljs-number">14</span> 		.restart = mxc_restart,
<span class="hljs-number">15</span> &#125;;</code></pre></div>

<p>从示例代码中可以看出，这里定义了一个 machine_desc 类型的结构体变量__mach_desc_MX35_3DS ， 这 个 变 量 存 储 在 “ .arch.info.init ” 段 中 。 第 4 行 的MACH_TYPE_MX35_3DS 就 是 “ Freescale MX35PDK ” 这 个 板 子 的 machine id 。</p>
<p>前面说了，uboot 会给 Linux 内核传递 machine id 这个参数，Linux 内核会检查这个machine id，其实就是将 machine id 与 include&#x2F;generated&#x2F;mach-types.h 中的这些 MACH_TYPE_XXX 宏进行对比，看看有没有相等的，如果相等的话就表示 Linux 内核支持这个设备，如果不支持的话那么这个设备就没法启动 Linux 内核。</p>
<h4 id="2、使用设备树以后的设备匹配方法"><a href="#2、使用设备树以后的设备匹配方法" class="headerlink" title="2、使用设备树以后的设备匹配方法"></a>2、使用设备树以后的设备匹配方法</h4><p>当 Linux 内核引入设备树以后就不再使用 <strong>MACHINE_START</strong> 了，而是换为了<strong>DT_MACHINE_START</strong>。<strong>DT_MACHINE_START</strong> 也定义在文件arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h 里面，定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_MACHINE_START(_name, _namestr) \</span>
<span class="hljs-meta">static const struct machine_desc __mach_desc_##_name \</span>
<span class="hljs-meta">	__used \</span>
<span class="hljs-meta">	__attribute__((__section__(<span class="hljs-string">&quot;.arch.info.init&quot;</span>))) = &#123; \</span>
<span class="hljs-meta">		.nr = ~0, \</span>
<span class="hljs-meta">		.name = _namestr,</span></code></pre></div>

<p>可以看出，<strong>DT_MACHINE_START</strong> 和 <strong>MACHINE_START</strong> 基本相同，只是.nr 的设置不同，在 <strong>DT_MACHINE_START</strong> 里面直接将.nr 设置为~0。说明引入设备树以后不会再根据 machine id 来检查 Linux 内核是否支持某个设备了。<br>打开文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-imx6ul.c，有如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">208</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *imx6ul_dt_compat[] __initconst = &#123;
<span class="hljs-number">209</span> 	<span class="hljs-string">&quot;fsl,imx6ul&quot;</span>,
<span class="hljs-number">210</span> 	<span class="hljs-string">&quot;fsl,imx6ull&quot;</span>,
<span class="hljs-number">211</span> 	<span class="hljs-literal">NULL</span>,
<span class="hljs-number">212</span> &#125;;
<span class="hljs-number">213</span>
<span class="hljs-number">214</span> DT_MACHINE_START(IMX6UL, <span class="hljs-string">&quot;Freescale i.MX6 Ultralite (Device Tree)&quot;</span>)
<span class="hljs-number">215</span> 	.map_io = imx6ul_map_io,
<span class="hljs-number">216</span> 	.init_irq = imx6ul_init_irq,
<span class="hljs-number">217</span> 	.init_machine = imx6ul_init_machine,
<span class="hljs-number">218</span> 	.init_late = imx6ul_init_late,
<span class="hljs-number">219</span> 	.dt_compat = imx6ul_dt_compat,
<span class="hljs-number">220</span> MACHINE_END</code></pre></div>

<p>machine_desc 结构体中有个**.dt_compat** 成员变量，<strong>此成员变量保存着本设备兼容属性</strong>，示例代码中设置.dt_compat &#x3D; <strong>imx6ul_dt_compat</strong>，<strong>imx6ul_dt_compat</strong> 表里面有”fsl,imx6ul”和”fsl,imx6ull”这两个兼容值。只要某个设备(板子)根节点“&#x2F;”的 compatible 属性值与imx6ul_dt_compat 表中的任何一个值相等，那么就表示 Linux 内核支持此设备。imx6ull-lxg-emmc.dts 中根节点的 compatible 属性值如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span><span class="hljs-comment">;</span></code></pre></div>

<p>其中“fsl,imx6ull”与 imx6ul_dt_compat 中的“fsl,imx6ull”匹配，因此 I.MX6U-ALPHA 开发板可以正常启动 Linux 内核。</p>
<p>接下来我们简单看一下 Linux 内核是如何根据设备树根节点的 compatible 属性来匹配出对应的 <strong>machine_desc</strong>，Linux 内核调用 start_kernel 函数来启动内核，start_kernel 函数会调用setup_arch 函数来匹配 machine_desc，setup_arch 函数定义在文件arch&#x2F;arm&#x2F;kernel&#x2F;setup.c 中，函数内容如下(有缩减)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">913</span> <span class="hljs-type">void</span> __init <span class="hljs-title function_">setup_arch</span><span class="hljs-params">(<span class="hljs-type">char</span> **cmdline_p)</span>
914 &#123;
<span class="hljs-number">915</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_desc</span> *<span class="hljs-title">mdesc</span>;</span>
<span class="hljs-number">916</span>
<span class="hljs-number">917</span> 	setup_processor();
<span class="hljs-number">918</span> 	mdesc = setup_machine_fdt(__atags_pointer);
<span class="hljs-number">919</span> 	<span class="hljs-keyword">if</span> (!mdesc)
<span class="hljs-number">920</span> 		mdesc = setup_machine_tags(__atags_pointer,
										__machine_arch_type);
<span class="hljs-number">921</span> 	machine_desc = mdesc;
<span class="hljs-number">922</span> 	machine_name = mdesc-&gt;name;
		......
<span class="hljs-number">986</span> &#125;</code></pre></div>

<p>第 918 行，调用 setup_machine_fdt 函数来获取匹配的 machine_desc，参数就是 atags 的首地址，也就是 uboot 传递给 Linux 内核的 dtb 文件首地址，setup_machine_fdt 函数的返回值就是找到的最匹配的 machine_desc。</p>
<p><strong>具体详情参考正点原子IMX6U驱动开发指南43.3.4节</strong></p>
<h3 id="5-向节点追加或修改内容"><a href="#5-向节点追加或修改内容" class="headerlink" title="5|向节点追加或修改内容"></a>5|向节点追加或修改内容</h3><p>产品开发过程中可能面临着频繁的需求更改，比如第一版硬件上有一个 IIC 接口的六轴芯片 MPU6050，第二版硬件又要把这个 MPU6050 更换为 MPU9250 等。一旦硬件修改了，我们就要同步的修改设备树文件，毕竟设备树是描述板子硬件信息的文件。假设现在有个六轴芯片 fxls8471，fxls8471 要接到 I.MX6U-ALPHA 开发板的 I2C1 接口上，那么相当于需要在 i2c1 这个节点上添加一个 fxls8471 子节点。先看一下 I2C1 接口对应的节点，打开文件 imx6ull.dtsi 文件，找到如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">937</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;
<span class="hljs-number">938</span> 	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">939</span> 	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
<span class="hljs-number">940</span> 	compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;
<span class="hljs-number">941</span> 	reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;
<span class="hljs-number">942</span> 	interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;
<span class="hljs-number">943</span> 	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;
<span class="hljs-number">944</span> 	status = <span class="hljs-string">&quot;disabled&quot;</span>;
<span class="hljs-number">945</span> &#125;;</code></pre></div>

<p>示例代码 就是 I.MX6ULL 的 I2C1 节点，现在要在 i2c1 节点下创建一个子节点，这个子节点就是 fxls8471，最简单的方法就是在 i2c1 下直接添加一个名为 fxls8471 的子节点，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">937</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;
<span class="hljs-number">938</span> 	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">939</span> 	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
<span class="hljs-number">940</span> 	compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;
<span class="hljs-number">941</span> 	reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;
<span class="hljs-number">942</span> 	interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;
<span class="hljs-number">943</span> 	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;
<span class="hljs-number">944</span> 	status = <span class="hljs-string">&quot;disabled&quot;</span>;
<span class="hljs-number">945</span>
<span class="hljs-number">946</span> 	<span class="hljs-comment">//fxls8471 子节点</span>
<span class="hljs-number">947</span> 	fxls8471@<span class="hljs-number">1</span>e &#123;
<span class="hljs-number">948</span> 		compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;
<span class="hljs-number">949</span> 		reg = &lt;<span class="hljs-number">0x1e</span>&gt;;
<span class="hljs-number">950</span> 	&#125;;
<span class="hljs-number">951</span> &#125;;</code></pre></div>

<p>第 947~950 行就是添加的 fxls8471 这个芯片对应的子节点。但是这样会有个问题！i2c1 节点是定义在 imx6ull.dtsi 文件中的，而 imx6ull.dtsi 是设备树头文件，其他所有使用到 I.MX6ULL这颗 SOC 的板子都会引用 imx6ull.dtsi 这个文件。直接在 i2c1 节点中添加 fxls8471 就相当于在其他的所有板子上都添加了 fxls8471 这个设备，但是其他的板子并没有这个设备啊！因此，按照示例代码 这样写肯定是不行的。</p>
<p>这里就要引入另外一个内容，那就是如何向节点追加数据，<strong>我们现在要解决的就是如何向i2c1 节点追加一个名为 fxls8471 的子节点，而且不能影响到其他使用到 I.MX6ULL 的板子</strong>。I.MX6U-ALPHA 开发板使用的设备树文件为 imx6ull-lxg-emmc.dts，因此我们需要在imx6ull-lxg-emmc.dts 文件中完成数据追加的内容，方式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;i2c1 &#123;
<span class="hljs-number">2</span> <span class="hljs-comment">/* 要追加或修改的内容 */</span>
<span class="hljs-number">3</span> &#125;;</code></pre></div>

<p>第 1 行，&amp;i2c1 表示要访问 i2c1 这个 label 所对应的节点，也就是 imx6ull.dtsi 中的“i2c1:i2c@021a0000”。<br>第 2 行，花括号内就是要向 i2c1 这个节点添加的内容，包括修改某些属性的值。打开 imx6ull-lxg-emmc.dts，找到如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">224</span> &amp;i2c1 &#123;
<span class="hljs-number">225</span> 	clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;
<span class="hljs-number">226</span> 	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">227</span> 	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;
<span class="hljs-number">228</span> 	status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">229</span>
<span class="hljs-number">230</span> 	mag3110@<span class="hljs-number">0</span>e &#123;
<span class="hljs-number">231</span> 		compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;
<span class="hljs-number">232</span> 		reg = &lt;<span class="hljs-number">0x0e</span>&gt;;
<span class="hljs-number">233</span> 		position = &lt;<span class="hljs-number">2</span>&gt;;
<span class="hljs-number">234</span> 	&#125;;
<span class="hljs-number">235</span>
<span class="hljs-number">236</span> 	fxls8471@<span class="hljs-number">1</span>e &#123;
<span class="hljs-number">237</span> 		compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;
<span class="hljs-number">238</span> 		reg = &lt;<span class="hljs-number">0x1e</span>&gt;;
<span class="hljs-number">239</span> 		position = &lt;<span class="hljs-number">0</span>&gt;;
<span class="hljs-number">240</span> 		interrupt-parent = &lt;&amp;gpio5&gt;;
<span class="hljs-number">241</span> 		interrupts = &lt;<span class="hljs-number">0</span> <span class="hljs-number">8</span>&gt;;
<span class="hljs-number">242</span> 	&#125;;
<span class="hljs-number">243</span> &#125;;</code></pre></div>

<p>示例代码  就是向 i2c1 节点添加&#x2F;修改数据</p>
<p><strong>第 225 行</strong>的属性“clock-frequency”就表示 i2c1 时钟为 100KHz。“clock-frequency”就是新添加的属性。<br><strong>第 228 行</strong>，将 status 属性的值由原来的 disabled 改为 okay。<br><strong>第 230~234 行</strong>，i2c1 子节点 mag3110，因为 NXP 官方开发板在 I2C1 上接了一个磁力计芯片 mag3110，正点原子的 I.MX6U-ALPHA 开发板并没有使用 mag3110。<br><strong>第 236~242 行</strong>，i2c1 子节点 fxls8471，同样是因为 NXP 官方开发板在 I2C1 上接了 fxls8471这颗六轴芯片。</p>
<p>因为示例代码 中的内容是 imx6ull-lxg-emmc.dts 这个文件内的，所以不会对使用 I.MX6ULL 这颗 SOC 的其他板子造成任何影响。这个就是向节点追加或修改内容，重点就是通过&amp;label 来访问节点，然后直接在里面编写要追加或者修改的内容</p>
<h2 id="四、创建小型模板设备树"><a href="#四、创建小型模板设备树" class="headerlink" title="四、创建小型模板设备树"></a>四、创建小型模板设备树</h2><p>上一节已经对 DTS 的语法做了比较详细的讲解，本节我们就根据前面讲解的语法，从头到尾编写一个小型的设备树文件。当然了，这个小型设备树没有实际的意义，做这个的目的是为了掌握设备树的语法。在实际产品开发中，我们是不需要完完全全的重写一个.dts 设备树文件，一般都是使用 SOC 厂商提供好的.dts 文件，我们只需要在上面根据自己的实际情况做相应的修改即可。在编写设备树之前要先定义一个设备，我们就以 I.MX6ULL 这个 SOC 为例，我们需要在设备树里面描述的内容如下：</p>
<p>①、I.MX6ULL 这个 Cortex-A7 架构的 32 位 CPU。<br>②、I.MX6ULL 内部 ocram，起始地址 0x00900000，大小为 128KB(0x20000)。<br>③、I.MX6ULL 内部 aips1 域下的 ecspi1 外设控制器，寄存器起始地址为 0x02008000 大<br>小为 0x4000。<br>④、I.MX6ULL 内部 aips2 域下的 usbotg1 外设控制器，寄存器起始地址为0x02184000，大小为 0x4000。<br>⑤、I.MX6ULL 内部 aips3 域下的 rngb 外设控制器，寄存器起始地址为 0x02284000，大小为 0x4000。</p>
<p>为了简单起见，我们就在设备树里面就实现这些内容即可，首先，搭建一个仅含有根节点“&#x2F;”的基础的框架，新建一个名为 myfirst.dts 文件，在里面输入如下所示内容</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> / &#123;
<span class="hljs-number">2</span> 	compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;
<span class="hljs-number">3</span> &#125;</code></pre></div>

<p>设备树框架很简单，就一个根节点“&#x2F;”，根节点里面只有一个 compatible 属性。我们就在这个基础框架上面将上面列出的内容一点点添加进来。</p>
<h3 id="1-添加-cpus-节点"><a href="#1-添加-cpus-节点" class="headerlink" title="1|添加 cpus  节点"></a>1|添加 cpus  节点</h3><p>首先添加 CPU 节点，I.MX6ULL 采用 Cortex-A7 架构，而且只有一个 CPU，因此只有一个cpu0 节点，完成以后如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">/&#123;
    compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;
    cpus &#123;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>

        <span class="hljs-comment">//cpu0节点</span>
        cpu0:cpu@<span class="hljs-number">0</span> &#123;
            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;
            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;
            reg = &lt;<span class="hljs-number">0</span>&gt;;
        &#125;;

    &#125;;


&#125;;</code></pre></div>

<p>cpus 节点，此节点用于描述 SOC 内部的所有 CPU，因为 I.MX6ULL 只有一个CPU，因此只有一个 cpu0 子节点。</p>
<h3 id="2-添加-soc-节点"><a href="#2-添加-soc-节点" class="headerlink" title="2|添加 soc  节点"></a>2|添加 soc  节点</h3><p>像 uart，iic 控制器等等这些都属于 SOC 内部外设，因此一般会创建一个叫做 soc 的父节点来管理这些 SOC 内部外设的子节点，添加 soc 节点以后的 myfirst.dts 文件内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">/&#123;
    compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;
    cpus &#123;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>

        <span class="hljs-comment">//cpu0节点</span>
        cpu0:cpu@<span class="hljs-number">0</span> &#123;
            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;
            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;
            reg = &lt;<span class="hljs-number">0</span>&gt;;
        &#125;;

    &#125;;
    <span class="hljs-comment">//soc 节点</span>
    soc &#123;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;
        ranges;
    &#125;;

&#125;;</code></pre></div>

<p>soc 节点，soc 节点设置#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，这样 soc 子节点的 reg 属性中起始地占用一个字长，地址空间长度也占用一个字长。ranges 属性，ranges 属性为空，说明子空间和父空间地址范围相同。</p>
<h3 id="3-添加-ocram-节点"><a href="#3-添加-ocram-节点" class="headerlink" title="3|添加 ocram  节点"></a>3|添加 ocram  节点</h3><p>根据第②点的要求，添加 ocram 节点，ocram 是 I.MX6ULL 内部 RAM，因此 ocram 节点应该是 soc 节点的子节点。ocram 起始地址为 0x00900000，大小为128KB(0x20000)，添加 ocram节点以后 myfirst.dts 文件内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">/&#123;
    compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;

    cpus &#123;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>

        <span class="hljs-comment">//cpu0节点</span>
        cpu0:cpu@<span class="hljs-number">0</span> &#123;
            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;
            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;
            reg = &lt;<span class="hljs-number">0</span>&gt;;
        &#125;;

    &#125;;
    <span class="hljs-comment">//soc 节点</span>
    soc &#123;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;
        ranges;
        <span class="hljs-comment">//ocram 节点</span>
        ocram: sram@<span class="hljs-number">00900000</span> &#123;
            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;
            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;
        &#125;;
    &#125;;

&#125;;</code></pre></div>

<p>ocram 节点，节点名字@后面的 0x00900000 就是 ocram 的起始地址。reg 属性也指明了 ocram 内存的起始地址为 0x00900000，大小为 0x20000。</p>
<h3 id="4-添加-aips1-、aips2-和-和-aips3-这三个子节点"><a href="#4-添加-aips1-、aips2-和-和-aips3-这三个子节点" class="headerlink" title="4|添加 aips1 、aips2 和 和 aips3 这三个子节点"></a>4|添加 aips1 、aips2 和 和 aips3 这三个子节点</h3><p>I.MX6ULL 内部分为三个域：aips1<del>3，这三个域分管不同的外设控制器，aips1</del>3 这三个域对应的内存范围如表所示</p>
<table>
<thead>
<tr>
<th align="center">域</th>
<th align="center">起始地址</th>
<th align="center">大小( 十六进制)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AIPS1</td>
<td align="center">0X02000000</td>
<td align="center">0X100000</td>
</tr>
<tr>
<td align="center">AIPS2</td>
<td align="center">0X02100000</td>
<td align="center">0X100000</td>
</tr>
<tr>
<td align="center">AIPS3</td>
<td align="center">0X02200000</td>
<td align="center">0X100000</td>
</tr>
</tbody></table>
<p>我们先在设备树中添加这三个域对应的子节点。aips1~3这三个域都属于soc节点的子节点，完成以后的 myfirst.dts 文件内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-title class_">/</span><span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span><span class="hljs-punctuation">;</span>

    <span class="hljs-title class_">cpus</span> <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>
        <span class="hljs-meta">#size-cells = &lt;0&gt;;</span>

        <span class="hljs-comment">//cpu0节点</span>
<span class="hljs-symbol">        cpu0:</span><span class="hljs-title class_">cpu@0</span> <span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;arm,cortex-a7&quot;</span><span class="hljs-punctuation">;</span>
            device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cpu&quot;</span><span class="hljs-punctuation">;</span>
            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-punctuation">&#125;;</span>

    <span class="hljs-punctuation">&#125;;</span>
    <span class="hljs-comment">//soc 节点</span>
    <span class="hljs-title class_">soc</span> <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>
        <span class="hljs-meta">#size-cells = &lt;1&gt;;</span>
        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">ranges</span><span class="hljs-punctuation">;</span>
        <span class="hljs-comment">//ocram 节点</span>
<span class="hljs-symbol">        ocram:</span> <span class="hljs-title class_">sram@00900000</span> <span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span><span class="hljs-punctuation">;</span>
            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-punctuation">&#125;;</span>
    <span class="hljs-punctuation">&#125;;</span>

    <span class="hljs-comment">//aips1  节点</span>
<span class="hljs-symbol">    aips1:</span> <span class="hljs-title class_">aips-bus@02000000</span> <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>
        <span class="hljs-meta">#size-cells = &lt;1&gt;;</span>
        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">ranges</span><span class="hljs-punctuation">;</span>
    <span class="hljs-punctuation">&#125;;</span>

    <span class="hljs-comment">//aips2  节点</span>
<span class="hljs-symbol">    aips2:</span> <span class="hljs-title class_">aips-bus@02100000</span> <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>
        <span class="hljs-meta">#size-cells = &lt;1&gt;;</span>
        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">ranges</span><span class="hljs-punctuation">;</span>
    <span class="hljs-punctuation">&#125;;</span>

    <span class="hljs-comment">//aips3  节点</span>
<span class="hljs-symbol">    aips3:</span> <span class="hljs-title class_">aips-bus@02200000</span> <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>
        <span class="hljs-meta">#size-cells = &lt;1&gt;;</span>
        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">ranges</span><span class="hljs-punctuation">;</span>
    <span class="hljs-punctuation">&#125;;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>

<h3 id="5-添加-ecspi1-、usbotg1-和-和-rngb-这三个外设控制器节点"><a href="#5-添加-ecspi1-、usbotg1-和-和-rngb-这三个外设控制器节点" class="headerlink" title="5|添加 ecspi1 、usbotg1 和 和 rngb 这三个外设控制器节点"></a>5|添加 ecspi1 、usbotg1 和 和 rngb 这三个外设控制器节点</h3><p>最后我们在 myfirst.dts 文件中加入 ecspi1，usbotg1 和 rngb 这三个外设控制器对应的节点，其中 ecspi1 属于 aips1 的子节点，usbotg1 属于 aips2 的子节点，rngb 属于aips3 的子节点。最终的 myfirst.dts 文件内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">/&#123;
    compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;

    cpus &#123;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>

        <span class="hljs-comment">//cpu0节点</span>
        cpu0:cpu@<span class="hljs-number">0</span> &#123;
            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;
            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;
            reg = &lt;<span class="hljs-number">0</span>&gt;;
        &#125;;

    &#125;;
    <span class="hljs-comment">//soc 节点</span>
    soc &#123;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;
        ranges;
        <span class="hljs-comment">//ocram 节点</span>
        ocram: sram@<span class="hljs-number">00900000</span> &#123;
            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;
            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;
        &#125;;
    &#125;;

    <span class="hljs-comment">//aips1  节点</span>
    aips1: aips-bus@<span class="hljs-number">02000000</span> &#123;
        compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        reg = &lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;;
        ranges;

        <span class="hljs-comment">//ecspi1 节点</span>
        ecspi1: ecspi@<span class="hljs-number">02008000</span> &#123;
            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
            compatible = <span class="hljs-string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="hljs-string">&quot;fsl,imx51-ecspi&quot;</span>;
            reg = &lt;<span class="hljs-number">0x02008000</span> <span class="hljs-number">0x4000</span>&gt;;
            status = <span class="hljs-string">&quot;disabled&quot;</span>;
        &#125;;
    &#125;;

    <span class="hljs-comment">//aips2  节点</span>
    aips2: aips-bus@<span class="hljs-number">02100000</span> &#123;
        compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        reg = &lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;;
        ranges;

        <span class="hljs-comment">//usbotg1 节点</span>
        usbotg1: usb@<span class="hljs-number">02184000</span> &#123;
            compatible = <span class="hljs-string">&quot;fsl,imx6ul-usb&quot;</span>, <span class="hljs-string">&quot;fsl,imx27-usb&quot;</span>;
            reg = &lt;<span class="hljs-number">0x02184000</span> <span class="hljs-number">0x200</span>&gt;;
            status = <span class="hljs-string">&quot;disabled&quot;</span>;
        &#125;;
    
    &#125;;

    <span class="hljs-comment">//aips3  节点</span>
    aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;
        compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;
        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
        reg = &lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;;
        ranges;

        <span class="hljs-comment">//rngb 节点</span>
        rngb: rngb@<span class="hljs-number">02284000</span> &#123;
            compatible = <span class="hljs-string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="hljs-string">&quot;fsl,imx-rng&quot;</span>, <span class="hljs-string">&quot;imx-rng&quot;</span>;
            reg = &lt;<span class="hljs-number">0x02284000</span> <span class="hljs-number">0x4000</span>&gt;;
        &#125;;
    &#125;;
&#125;;</code></pre></div>

<p>至此，myfirst.dts 这个小型的模板设备树就编写好了，基本和 imx6ull.dtsi 很像，可以看做是 imx6ull.dtsi 的缩小版。在 myfirst.dts 里面我们仅仅是编写了 I.MX6ULL 的外设控制器节点，像 IIC 接口，SPI 接口下所连接的具体设备我们并没有写，因为具体的设备其设备树属性内容不同，这个等到具体的实验在详细讲解。</p>
<h2 id="五、设备树在系统中的体现"><a href="#五、设备树在系统中的体现" class="headerlink" title="五、设备树在系统中的体现"></a>五、设备树在系统中的体现</h2><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系统的&#x2F;proc&#x2F;device-tree 目录下根据节点名字创建不同文件夹，如图 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202310685.png" srcset="/img/loading.gif" lazyload alt="image-20200820202310685"></p>
<p>图 就是目录&#x2F;proc&#x2F;device-tree 目录下的内容，&#x2F;proc&#x2F;device-tree 目录下是根节点“&#x2F;”的所有属性和子节点，我们依次来看一下这些属性和子节点。</p>
<h3 id="1-、根节点“-x2F-”各个属性"><a href="#1-、根节点“-x2F-”各个属性" class="headerlink" title="1 、根节点“&#x2F; ”各个属性"></a><strong>1 、根节点“&#x2F; ”各个属性</strong></h3><p>在图中，根节点属性属性表现为一个个的文件(图中细字体文件)，比如图中的“#address-cells”、“#size-cells”、“compatible”、“model”和“name”这 5 个文件，它们在设备树中就是根节点的5个属性。</p>
<p>既然是文件那么肯定可以查看其内容，输入cat命令来查看model和 compatible 这两个文件的内容，结果如图 所示</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202617800.png" srcset="/img/loading.gif" lazyload alt="image-20200820202617800"></p>
<p>从图 可以看出，文件 model 的内容是“Freescale i.MX6 ULL 14x14 EVK Board”，文件 compatible 的内容为“fsl,imx6ull-14x14-evkfsl,imx6ull”。</p>
<p>打开文件 imx6ull-lxg-emmc.dts查看一下，这不正是根节点“&#x2F;”的 model 和 compatible 属性值吗！</p>
<h3 id="2-、根节点“-x2F-”各子节点"><a href="#2-、根节点“-x2F-”各子节点" class="headerlink" title="2 、根节点“&#x2F; ”各子节点"></a><strong>2 、根节点“&#x2F; ”各子节点</strong></h3><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202310685.png" srcset="/img/loading.gif" lazyload alt="image-20200820202310685"></p>
<p>图中各个文件夹(途中粗字体文件夹)就是根节点“&#x2F;”的各个子节点，比如“aliases”、“backlight”、“chosen”和“clocks”等等。大家可以查看一下 imx6ull-lxg-emmc.dts 和 imx6ull.dtsi 这两个文件，看看根节点的子节点都有哪些，看看是否和图 中的一致。</p>
<p>&#x2F;proc&#x2F;device-tree 目录就是设备树在根文件系统中的体现，同样是按照树形结构组织的，进入&#x2F;proc&#x2F;device-tree&#x2F;soc 目录中就可以看到 soc 节点的所有子节点，如图  所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202737979.png" srcset="/img/loading.gif" lazyload alt="image-20200820202737979"></p>
<p>和根节点“&#x2F;”一样，图 中的所有文件分别为 soc 节点的属性文件和子节点文件夹。</p>
<h2 id="六、特殊节点"><a href="#六、特殊节点" class="headerlink" title="六、特殊节点"></a>六、特殊节点</h2><p>在根节点“&#x2F;”中有两个特殊的子节点：<strong>aliases</strong> 和 <strong>chosen</strong>，我们接下来看一下这两个特殊的子节点。</p>
<h3 id="aliases子节点"><a href="#aliases子节点" class="headerlink" title="aliases子节点"></a>aliases子节点</h3><p>打开 imx6ull.dtsi 文件，aliases 节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">18</span> aliases &#123;
<span class="hljs-number">19</span> 	can0 = &amp;flexcan1;
<span class="hljs-number">20</span> 	can1 = &amp;flexcan2;
<span class="hljs-number">21</span> 	ethernet0 = &amp;fec1;
<span class="hljs-number">22</span> 	ethernet1 = &amp;fec2;
<span class="hljs-number">23</span> 	gpio0 = &amp;gpio1;
<span class="hljs-number">24</span> 	gpio1 = &amp;gpio2;
......
<span class="hljs-number">42</span> 	spi0 = &amp;ecspi1;
<span class="hljs-number">43</span> 	spi1 = &amp;ecspi2;
<span class="hljs-number">44</span> 	spi2 = &amp;ecspi3;
<span class="hljs-number">45</span> 	spi3 = &amp;ecspi4;
<span class="hljs-number">46</span> 	usbphy0 = &amp;usbphy1;
<span class="hljs-number">47</span> 	usbphy1 = &amp;usbphy2;
<span class="hljs-number">48</span> &#125;;</code></pre></div>

<p>单词 aliases 的意思是“别名”，因此 aliases 节点的<strong>主要功能就是定义别</strong>名，定义别名的目的就是为了方便访问节点。不过我们一般会在节点命名的时候会加上 label，然后通过&amp;label来访问节点，这样也很方便，而且设备树里面大量的使用&amp;label 的形式来访问节点。</p>
<h3 id="chosen子节点"><a href="#chosen子节点" class="headerlink" title="chosen子节点"></a>chosen子节点</h3><p>chosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数。一般.dts 文件中 chosen 节点通常为空或者内容很少，imx6ull-lxg-emmc.dts 中 chosen 节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">18</span> chosen &#123;
<span class="hljs-number">19</span> 		<span class="hljs-built_in">stdout</span>-path = &amp;uart1;
<span class="hljs-number">20</span> &#125;;</code></pre></div>

<p>从示例代码中可以看出，chosen 节点仅仅设置了属性“stdout-path”，表示标准输出使用 uart1。但是当我们进入到&#x2F;proc&#x2F;device-tree&#x2F;chosen 目录里面，会发现多了 bootargs 这个属性，如图 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203103001.png" srcset="/img/loading.gif" lazyload alt="image-20200820203103001"></p>
<p>输入 cat 命令查看 bootargs 这个文件的内容，结果如图所示</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203119368.png" srcset="/img/loading.gif" lazyload alt="image-20200820203119368"></p>
<p>从图可以看出，bootargs 这个文件的内容为“console&#x3D;ttymxc0,115200……”，这个不就是我们在 uboot 中设置的 bootargs 环境变量的值吗？现在有两个疑点：<br>①、我们并没有在设备树中设置 chosen 节点的 bootargs 属性，那么图中 bootargs这个属性是怎么产生的？<br>②、为何 bootargs 文件的内容和 uboot 中 bootargs 环境变量的值一样？它们之间有什么关系？</p>
<p>前面讲解 uboot 的时候说过，uboot 在启动 Linux 内核的时候会将 bootargs 的值传递给 Linux内核，bootargs 会作为 Linux 内核的命令行参数，Linux 内核启动的时候会打印出命令行参数(也就是 uboot 传递进来的 bootargs 的值)，如图 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203214452.png" srcset="/img/loading.gif" lazyload alt="image-20200820203214452"></p>
<p>既然 chosen 节点的 bootargs 属性不是我们在设备树里面设置的，那么只有一种可能，那就是 uboot 自己在 chosen 节点里面添加了 bootargs 属性！并且设置 bootargs 属性的值为 bootargs环境变量的值。因为在启动 Linux 内核之前，只有 uboot 知道 bootargs 环境变量的值，并且 uboot也知道.dtb 设备树文件在 DRAM 中的位置，因此 uboot 的“作案”嫌疑最大。在 uboot 源码中全局搜索“chosen”这个字符串，看看能不能找到一些蛛丝马迹。</p>
<p>果然不出所料，在common&#x2F;fdt_support.c 文件中发现了“chosen”的身影，fdt_support.c 文件中有个 fdt_chosen 函数，此函数内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">275</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fdt_chosen</span><span class="hljs-params">(<span class="hljs-type">void</span> *fdt)</span>
276 &#123;
<span class="hljs-number">277</span> 	<span class="hljs-type">int</span> nodeoffset;
<span class="hljs-number">278</span> 	<span class="hljs-type">int</span> err;
<span class="hljs-number">279</span> 	<span class="hljs-type">char</span> *str; <span class="hljs-comment">/* used to set string properties */</span>
<span class="hljs-number">280</span>
<span class="hljs-number">281</span> 	err = fdt_check_header(fdt);
<span class="hljs-number">282</span> 	<span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;
<span class="hljs-number">283</span> 		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fdt_chosen: %s\n&quot;</span>, fdt_strerror(err));
<span class="hljs-number">284</span> 		<span class="hljs-keyword">return</span> err;
<span class="hljs-number">285</span> 	&#125;
<span class="hljs-number">286</span>
<span class="hljs-number">287</span> 	<span class="hljs-comment">/* find or create &quot;/chosen&quot; node. */</span>
<span class="hljs-number">288</span> 	nodeoffset = fdt_find_or_add_subnode(fdt, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;chosen&quot;</span>);
<span class="hljs-number">289</span> 	<span class="hljs-keyword">if</span> (nodeoffset &lt; <span class="hljs-number">0</span>)
<span class="hljs-number">290</span> 		<span class="hljs-keyword">return</span> nodeoffset;
<span class="hljs-number">291</span>
<span class="hljs-number">292</span> 	str = getenv(<span class="hljs-string">&quot;bootargs&quot;</span>);
<span class="hljs-number">293</span> 	<span class="hljs-keyword">if</span> (str) &#123;
<span class="hljs-number">294</span> 		err = fdt_setprop(fdt, nodeoffset, <span class="hljs-string">&quot;bootargs&quot;</span>, str,
<span class="hljs-number">295</span> 		<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);
<span class="hljs-number">296</span> 		<span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;
<span class="hljs-number">297</span> 			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WARNING: could not set bootargs %s.\n&quot;</span>,
<span class="hljs-number">298</span> 			fdt_strerror(err));
<span class="hljs-number">299</span> 			<span class="hljs-keyword">return</span> err;
<span class="hljs-number">300</span> 		&#125;
<span class="hljs-number">301</span> 	&#125;
<span class="hljs-number">302</span>
<span class="hljs-number">303</span> 	<span class="hljs-keyword">return</span> fdt_fixup_stdout(fdt, nodeoffset);
<span class="hljs-number">304</span> &#125;</code></pre></div>

<p>第 288 行，调用函数 fdt_find_or_add_subnode 从设备树(.dtb)中找到 chosen 节点，如果没有找到的话就会自己创建一个 chosen 节点。<br>第 292 行，读取 uboot 中 bootargs 环境变量的内容。<br>第 294 行，调用函数 fdt_setprop 向 chosen 节点添加 bootargs 属性，并且 bootargs 属性的值就是环境变量 bootargs 的内容。证据“实锤”了，就是 uboot 中的 fdt_chosen 函数在设备树的 chosen 节点中加入了 bootargs属性，并且还设置了 bootargs 属性值。接下来我们顺着 fdt_chosen 函数一点点的抽丝剥茧，看看都有哪些函数调用了 fdt_chosen，一直找到最终的源头。这里我就不卖关子了，直接告诉大家整个流程是怎么样的，见图 :</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203540965.png" srcset="/img/loading.gif" lazyload alt="image-20200820203540965"></p>
<p>图 中框起来的部分就是函数 do_bootm_linux 函数的执行流程，也就是说do_bootm_linux 函数会通过一系列复杂的调用，最终通过 fdt_chosen 函数在 chosen 节点中加入了 bootargs 属性。而我们通过 bootz 命令启动 Linux 内核的时候会运行 do_bootm_linux 函数，至此，真相大白，一切事情的源头都源于如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">bootz</span> <span class="hljs-number">80800000</span> – <span class="hljs-number">83000000</span></code></pre></div>

<p>当我们输入上述命令并执行以后，do_bootz 函数就会执行，然后一切就按照图  中所示的流程开始运行。</p>
<h2 id="七、Linux内核解析DTB文件"><a href="#七、Linux内核解析DTB文件" class="headerlink" title="七、Linux内核解析DTB文件"></a>七、Linux内核解析DTB文件</h2><p>Linux 内核在启动的时候会解析 DTB 文件，然后在&#x2F;proc&#x2F;device-tree 目录下生成相应的设备树节点文件。接下来我们简单分析一下 Linux 内核是如何解析 DTB 文件的，流程如图  所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820211529586.png" srcset="/img/loading.gif" lazyload alt="image-20200820211529586"></p>
<p>从图中可以看出，在 start_kernel 函数中完成了设备树节点解析的工作，最终实际工作的函数为 unflatten_dt_node。</p>
<h2 id="八、绑定信息文档"><a href="#八、绑定信息文档" class="headerlink" title="八、绑定信息文档"></a>八、绑定信息文档</h2><p>设备树是用来描述板子上的设备信息的，不同的设备其信息不同，反映到设备树中就是属性不同。</p>
<p>那么我们在设备树中添加一个硬件对应的节点的时候从哪里查阅相关的说明呢？在Linux 内核源码中有详细的.txt 文档描述了如何添加节点，这些.txt 文档叫做<strong>绑定文档</strong>，路径为：Linux 源码目录&#x2F;Documentation&#x2F;devicetree&#x2F;bindings，如图所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820211703146.png" srcset="/img/loading.gif" lazyload alt="image-20200820211703146"></p>
<p>比如我们现在要想在 I.MX6ULL 这颗 SOC 的 I2C 下添加一个节点，那么就可以查看<strong>Documentation&#x2F;devicetree&#x2F;bindings&#x2F;i2c&#x2F;i2c-imx.txt</strong>，此文档详细的描述了 I.MX 系列的 SOC 如何在设备树中添加 I2C 设备节点，文档内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nix">* Freescale Inter IC (I2C) <span class="hljs-literal">and</span> High Speed Inter IC (HS-I2C) for i.MX
Required properties:
- compatible :
- <span class="hljs-string">&quot;fsl,imx1-i2c&quot;</span> for I2C compatible <span class="hljs-keyword">with</span> the one integrated on i.MX1
SoC
- <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span> for I2C compatible <span class="hljs-keyword">with</span> the one integrated on i.MX21
SoC
- <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span> for I2C compatible <span class="hljs-keyword">with</span> the one integrated on Vybrid
vf610 SoC
- reg : Should contain I2C/HS-I2C registers location <span class="hljs-literal">and</span> length
- interrupts : Should contain I2C/HS-I2C interrupt
- clocks : Should contain the I2C/HS-I2C clock specifier
Optional properties:
- clock-frequency : Constains desired I2C/HS-I2C bus clock frequency <span class="hljs-keyword">in</span>
Hz.
The absence of the propoerty indicates the default frequency <span class="hljs-number">100</span> kHz.
- dmas: A list of two dma specifiers, one for each entry <span class="hljs-keyword">in</span> dma-names.
- dma-names: should contain <span class="hljs-string">&quot;tx&quot;</span> <span class="hljs-literal">and</span> <span class="hljs-string">&quot;rx&quot;</span>.
Examples:
i2c@<span class="hljs-number">83</span>fc4000 &#123; <span class="hljs-comment">/* I2C2 on i.MX51 */</span>
    <span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;
    <span class="hljs-attr">reg</span> = &lt;<span class="hljs-number">0</span>x83fc4000 <span class="hljs-number">0</span>x4000&gt;;
    <span class="hljs-attr">interrupts</span> = &lt;<span class="hljs-number">63</span>&gt;;
&#125;;
i2c@<span class="hljs-number">70038000</span> &#123; <span class="hljs-comment">/* HS-I2C on i.MX51 */</span>
    <span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;
    <span class="hljs-attr">reg</span> = &lt;<span class="hljs-number">0</span>x70038000 <span class="hljs-number">0</span>x4000&gt;;
    <span class="hljs-attr">interrupts</span> = &lt;<span class="hljs-number">64</span>&gt;;
    <span class="hljs-attr">clock-frequency</span> = &lt;<span class="hljs-number">400000</span>&gt;;
&#125;;
i2c0: i2c@<span class="hljs-number">40066000</span> &#123; <span class="hljs-comment">/* i2c0 on vf610 */</span>
    <span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span>;
    <span class="hljs-attr">reg</span> = &lt;<span class="hljs-number">0</span>x40066000 <span class="hljs-number">0</span>x1000&gt;;
    <span class="hljs-attr">interrupts</span> =&lt;<span class="hljs-number">0</span> <span class="hljs-number">71</span> <span class="hljs-number">0</span>x04&gt;;
    <span class="hljs-attr">dmas</span> = &lt;&amp;edma0 <span class="hljs-number">0</span> <span class="hljs-number">50</span>&gt;,
    &lt;&amp;edma0 <span class="hljs-number">0</span> <span class="hljs-number">51</span>&gt;;
    <span class="hljs-attr">dma-names</span> = <span class="hljs-string">&quot;rx&quot;</span>,<span class="hljs-string">&quot;tx&quot;</span>;
&#125;;</code></pre></div>

<p>有时候使用的一些芯片在 Documentation&#x2F;devicetree&#x2F;bindings 目录下找不到对应的文档，这个时候就要咨询芯片的提供商，让他们给你提供参考的设备树文件。</p>
<h2 id="九、设备树常用-OF-操作函数"><a href="#九、设备树常用-OF-操作函数" class="headerlink" title="九、设备树常用 OF  操作函数"></a>九、设备树常用 OF  操作函数</h2><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，我们在编写驱动的时候需要获取到这些信息。</p>
<p>比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性的0X02005482 和 0X400 这两个值，然后初始化外设。</p>
<p>Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 <strong>include&#x2F;linux&#x2F;of.h</strong> 文件中。</p>
<h3 id="1-查找节点的OF函数"><a href="#1-查找节点的OF函数" class="headerlink" title="1|查找节点的OF函数"></a>1|查找节点的OF函数</h3><p>设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。Linux 内核使用 device_node 结构体来描述一个节点，此结构体定义在文件 include&#x2F;linux&#x2F;of.h 中，定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> &#123;</span>
	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;		<span class="hljs-comment">/* 节点名字 */</span>
	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *type;		<span class="hljs-comment">/* 设备类型 */</span>
	phandle phandle;
	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *full_name;	<span class="hljs-comment">/* 节点全名 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fwnode_handle</span> <span class="hljs-title">fwnode</span>;</span>

	<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">property</span> *<span class="hljs-title">properties</span>;</span>	<span class="hljs-comment">/* 属性 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">property</span> *<span class="hljs-title">deadprops</span>;</span>	<span class="hljs-comment">/* removed 属性 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">device_node</span> *<span class="hljs-title">parent</span>;</span>	<span class="hljs-comment">/* 父节点 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">device_node</span> *<span class="hljs-title">child</span>;</span>		<span class="hljs-comment">/* 子节点 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">device_node</span> *<span class="hljs-title">sibling</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _flags;
	<span class="hljs-type">void</span>	*data;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SPARC)</span>
	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path_component_name;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unique_id;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_irq_controller</span> *<span class="hljs-title">irq_trans</span>;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
&#125;;</code></pre></div>

<p>与查找节点有关的 OF 函数有 5 个，我们依次来看一下。</p>
<h4 id="of-find-node-by-name-函数"><a href="#of-find-node-by-name-函数" class="headerlink" title="of_find_node_by_name  函数"></a>of_find_node_by_name  函数</h4><p>of_find_node_by_name 函数通过节点名字查找指定的节点，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from,</span>
<span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;</code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>name</strong>：要查找的节点名字。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败。</p>
<hr>
<h4 id="of-find-node-by-type-函数"><a href="#of-find-node-by-type-函数" class="headerlink" title="of_find_node_by_type 函数"></a>of_find_node_by_type 函数</h4><p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_type</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>type</strong>：要查找的节点对应的 type 字符串，也就是 device_type 属性值。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败。</p>
<hr>
<h4 id="of-find-compatible-node-函数"><a href="#of-find-compatible-node-函数" class="headerlink" title="of_find_compatible_node  函数"></a>of_find_compatible_node  函数</h4><p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_compatible_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *compatible)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>type</strong>：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为NULL，表示忽略掉 device_type 属性。<br><strong>compatible</strong> ：要查找的节点所对应的 compatible 属性列表。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败</p>
<hr>
<h4 id="of-find-matching-node-and-match-函数"><a href="#of-find-matching-node-and-match-函数" class="headerlink" title="of_find_matching_node_and_match  函数"></a>of_find_matching_node_and_match  函数</h4><p>of_find_matching_node_and_match 函数通过 of_device_id 匹配表来查找指定的节点，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_matching_node_and_match</span><span class="hljs-params">(</span>
<span class="hljs-params">                            <span class="hljs-keyword">struct</span> device_node *from,</span>
<span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> of_device_id *matches, </span>
<span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> of_device_id **match)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>matches</strong>：of_device_id 匹配表，也就是在此匹配表里面查找节点。<br><strong>match</strong> ：找到的匹配的 of_device_id。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败</p>
<hr>
<h4 id="of-find-node-by-path-函数"><a href="#of-find-node-by-path-函数" class="headerlink" title="of_find_node_by_path  函数"></a>of_find_node_by_path  函数</h4><p>of_find_node_by_path 函数通过路径来查找指定的节点，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_path</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>path</strong>：带有全路径的节点名，可以使用节点的别名，比如“&#x2F;backlight”就是 backlight 这个节点的全路径。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败</p>
<h3 id="2-查找父-x2F-子节点的-OF-函数"><a href="#2-查找父-x2F-子节点的-OF-函数" class="headerlink" title="2|  查找父&#x2F; 子节点的 OF  函数"></a>2|  查找父&#x2F; 子节点的 OF  函数</h3><p>Linux 内核提供了几个查找节点对应的父节点或子节点的 OF 函数，我们依次来看一下。</p>
<h4 id="of-get-parent-函数"><a href="#of-get-parent-函数" class="headerlink" title="of_get_parent  函数"></a>of_get_parent  函数</h4><p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_get_parent</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *node)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<p><strong>node</strong>：要查找的父节点的节点。<br><strong>返回值</strong>：找到的父节点。</p>
<hr>
<h4 id="of-get-next-child-函数"><a href="#of-get-next-child-函数" class="headerlink" title="of_get_next_child  函数"></a>of_get_next_child  函数</h4><p>of_get_next_child 函数用迭代的查找子节点，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_get_next_child</span><span class="hljs-params">(</span>
<span class="hljs-params">                                <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *node, </span>
<span class="hljs-params">                                <span class="hljs-keyword">struct</span> device_node *prev)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>node</strong>：父节点。<br><strong>prev</strong>：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。<br><strong>返回值</strong>：找到的下一个子节点。</p>
<h3 id="3-提取属性值的-OF-函数"><a href="#3-提取属性值的-OF-函数" class="headerlink" title="3| 提取属性值的 OF  函数"></a>3| 提取属性值的 OF  函数</h3><p>节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要，Linux 内核中使用<strong>结构体 property 表示属性</strong>，此结构体同样定义在文件include&#x2F;linux&#x2F;of.h 中，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">35</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> &#123;</span>
<span class="hljs-number">36</span> 		<span class="hljs-type">char</span> *name; 			<span class="hljs-comment">/* 属性名字 */</span>
<span class="hljs-number">37</span> 		<span class="hljs-type">int</span> length; 			<span class="hljs-comment">/* 属性长度 */</span>
<span class="hljs-number">38</span> 		<span class="hljs-type">void</span> *value; 			<span class="hljs-comment">/* 属性值 */</span>
<span class="hljs-number">39</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">next</span>;</span> 	<span class="hljs-comment">/* 下一个属性 */</span>
<span class="hljs-number">40</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _flags;
<span class="hljs-number">41</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unique_id;
<span class="hljs-number">42</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bin_attribute</span> <span class="hljs-title">attr</span>;</span>
<span class="hljs-number">43</span> &#125;;</code></pre></div>

<p>Linux 内核也提供了提取属性值的 OF 函数，我们依次来看一下。</p>
<h4 id="of-find-property-函数"><a href="#of-find-property-函数" class="headerlink" title="of_find_property  函数"></a>of_find_property  函数</h4><p>of_find_property 函数用于<strong>查找指定的属性</strong>，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">property *<span class="hljs-title function_">of_find_property</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">							<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> *lenp)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>name</strong>： 属性名字。<br><strong>lenp</strong>：属性值的字节数<br><strong>返回值</strong>：找到的属性。</p>
<h4 id="of-property-count-elems-of-size-函数"><a href="#of-property-count-elems-of-size-函数" class="headerlink" title="of_property_count_elems_of_size  函数"></a>of_property_count_elems_of_size  函数</h4><p>of_property_count_elems_of_size 函数用于<strong>获取属性中元素的数量</strong>，比如 reg 属性值是一个数组，那么使用此函数可以获取到这个数组的大小，此函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_count_elems_of_size</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">							<span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, <span class="hljs-type">int</span> elem_size)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 需要统计元素数量的属性名字。<br><strong>elem_size</strong>：元素长度。<br><strong>返回值</strong>：得到的属性元素数量。</p>
<hr>
<h4 id="of-property-read-u32-index-函数"><a href="#of-property-read-u32-index-函数" class="headerlink" title="of_property_read_u32_index  函数"></a>of_property_read_u32_index  函数</h4><p>of_property_read_u32_index 函数<strong>用于从属性中获取指定标号的 u32 类型数据值</strong>(无符号 32位)，比如某个属性有多个 u32 类型的值，那么就可以使用此函数来获取指定标号的数据值，此函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32_index</span><span class="hljs-params">(	<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                                u32  index,</span>
<span class="hljs-params">                                u32 *out_value)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 要读取的属性名字。<br><strong>index</strong>：要读取的值标号。<br><strong>out_value</strong>：读取到的值<br><strong>返回值</strong>：0 读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p>
<hr>
<h4 id="of-property-read-u-array-函数"><a href="#of-property-read-u-array-函数" class="headerlink" title="of_property_read_u?_array  函数"></a>of_property_read_u?_array  函数</h4><p><strong>of_property_read_u8_array  函数</strong><br><strong>of_property_read_u16_array  函数</strong><br><strong>of_property_read_u32_array  函数</strong><br><strong>of_property_read_u64_array 函数</strong></p>
<p>这 4 个函数分别是<strong>读取属性中 u8、u16、u32 和 u64 类型的数组数据</strong>，比如大多数的 reg 属性都是数组数据，可以使用这 4 个函数一次读取出 reg 属性中的所有数据。这四个函数的原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u8_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                              <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                              u8 *out_values,</span>
<span class="hljs-params">                              <span class="hljs-type">size_t</span> sz)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u16_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                               u16 *out_values,</span>
<span class="hljs-params">                               <span class="hljs-type">size_t</span> sz)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                               u32 *out_values,</span>
<span class="hljs-params">                               <span class="hljs-type">size_t</span> sz)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u64_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                               u64 *out_values,</span>
<span class="hljs-params">                               <span class="hljs-type">size_t</span> sz)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 要读取的属性名字。<br><strong>out_value</strong>：读取到的数组值，分别为 u8、u16、u32 和 u64。<br><strong>sz</strong> ：要读取的数组元素数量。<br><strong>返回值</strong>：0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p>
<hr>
<h4 id="of-property-read-u-函数"><a href="#of-property-read-u-函数" class="headerlink" title="of_property_read_u?  函数"></a>of_property_read_u?  函数</h4><p><strong>of_property_read_u8  函数</strong><br><strong>of_property_read_u16  函数</strong><br><strong>of_property_read_u32  函数</strong><br><strong>of_property_read_u64  函数</strong><br>有些属性只有一个整形值，这四个函数就是用于读取这种只有一个整形值的属性，分别用于读取 u8、u16、u32 和 u64 类型属性值，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u8</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                        u8 *out_value)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u16</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                         u16 *out_value)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                         u32 *out_value)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u64</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                         u64 *out_value)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 要读取的属性名字。<br><strong>out_value</strong>：读取到的数组值。<br><strong>返回值</strong>：0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p>
<hr>
<h4 id="of-property-read-string-函数"><a href="#of-property-read-string-函数" class="headerlink" title="of_property_read_string  函数"></a>of_property_read_string  函数</h4><p>of_property_read_string 函数用于读取属性中字符串值，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_string</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span>
<span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> **out_string)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 要读取的属性名字。<br><strong>out_string</strong>：读取到的字符串值。<br><strong>返回值</strong>：0，读取成功，负值，读取失败。</p>
<hr>
<h4 id="of-n-addr-cells-函数"><a href="#of-n-addr-cells-函数" class="headerlink" title="of_n_addr_cells  函数"></a>of_n_addr_cells  函数</h4><p>of_n_addr_cells 函数用于获取#address-cells 属性值，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_n_addr_cells</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>返回值</strong>：获取到的#address-cells 属性值。</p>
<hr>
<h4 id="of-n-size-cells-函数"><a href="#of-n-size-cells-函数" class="headerlink" title="of_n_size_cells  函数"></a>of_n_size_cells  函数</h4><p>of_size_cells 函数用于获取#size-cells 属性值，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_n_size_cells</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>返回值</strong>：获取到的#size-cells 属性值。</p>
<h3 id="4-其他常用的-OF-函数"><a href="#4-其他常用的-OF-函数" class="headerlink" title="4|其他常用的 OF  函数"></a>4|其他常用的 OF  函数</h3><h4 id="of-device-is-compatible-函数"><a href="#of-device-is-compatible-函数" class="headerlink" title="of_device_is_compatible  函数"></a>of_device_is_compatible  函数</h4><p>of_device_is_compatible 函数用于查看节点的 <strong>compatible 属性是否有包含 compat 指定的字符串</strong>，也就是检查设备节点的兼容性，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_device_is_compatible</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *device,</span>
<span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *compat)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>device</strong>：设备节点。<br><strong>compat</strong>：要查看的字符串。<br><strong>返回值</strong>：0，节点的 compatible 属性中不包含 compat 指定的字符串；正数，节点的 compatible属性中包含 compat 指定的字符串。</p>
<hr>
<h4 id="of-get-address-函数"><a href="#of-get-address-函数" class="headerlink" title="of_get_address  函数"></a>of_get_address  函数</h4><p>of_get_address 函数用于<strong>获取地址相关属性</strong>，主要是“reg”或者“assigned-addresses”属性值，函数属性如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> __be32 *<span class="hljs-title function_">of_get_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev,</span>
<span class="hljs-params">                             <span class="hljs-type">int</span> index,</span>
<span class="hljs-params">                             u64 *size,</span>
<span class="hljs-params">                             <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *flags)</span></code></pre></div>

<p><strong>函数参数和返回值含义如下：</strong><br><strong>dev</strong>：设备节点。<br><strong>index</strong>：要读取的地址标号。<br><strong>size</strong>：地址长度。<br><strong>flags</strong>：参数，比如 IORESOURCE_IO、IORESOURCE_MEM 等<br><strong>返回值</strong>：读取到的地址数据首地址，为 NULL 的话表示读取失败。</p>
<hr>
<h4 id="of-translate-address-函数"><a href="#of-translate-address-函数" class="headerlink" title="of_translate_address  函数"></a>of_translate_address  函数</h4><p>of_translate_address 函数负责<strong>将从设备树读取到的地址转换为物理地址</strong>，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">u64 <span class="hljs-title function_">of_translate_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev,</span>
<span class="hljs-params">                         <span class="hljs-type">const</span> __be32 *in_addr)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong>：设备节点。<br><strong>in_addr</strong>：要转换的地址。<br><strong>返回值</strong>：得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</p>
<hr>
<h4 id="of-address-to-resource-函数"><a href="#of-address-to-resource-函数" class="headerlink" title="of_address_to_resource  函数"></a>of_address_to_resource  函数</h4><p>IIC、SPI、GPIO 等这些外设都有对应的寄存器，这些寄存器其实就是一组内存空间，Linux内核使用 <strong>resource 结构体来描述一段内存空间</strong>， “resource”翻译出来就是“资源”，因此用 resource结构体描述的都是设备资源信息，resource 结构体定义在文件 include&#x2F;linux&#x2F;ioport.h 中，定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">18</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> &#123;</span>
<span class="hljs-number">19</span> 		<span class="hljs-type">resource_size_t</span> start;
<span class="hljs-number">20</span> 		<span class="hljs-type">resource_size_t</span> end;
<span class="hljs-number">21</span> 		<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;
<span class="hljs-number">22</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;
<span class="hljs-number">23</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">parent</span>, *<span class="hljs-title">sibling</span>, *<span class="hljs-title">child</span>;</span>
<span class="hljs-number">24</span> &#125;;</code></pre></div>

<p>对于 32 位的 SOC 来说，resource_size_t 是 u32 类型的。</p>
<p>其中 start 表示开始地址，end 表示结束地址，name 是这个资源的名字，flags 是资源标志位，一般表示资源类型，可选的资源标志定义在文件 include&#x2F;linux&#x2F;ioport.h 中，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BITS 0x000000ff</span>
<span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_TYPE_BITS 0x00001f00</span>
<span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IO 0x00000100</span>
<span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM 0x00000200</span>
<span class="hljs-number">5</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_REG 0x00000300</span>
<span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IRQ 0x00000400</span>
<span class="hljs-number">7</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DMA 0x00000800</span>
<span class="hljs-number">8</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUS 0x00001000</span>
<span class="hljs-number">9</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_PREFETCH 0x00002000</span>
<span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_READONLY 0x00004000</span>
<span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_CACHEABLE 0x00008000</span>
<span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_RANGELENGTH 0x00010000</span>
<span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_SHADOWABLE 0x00020000</span>
<span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_SIZEALIGN 0x00040000</span>
<span class="hljs-number">15</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_STARTALIGN 0x00080000</span>
<span class="hljs-number">16</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM_64 0x00100000</span>
<span class="hljs-number">17</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_WINDOW 0x00200000</span>
<span class="hljs-number">18</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MUXED 0x00400000</span>
<span class="hljs-number">19</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_EXCLUSIVE 0x08000000</span>
<span class="hljs-number">20</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DISABLED 0x10000000</span>
<span class="hljs-number">21</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_UNSET 0x20000000</span>
<span class="hljs-number">22</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_AUTO 0x40000000</span>
<span class="hljs-number">23</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUSY 0x80000000</span></code></pre></div>

<p>大 家 一 般 最 常 见 的 资 源 标 志 就 是 IORESOURCE_MEM 、 IORESOURCE_REG 和<br>IORESOURCE_IRQ 等。</p>
<p>接下来我们回到 of_address_to_resource 函数，此函数看名字像是从设备树里面提取资源值，但是本质上就是将 reg 属性值转换为 resource 结构体类型，函数原型如下所示</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_address_to_resource</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node  *dev,</span>
<span class="hljs-params">                           <span class="hljs-type">int</span> index,</span>
<span class="hljs-params">                           <span class="hljs-keyword">struct</span> resource *r)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong>：设备节点。<br><strong>index</strong>：地址资源标号。<br><strong>r</strong>：得到的 resource 类型的资源值。<br><strong>返回值</strong>：0，成功；负值，失败。</p>
<hr>
<h4 id="of-iomap-函数"><a href="#of-iomap-函数" class="headerlink" title="of_iomap 函数"></a>of_iomap 函数</h4><p><strong>of_iomap 函数用于直接内存映射</strong>，以前我们会通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了。当然了，你也可以使用 ioremap 函数来完成物理地址到虚拟地址的内存映射，只是在采用设备树以后，大部分的驱动都使用 of_iomap 函数了。of_iomap 函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段，of_iomap 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> __iomem *<span class="hljs-title function_">of_iomap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,</span>
<span class="hljs-params">                       <span class="hljs-type">int</span> index)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>index</strong>：reg 属性中要完成内存映射的段，如果reg属性只有一段的话index就设置为0<br><strong>返回值</strong>：经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</p>
<hr>
<p>关于设备树常用的 OF 函数就先讲解到这里，Linux 内核中关于设备树的 OF 函数不仅仅只有前面讲的这几个，还有很多 OF 函数我们并没有讲解，这些没有讲解的 OF 函数要结合具体的驱动，比如获取中断号的 OF 函数、获取 GPIO 的 OF 函数等等，这些 OF 函数我们在后面的驱动实验中再详细的讲解。</p>
<h1 id="设备树下的LED驱动"><a href="#设备树下的LED驱动" class="headerlink" title="设备树下的LED驱动"></a>设备树下的LED驱动</h1><p>本章我们使用设备树来向 Linux 内核传递相关的寄存器物理地址，Linux 驱动文件使用上一章讲解的 OF函数从设备树中获取所需的属性值，然后使用获取到的属性值来初始化相关的 IO。本章实验还是比较简单的，本章实验重点内容如下：</p>
<p>①、在 imx6ull-lxg-emmc.dts 文件中创建相应的设备节点。<br>②、编写驱动程序(在前面实验基础上完成)，获取设备树中的相关属性值。<br>③、使用获取到的有关属性值来初始化 LED 所使用的 GPIO。</p>
<h2 id="修改设备树文件"><a href="#修改设备树文件" class="headerlink" title="修改设备树文件"></a>修改设备树文件</h2><p>在根节点“&#x2F;”下创建一个名为“alphaled”的子节点，打开 imx6ull-lxg-emmc.dts 文件，在根节点“&#x2F;”最后面输入如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> alphaled &#123;
<span class="hljs-number">2</span> 		<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">3</span> 		<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">4</span> 		compatible = <span class="hljs-string">&quot;atkalpha-led&quot;</span>;
<span class="hljs-number">5</span> 		status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">6</span> 		reg = &lt; <span class="hljs-number">0X020C406C</span> <span class="hljs-number">0X04</span> <span class="hljs-comment">/* CCM_CCGR1_BASE */</span>
<span class="hljs-number">7</span> 				<span class="hljs-number">0X020E0068</span> <span class="hljs-number">0X04</span> <span class="hljs-comment">/* SW_MUX_GPIO1_IO03_BASE */</span>
<span class="hljs-number">8</span> 				<span class="hljs-number">0X020E02F4</span> <span class="hljs-number">0X04</span> <span class="hljs-comment">/* SW_PAD_GPIO1_IO03_BASE */</span>
<span class="hljs-number">9</span> 				<span class="hljs-number">0X0209C000</span> <span class="hljs-number">0X04</span> <span class="hljs-comment">/* GPIO1_DR_BASE */</span>
<span class="hljs-number">10</span> 				<span class="hljs-number">0X0209C004</span> <span class="hljs-number">0X04</span> &gt;; <span class="hljs-comment">/* GPIO1_GDIR_BASE */</span>
<span class="hljs-number">11</span> &#125;;</code></pre></div>

<p><strong>第 2、3 行</strong>，属性#address-cells 和#size-cells 都为 1，表示 reg 属性中起始地址占用一个字长(cell)，地址长度也占用一个字长(cell)。<br><strong>第 4 行</strong>，属性 compatbile 设置 alphaled 节点兼容性为“atkalpha-led”。<br><strong>第 5 行</strong>，属性 status 设置状态为“okay”。<br><strong>第 6~10 行</strong>，reg 属性，非常重要！<strong>reg 属性设置了驱动里面所要使用的寄存器物理地址</strong>，比如第 6 行的“0X020C406C 0X04”表示 I.MX6ULL 的 CCM_CCGR1 寄存器，其中寄存器首地址为 0X020C406C，长度为 4 个字节。设备树修改完成以后输入如下命令重新编译一下 imx6ull-lxg-emmc.dts：<code>make dtbs</code></p>
<p>编译完成以后得到 imx6ull-lxg-emmc.dtb，使用新的 imx6ull-lxg-emmc.dtb 启动Linux 内核。Linux 启动成功以后进入到&#x2F;proc&#x2F;device-tree&#x2F;目录中查看是有“alphaled”这个节点，结果如图 所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200821114222276.png" srcset="/img/loading.gif" lazyload alt="image-20200821114222276"></p>
<p>可以进入到图中的 alphaled 目录中，查看一下都有哪些属性文件，结果如图所示：</p>
<p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200821114301406.png" srcset="/img/loading.gif" lazyload alt="image-20200821114301406"></p>
<p>大家可以查看一下 compatible、status 等属性值是否和我们设置的一致。</p>
<h2 id="LED灯驱动编写"><a href="#LED灯驱动编写" class="headerlink" title="LED灯驱动编写"></a>LED灯驱动编写</h2><p>设备树准备好以后就可以编写驱动程序了，本章实验在前面实验驱动文件newchrled.c 的基础上修改而来。新建名为“4_dtsled”文件夹，然后在 4_dtsled 文件夹里面创建vscode 工程，工作区命名为“dtsled”。工程创建好以后新建 dtsled.c 文件，在 dtsled.c 里面输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> DTSLED_DEV_NUM 1	<span class="hljs-comment">/* 设备号数量 */</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>
	LED_OFF = <span class="hljs-number">0</span>,
	LED_ON = !LED_OFF
&#125;<span class="hljs-type">led_switch_t</span>;

<span class="hljs-comment">/* 寄存器虚拟地址 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_CCM_CCGR1;
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_SW_MUX_GPIO1_IO03;
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_SW_PAD_GPIO1_IO03;
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_GPIO1_DR;
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_GPIO1_GDIR;


<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>
&#123;
	<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(sw == LED_ON)
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为低电平 默认点亮LED */</span>
		val = readl(VA_GPIO1_DR);
		val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);
		writel(val, VA_GPIO1_DR);
	&#125;
	<span class="hljs-keyword">else</span>
	&#123;
		<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>
		val = readl(VA_GPIO1_DR);
		val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);
		writel(val, VA_GPIO1_DR);
	&#125;
&#125;

<span class="hljs-comment">/* dtsled设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dtsled_dev</span> &#123;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>		<span class="hljs-comment">//字符设备</span>
	<span class="hljs-type">dev_t</span> devid;			<span class="hljs-comment">//设备号</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>	<span class="hljs-comment">//类</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>	<span class="hljs-comment">//设备</span>
	<span class="hljs-type">int</span> major;				<span class="hljs-comment">//主设备号</span>
	<span class="hljs-type">int</span> minor;				<span class="hljs-comment">//次设备号</span>
	<span class="hljs-type">char</span> *chrDevName;		<span class="hljs-comment">//设备名</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span>	<span class="hljs-comment">//设备树节点</span>
&#125;;
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dtsled_dev</span> <span class="hljs-title">dtsled</span>;</span>

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dtsled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	
	<span class="hljs-comment">//filp-&gt;private_data = &amp;dtsled;	/* 设置私有数据 */</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">dtsled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-comment">//struct dtsled_dev *dev = (struct dtsled_dev*)filp-&gt;private_data;	/* 以访问私有数据 */</span>
	<span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	ret = copy_from_user(userDataBuf, buf, cnt);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)
	&#123;
		printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;
	led_switch(userDataBuf[<span class="hljs-number">0</span>]);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dtsled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;


<span class="hljs-comment">/* 设备操作集合 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">dtsled_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.write = dtsled_write,
	.open = dtsled_open,
	.release = dtsled_release
&#125;;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">dtsled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;
	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str;
	u32 regdata[<span class="hljs-number">10</span>], i = <span class="hljs-number">0</span>;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;


	<span class="hljs-comment">/* 注册设备号 */</span>
	dtsled.chrDevName = <span class="hljs-string">&quot;dtsled&quot;</span>;
	dtsled.major = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(dtsled.major)&#123;	<span class="hljs-comment">//如果给定了主设备号</span>
		dtsled.devid = MKDEV(dtsled.major, <span class="hljs-number">0</span>);
		ret = register_chrdev_region(dtsled.devid, DTSLED_DEV_NUM, dtsled.chrDevName);

	&#125;<span class="hljs-keyword">else</span>&#123;	<span class="hljs-comment">//如果没给定主设备号那么申请设备号</span>
		ret = alloc_chrdev_region(&amp;dtsled.devid, <span class="hljs-number">0</span>, DTSLED_DEV_NUM, dtsled.chrDevName);
	&#125;
	dtsled.major = MAJOR(dtsled.devid);
	dtsled.minor = MINOR(dtsled.devid);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_devid;
	&#125;
	printk(<span class="hljs-string">&quot;dtsled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, dtsled.major, dtsled.minor);

	<span class="hljs-comment">/* 添加字符设备 */</span>
	dtsled.cdev.owner = dtsled_fops.owner;
	cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops);
	ret = cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_DEV_NUM);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_cdev;
	&#125;
	
	<span class="hljs-comment">/* 创建设备节点 */</span>
	<span class="hljs-comment">/* 	1.创建类 */</span>
	dtsled.class = class_create(THIS_MODULE, dtsled.chrDevName);
	<span class="hljs-keyword">if</span>(IS_ERR(dtsled.class))&#123;
		result = PTR_ERR(dtsled.class);
		<span class="hljs-keyword">goto</span> fail_class;
	&#125;
	<span class="hljs-comment">/*	2.创建设备*/</span>
	dtsled.device = device_create(dtsled.class, <span class="hljs-literal">NULL</span>,
						dtsled.devid, <span class="hljs-literal">NULL</span>, dtsled.chrDevName);
	<span class="hljs-keyword">if</span>(IS_ERR(dtsled.device))&#123;
		result = PTR_ERR(dtsled.device);
		<span class="hljs-keyword">goto</span> fail_device;
	&#125;

	<span class="hljs-comment">/* 获取设备节点 */</span>
	dtsled.np = of_find_node_by_path(<span class="hljs-string">&quot;/alphaled&quot;</span>);
	<span class="hljs-keyword">if</span>(dtsled.np == <span class="hljs-literal">NULL</span>)&#123;
		printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);
		ret = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_findnd;
	&#125;

	<span class="hljs-comment">/* 读取status属性 */</span>
	ret = of_property_read_string(dtsled.np, <span class="hljs-string">&quot;status&quot;</span>, &amp;str);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;no status found!\r\n&quot;</span>);
		<span class="hljs-keyword">goto</span> fail_rs;
	&#125;<span class="hljs-keyword">else</span>&#123;
		printk(<span class="hljs-string">&quot;status=%s\r\n&quot;</span>, str);
	&#125;	


	<span class="hljs-comment">/* 读取reg属性 */</span>
	ret = of_property_read_u32_array(dtsled.np, <span class="hljs-string">&quot;reg&quot;</span>, regdata, <span class="hljs-number">10</span>);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;no reg found!\r\n&quot;</span>);
		<span class="hljs-keyword">goto</span> fail_rs;
	&#125;<span class="hljs-keyword">else</span>&#123;
		printk(<span class="hljs-string">&quot;reg data:\r\n&quot;</span>);
		<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;
			printk(<span class="hljs-string">&quot;%#X &quot;</span>, regdata[i]);
		&#125;
		printk(<span class="hljs-string">&quot;\r\n&quot;</span>);
	&#125;	
<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
	<span class="hljs-comment">/* LED初始化 */</span>
	<span class="hljs-comment">/* 	-&gt;	1.地址映射 */</span>
	VA_CCM_CCGR1 = ioremap(regdata[<span class="hljs-number">0</span>], regdata[<span class="hljs-number">1</span>]);
	VA_SW_MUX_GPIO1_IO03 = ioremap(regdata[<span class="hljs-number">2</span>], regdata[<span class="hljs-number">3</span>]);
	VA_SW_PAD_GPIO1_IO03 = ioremap(regdata[<span class="hljs-number">4</span>], regdata[<span class="hljs-number">5</span>]);
	VA_GPIO1_DR = ioremap(regdata[<span class="hljs-number">6</span>], regdata[<span class="hljs-number">7</span>]);
	VA_GPIO1_GDIR = ioremap(regdata[<span class="hljs-number">8</span>], regdata[<span class="hljs-number">9</span>]);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
	<span class="hljs-comment">/* LED初始化 */</span>
	<span class="hljs-comment">/* 使用of_iomap() 可以直接将设备节点的&lt;reg&gt;属性获取并映射，</span>
<span class="hljs-comment">	 * 以省去使用of_property_read_u32_array()，和ioremap()</span>
<span class="hljs-comment">	 * 一般驱动使用设备树节点，都会这么使用，更加方便</span>
<span class="hljs-comment">	 * void __iomem *of_iomap(struct device_node *np, int index)</span>
<span class="hljs-comment">	 * index:reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为 0。</span>
<span class="hljs-comment">	 */</span>
	VA_CCM_CCGR1 = of_iomap(dtsled.np, <span class="hljs-number">0</span>);
	VA_SW_MUX_GPIO1_IO03 = of_iomap(dtsled.np, <span class="hljs-number">1</span>);
	VA_SW_PAD_GPIO1_IO03 = of_iomap(dtsled.np, <span class="hljs-number">2</span>);
	VA_GPIO1_DR = of_iomap(dtsled.np, <span class="hljs-number">3</span>);
	VA_GPIO1_GDIR = of_iomap(dtsled.np, <span class="hljs-number">4</span>);

	<span class="hljs-comment">/* 	-&gt;	2.初始化 */</span>
	<span class="hljs-comment">/* 	-&gt;	-&gt;	打开时钟 */</span>
	val = readl(VA_CCM_CCGR1);
	val &amp;=  ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);
	val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);
	writel(val, VA_CCM_CCGR1);

	writel(<span class="hljs-number">0x5</span>, VA_SW_MUX_GPIO1_IO03);		<span class="hljs-comment">/* 设置复用 */</span>
	writel(<span class="hljs-number">0x10B0</span>, VA_SW_PAD_GPIO1_IO03);	<span class="hljs-comment">/* 设置电气属性 */</span>

	<span class="hljs-comment">/* 	-&gt;	-&gt;	设置GPIO方向为输出*/</span>
	val = readl(VA_GPIO1_GDIR);
	val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);
	writel(val, VA_GPIO1_GDIR);

	<span class="hljs-comment">/* 	-&gt;	-&gt;	设置GPIO电平为高电平 默认关闭LED */</span>
	val = readl(VA_GPIO1_DR);
	val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);
	writel(val, VA_GPIO1_DR);


	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
fail_rs:
fail_findnd:
	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(dtsled.class, dtsled.devid);
fail_device:
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(dtsled.class);
fail_class:
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;dtsled.cdev);
fail_register_cdev:
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(dtsled.devid, DTSLED_DEV_NUM);
fail_register_devid:
	<span class="hljs-keyword">return</span> result;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">dtsled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-comment">/* 地址映射释放 */</span>
	iounmap(VA_CCM_CCGR1);
	iounmap(VA_SW_MUX_GPIO1_IO03);
	iounmap(VA_SW_PAD_GPIO1_IO03);
	iounmap(VA_GPIO1_DR);
	iounmap(VA_GPIO1_GDIR);

	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(dtsled.class, dtsled.devid);

	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(dtsled.class);

	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;dtsled.cdev);

	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(dtsled.devid, DTSLED_DEV_NUM);

&#125;

<span class="hljs-comment">/* 驱动入口和出口 */</span>
module_init(dtsled_init);
module_exit(dtsled_exit);

<span class="hljs-comment">/* 许可 */</span>
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-comment">/* 作者信息 */</span>
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>



<h2 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a>编写测试 APP</h2><p>本章直接使用前面的测试 APP，将上一章的 ledApp.c 文件复制到本章实验工程下即可。</p>
<h2 id="编译测试运行即可"><a href="#编译测试运行即可" class="headerlink" title="编译测试运行即可"></a>编译测试运行即可</h2>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                      <a class="hover-with-bg" href="/tags/dts%E8%AE%BE%E5%A4%87%E6%A0%91/">dts设备树</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">9| Linux 中断实验</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">
                        <span class="hidden-mobile">5| pinctrl 和 gpio 子系统实验</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
