

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="linux内核移植一、获取内核源码Linux 官网为 https:&#x2F;&#x2F;www.kernel.org，所以你想获取最新的Linux 版本就可以在这个网站上下载，网站界面如图所示：  从图可以看出最新的稳定版 Linux 已经到了 5.1.4，大家没必要追新，因为 4.x 版本的 Linux 和 5.x 版本没有本质上的区别，5.x 更多的是加入了一些新的平台、新的外设驱动而已。NXP 会从 http">
<meta property="og:type" content="article">
<meta property="og:title" content="8| linux内核移植">
<meta property="og:url" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="linux内核移植一、获取内核源码Linux 官网为 https:&#x2F;&#x2F;www.kernel.org，所以你想获取最新的Linux 版本就可以在这个网站上下载，网站界面如图所示：  从图可以看出最新的稳定版 Linux 已经到了 5.1.4，大家没必要追新，因为 4.x 版本的 Linux 和 5.x 版本没有本质上的区别，5.x 更多的是加入了一些新的平台、新的外设驱动而已。NXP 会从 http">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819114832709.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819120745881.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819120815125.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819120827827.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819121018040.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819121036268.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819121223952.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819122938067.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819123316222.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819123555197.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819130548552.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819131258173.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819131816436.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819133111334.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819143359337.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819143452149.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819143815635.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819144003337.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819144814735.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819144848532.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819145152374.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819150034290.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819150158116.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819150756416.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819160409699.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162229077.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162256490.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162751401.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162818948.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162957546.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819163450607.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819163502121.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819163905798.png">
<meta property="article:published_time" content="2020-09-06T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-06T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819114832709.png">
  
  
  <title>8| linux内核移植 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="8| linux内核移植">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-07 00:00" pubdate>
        2020年9月7日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      183 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">8| linux内核移植</h1>
            
            <div class="markdown-body">
              <h1 id="linux内核移植"><a href="#linux内核移植" class="headerlink" title="linux内核移植"></a>linux内核移植</h1><h2 id="一、获取内核源码"><a href="#一、获取内核源码" class="headerlink" title="一、获取内核源码"></a>一、获取内核源码</h2><p>Linux 官网为 <a target="_blank" rel="noopener" href="https://www.kernel.org,所以你想获取最新的linux/">https://www.kernel.org，所以你想获取最新的Linux</a> 版本就可以在这个网站上下载，网站界面如图所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819114832709.png" srcset="/img/loading.gif" lazyload alt="image-20200819114832709"></p>
<p>从图可以看出最新的稳定版 Linux 已经到了 5.1.4，大家没必要追新，因为 4.x 版本的 Linux 和 5.x 版本没有本质上的区别，5.x 更多的是加入了一些新的平台、新的外设驱动而已。NXP 会从 <a target="_blank" rel="noopener" href="https://www.kernel.org/">https://www.kernel.org</a> 下载某个版本的 Linux 内核，然后将其移植到自己的 CPU上，测试成功以后就会将其开放给 NXP 的 CPU 开发者。开发者下载 NXP 提供的 Linux 内核，然后将其移植到自己的产品上。本章的移植我们就使用 NXP 提供的Linux 源码。</p>
<p>和uboot源码一样，从对应的开发板厂商或SOC厂商获取，具体看你的开发板参考谁的板子</p>
<h2 id="二、内核浅析"><a href="#二、内核浅析" class="headerlink" title="二、内核浅析"></a>二、内核浅析</h2><h3 id="1、内核目录分析"><a href="#1、内核目录分析" class="headerlink" title="1、内核目录分析"></a>1、内核目录分析</h3><p>将 Linux 源码进行解压，解压完成以后的目录如图所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819120745881.png" srcset="/img/loading.gif" lazyload alt="image-20200819120745881"></p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819120815125.png" srcset="/img/loading.gif" lazyload alt="image-20200819120815125"></p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819120827827.png" srcset="/img/loading.gif" lazyload alt="image-20200819120827827"></p>
<ul>
<li><p>1 、arch  目录</p>
<p>这个目录是和架构有关的目录，比如 arm、arm64、avr32、x86 等等架构。每种架构都对应一个目录，在这些目录中又有很多子目录，比如 boot、common、configs 等等</p>
<p>以 arch&#x2F;arm 为例，其子目录如图 35.3.2 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819121018040.png" srcset="/img/loading.gif" lazyload alt="image-20200819121018040"></p>
<p>图 35.3.2 是 arch&#x2F;arm 的一部分子目录，这些子目录用于控制系统引导、系统调用、动态调频、主频设置等。</p>
<p>arch&#x2F;arm&#x2F;configs 目录是不同平台的默认配置文件：xxx_defconfig，如图 35.3.3所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819121036268.png" srcset="/img/loading.gif" lazyload alt="image-20200819121036268"></p>
<p>在 <strong>arch&#x2F;arm&#x2F;configs</strong> 中就包含有 I.MX6U-ALPHA 开发板的默认配置文件：imx_v7_defconfig,执行“make imx_v7_defconfig”即可完成配置。</p>
<p><strong>arch&#x2F;arm&#x2F;boot&#x2F;dts</strong> 目录里面是对应开发平台的设备树文件，正点原子 I.MX6U-ALPHA 开发板对应的设备树文件如图 35.3.4 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819121223952.png" srcset="/img/loading.gif" lazyload alt="image-20200819121223952"></p>
<p><strong>arch&#x2F;arm&#x2F;boot</strong> 目录下会保存编译出来的 Image 和 zImage 镜像文件，而 zImage 就是我们要用的 linux 镜像文件。</p>
<p><strong>arch&#x2F;arm&#x2F;mach-xxx</strong> 目录分别为相应平台的驱动和初始化文件，比如 mach-imx 目录里面就是 I.MX 系列 CPU 的驱动和初始化文件。</p>
</li>
<li><p>2 、block  目录</p>
<p>block 是 Linux 下块设备目录，像 SD 卡、EMMC、NAND、硬盘等存储设备就属于块设备，block 目录中存放着管理块设备的相关文件。</p>
</li>
<li><p>3 、crypto  目录</p>
<p>crypto 目录里面存放着加密文件，比如常见的 crc、crc32、md4、md5、hash 等加密算法。</p>
</li>
<li><p>4 、Documentation 目录</p>
<p>此目录里面存放着 Linux 相关的文档，如果要想了解 Linux 某个功能模块或驱动架构的功能，就可以在 Documentation 目录中查找有没有对应的文档。</p>
</li>
<li><p>5 、drivers  目录</p>
<p>驱动目录文件，此目录根据驱动类型的不同，分门别类进行整理，比如 drivers&#x2F;i2c 就是 I2C相关驱动目录，drivers&#x2F;gpio 就是 GPIO 相关的驱动目录，这是我们学习的重点。</p>
</li>
<li><p>6 、firmware  目录</p>
<p>此目录用于存放固件。</p>
</li>
<li><p>7 、fs  目录</p>
<p>此目录存放文件系统，比如 fs&#x2F;ext2、fs&#x2F;ext4、fs&#x2F;f2fs 等，分别是 ext2、ext4 和 f2fs 等文件系统。</p>
</li>
<li><p>8 、include  目录</p>
<p>头文件目录。</p>
</li>
<li><p>9 、init  目录</p>
<p>此目录存放 Linux 内核启动的时候初始化代码。</p>
</li>
<li><p>10 、ipc  目录</p>
<p>IPC 为进程间通信，ipc 目录是进程间通信的具体实现代码。</p>
</li>
<li><p>11 、kernel  目录</p>
<p>Linux 内核代码。</p>
</li>
<li><p>12 、lib  目录</p>
<p>lib 是库的意思，lib 目录都是一些公用的库函。</p>
</li>
<li><p>13 、mm  目录</p>
<p>此目录存放内存管理相关代码。</p>
</li>
<li><p>14 、net  目录</p>
<p>此目录存放网络相关代码。</p>
</li>
<li><p>15 、samples  目录</p>
<p>此目录存放一些示例代码文件。</p>
</li>
<li><p>16 、scripts  目录</p>
<p>脚本目录，Linux 编译的时候会用到很多脚本文件，这些脚本文件就保存在此目录中。</p>
</li>
<li><p>17 、security  目录</p>
<p>此目录存放安全相关的文件。</p>
</li>
<li><p>18 、sound  目录</p>
<p>此目录存放音频相关驱动文件，音频驱动文件并没有存放到 drivers 目录中，而是单独的目录。</p>
</li>
<li><p>19 、tools  目录</p>
<p>此目录存放一些编译的时候使用到的工具。</p>
</li>
<li><p>20 、usr  目录</p>
<p>此目录存放与 initramfs 有关的代码。</p>
</li>
<li><p>21 、virt  目录</p>
<p>此目录存放虚拟机相关文件。</p>
</li>
<li><p>22 、.config  文件</p>
<p>跟 uboot 一样，.config 保存着 Linux 最终的配置信息，编译 Linux 的时候会读取此文件中<br>的配置信息。最终根据配置信息来选择编译 Linux 哪些模块，哪些功能。</p>
</li>
<li><p>23 、Kbuild  文件</p>
<p>有些 Makefile 会读取此文件。</p>
</li>
<li><p>24 、Kconfig </p>
<p>图形化配置界面的配置文件。</p>
</li>
<li><p>25 、Makefile  文件</p>
<p>Linux 顶层 Makefile 文件，建议好好阅读一下此文件。</p>
</li>
<li><p>26 、README  文件</p>
<p>此文件详细讲解了如何编译 Linux 源码，以及 Linux 源码的目录信息，建议仔细阅读一下此文件。</p>
</li>
</ul>
<h3 id="2、顶层Makefile分析"><a href="#2、顶层Makefile分析" class="headerlink" title="2、顶层Makefile分析"></a>2、顶层Makefile分析</h3><p>参考正点原子IMX6U驱动开发指南35.5节。</p>
<h3 id="3、内核启动流程分析"><a href="#3、内核启动流程分析" class="headerlink" title="3、内核启动流程分析"></a>3、内核启动流程分析</h3><p>参考正点原子IMX6U驱动开发指南36.1、36.2节。</p>
<h2 id="三、内核移植"><a href="#三、内核移植" class="headerlink" title="三、内核移植"></a>三、内核移植</h2><h3 id="1、创建VSCode工程"><a href="#1、创建VSCode工程" class="headerlink" title="1、创建VSCode工程"></a>1、创建VSCode工程</h3><p>这里我们使用 NXP 官方提供的 Linux 源码，将其移植到正点原子 I.MX6U-ALPHA 开发板上。</p>
<p>源码压缩包<strong>linux-imx-rel_imx_4.1.15_2.1.0_ga.tar.bz2</strong>。使用FileZilla将其发送到Ubuntu中并解压，得到名为<code>linux-imx-rel_imx_4.1.15_2.1.0_ga</code>的目录，为了和 NXP 官方的名字区分，可 以使用“ mv ”命令对其重命名，我这里将其重命名为 “ linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg”.</p>
<p>命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mv</span> linux-imx-rel_imx_4.1.15_2.1.0_ga linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg</code></pre></div>

<p>完成以后创建 VSCode 工程，步骤和 Windows 下一样，重点是.vscode&#x2F;settings.json 这个文件。</p>
<h3 id="2、NXP-官方开发板-Linux-内核初次编译"><a href="#2、NXP-官方开发板-Linux-内核初次编译" class="headerlink" title="2、NXP  官方开发板 Linux 内核初次编译"></a>2、NXP  官方开发板 Linux 内核初次编译</h3><p>编译内核之前需要先在 ubuntu 上安装 lzop 库，否则内核编译会失败！命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">sudo apt-get install lzop</code></pre></div>

<p>修改顶层 Makefile，直接在顶层 Makefile 文件里面定义 ARCH 和 CROSS_COMPILE 这两个的变量值为 arm 和 arm-linux-gnueabihf-，结果如图 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819122938067.png" srcset="/img/loading.gif" lazyload alt="image-20200819122938067"></p>
<p>分别设置了 ARCH 和 CROSS_COMPILE 这两个变量的值，这样在编译的时候就不用输入很长的命令了。</p>
<p>和 uboot 一样，在编译 Linux 内核之前要先配置 Linux 内核。每个板子都有其对应的默认配置文件，这些默认配置文件保存 在 <strong>arch&#x2F;arm&#x2F;configs</strong> 目录中。 imx_v7_defconfig 和imx_v7_mfg_defconfig 都可作为 I.MX6ULL EVK 开发板所使用的默认配置文件。但是这里建议使用 imx_v7_mfg_defconfig 这个默认配置文件，首先此配置文件默认支持 I.MX6UL 这款芯片，而且重要的一点就是此文件编译出来的 zImage 可以通过 NXP 官方提供的 MfgTool 工具烧写！！imx_v7_mfg_defconfig 中的“mfg”的意思就是 MfgTool。进入到 Ubuntu 中的 Linux 源码根目录下，执行如下命令配置 Linux 内核：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">make clean  <span class="hljs-regexp">//</span>第一次编译 Linux 内核之前先清理一下
make imx_v7_mfg_defconfig <span class="hljs-regexp">//</span>配置 Linux 内核</code></pre></div>

<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819123316222.png" srcset="/img/loading.gif" lazyload alt="image-20200819123316222"></p>
<p>配置完成以后就可以编译了，使用如下命令编译 Linux 内核：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">make -j12  <span class="hljs-regexp">//</span>编译 Linux 内核</code></pre></div>

<p>等待编译完成，结果如图所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819123555197.png" srcset="/img/loading.gif" lazyload alt="image-20200819123555197"></p>
<p>Linux 内核编译完成以后会在 <strong>arch&#x2F;arm&#x2F;boot</strong> 目录下生成 <strong>zImage</strong> 镜像文件，如果使用设备树的话还会在 <strong>arch&#x2F;arm&#x2F;boot&#x2F;dts</strong> 目录下开发板对应的**.dtb**(设备树)文件，比如 imx6ull-14x14-evk.dtb就是 NXP 官方的 I.MX6ULL EVK 开发板对应的设备树文件。至此我们得到两个文件：<br><strong>①、Linux 内核镜像文件：zImage。</strong><br><strong>②、NXP 官方 I.MX6ULL EVK 开发板对应的设备树文件：imx6ull-14x14-evk.dtb。</strong></p>
<h3 id="3、Linux-内核启动测试"><a href="#3、Linux-内核启动测试" class="headerlink" title="3、Linux 内核启动测试"></a>3、Linux 内核启动测试</h3><p>在上一小节我们已经得到了 NXP 官方 I.MX6ULL EVK 开发板对应的 zImage 和 imx6ull-14x14-evk.dtb 这两个文件。</p>
<p>现在测试这两个文件能不能在正点原子的 I.MX6U-ALPHA EMMC 版开发板上启动，在测试之前确保 uboot 中的环境变量 bootargs 内容如下：<br><code>console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw</code><br>将上一小节编译出来的 zImage 和 imx6ull-14x14-evk.dtb 复制到 Ubuntu 中的 tftp 目录下，因为我们要在 uboot 中使用 tftp 命令将其下载到开发板中，拷贝命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> <span class="hljs-built_in">arch</span>/arm/boot/zImage /home/firestaradmin/linux/tftpboot/ -f
<span class="hljs-built_in">cp</span> <span class="hljs-built_in">arch</span>/arm/boot/dts/imx6ull-14x14-evk.dtb /home/firestaradmin/linux/tftpboot/ -f</code></pre></div>

<p>拷贝完成以后就可以测试了，启动开发板，进入 uboot 命令行模式，然后输入如下命令将zImage 和 imx6ull-14x14-evk.dtb 下载到开发板中并启动：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">tftp 80800000 zImage
tftp 83000000 imx6ull-14x14-evk.dtb
bootz 80800000 - 83000000</code></pre></div>

<p>结果图所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819130548552.png" srcset="/img/loading.gif" lazyload alt="image-20200819130548552"></p>
<h3 id="4、在linux内核中添加自己的开发板"><a href="#4、在linux内核中添加自己的开发板" class="headerlink" title="4、在linux内核中添加自己的开发板"></a>4、在linux内核中添加自己的开发板</h3><h4 id="1、添加默认配置文件"><a href="#1、添加默认配置文件" class="headerlink" title="1、添加默认配置文件"></a>1、添加默认配置文件</h4><p>将 arch&#x2F;arm&#x2F;configs 目 录 下 的 imx_v7_mfg_defconfig 重 新 复 制 一 份 ， 命 名 imx_lxg_emmc_defconfig，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">arch</span>/arm/configs
<span class="hljs-built_in">cp</span> imx_v7_mfg_defconfig imx_lxg_emmc_defconfig</code></pre></div>

<p>以后 imx_lxg_emmc_defconfig就是我们的 EMMC 版开发板默认配置文件了。完成以后如图 37.3.1.1 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819131258173.png" srcset="/img/loading.gif" lazyload alt="image-20200819131258173"></p>
<h4 id="2、添加开发板对应的设备树文件"><a href="#2、添加开发板对应的设备树文件" class="headerlink" title="2、添加开发板对应的设备树文件"></a>2、添加开发板对应的设备树文件</h4><p>添加适合正点原子 EMMC 版开发板的设备树文件，进入目录 arch&#x2F;arm&#x2F;boot&#x2F;dts 中，复制一份 imx6ull-14x14-evk.dts，然后将其重命名为 imx6ull-lxg-emmc.dts，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">arch</span>/arm/boot/dts
<span class="hljs-built_in">cp</span> imx6ull-14x14-evk.dts imx6ull-lxg-emmc.dts</code></pre></div>

<p>.dts 是设备树源码文件，编译 Linux 的时候会将其编译为.dtb 文件。imx6ull-lxg-emmc.dts<br>创建好以后我们还需要修改arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;Makefile，找到 “ dtb-$(CONFIG_SOC_IMX6ULL)”配置项，在此配置项中加入“imx6ull-lxg-emmc.dtb” ，如下所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819131816436.png" srcset="/img/loading.gif" lazyload alt="image-20200819131816436"></p>
<p>这样编译 Linux 的时候就可以从 imx6ull-lxg-emmc.dts 编译出 imx6ull-lxg-emmc.dtb 文件了。</p>
<h4 id="3、编译测试"><a href="#3、编译测试" class="headerlink" title="3、编译测试"></a>3、编译测试</h4><p>经过前面两个小节，Linux 内核里面已经添加了我们自己的I.MX6UL-LXG-EMMC 版开发板了，接下接编译测试一下，我们可以创建一个编译脚本，imx6ull_lxg_emmc.sh，脚本内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_lxg_emmc_defconfig
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all -j12</code></pre></div>

<p>第 2 行，清理工程。<br>第 3 行，使用默认配置文件 imx_lxg_emmc_defconfig 来配置 Linux 内核。<br>第 4 行，打开 Linux 的图形配置界面，如果不需要每次都打开图形配置界面可以删除此行。<br>第 5 行，编译 Linux。</p>
<p>执行 shell 脚本 imx_lxg_emmc.sh 编译 Linux 内核，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 imx_lxg_emmc.sh //给予可执行权限
./imx_lxg_emmc.sh //执行 shell 脚本编译内核</code></pre></div>

<p>编译完成以后就会在目录 arch&#x2F;arm&#x2F;boot 下生成 zImage 镜像文件。在 arch&#x2F;arm&#x2F;boot&#x2F;dts 目录下生成 imx6ull-lxg-emmc.dtb 文件。将这两个文件拷贝到 tftp 目录下，然后重启开发板，在uboot 命令模式中使用 tftp 命令下载这两个文件并启动，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">tftp 80800000 zImage
tftp 83000000 imx6ull-lxg-emmc.dtb
bootz 80800000 – 83000000</code></pre></div>

<p>只要出现如图所示内容就表示 Linux 内核启动成功：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819133111334.png" srcset="/img/loading.gif" lazyload alt="image-20200819133111334"></p>
<p>红框为linux内核的编译时间</p>
<h3 id="5、部分驱动修改（CPU、NET、EMMC）"><a href="#5、部分驱动修改（CPU、NET、EMMC）" class="headerlink" title="5、部分驱动修改（CPU、NET、EMMC）"></a>5、部分驱动修改（CPU、NET、EMMC）</h3><h4 id="1、CPU主频修改"><a href="#1、CPU主频修改" class="headerlink" title="1、CPU主频修改"></a>1、CPU主频修改</h4><h5 id="1、在linux下手动修改cpu配置文件或修改linux内核配置文件"><a href="#1、在linux下手动修改cpu配置文件或修改linux内核配置文件" class="headerlink" title="1、在linux下手动修改cpu配置文件或修改linux内核配置文件"></a>1、在linux下手动修改cpu配置文件或修改linux内核配置文件</h5><p>正点原子 I.MX6U-ALPHA 开发板所使用的 I.MX6ULL 芯片主频都是 792MHz 的，也就是NXP 官方宣传的 800MHz 版本。这里以此板为例。</p>
<p>1 、设置 I.MX6U-ALPHA  开发板工作在 792MHz<br>确保 EMMC 中的根文件系统可用！然后重新启动开发板，进入终端(可以输入命令)，如图</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /proc/cpuinfo</code></pre></div>

<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819143359337.png" srcset="/img/loading.gif" lazyload alt="image-20200819143359337"></p>
<p>在图 中有 BogoMIPS 这一条，此时 BogoMIIS 为 3.00，BogoMIPS 是 Linux 系统中衡量处理器运行速度的一个“尺子”，处理器性能越强，主频越高，BogoMIPS 值就越大。BogoMIPS 只是粗略的计算 CPU 性能，并不十分准确。但是我们可以通过 BogoMIPS 值来大致的判断当前处理器的性能。在图中并没有看到当前 CPU 的工作频率，那我们就转变另一种方法查看当前 CPU 的工作频率。进入到目录 &#x2F;sys&#x2F;bus&#x2F;cpu&#x2F;devices&#x2F;cpu0&#x2F;cpufreq 中，此目录下会有很多文件，如图 37.4.1.3 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819143452149.png" srcset="/img/loading.gif" lazyload alt="image-20200819143452149"></p>
<p>此目录中记录了 CPU 频率等信息，这些文件的含义如下：<br><strong>cpuinfo_cur_freq</strong>：当前 cpu 工作频率，从 CPU 寄存器读取到的工作频率。<br><strong>cpuinfo_max_freq</strong>：处理器所能运行的最高工作频率(单位: KHz）。<br><strong>cpuinfo_min_freq</strong> ：处理器所能运行的最低工作频率(单位: KHz）。<br><strong>cpuinfo_transition_latency</strong>：处理器切换频率所需要的时间(单位:ns)。<br><strong>scaling_available_frequencies</strong>：处理器支持的主频率列表(单位: KHz）。<br><strong>scaling_available_governors</strong>：当前内核中支持的所有 governor(调频)类型。<br><strong>scaling_cur_freq</strong>：保存着 cpufreq 模块缓存的当前 CPU 频率，不会对 CPU 硬件寄存器进行检查。<br><strong>scaling_driver</strong>：该文件保存当前 CPU 所使用的调频驱动。<br><strong>scaling_governor</strong> ：governor(调频)策略，Linux 内核一共有 5 中调频策略，</p>
<ul>
<li>①、Performance，最高性能，直接用最高频率，不考虑耗电。<br>②、Interactive，一开始直接用最高频率，然后根据 CPU 负载慢慢降低。<br>③、Powersave，省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！<br>④、Userspace，可以在用户空间手动调节频率。<br>⑤、Ondemand，定时检查负载，然后根据负载来调节频率。负载低的时候降低 CPU 频率，这样省电，负载高的时候提高 CPU 频率，增加性能。</li>
</ul>
<p><strong>scaling_max_freq</strong> ：governor(调频)可以调节的最高频率。<br><strong>cpuinfo_min_freq</strong>：governor(调频)可以调节的最低频率。</p>
<p><strong>stats 目录</strong>下给出了 CPU 各种运行频率的统计情况，比如 CPU 在各频率下的运行时间以及<br>变频次数。</p>
<p>使用如下命令查看当前 CPU 频率：<code>cat cpuinfo_cur_freq</code><br>结果如图 37.4.1.4 所示</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819143815635.png" srcset="/img/loading.gif" lazyload alt="image-20200819143815635"></p>
<p>从图 37.4.1.4 可以看出，当前 CPU 频率为 198MHz，工作频率很低！其他的值如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cpuinfo_cur_freq</span> = <span class="hljs-number">198000</span>
<span class="hljs-attribute">cpuinfo_max_freq</span> = <span class="hljs-number">792000</span>
<span class="hljs-attribute">cpuinfo_min_freq</span> = <span class="hljs-number">198000</span>
<span class="hljs-attribute">scaling_cur_freq</span> = <span class="hljs-number">198000</span>
<span class="hljs-attribute">scaling_max_freq</span> = <span class="hljs-number">792000</span>
<span class="hljs-attribute">cat</span> scaling_min_freq = <span class="hljs-number">198000</span>
<span class="hljs-attribute">scaling_available_frequencies</span> = <span class="hljs-number">198000</span> <span class="hljs-number">396000</span> <span class="hljs-number">528000</span> <span class="hljs-number">792000</span>
<span class="hljs-attribute">cat</span> scaling_governor = ondemand</code></pre></div>

<p>可以看出，当前 CPU 支持 198MHz、396MHz、528Mhz 和 792000 四种频率切换，其中调频策略为 ondemand，也就是定期检查负载，然后根据负载情况调节 CPU 频率。因为当前我们开发板并没有做什么工作，因此 CPU 频率降低为 198MHz 以省电。如果开发板做一些高负载的工作，比如播放视频等操作那么 CPU 频率就会提升上去。</p>
<p>查看 stats 目录下的 time_in_state 文件可以看到 CPU 在各频率下的工作时间，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /sys/bus/cpu/devices/cpu0/cpufreq/stats/time_in_state</code></pre></div>

<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819144003337.png" srcset="/img/loading.gif" lazyload alt="image-20200819144003337"></p>
<p>从图中可以看出，CPU 在 198MHz、396MHz、528MHz 和 792MHz 都工作过，其中 198MHz 的工作时间最长！假如我们想让 CPU 一直工作在 792MHz 那该怎么办？很简单，配置 Linux 内核，将调频策略选择为 performance（直接修改<strong>scaling_governor</strong> 文件的内容，将ondemand修改为performance）。</p>
<p>或者修改 imx_lxg_emmc_defconfig 文件，此文件中有下面几行：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND</span>=y
<span class="hljs-attr">CONFIG_CPU_FREQ_GOV_POWERSAVE</span>=y
<span class="hljs-attr">CONFIG_CPU_FREQ_GOV_USERSPACE</span>=y
<span class="hljs-attr">CONFIG_CPU_FREQ_GOV_INTERACTIVE</span>=y</code></pre></div>

<p>分别为：</p>
<p>配置 ondemand 为默认调频策略。<br>使能 powersave 策略。<br>使能 userspace 策略。<br>使能 interactive 策略</p>
<p>将示例代码中的第 1 行屏蔽掉，然后在最后面添加：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_CPU_FREQ_GOV_ONDEMAND</span>=y</code></pre></div>

<p>修改完成以后重新编译 Linux 内核，编译之前先清理一下工程！因为我们重新修改过默认配置文件了，编译完成以后使用新的 zImage 镜像文件重新启动 Linux。再次查看&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F; cpuinfo_cur_freq 文件的值，如图 37.4.1.6 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819144814735.png" srcset="/img/loading.gif" lazyload alt="image-20200819144814735"></p>
<p>从图可以看出，当前 CPU 频率为 792MHz 了。查看 scaling_governor 文件看一下当前的调频策略，如图 37.4.1.7 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819144848532.png" srcset="/img/loading.gif" lazyload alt="image-20200819144848532"></p>
<p>从图 可以看出当前的 CPU 调频策略为 preformance，也就是高性能模式，一直以最高主频运行。</p>
<h5 id="2、使用linux图形化配置界面配置"><a href="#2、使用linux图形化配置界面配置" class="headerlink" title="2、使用linux图形化配置界面配置"></a>2、使用linux图形化配置界面配置</h5><p>输入<code>make menuconfig</code>打开 Linux 内核的图形化配置界面</p>
<p>进入如下路径：<br>CPU Power Management<br>    -&gt; CPU Frequency scaling<br>        -&gt; CPU Frequency scaling<br>            -&gt; Default CPUFreq governor<br>打开默认调频策略选择界面，选择“performance”，如图所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819145152374.png" srcset="/img/loading.gif" lazyload alt="image-20200819145152374"></p>
<p>在图中选择“performance”即可，选择以后退出图形化配置界面，然后编译 Linux内核，一定不要清理工程！否则的话我们刚刚的设置就会被清理掉。编译完成以后使用新的zImage 重启 Linux，查看当前 CPU 的工作频率和调频策略。</p>
<p>我们学习的时候为了高性能，大家可以使用 performance 模式。但是在以后的实际产品开发中，从省电的角度考虑，建议大家使用 ondemand 模式，一来可以省电，二来可以减少发热。</p>
<h5 id="3、超频设置"><a href="#3、超频设置" class="headerlink" title="3、超频设置"></a>3、超频设置</h5><p>I.MX6ULL 有多种型号，按照工作频率可以分为 528MHz、700Mhz(实际 696MHz)，800MHz(实际 792MHz)和 900MHz(实际频率未知，应该在 900MHz 左右)。</p>
<p><strong>声明：</strong><br>想体验一下高性能的朋友可以体验一下超频，但是！毕竟是超频了的，工作肯定没有在默认频率稳定。<strong>如果因为超频带来任何损坏，本文档不负任何责任！</strong></p>
<p>在实际的产品中，禁止任何超频！务必严格按照 I.MX6ULL 手册上给出的标准工作频率来运行！！如果想要更高的性能，请购买相应型号的处理器！看到这里，如果您还是执意要超频，那么就接着往下看，如果要放弃超频，那就跳过本小节。</p>
<p>超频设置其实很简单，修改一下设备树文件 arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi 即可，打开imx6ull.dtsi，找到下面代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">cpu0: cpu@<span class="hljs-number">0</span> &#123;
	compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;
	device_type = <span class="hljs-string">&quot;cpu&quot;</span>;
	reg = &lt;<span class="hljs-number">0</span>&gt;;
	clock-latency = &lt;<span class="hljs-number">61036</span>&gt;; <span class="hljs-comment">/* two CLK32 periods */</span>
	operating-points = &lt;
		<span class="hljs-comment">/* kHz	uV */</span>
		<span class="hljs-number">996000</span>	<span class="hljs-number">1275000</span>
		<span class="hljs-number">792000</span>	<span class="hljs-number">1225000</span>
		<span class="hljs-number">528000</span>	<span class="hljs-number">1175000</span>
		<span class="hljs-number">396000</span>	<span class="hljs-number">1025000</span>
		<span class="hljs-number">198000</span>	<span class="hljs-number">950000</span>
	&gt;;
	fsl,soc-operating-points = &lt;
		<span class="hljs-comment">/* KHz	uV */</span>
		<span class="hljs-number">996000</span>	<span class="hljs-number">1175000</span>
		<span class="hljs-number">792000</span>	<span class="hljs-number">1175000</span>
		<span class="hljs-number">528000</span>	<span class="hljs-number">1175000</span>
		<span class="hljs-number">396000</span>	<span class="hljs-number">1175000</span>
		<span class="hljs-number">198000</span>	<span class="hljs-number">1175000</span>
	&gt;;
	fsl,low-power-run;
	clocks = &lt;&amp;clks IMX6UL_CLK_ARM&gt;,</code></pre></div>

<p>想要超频的小伙伴只需要添加两行代码：如下：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819150034290.png" srcset="/img/loading.gif" lazyload alt="image-20200819150034290"></p>
<p>加入了“696000 1225000”，这个就是 696MHz 的支持。<br>加入了“696000 1175000”，也是对 696MHz 的支持。</p>
<p>修改好以后保存，并且编译设备树，在 Linux 内核源码根目录下输入如下命令编译设备树：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make dtbs</span></code></pre></div>

<p>命令“make dtbs”只编译设备树文件，也就是将.dts 编译为.dtb，编译完成以后使用新的设备树文件imx6ull-lxg_emmc.dtb 启动Linux.</p>
<p>重启以后查看文件&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F; scaling_available_frequencies 的内容，如图 37.4.1.10 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819150158116.png" srcset="/img/loading.gif" lazyload alt="image-20200819150158116"></p>
<p>从图可以看出，此时支持了 696MHz。如果设置调频策略为 performance，那么处理器就会一直工作在696MHz。可以对比一下工作在528MHz和696MHz下的BogoMIPS的值</p>
<h3 id="6、使能8线EMMC驱动"><a href="#6、使能8线EMMC驱动" class="headerlink" title="6、使能8线EMMC驱动"></a>6、使能8线EMMC驱动</h3><p>正点原子 EMMC 版本核心板上的 EMMC 采用的 8 位数据线，原理图如图 37.4.2.1 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819150756416.png" srcset="/img/loading.gif" lazyload alt="image-20200819150756416"></p>
<p>Linux 内核驱动里面 EMMC 默认是 4 线模式的，4 线模式肯定没有 8 线模式的速度快，所以本节我们将 EMMC 的驱动修改为 8 线模式。修改方法很简单，直接修改设备树即可，打开文件 imx6ull-lxg-emmc.dts，找到如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">&amp;usdhc2 &#123;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_usdhc2&gt;;
	non-removable;
	status = <span class="hljs-string">&quot;okay&quot;</span>;
&#125;;</code></pre></div>

<p>关于设备树的原理以及内容后面会专门讲解，示例代码中的代码含义我们现在不去纠结，只需要将其改为如下代码即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">&amp;usdhc2 &#123;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;state_100mhz&quot;</span>, <span class="hljs-string">&quot;state_200mhz&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_usdhc2_8bit&gt;;
	pinctrl<span class="hljs-number">-1</span> = &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;;
	pinctrl<span class="hljs-number">-2</span> = &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;;
	bus-width = &lt;<span class="hljs-number">8</span>&gt;;
	non-removable;
	status = <span class="hljs-string">&quot;okay&quot;</span>;
&#125;;</code></pre></div>

<p>修改完成以后保存一下 imx6ull-lxg-emmc.dts，然后使用命令“make dtbs”重新编译一下设备树，编译完成以后使用新的设备树重启 Linux 系统即可。</p>
<h3 id="7、修改网络驱动"><a href="#7、修改网络驱动" class="headerlink" title="7、修改网络驱动"></a>7、修改网络驱动</h3><p>因为在后面学习 Linux 驱动开发的时候要用到网络调试驱动，所以必须要把网络驱动调试好。在讲解uboot 移植的时候就已经说过了，正点原子开发板的网络和 NXP 官方的网络硬件上不同，网络 PHY 芯片由 KSZ8081 换为了 LAN8720A，两个网络 PHY 芯片的复位 IO 也不同。所以 Linux 内核自带的网络驱动是驱动不起来 I.MX6U-ALPHA 开发板上的网络的，需要做修改。</p>
<h4 id="1、修改LAN8720-的复位-以及网络时钟引脚驱动"><a href="#1、修改LAN8720-的复位-以及网络时钟引脚驱动" class="headerlink" title="1、修改LAN8720  的复位 以及网络时钟引脚驱动"></a>1、修改LAN8720  的复位 以及网络时钟引脚驱动</h4><p>ENET1 复位引脚 ENET1_RST 连接在 I.M6ULL 的 SNVS_TAMPER7 这个引脚上。ENET2的复位引脚 ENET2_RST 连接在 I.MX6ULL 的 SNVS_TAMPER8 上。打开设备树文件 imx6ull-lxg-emmc.dts，找到如下代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">pinctrl_spi4: spi4grp &#123;
                   fsl,pins = &lt;
                           MX6ULL_PAD_BOOT_MODE0__GPIO5_IO10        <span class="hljs-number">0x70a1</span>
                           MX6ULL_PAD_BOOT_MODE1__GPIO5_IO11        <span class="hljs-number">0x70a1</span>
                           MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07      <span class="hljs-number">0x70a1</span>
                           MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08      <span class="hljs-number">0x80000000</span>
                       &gt;;
               &#125;;</code></pre></div>

<p>示例代码中</p>
<div class="hljs code-wrapper"><pre><code class="hljs gcode">MX<span class="hljs-number">6</span>ULL_PAD_S<span class="hljs-symbol">NVS_TAMPER7</span>__GPI<span class="hljs-meta">O5</span>_I<span class="hljs-meta">O07</span>      <span class="hljs-number">0</span>x<span class="hljs-number">70</span>a<span class="hljs-number">1</span>
MX<span class="hljs-number">6</span>ULL_PAD_S<span class="hljs-symbol">NVS_TAMPER8</span>__GPI<span class="hljs-meta">O5</span>_I<span class="hljs-meta">O08</span>      <span class="hljs-number">0</span>x<span class="hljs-number">80000000</span></code></pre></div>

<p>就是初始化 SNVS_TAMPER7 和 SNVS_TAMPER8 这两个引脚的，不过看样子好像是作为了 SPI4 的 IO，这不是我们想要的，所以将这两行删除掉！删除掉以后继续在 imx6ull-lxg-emmc.dts 中找到如下所示代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">spi4 &#123;
	compatible = <span class="hljs-string">&quot;spi-gpio&quot;</span>;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_spi4&gt;;
	pinctrl-assert-gpios = &lt;&amp;gpio5 <span class="hljs-number">8</span> GPIO_ACTIVE_LOW&gt;;
	status = <span class="hljs-string">&quot;okay&quot;</span>;
	gpio-sck = &lt;&amp;gpio5 <span class="hljs-number">11</span> <span class="hljs-number">0</span>&gt;;
	gpio-mosi = &lt;&amp;gpio5 <span class="hljs-number">10</span> <span class="hljs-number">0</span>&gt;;
	cs-gpios = &lt;&amp;gpio5 <span class="hljs-number">7</span> <span class="hljs-number">0</span>&gt;;
	num-chipselects = &lt;<span class="hljs-number">1</span>&gt;;
       ......</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs c">pinctrl-assert-gpios = &lt;&amp;gpio5 <span class="hljs-number">8</span> GPIO_ACTIVE_LOW&gt;;
cs-gpios = &lt;&amp;gpio5 <span class="hljs-number">7</span> <span class="hljs-number">0</span>&gt;;</code></pre></div>

<p>其中这两行分别是</p>
<p>设置 GPIO5_IO08 为 SPI4 的一个功能引脚(我也不清楚具体作为什么功能用)，而 GPIO5_IO08 就是 SNVS_TAMPER8 的 GPIO 功能引脚。</p>
<p>设置 GPIO5_IO07 作为 SPI4 的片选引脚，而 GPIO5_IO07 就是 SNVS_TAMPER7的 GPIO 功能引脚。</p>
<p>现在我们需要 GPIO5_IO07 和 GPIO5_IO08 分别作为 ENET1 和 ENET2 的复位引脚，而不是 SPI4 的什么功能引脚，<strong>因此将示例代码 中的两行代码删除掉！！</strong>否则会干扰到网络复位引脚！</p>
<p>在 imx6ull-alientek-emmc.dts 里面找到名为“iomuxc_snvs”的节点(就是直接搜索)，然后在<br>此节点下添加网络复位引脚信息，添加完成以后的“iomuxc_snvs”的节点内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">&amp;iomuxc_snvs &#123;
	pinctrl-names = <span class="hljs-string">&quot;default_snvs&quot;</span>;
        pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_hog_2&gt;;
        imx6ul-evk &#123;
		......
        ......
		<span class="hljs-comment">/*enet1 reset firestaradmin*/</span>
		pinctrl_enet1_reset: enet1resetgrp &#123;
			fsl,pins = &lt;
				<span class="hljs-comment">/* used for enet1 reset */</span>
				MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 <span class="hljs-number">0x10B0</span>
			&gt;;
		&#125;;

		<span class="hljs-comment">/*enet2 reset firestaradmin*/</span>
		pinctrl_enet2_reset: enet2resetgrp &#123;
			fsl,pins = &lt;
				<span class="hljs-comment">/* used for enet2 reset */</span>
				MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 <span class="hljs-number">0x10B0</span>
			&gt;;
		&#125;;
        
	&#125;;
&#125;;</code></pre></div>

<p>最后还需要修改一下 ENET1 和 ENET2 的网络时钟引脚配置，继续在 imx6ull-lxg-emmc.dts 中找到如下所示代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">pinctrl_enet1: enet1grp &#123;
    fsl,pins = &lt;
        MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	<span class="hljs-number">0x4001b009</span>
    &gt;;
&#125;;

pinctrl_enet2: enet2grp &#123;
    fsl,pins = &lt;
        MX6UL_PAD_GPIO1_IO07__ENET2_MDC		<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_GPIO1_IO06__ENET2_MDIO	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01	<span class="hljs-number">0x1b0b0</span>
        MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	<span class="hljs-number">0x4001b009</span>
    &gt;;
&#125;;</code></pre></div>

<p>两个节点中的最后一行分别为 ENET1 和 ENET2 的网络时钟引脚配置信息，<strong>将这两个引脚的电气属性值改为 0x4001b009，原来默认值为 0x4001b031</strong>。修改完成以后记得保存一下 imx6ull-lxg-emmc.dts，网络复位以及时钟引脚驱动就修改好了。</p>
<h4 id="2-、修改-fec1-和-和-fec2-节点的-pinctrl-0-属性"><a href="#2-、修改-fec1-和-和-fec2-节点的-pinctrl-0-属性" class="headerlink" title="2 、修改 fec1 和 和 fec2  节点的 pinctrl-0  属性"></a>2 、修改 fec1 和 和 fec2  节点的 pinctrl-0  属性</h4><p>在 imx6ull-lxg-emmc.dts 文件中找到名为“fec1”和“fec2”的这两个节点，修改其中的“pinctrl-0”属性值，修改以后如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">&amp;fec1 &#123;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet1
        		 &amp;pinctrl_enet1_reset&gt;;
	phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;
	phy-handle = &lt;&amp;ethphy0&gt;;
	status = <span class="hljs-string">&quot;okay&quot;</span>;
&#125;;

&amp;fec2 &#123;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet2
        		 &amp;pinctrl_enet2_reset&gt;;
	phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;
	......
    ......
&#125;;</code></pre></div>

<h4 id="3、修改-LAN8720A-的-的-PHY-地址"><a href="#3、修改-LAN8720A-的-的-PHY-地址" class="headerlink" title="3、修改 LAN8720A 的 的 PHY 地址"></a>3、修改 LAN8720A 的 的 PHY 地址</h4><p>在 uboot 移植中，我们说过 ENET1 的 LAN8720A 地址为 0x0，ENET2 的 LAN8720A地址为 0x1。在 imx6ull-lxg-emmc.dts 中找到如下代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">&amp;fec1 &#123;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet1
        		 &amp;pinctrl_enet1_reset&gt;;
	phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;
	phy-handle = &lt;&amp;ethphy0&gt;;
	status = <span class="hljs-string">&quot;okay&quot;</span>;
&#125;;

&amp;fec2 &#123;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet2
        		 &amp;pinctrl_enet2_reset&gt;;
	phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;
	phy-handle = &lt;&amp;ethphy1&gt;;
	status = <span class="hljs-string">&quot;okay&quot;</span>;

	mdio &#123;
		<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
		<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>

		ethphy0: ethernet-phy@<span class="hljs-number">2</span> &#123;
			compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;
			reg = &lt;<span class="hljs-number">2</span>&gt;;
		&#125;;

		ethphy1: ethernet-phy@<span class="hljs-number">1</span> &#123;
			compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;
			reg = &lt;<span class="hljs-number">1</span>&gt;;
		&#125;;
	&#125;;
&#125;;</code></pre></div>

<p>上述代码中的</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">mdio &#123;
	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>

	ethphy0: ethernet-phy@<span class="hljs-number">2</span> &#123;
		compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;
		reg = &lt;<span class="hljs-number">2</span>&gt;;
	&#125;;

	ethphy1: ethernet-phy@<span class="hljs-number">1</span> &#123;
		compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;
		reg = &lt;<span class="hljs-number">1</span>&gt;;
	&#125;;
&#125;;</code></pre></div>

<p>部分为mdio节点，述了 ENET1和 ENET2 的 PHY 地址信息。</p>
<p>将示例代码改为如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">&amp;fec1 &#123;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet1
        		 &amp;pinctrl_enet1_reset&gt;;
	phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;
	phy-handle = &lt;&amp;ethphy0&gt;;
    phy-reset-gpios = &lt;&amp;gpio5 <span class="hljs-number">7</span> GPIO_ACTIVE_LOW&gt;;
    phy-reset-duration = &lt;<span class="hljs-number">200</span>&gt;;
	status = <span class="hljs-string">&quot;okay&quot;</span>;
&#125;;

&amp;fec2 &#123;
	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet2
        		 &amp;pinctrl_enet2_reset&gt;;
	phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;
	phy-handle = &lt;&amp;ethphy1&gt;;
    phy-reset-gpios = &lt;&amp;gpio5 <span class="hljs-number">8</span> GPIO_ACTIVE_LOW&gt;;
    phy-reset-duration = &lt;<span class="hljs-number">200</span>&gt;;
	status = <span class="hljs-string">&quot;okay&quot;</span>;

	mdio &#123;
		<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
		<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>

		ethphy0: ethernet-phy@<span class="hljs-number">0</span> &#123;
			compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;
            smsc,disable-energy-detect;
			reg = &lt;<span class="hljs-number">0</span>&gt;;
		&#125;;

		ethphy1: ethernet-phy@<span class="hljs-number">1</span> &#123;
			compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;
            smsc,disable-energy-detect;
			reg = &lt;<span class="hljs-number">1</span>&gt;;
		&#125;;
	&#125;;
&#125;;</code></pre></div>

<p>先是添加了 ENET1 网络复位引脚所使用的 IO 为 GPIO5_IO07，低电平有效。复位低电平信号持续时间为 200ms。</p>
<p>然后添加ENET2 网络复位引脚所使用的 IO 为 GPIO5_IO08，同样低电平有效，持续时间同样为 200ms。</p>
<p>“smsc,disable-energy-detect”表明 PHY 芯片是 SMSC 公司的，这样 Linux内核就会找到 SMSC 公司的 PHY 芯片驱动来驱动 LAN8720A。</p>
<p>注意“ethernet-phy@”后面的数字是 PHY 的地址，ENET1 的 PHY 地址为 0，所以“@”后面是 0(默认为 2)。</p>
<p>reg 的值也表示 PHY 地址，ENET1 的 PHY 地址为 0，所以 reg&#x3D;0。</p>
<p>至此，LAN8720A 的 PHY 地址就改好了，保存一下 imx6ull-lxg-emmc.dts 文件。然后使用“make dtbs”命令重新编译一下设备树。</p>
<h4 id="4、修改-fec-main-c-文件"><a href="#4、修改-fec-main-c-文件" class="headerlink" title="4、修改 fec_main.c  文件"></a>4、修改 fec_main.c  文件</h4><p>要 在 I.MX6ULL 上 使 用 LAN8720A ， 需 要 修 改 一 下 Linux 内 核 源 码 ， 打 开drivers&#x2F;net&#x2F;ethernet&#x2F;freescale&#x2F;fec_main.c，找到函数 fec_probe，在 fec_probe 中加入如下代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span>
<span class="hljs-title function_">fec_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fec_enet_private</span> *<span class="hljs-title">fep</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fec_platform_data</span> *<span class="hljs-title">pdata</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">ndev</span>;</span>
	<span class="hljs-type">int</span> i, irq, ret = <span class="hljs-number">0</span>;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">r</span>;</span>
	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">of_id</span>;</span>
	<span class="hljs-type">static</span> <span class="hljs-type">int</span> dev_id;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span> =</span> pdev-&gt;dev.of_node, *phy_node;
	<span class="hljs-type">int</span> num_tx_qs;
	<span class="hljs-type">int</span> num_rx_qs;

	<span class="hljs-comment">/* 设置 MX6UL_PAD_ENET1_TX_CLK 和 MX6UL_PAD_ENET2_TX_CLK</span>
<span class="hljs-comment">	* 这两个 IO 的复用寄存器的 SION 位为 1。</span>
<span class="hljs-comment">	*/</span>
	<span class="hljs-type">void</span> __iomem *IMX6U_ENET1_TX_CLK;
	<span class="hljs-type">void</span> __iomem *IMX6U_ENET2_TX_CLK;

	IMX6U_ENET1_TX_CLK = ioremap(<span class="hljs-number">0X020E00DC</span>, <span class="hljs-number">4</span>);
	writel(<span class="hljs-number">0X14</span>, IMX6U_ENET1_TX_CLK);

	IMX6U_ENET2_TX_CLK = ioremap(<span class="hljs-number">0X020E00FC</span>, <span class="hljs-number">4</span>);
	writel(<span class="hljs-number">0X14</span>, IMX6U_ENET2_TX_CLK);

	fec_enet_get_queue_num(pdev, &amp;num_tx_qs, &amp;num_rx_qs);

	<span class="hljs-comment">/* Init network device */</span>
	ndev = alloc_etherdev_mqs(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fec_enet_private),
				  num_tx_qs, num_rx_qs);
......</code></pre></div>

<p>如果要在 I.MX6ULL 上使用 LAN8720A 就需要设置ENET1 和 ENET2 的 TX_CLK 引脚复位寄存器的 SION 位为 1。</p>
<h4 id="5、配置-Linux-内核，使能-LAN8720-驱动"><a href="#5、配置-Linux-内核，使能-LAN8720-驱动" class="headerlink" title="5、配置 Linux  内核，使能 LAN8720  驱动"></a>5、配置 Linux  内核，使能 LAN8720  驱动</h4><p>输入命令“make menuconfig”，打开图形化配置界面，选择使能 LAN8720A 的驱动，路径如下：<br>-&gt; Device Drivers<br>    -&gt; Network device support<br>        -&gt; PHY Device support and infrastructure<br>            -&gt; Drivers for SMSC PHYs</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819160409699.png" srcset="/img/loading.gif" lazyload alt="image-20200819160409699"></p>
<p>图中选择将“Drivers for SMSC PHYs”编译到 Linux 内核中，因此“&lt;&gt;”里面变为了“*”。LAN8720A 是 SMSC 公司出品的，因此勾选这个以后就会编译 LAN8720 驱动，配置好以后退出配置界面，然后重新编译一下 Linux 内核。</p>
<h4 id="6、修改-smsc-c-文件"><a href="#6、修改-smsc-c-文件" class="headerlink" title="6、修改 smsc.c  文件"></a>6、修改 smsc.c  文件</h4><p>在修改 smsc.c 文件之前先说点题外话，那就是我是怎么确定要修改 smsc.c 这个文件的。在写本书之前我并没有修改过 smsc.c 这个文件，都是使能 LAN8720A 驱动以后就直接使用。但是我在测试 NFS 挂载文件系统的时候发现文件系统挂载成功率很低！老是提示 NFS 服务器找不到，三四次就有一次挂载失败！很折磨人。NFS 挂载就是通过网络来挂载文件系统，这样做的好处就是方便我们后续调试 Linux 驱动。既然老是挂载失败那么可以肯定的是网络驱动有问题，网络驱动分两部分：内部 MAC+外部 PHY，内部 MAC 驱动是由 NXP 提供的，一般不会出问题，否则的话用户早就给 NXP 反馈了。而且我用 NXP 官方的开发板测试网络是一直正常的，但是 NXP 官方的开发板所使用的 PHY 芯片为KSZ8081。所以只有可能是外部 PHY，也就是LAN8720A 的驱动可能出问题了。</p>
<p>鉴于 LAN8720A有“前车之鉴”，那就是在 uboot 中需要对LAN8720A 进行一次软复位，要设置LAN8720A 的 BMCR(寄存器地址为 0)寄存器 bit15 为 1。所以我猜测，在 Linux 中也需要对 LAN8720A 进行一次软复位。首先需要找到 LAN8720A 的驱动文件，LAN8720A 的驱动文件是 drivers&#x2F;net&#x2F;phy&#x2F;smsc.c，在此文件中有个叫做 smsc_phy_reset 的函数，看名字都知道这是 SMSC PHY 的复位函数，因此，LAN8720A 肯定也会使用到这个复位函数，修改此函数的内容，修改以后的 smsc_phy_reset函数内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smsc_phy_reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> phy_device *phydev)</span>
&#123;
    <span class="hljs-comment">//添加的内容如下</span>
    <span class="hljs-type">int</span> err, phy_reset;
    <span class="hljs-type">int</span> msec = <span class="hljs-number">1</span>;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span>
    <span class="hljs-type">int</span> timeout = <span class="hljs-number">50000</span>;
    <span class="hljs-keyword">if</span>(phydev-&gt;addr == <span class="hljs-number">0</span>) <span class="hljs-comment">/* FEC1 */</span> &#123;
        <span class="hljs-comment">/*获取 FEC1 网卡对应的设备节点。*/</span>
        np = of_find_node_by_path(<span class="hljs-string">&quot;/soc/aips-bus@02100000/ethernet@02188000&quot;</span>);
        <span class="hljs-keyword">if</span>(np == <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-keyword">return</span> -EINVAL;
        &#125;
    &#125;

    <span class="hljs-keyword">if</span>(phydev-&gt;addr == <span class="hljs-number">1</span>) <span class="hljs-comment">/* FEC2 */</span> &#123;
        <span class="hljs-comment">/*获取 FEC2 网卡对应的设备节点。*/</span>
        np = of_find_node_by_path(<span class="hljs-string">&quot;/soc/aips-bus@02000000/ethernet@020b4000&quot;</span>);
        <span class="hljs-keyword">if</span>(np == <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-keyword">return</span> -EINVAL;
        &#125;
    &#125;
	
    <span class="hljs-comment">/*从设备树中获取“phy-reset-duration”属性信息，也就是复位时间。*/</span>
    err = of_property_read_u32(np, <span class="hljs-string">&quot;phy-reset-duration&quot;</span>, &amp;msec);
    <span class="hljs-comment">/* A sane reset duration should not be longer than 1s */</span>
    <span class="hljs-keyword">if</span> (!err &amp;&amp; msec &gt; <span class="hljs-number">1000</span>)
        msec = <span class="hljs-number">1</span>;
    <span class="hljs-comment">/*从设备树中获取“phy-reset-gpios”属性信息，也就是复位 IO。*/</span>
    phy_reset = of_get_named_gpio(np, <span class="hljs-string">&quot;phy-reset-gpios&quot;</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (!gpio_is_valid(phy_reset))
        <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/*设置 PHY 的复位 IO，复位 LAN8720A*/</span>
    gpio_direction_output(phy_reset, <span class="hljs-number">0</span>);
    gpio_set_value(phy_reset, <span class="hljs-number">0</span>);
    msleep(msec);
    gpio_set_value(phy_reset, <span class="hljs-number">1</span>);
    
    
	<span class="hljs-type">int</span> rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);
	<span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)
		<span class="hljs-keyword">return</span> rc;

	<span class="hljs-comment">/* If the SMSC PHY is in power down mode, then set it</span>
<span class="hljs-comment">	 * in all capable mode before using it.</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-keyword">if</span> ((rc &amp; MII_LAN83C185_MODE_MASK) == MII_LAN83C185_MODE_POWERDOWN) &#123;
		<span class="hljs-type">int</span> timeout = <span class="hljs-number">50000</span>;

		<span class="hljs-comment">/* set &quot;all capable&quot; mode and reset the phy */</span>
		rc |= MII_LAN83C185_MODE_ALL;
		phy_write(phydev, MII_LAN83C185_SPECIAL_MODES, rc);
	&#125;
    <span class="hljs-comment">/*这里我们将软复位代码移出来，这样每次调用 smsc_phy_reset 函数 LAN8720A 都会被软复位*/</span>
    phy_write(phydev, MII_BMCR, BMCR_RESET);
    <span class="hljs-comment">/* wait end of reset (max 500 ms) */</span>
    <span class="hljs-keyword">do</span> &#123;
        udelay(<span class="hljs-number">10</span>);
        <span class="hljs-keyword">if</span> (timeout-- == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        rc = phy_read(phydev, MII_BMCR);
    &#125; <span class="hljs-keyword">while</span> (rc &amp; BMCR_RESET);
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>最后我们还需要在 drivers&#x2F;net&#x2F;phy&#x2F;smsc.c 文件中添加两个头文件，因为修改后的smsc_phy_reset 函数用到了 gpio_direction_output 和 gpio_set_value 这两个函数，需要添加的头文件如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span></code></pre></div>

<h4 id="7、网络驱动测试"><a href="#7、网络驱动测试" class="headerlink" title="7、网络驱动测试"></a>7、网络驱动测试</h4><p>修改好设备树和 Linux 内核以后重新编译一下，得到新的 zImage 镜像文件和 imx6ull-lxg-emmc.dtb设备树文件，使用网线将 I.MX6U-ALPHA 开发板的两个网口与路由器或者电脑连接起来，最后使用新的文件启动 Linux 内核。启动以后使用“ifconfig”命令查看一下当前活动的网卡有哪些，结果如图 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162229077.png" srcset="/img/loading.gif" lazyload alt="image-20200819162229077"></p>
<p>从图可以看出，当前没有活动的网卡。</p>
<p>输入命令“ifconfig -a”来查看一下开发板中存在的所有网卡，结果如图所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162256490.png" srcset="/img/loading.gif" lazyload alt="image-20200819162256490"></p>
<p>图中 can0 和 can1 为 CAN 接口的网卡，eth0 和 eth1 才是网络接口的网卡，其中eth0 对应于 ENET2，eth1 对应于 ENET1。使用如下命令依次打开 eth0 和 eth1 这两个网卡：</p>
<div class="hljs code-wrapper"><pre><code class="hljs vim">ifconfig eth0 <span class="hljs-keyword">up</span>
ifconfig eth1 <span class="hljs-keyword">up</span></code></pre></div>

<p>网卡的打开过程如图 37.4.3.4 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162751401.png" srcset="/img/loading.gif" lazyload alt="image-20200819162751401"></p>
<p>可以看到“SMSC LAN8710&#x2F;LAN8720”字样，说明当前的网络驱动使用的就是我们前面使能的 SMSC 驱动。再次输入“ifconfig”命令来查看一下当前活动的网卡，结果如图所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162818948.png" srcset="/img/loading.gif" lazyload alt="image-20200819162818948"></p>
<p>可以看出，此时 eth0 和 eth1 两个网卡都已经打开，并且工作正常，但是这两个网卡都还没<br>有 IP 地址，所以不能进行 ping 等操作。使用如下命令给两个网卡配置 IP 地址：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">ifconfig eth0 192.168.0.251
ifconfig eth1 192.168.0.252</code></pre></div>

<p>上述命令配置 eth0 和 eth1 这两个网卡的 IP 地址，注意 IP 地址选择的合理性，一定要和自己的电脑处于同一个网段内，并且没有被其他的设备占用！</p>
<p>设置好以后，使用“ping”命令来 ping 一下自己的主机，如果能 ping 通那说明网络驱动修改成功！比如我的 Ubuntu 主机 IP 地址为 192.168.0.111，使用如下命令 ping 一下：ping 192.168.0.111<br>结果如图 37.4.3.6 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162957546.png" srcset="/img/loading.gif" lazyload alt="image-20200819162957546"></p>
<h4 id="8、保存修改后的图形化配置文件"><a href="#8、保存修改后的图形化配置文件" class="headerlink" title="8、保存修改后的图形化配置文件"></a>8、保存修改后的图形化配置文件</h4><p>在修改网络驱动的时候我们通过图形界面使能了 LAN8720A 的驱动，使能以后会在.config中存在如下代码：<br><code>CONFIG_SMSC_PHY=y</code><br>打开 drivers&#x2F;net&#x2F;phy&#x2F;Makefile，有如下代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">obj-$(CONFIG_SMSC_PHY) += smsc.o</code></pre></div>

<p>当 CONFIG_SMSC_PHY&#x3D;y 的时候就会编译 smsc.c 这个文件，smsc.c 就是 LAN8720A 的驱动文件。但是当我们执行“make clean”清理工程以后.config 文件就会被删除掉，因此我们所有的配置内容都会丢失，结果就是前功尽弃，一“删”回到解放前！所以我们在配置完图形界面以后经过测试没有问题，就必须要保存一下配置文件。保存配置的方法有两个。</p>
<h5 id="1、直接另存为-config-文件"><a href="#1、直接另存为-config-文件" class="headerlink" title="1、直接另存为.config 文件"></a>1、直接另存为.config 文件</h5><p>既然图形化界面配置后的配置项保存在.config 中，那么就简单粗暴，直接将.config 文件另存为 imx_lxg_emmc_defconfig，然后其复制到 arch&#x2F;arm&#x2F;configs 目录下，替换以前的imx_lxg_emmc_defconfig。这样以后执行“make imx_lxg_emmc_defconfig”重新配置Linux 内核的时候就会使用新的配置文件，默认就会使能 LAN8720A 的驱动。</p>
<h5 id="2、通过图形界面保存配置文件"><a href="#2、通过图形界面保存配置文件" class="headerlink" title="2、通过图形界面保存配置文件"></a>2、通过图形界面保存配置文件</h5><p>相比于第 1 种直接另存为.config 文件，第 2 种方法就很“文雅”了，在图形界面中保存配置文件，在图形界面中会有“&lt; Save &gt;”选项，如图 37.4.4.1 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819163450607.png" srcset="/img/loading.gif" lazyload alt="image-20200819163450607"></p>
<p>通过键盘的“→”键，移动到“&lt; Save &gt;”选项，然后按下回车键，打开文件名输入对话框，<br>如图 37.4.4.2 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819163502121.png" srcset="/img/loading.gif" lazyload alt="image-20200819163502121"></p>
<p>在图 中输入要保存的文件名，可以带路径，一般是相对路径(相对于 Linux 内核源码根目录)。比如我们要将新的配置文件保存到目录 arch&#x2F;arm&#x2F;configs 下，文件名为imx_lxg_emmc_defconfig，也就是用新的配置文件替换掉老的默认配置文件。那么我们在图中输入 “arch&#x2F;arm&#x2F;configs&#x2F;imx_lxg_emmc_defconfig”即可，如图 37.4.4.3 所示：</p>
<p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819163905798.png" srcset="/img/loading.gif" lazyload alt="image-20200819163905798"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/">环境搭建系统移植篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">9| BusyBox根文件系统rootfs构建</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/">
                        <span class="hidden-mobile">7| uboot移植</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
