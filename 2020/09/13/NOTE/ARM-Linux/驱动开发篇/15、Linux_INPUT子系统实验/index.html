

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux INPUT子系统实验按键、鼠标、键盘、触摸屏等都属于输入(input)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。 输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息，input 核心层负责处理这些事件。本章我们就来学习一下 Linux 内核中的 input 子系统。 一、INPU">
<meta property="og:type" content="article">
<meta property="og:title" content="15| Linux INPUT子系统实验">
<meta property="og:url" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Linux INPUT子系统实验按键、鼠标、键盘、触摸屏等都属于输入(input)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。 输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息，input 核心层负责处理这些事件。本章我们就来学习一下 Linux 内核中的 input 子系统。 一、INPU">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829114244477.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829114745845.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122445514.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122604797.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122743481.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122902349.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829123547978.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829124758907.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829124848591.png">
<meta property="article:published_time" content="2020-09-12T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-12T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829114244477.png">
  
  
  <title>15| Linux INPUT子系统实验 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="15| Linux INPUT子系统实验">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-13 00:00" pubdate>
        2020年9月13日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      167 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">15| Linux INPUT子系统实验</h1>
            
            <div class="markdown-body">
              <h1 id="Linux-INPUT子系统实验"><a href="#Linux-INPUT子系统实验" class="headerlink" title="Linux INPUT子系统实验"></a>Linux INPUT子系统实验</h1><p>按键、鼠标、键盘、触摸屏等都属于输入(input)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。</p>
<p>输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息，input 核心层负责处理这些事件。本章我们就来学习一下 Linux 内核中的 input 子系统。</p>
<h2 id="一、INPUT子系统"><a href="#一、INPUT子系统" class="headerlink" title="一、INPUT子系统"></a>一、INPUT子系统</h2><h3 id="1-input-子系统简介"><a href="#1-input-子系统简介" class="headerlink" title="1| input  子系统简介"></a>1| input  子系统简介</h3><p>input 就是输入的意思，因此 input 子系统就是管理输入的子系统，和 pinctrl 和 gpio 子系统一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，不同的输入设备所代表的含义不同，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同，对于驱动编写者而言不需要去关心应用层的事情，我们只需要按照要求上报这些输入事件即可。为此 input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点，input 子系统框架如图所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829114244477.png" srcset="/img/loading.gif" lazyload alt="image-20200829114244477"></p>
<p>图中左边就是最底层的具体设备，比如按键、USB 键盘&#x2F;鼠标等，中间部分属于Linux 内核空间，分为驱动层、核心层和事件层，最右边的就是用户空间，所有的输入设备以文件的形式供用户应用程序使用。</p>
<p>可以看出 input 子系统用到了我们前面讲解的驱动分层模型，我们编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层，这三个层的分工如下：</p>
<ul>
<li><strong>驱动层</strong>：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。</li>
<li><strong>核心层</strong>：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。</li>
<li><strong>事件层</strong>：主要和用户空间进行交互。</li>
</ul>
<h3 id="2-input-驱动编写流程"><a href="#2-input-驱动编写流程" class="headerlink" title="2| input  驱动编写流程"></a>2| input  驱动编写流程</h3><p>input 核心层会向 Linux 内核注册一个字符设备，大家找到 drivers&#x2F;input&#x2F;input.c 这个文件，input.c 就是 input 输入子系统的核心层，此文件里面有如下所示代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1767</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> <span class="hljs-title">input_class</span> =</span> &#123;
<span class="hljs-number">1768</span> 	.name = <span class="hljs-string">&quot;input&quot;</span>,
<span class="hljs-number">1769</span> 	.devnode = input_devnode,
<span class="hljs-number">1770</span> &#125;;
......
<span class="hljs-number">2414</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">input_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
2415 &#123;
<span class="hljs-number">2416</span> 	<span class="hljs-type">int</span> err;
<span class="hljs-number">2417</span>
<span class="hljs-number">2418</span> 	err = class_register(&amp;input_class);
<span class="hljs-number">2419</span> 	<span class="hljs-keyword">if</span> (err) &#123;
<span class="hljs-number">2420</span> 		pr_err(<span class="hljs-string">&quot;unable to register input_dev class\n&quot;</span>);
<span class="hljs-number">2421</span> 		<span class="hljs-keyword">return</span> err;
<span class="hljs-number">2422</span> 	&#125;
<span class="hljs-number">2423</span>
<span class="hljs-number">2424</span> 	err = input_proc_init();
<span class="hljs-number">2425</span> 	<span class="hljs-keyword">if</span> (err)
<span class="hljs-number">2426</span> 		<span class="hljs-keyword">goto</span> fail1;
<span class="hljs-number">2427</span>
<span class="hljs-number">2428</span> 	err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="hljs-number">0</span>),
<span class="hljs-number">2429</span> 	INPUT_MAX_CHAR_DEVICES, <span class="hljs-string">&quot;input&quot;</span>);
<span class="hljs-number">2430</span> 	<span class="hljs-keyword">if</span> (err) &#123;
<span class="hljs-number">2431</span> 		pr_err(<span class="hljs-string">&quot;unable to register char major %d&quot;</span>, INPUT_MAJOR);
<span class="hljs-number">2432</span> 		<span class="hljs-keyword">goto</span> fail2;
<span class="hljs-number">2433</span> 	&#125;
<span class="hljs-number">2434</span>
<span class="hljs-number">2435</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">2436</span>
<span class="hljs-number">2437</span> 	fail2: input_proc_exit();
<span class="hljs-number">2438</span> 	fail1: class_unregister(&amp;input_class);
<span class="hljs-number">2439</span> 	<span class="hljs-keyword">return</span> err;
<span class="hljs-number">2440</span> &#125;</code></pre></div>

<p>第 2418 行，注册一个 input 类，这样系统启动以后就会在&#x2F;sys&#x2F;class 目录下有一个 input 子目录，如图 所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829114745845.png" srcset="/img/loading.gif" lazyload alt="image-20200829114745845"></p>
<p>第 2428~2429 行，注册一个字符设备，主设备号为 INPUT_MAJOR，INPUT_MAJOR 定义在 include&#x2F;uapi&#x2F;linux&#x2F;major.h 文件中，定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MAJOR  13</span></code></pre></div>

<p>因此，input 子系统的所有设备主设备号都为 13，我们在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，我们只需要向系统注册一个 input_device 即可。</p>
<h4 id="1-、注册-input-dev"><a href="#1-、注册-input-dev" class="headerlink" title="1 、注册 input_dev"></a>1 、注册 input_dev</h4><p>在使用 input 子系统的时候我们只需要注册一个 input 设备即可，input_dev 结构体表示 input设备，此结构体定义在 include&#x2F;linux&#x2F;input.h 文件中，定义如下(有省略)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">121</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> &#123;</span>
<span class="hljs-number">122</span> 	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;
<span class="hljs-number">123</span> 	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *phys;
<span class="hljs-number">124</span> 	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *uniq;
<span class="hljs-number">125</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_id</span> <span class="hljs-title">id</span>;</span>
<span class="hljs-number">126</span>
<span class="hljs-number">127</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];
<span class="hljs-number">128</span>
<span class="hljs-number">129</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; 	<span class="hljs-comment">/* 事件类型的位图 */</span>
<span class="hljs-number">130</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; 	<span class="hljs-comment">/* 按键值的位图 */</span>
<span class="hljs-number">131</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; 	<span class="hljs-comment">/* 相对坐标的位图 */</span>
<span class="hljs-number">132</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; 	<span class="hljs-comment">/* 绝对坐标的位图 */</span>
<span class="hljs-number">133</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; 	<span class="hljs-comment">/* 杂项事件的位图 */</span>
<span class="hljs-number">134</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; 	<span class="hljs-comment">/*LED 相关的位图 */</span>
<span class="hljs-number">135</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];	<span class="hljs-comment">/* sound 有关的位图 */</span>
<span class="hljs-number">136</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; 	<span class="hljs-comment">/* 压力反馈的位图 */</span>
<span class="hljs-number">137</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; 	<span class="hljs-comment">/*开关状态的位图 */</span>
......
<span class="hljs-number">189</span> 	<span class="hljs-type">bool</span> devres_managed;
<span class="hljs-number">190</span> &#125;;</code></pre></div>

<p>第 129 行，evbit 表示输入事件类型，可选的事件类型定义在 include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，事件类型如下：</p>
<ul>
<li>&#96;&#96;&#96;c<br>#define EV_SYN     0x00 &#x2F;* 同步事件 <em>&#x2F;<br>#define EV_KEY     0x01 &#x2F;</em> 按键事件 <em>&#x2F;<br>#define EV_REL     0x02 &#x2F;</em> 相对坐标事件 <em>&#x2F;<br>#define EV_ABS     0x03 &#x2F;</em> 绝对坐标事件 <em>&#x2F;<br>#define EV_MSC     0x04 &#x2F;</em> 杂项(其他)事件 <em>&#x2F;<br>#define EV_SW     0x05 &#x2F;</em> 开关事件 <em>&#x2F;<br>#define EV_LED     0x11 &#x2F;</em> LED <em>&#x2F;<br>#define EV_SND     0x12 &#x2F;</em> sound(声音) <em>&#x2F;<br>#define EV_REP     0x14 &#x2F;</em> 重复事件 <em>&#x2F;<br>#define EV_FF     0x15 &#x2F;</em> 压力事件 <em>&#x2F;<br>#define EV_PWR     0x16 &#x2F;</em> 电源事件 <em>&#x2F;<br>#define EV_FF_STATUS 0x17 &#x2F;</em> 压力状态事件 *&#x2F;<div class="hljs code-wrapper"><pre><code class="hljs dts">
比如本章我们要使用到按键，那么就需要注册 EV_KEY 事件，如果要使用连按功能的话还需要注册 EV_REP 事件。

继续回到示例代码中，第 <span class="hljs-number">129</span> 行~<span class="hljs-number">137</span> 行的 evbit、keybit、relbit 等等都是存放不同事件对应的值。比如我们本章要使用按键事件，因此要用到 keybit，keybit 就是按键事件使用的位图，Linux 内核定义了很多按键值，这些按键值定义在 include<span class="hljs-keyword">/uapi/</span>linux/input.h 文件中，按键值如下：

```c
<span class="hljs-number">215</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_RESERVED 	0</span>
<span class="hljs-number">216</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_ESC 		1</span>
<span class="hljs-number">217</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_1 			2</span>
<span class="hljs-number">218</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_2 			3</span>
<span class="hljs-number">219</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_3 			4</span>
<span class="hljs-number">220</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_4 			5</span>
<span class="hljs-number">221</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_5 			6</span>
<span class="hljs-number">222</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_6 			7</span>
<span class="hljs-number">223</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_7 			8</span>
<span class="hljs-number">224</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_8 			9</span>
<span class="hljs-number">225</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_9 			10</span>
<span class="hljs-number">226</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_0 			11</span>
......
<span class="hljs-number">794</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> BTN_TRIGGER_HAPPY39 0x2e6</span>
<span class="hljs-number">795</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> BTN_TRIGGER_HAPPY40 0x2e7</span></code></pre></div></li>
</ul>
<p>我们可以将开发板上的按键值设置为示例代码 中的任意一个，比如我们本章实验会将 I.MX6U-ALPHA 开发板上的 KEY 按键值设置为 KEY_0。</p>
<hr>
<p>在编写 input 设备驱动的时候我们需要先<strong>申请一个 input_dev 结构体变量</strong>，使用input_allocate_device 函数来申请一个 input_dev，此函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> input_dev *<span class="hljs-title function_">input_allocate_device</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>参数</strong>：无。<br><strong>返回值</strong>：申请到的 input_dev。</p>
<hr>
<p>如果要注销的 input 设备的话需要使用 input_free_device 函数来<strong>释放掉前面申请到的input_dev</strong>，input_free_device 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_free_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong>：需要释放的 input_dev。<br><strong>返回值</strong>：无。</p>
<hr>
<p>申请好一个 input_dev 以后就需要<strong>初始化这个 input_dev</strong>，需要初始化的内容主要为事件类型(evbit)和事件值(keybit)这两种。input_dev 初始化完成以后就需要向 Linux 内核注册input_dev<br>了，需要用到 input_register_device 函数，此函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">input_register_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong>：要注册的 input_dev 。<br><strong>返回值</strong>：0，input_dev 注册成功；负值，input_dev 注册失败。</p>
<hr>
<p>同样的，注销 input 驱动的时候也需要使用 input_unregister_device 函数来<strong>注销掉前面注册的 input_dev</strong>，input_unregister_device 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_unregister_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong>：要注销的 input_dev 。<br><strong>返回值</strong>：无。</p>
<hr>
<p>综上所述，input_dev 注册过程如下：</p>
<p>①、使用 input_allocate_device 函数申请一个 input_dev。<br>②、初始化 input_dev 的事件类型以及事件值。<br>③、使用 input_register_device 函数向 Linux 系统注册前面初始化好的 input_dev。<br>④、卸载input驱动的时候需要先使用input_unregister_device函数注销掉注册的input_dev, 然后使用 input_free_device 函数释放掉前面申请的 input_dev。</p>
<p>input_dev 注册过程示例代码如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">inputdev</span>;</span> <span class="hljs-comment">/* input 结构体变量 */</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span> <span class="hljs-comment">/* 驱动入口函数 */</span>
<span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
5 &#123;
<span class="hljs-number">6</span> 		......
<span class="hljs-number">7</span> 		inputdev = input_allocate_device(); <span class="hljs-comment">/* 申请 input_dev */</span>
<span class="hljs-number">8</span> 		inputdev-&gt;name = <span class="hljs-string">&quot;test_inputdev&quot;</span>; <span class="hljs-comment">/* 设置 input_dev 名字 */</span>
<span class="hljs-number">9</span>
<span class="hljs-number">10</span> 		<span class="hljs-comment">/*********第一种设置事件和事件值的方法***********/</span>
<span class="hljs-number">11</span> 		__set_bit(EV_KEY, inputdev-&gt;evbit); <span class="hljs-comment">/* 设置产生按键事件 */</span>
<span class="hljs-number">12</span> 		__set_bit(EV_REP, inputdev-&gt;evbit); <span class="hljs-comment">/* 重复事件 */</span>
<span class="hljs-number">13</span> 		__set_bit(KEY_0, inputdev-&gt;keybit); <span class="hljs-comment">/*设置产生哪些按键值 */</span>
<span class="hljs-number">14</span> 		<span class="hljs-comment">/************************************************/</span>
<span class="hljs-number">15</span>
<span class="hljs-number">16</span> 		<span class="hljs-comment">/*********第二种设置事件和事件值的方法***********/</span>
<span class="hljs-number">17</span> 		keyinputdev.inputdev-&gt;evbit[<span class="hljs-number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
<span class="hljs-number">18</span> 		keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);
<span class="hljs-number">19</span> 		<span class="hljs-comment">/************************************************/</span>
<span class="hljs-number">20</span>
<span class="hljs-number">21</span> 		<span class="hljs-comment">/*********第三种设置事件和事件值的方法***********/</span>
<span class="hljs-number">22</span> 		keyinputdev.inputdev-&gt;evbit[<span class="hljs-number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
<span class="hljs-number">23</span> 		input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);
<span class="hljs-number">24</span> 		<span class="hljs-comment">/************************************************/</span>
<span class="hljs-number">25</span>
<span class="hljs-number">26</span> 		<span class="hljs-comment">/* 注册 input_dev */</span>
<span class="hljs-number">27</span>		input_register_device(inputdev);
<span class="hljs-number">28</span> 		......
<span class="hljs-number">29</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">30</span> &#125;
<span class="hljs-number">31</span>
<span class="hljs-number">32</span> <span class="hljs-comment">/* 驱动出口函数 */</span>
<span class="hljs-number">33</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
34 &#123;
<span class="hljs-number">35</span> 		input_unregister_device(inputdev); <span class="hljs-comment">/* 注销 input_dev */</span>
<span class="hljs-number">36</span> 		input_free_device(inputdev); <span class="hljs-comment">/* 删除 input_dev */</span>
<span class="hljs-number">37</span> &#125;</code></pre></div>

<p>第 1 行，定义一个 input_dev 结构体指针变量。</p>
<p>第 4<del>30 行，驱动入口函数，在此函数中完成 input_dev 的申请、设置、注册等工作。第 7行调用 input_allocate_device 函数申请一个 input_dev。第 10</del>23 行都是设置 input 设备事件和按键值，这里用了三种方法来设置事件和按键值。第 27 行调用 input_register_device 函数向Linux内核注册 inputdev。</p>
<p>第 33~37 行，驱动出口函数，第 35 行调用 input_unregister_device 函数注销前面注册的input_dev，第 36 行调用 input_free_device 函数删除前面申请的 input_dev。 </p>
<h4 id="2-、上报输入事件"><a href="#2-、上报输入事件" class="headerlink" title="2 、上报输入事件"></a>2 、上报输入事件</h4><p>当我们向 Linux 内核注册好 input_dev 以后还不能高枕无忧的使用 input 设备，input 设备都是具有输入功能的，但是具体是什么样的输入值 Linux 内核是不知道的，我们需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。</p>
<p>比如按键，我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。</p>
<p>不同的事件，其上报事件的 API 函数不同，我们依次来看一下一些常用的事件上报 API 函数。首先是 input_event 函数，此函数用于上报指定的事件以及对应的值，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_event</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev,</span>
<span class="hljs-params">                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type,</span>
<span class="hljs-params">                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code,</span>
<span class="hljs-params">                 <span class="hljs-type">int</span> value)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong>：    需要上报的 input_dev。<br><strong>type</strong>:     上报的事件类型，比如 EV_KEY。<br><strong>code</strong> ： 事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等。<br><strong>value</strong>： 事件值，比如 1 表示按键按下，0 表示按键松开。<br><strong>返回值</strong>：无。</p>
<hr>
<p>input_event 函数可以上报所有的事件类型和事件值，Linux 内核也提供了其他的针对具体事件的上报函数，这些函数其实都用到了 input_event 函数。比如上报按键所使用的input_report_key 函数，此函数内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">input_report_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span>
&#123;
	input_event(dev, EV_KEY, code, !!value);
&#125;</code></pre></div>

<p>从示例代码  可以看出，input_report_key 函数的本质就是 input_event 函数，如果要上报按键事件的话还是建议大家使用 input_report_key 函数。</p>
<hr>
<p>同样的还有一些其他的事件上报函数，这些函数如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_report_rel</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">input_report_abs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">input_report_ff_status</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">input_report_switch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div>

<hr>
<p>当我们上报事件以后还需要使用 input_sync 函数来告诉 Linux 内核 input 子系统上报结束，input_sync 函数本质是上报一个同步事件，此函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>dev</strong>：需要上报同步事件的 input_dev。<br><strong>返回值</strong>：无。</p>
<p>综上所述，按键的上报事件的参考代码如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 用于按键消抖的定时器服务函数 */</span>
<span class="hljs-number">2</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>
3 &#123;
<span class="hljs-number">4</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;
<span class="hljs-number">5</span>
<span class="hljs-number">6</span> 		value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/*  读取 IO  值 */</span>
<span class="hljs-number">7</span> 		<span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span>
<span class="hljs-number">8</span> 			<span class="hljs-comment">/*  上报按键值 */</span>
<span class="hljs-number">9</span> 			input_report_key(inputdev, KEY_0, <span class="hljs-number">1</span>); <span class="hljs-comment">/*  最后一个参数 1 ， 按下 */</span>
<span class="hljs-number">10</span> 			input_sync(inputdev); <span class="hljs-comment">/* 同步事件 */</span>
<span class="hljs-number">11</span> 		&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 按键松开 */</span>
<span class="hljs-number">12</span> 			input_report_key(inputdev, KEY_0, <span class="hljs-number">0</span>); <span class="hljs-comment">/*  最后一个参数 0 ， 松开 */</span>
<span class="hljs-number">13</span> 			input_sync(inputdev); <span class="hljs-comment">/* 同步事件 */</span>
<span class="hljs-number">14</span> 		&#125;
<span class="hljs-number">15</span> &#125;</code></pre></div>

<h4 id="3、input-event-结构体"><a href="#3、input-event-结构体" class="headerlink" title="3、input_event  结构体"></a>3、input_event  结构体</h4><p>Linux 内核使用 input_event 这个结构体来表示所有的输入事件，input_envent 结构体定义在include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">24</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_event</span> &#123;</span>
<span class="hljs-number">25</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">time</span>;</span>
<span class="hljs-number">26</span> 		__u16 type;
<span class="hljs-number">27</span> 		__u16 code;
<span class="hljs-number">28</span> 		__s32 value;
<span class="hljs-number">29</span> &#125;;</code></pre></div>

<p>我们依次来看一下 input_event 结构体中的各个成员变量：</p>
<ul>
<li><p><strong>time</strong>：时间，也就是此事件发生的时间，为 timeval 结构体类型，timeval 结构体定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">__kernel_long_t</span>;
<span class="hljs-number">2</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">__kernel_long_t</span> <span class="hljs-type">__kernel_time_t</span>;
<span class="hljs-number">3</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">__kernel_long_t</span> <span class="hljs-type">__kernel_suseconds_t</span>;
<span class="hljs-number">4</span>
<span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span>
<span class="hljs-number">6</span> 		<span class="hljs-type">__kernel_time_t</span> tv_sec; <span class="hljs-comment">/* 秒  */</span>
<span class="hljs-number">7</span> 		<span class="hljs-type">__kernel_suseconds_t</span> tv_usec; <span class="hljs-comment">/* 微秒 */</span>
<span class="hljs-number">8</span> &#125;;</code></pre></div>

<p>从示例代码 可以看出，tv_sec 和 tv_usec 这两个成员变量都为 long 类型，也就是 32位，这个一定要记住，后面我们分析 event 事件上报数据的时候要用到。</p>
</li>
<li><p><strong>type</strong> ：事件类型，比如 EV_KEY，表示此次事件为按键事件，此成员变量为 16 位。</p>
</li>
<li><p><strong>code</strong> ：事件码，比如在 EV_KEY 事件中 code 就表示具体的按键码，如：KEY_0、KEY_1等等这些按键。此成员变量为 16 位。</p>
</li>
<li><p><strong>value</strong> ：值，比如 EV_KEY 事件中 value 就是按键值，表示按键有没有被按下，如果为 1 的话说明按键按下，如果为 0 的话说明按键没有被按下或者按键松开了。</p>
</li>
</ul>
<p>input_envent 这个结构体非常重要，因为所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过 input_event 来获取到具体的输入事件或相关的值，比如按键值等。关于 input 子系统就讲解到这里，接下来我们就以开发板上的 KEY0 按键为例，讲解一下如何编写 input 驱动。</p>
<h2 id="二、硬件原理图分析"><a href="#二、硬件原理图分析" class="headerlink" title="二、硬件原理图分析"></a>二、硬件原理图分析</h2><p>参考之前按键的实验。</p>
<h2 id="三、实验程序编写"><a href="#三、实验程序编写" class="headerlink" title="三、实验程序编写"></a>三、实验程序编写</h2><h3 id="1-修改设备树文件"><a href="#1-修改设备树文件" class="headerlink" title="1| 修改设备树文件"></a>1| 修改设备树文件</h3><p>直接使用上次的key节点即可。</p>
<h3 id="2-按键-input-驱动程序编写"><a href="#2-按键-input-驱动程序编写" class="headerlink" title="2| 按键 input  驱动程序编写"></a>2| 按键 input  驱动程序编写</h3><p>新建名为“20_input”的文件夹，然后在 20_input 文件夹里面创建 vscode 工程，工作区命名为“keyinput”。工程创建好以后新建 keyinput.c 文件，在 keyinput.c 里面输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYINPUT_CNT		1			<span class="hljs-comment">/* 设备号个数 	*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYINPUT_NAME		<span class="hljs-string">&quot;keyinput&quot;</span>	<span class="hljs-comment">/* 名字 		*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE			0X01		<span class="hljs-comment">/* KEY0按键值 	*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY				0XFF		<span class="hljs-comment">/* 无效的按键值 */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_NUM				1			<span class="hljs-comment">/* 按键数量 	*/</span></span>

<span class="hljs-comment">/* 中断IO描述结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> &#123;</span>
	<span class="hljs-type">int</span> gpio;								<span class="hljs-comment">/* gpio */</span>
	<span class="hljs-type">int</span> irqnum;								<span class="hljs-comment">/* 中断号     */</span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;					<span class="hljs-comment">/* 按键对应的键值 */</span>
	<span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];							<span class="hljs-comment">/* 名字 */</span>
	<span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *);	<span class="hljs-comment">/* 中断服务函数 */</span>
&#125;;

<span class="hljs-comment">/* keyinput设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyinput_dev</span>&#123;</span>
	<span class="hljs-type">dev_t</span> devid;			<span class="hljs-comment">/* 设备号 	 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>		<span class="hljs-comment">/* cdev 	*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>	<span class="hljs-comment">/* 类 		*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>	<span class="hljs-comment">/* 设备 	 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>	*<span class="hljs-title">nd</span>;</span> <span class="hljs-comment">/* 设备节点 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span><span class="hljs-comment">/* 定义一个定时器*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> <span class="hljs-title">irqkeydesc</span>[<span class="hljs-title">KEY_NUM</span>];</span>	<span class="hljs-comment">/* 按键描述数组 */</span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> curkeynum;				<span class="hljs-comment">/* 当前的按键号 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">inputdev</span>;</span>		<span class="hljs-comment">/* input结构体 */</span>
&#125;;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyinput_dev</span> <span class="hljs-title">keyinputdev</span>;</span>	<span class="hljs-comment">/* key input设备 */</span>

<span class="hljs-comment">/* @description		: 中断服务函数，开启定时器，延时10ms，</span>
<span class="hljs-comment"> *				  	  定时器用于按键消抖。</span>
<span class="hljs-comment"> * @param - irq 	: 中断号 </span>
<span class="hljs-comment"> * @param - dev_id	: 设备结构。</span>
<span class="hljs-comment"> * @return 			: 中断执行结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">key0_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyinput_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> keyinput_dev *)dev_id;

	dev-&gt;curkeynum = <span class="hljs-number">0</span>;
	dev-&gt;timer.data = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span>)dev_id;
	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="hljs-number">10</span>));	<span class="hljs-comment">/* 10ms定时 */</span>
	<span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);
&#125;

<span class="hljs-comment">/* @description	: 定时器服务函数，用于按键消抖，定时器到了以后</span>
<span class="hljs-comment"> *				  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span>
<span class="hljs-comment"> * @param - arg	: 设备结构变量</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> *<span class="hljs-title">keydesc</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyinput_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> keyinput_dev *)arg;

	num = dev-&gt;curkeynum;
	keydesc = &amp;dev-&gt;irqkeydesc[num];
	value = gpio_get_value(keydesc-&gt;gpio); 	<span class="hljs-comment">/* 读取IO值 */</span>
	<span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; 						<span class="hljs-comment">/* 按下按键 */</span>
		<span class="hljs-comment">/* 上报按键值 */</span>
		<span class="hljs-comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 1);</span>
		input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 最后一个参数表示按下还是松开，1为按下，0为松开 */</span>
		input_sync(dev-&gt;inputdev);
	&#125; <span class="hljs-keyword">else</span> &#123; 									<span class="hljs-comment">/* 按键松开 */</span>
		<span class="hljs-comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 0);</span>
		input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="hljs-number">0</span>);
		input_sync(dev-&gt;inputdev);
	&#125;	
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 按键IO初始化</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	
	keyinputdev.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);
	<span class="hljs-keyword">if</span> (keyinputdev.nd== <span class="hljs-literal">NULL</span>)&#123;
		printk(<span class="hljs-string">&quot;k:key node not find!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> -EINVAL;
	&#125; 

	<span class="hljs-comment">/* 提取GPIO */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_NUM; i++) &#123;
		keyinputdev.irqkeydesc[i].gpio = of_get_named_gpio(keyinputdev.nd ,<span class="hljs-string">&quot;key-gpios&quot;</span>, i);
		<span class="hljs-keyword">if</span> (keyinputdev.irqkeydesc[i].gpio &lt; <span class="hljs-number">0</span>) &#123;
			printk(<span class="hljs-string">&quot;k:can&#x27;t get key%d\r\n&quot;</span>, i);
		&#125;
	&#125;
	
	<span class="hljs-comment">/* 初始化key所使用的IO，并且设置成中断模式 */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_NUM; i++) &#123;
		<span class="hljs-built_in">memset</span>(keyinputdev.irqkeydesc[i].name, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(name));	<span class="hljs-comment">/* 缓冲区清零 */</span>
		<span class="hljs-built_in">sprintf</span>(keyinputdev.irqkeydesc[i].name, <span class="hljs-string">&quot;KEY%d&quot;</span>, i);		<span class="hljs-comment">/* 组合名字 */</span>
		gpio_request(keyinputdev.irqkeydesc[i].gpio, name);
		gpio_direction_input(keyinputdev.irqkeydesc[i].gpio);	
		keyinputdev.irqkeydesc[i].irqnum = irq_of_parse_and_map(keyinputdev.nd, i);
	&#125;
	<span class="hljs-comment">/* 申请中断 */</span>
	keyinputdev.irqkeydesc[<span class="hljs-number">0</span>].handler = key0_handler;
	keyinputdev.irqkeydesc[<span class="hljs-number">0</span>].value = KEY_0;
	
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_NUM; i++) &#123;
		ret = request_irq(keyinputdev.irqkeydesc[i].irqnum, keyinputdev.irqkeydesc[i].handler, 
		                 IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, keyinputdev.irqkeydesc[i].name, &amp;keyinputdev);
		<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
			printk(<span class="hljs-string">&quot;k:irq %d request failed!\r\n&quot;</span>, keyinputdev.irqkeydesc[i].irqnum);
			<span class="hljs-keyword">return</span> -EFAULT;
		&#125;
	&#125;

	<span class="hljs-comment">/* 创建定时器 */</span>
	init_timer(&amp;keyinputdev.timer);
	keyinputdev.timer.function = timer_function;

	<span class="hljs-comment">/* 申请input_dev */</span>
	keyinputdev.inputdev = input_allocate_device();
	keyinputdev.inputdev-&gt;name = KEYINPUT_NAME;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
	<span class="hljs-comment">/* 初始化input_dev，设置产生哪些事件 */</span>
	__set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit);	<span class="hljs-comment">/* 设置产生按键事件          */</span>
	__set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit);	<span class="hljs-comment">/* 重复事件，比如按下去不放开，就会一直输出信息 		 */</span>

	<span class="hljs-comment">/* 初始化input_dev，设置产生哪些按键 */</span>
	__set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit);	
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
	keyinputdev.inputdev-&gt;evbit[<span class="hljs-number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
	keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

	keyinputdev.inputdev-&gt;evbit[<span class="hljs-number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
	input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);

	<span class="hljs-comment">/* 注册输入设备 */</span>
	ret = input_register_device(keyinputdev.inputdev);
	<span class="hljs-keyword">if</span> (ret) &#123;
		printk(<span class="hljs-string">&quot;k:register input device failed!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> ret;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动入口函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">keyinput_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	keyio_init();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动出口函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">keyinput_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-comment">/* 删除定时器 */</span>
	del_timer_sync(&amp;keyinputdev.timer);	<span class="hljs-comment">/* 删除定时器 */</span>
		
	<span class="hljs-comment">/* 释放中断 */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_NUM; i++) &#123;
		free_irq(keyinputdev.irqkeydesc[i].irqnum, &amp;keyinputdev);
	&#125;
	<span class="hljs-comment">/* 释放input_dev */</span>
	input_unregister_device(keyinputdev.inputdev);
	input_free_device(keyinputdev.inputdev);
&#125;

module_init(keyinput_init);
module_exit(keyinput_exit);
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>keyinput.c 文件内容其实就是实验“irq”中的 imx6uirq.c 文件中修改而来的，只是将其中与字符设备有关的内容进行了删除，加入了 input_dev 相关的内容，我们简单来分析一下示例代码中的程序。</p>
<ul>
<li>第 57 行，在设备结构体中定义一个 input_dev 指针变量。</li>
<li>第 93~102 行，在按键消抖定时器处理函数中上报输入事件，也就是使用 input_report_key函数上报按键事件以及按键值，最后使用 input_sync 函数上报一个同步事件，这一步一定得做！</li>
<li>第 156~180 行，使用 input_allocate_device 函数申请 input_dev，然后设置相应的事件以及事件码(也就是 KEY 模拟成那个按键，这里我们设置为 KEY_0)。最后使用 input_register_device函数向 Linux 内核注册 input_dev。</li>
<li>第 211~212 行，当注销 input 设备驱动的时候使用 input_unregister_device 函数注销掉前面注册的 input_dev，最后使用 input_free_device 函数释放掉前面申请的 input_dev。</li>
</ul>
<h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3| 编写测试 APP"></a>3| 编写测试 APP</h3><p>新建 keyinputApp.c 文件，然后在里面输入如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/ioctl.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span>



<span class="hljs-comment">/* 定义一个input_event变量，存放输入事件信息 */</span>
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_event</span> <span class="hljs-title">inputevent</span>;</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: main主程序</span>
<span class="hljs-comment"> * @param - argc 	: argv数组元素个数</span>
<span class="hljs-comment"> * @param - argv 	: 具体参数</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
&#123;
	<span class="hljs-type">int</span> fd;
	<span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;
	<span class="hljs-type">char</span> *filename;

	<span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>) &#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;

	filename = argv[<span class="hljs-number">1</span>];

	fd = open(filename, O_RDWR);
	<span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;

	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
		err = read(fd, &amp;inputevent, <span class="hljs-keyword">sizeof</span>(inputevent));
		<span class="hljs-keyword">if</span> (err &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 读取数据成功 */</span>
			<span class="hljs-keyword">switch</span> (inputevent.type) &#123;


				<span class="hljs-keyword">case</span> EV_KEY:
					<span class="hljs-keyword">if</span> (inputevent.code &lt; BTN_MISC) &#123; <span class="hljs-comment">/* 键盘键值 */</span>
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key %d %s\r\n&quot;</span>, inputevent.code, inputevent.value ? <span class="hljs-string">&quot;press&quot;</span> : <span class="hljs-string">&quot;release&quot;</span>);
					&#125; <span class="hljs-keyword">else</span> &#123;
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;button %d %s\r\n&quot;</span>, inputevent.code, inputevent.value ? <span class="hljs-string">&quot;press&quot;</span> : <span class="hljs-string">&quot;release&quot;</span>);
					&#125;
					<span class="hljs-keyword">break</span>;

				<span class="hljs-comment">/* 其他类型的事件，自行处理 */</span>
				<span class="hljs-keyword">case</span> EV_REL:
					<span class="hljs-keyword">break</span>;
				<span class="hljs-keyword">case</span> EV_ABS:
					<span class="hljs-keyword">break</span>;
				<span class="hljs-keyword">case</span> EV_MSC:
					<span class="hljs-keyword">break</span>;
				<span class="hljs-keyword">case</span> EV_SW:
					<span class="hljs-keyword">break</span>;
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;读取数据失败\r\n&quot;</span>);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>前面已经说过了，Linux 内核会使用 input_event 结构体来表示输入事件，所以我们要获取按键输入信息，那么必须借助于 input_event 结构体。定义了一个 inputevent 变量，此变量为 input_event 结构体类型。</p>
<p>当我们向 Linux 内核成功注册 input_dev 设备以后，会在&#x2F;dev&#x2F;input 目录下生成一个名为“eventX(X&#x3D;0….n)”的文件，这个&#x2F;dev&#x2F;input&#x2F;eventX 就是对应的 input 设备文件。我们读取这个文件就可以获取到输入事件信息，比如按键值什么的。使用read函数读取输入设备文件，也就是&#x2F;dev&#x2F;input&#x2F;eventX，读取到的数据按照 input_event 结构体组织起来。获取到输入事件以后(input_event 结构体类型)使用 switch case 语句来判断事件类型，本章实验我们设置的事件类型为 EV_KEY，因此只需要处理 EV_KEY 事件即可。比如获取按键编号(KEY_0 的编号为 11)、获取按键状态，按下还是松开的？</p>
<h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4| 运行测试"></a>4| 运行测试</h3><p>编译运行。</p>
<p>将编译出来keyinput.ko和keyinputApp这两个文件拷贝到rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15目录中，在加载 keyinput.ko 驱动模块之前，先看一下&#x2F;dev&#x2F;input 目录下都有哪些文件，结果如图 所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122445514.png" srcset="/img/loading.gif" lazyload alt="image-20200829122445514"></p>
<p>从图 可以看出，当前&#x2F;dev&#x2F;input 目录只有 event0 和 mice 这两个文件。接下来输入如下命令加载 keyinput.ko 这个驱动模块。</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">depmod <span class="hljs-regexp">//</span>第一次加载驱动的时候需要运行此命令
modprobe keyinput.ko <span class="hljs-regexp">//</span>加载驱动模块</code></pre></div>

<p>当驱动模块加载成功以后再来看一下&#x2F;dev&#x2F;input 目录下有哪些文件，结果如图所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122604797.png" srcset="/img/loading.gif" lazyload alt="image-20200829122604797"></p>
<p>从图可以看出，多了一个 event1 文件，因此&#x2F;dev&#x2F;input&#x2F;event1 就是我们注册的驱动所对应的设备文件。keyinputApp 就是通过读取&#x2F;dev&#x2F;input&#x2F;event1 这个文件来获取输入事件信息的，输入如下测试命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">./keyinputApp /dev/input/event1</code></pre></div>

<p>然后按下开发板上的 KEY 按键，结果如图所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122743481.png" srcset="/img/loading.gif" lazyload alt="image-20200829122743481"></p>
<p>从图可以看出，当我们按下或者释放开发板上的按键以后都会在终端上输出相应的内容，提示我们哪个按键按下或释放了，在 Linux 内核中 KEY_0 为 11。</p>
<p>另外，我们也可以不用 keyinputApp 来测试驱动，可以直接使用 hexdump 命令来查看&#x2F;dev&#x2F;input&#x2F;event1 文件内容，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">hexdump /dev/input/event1</code></pre></div>

<p>然后按下按键，终端输出如图 所示信息：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122902349.png" srcset="/img/loading.gif" lazyload alt="image-20200829122902349"></p>
<p>图就是 input_event 类型的原始事件数据值，采用十六进制表示，这些原始数据的含义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*  编号 */</span>  <span class="hljs-comment">/* tv_sec */</span>   <span class="hljs-comment">/* tv_usec */</span> <span class="hljs-comment">/* type */</span>  <span class="hljs-comment">/* code */</span> <span class="hljs-comment">/* value */</span>
<span class="hljs-number">0000000</span> 	<span class="hljs-number">106</span>a <span class="hljs-number">0000</span> 		d395 <span class="hljs-number">0001</span>     <span class="hljs-number">0001</span> 	      <span class="hljs-number">000b</span> 		<span class="hljs-number">0001</span> <span class="hljs-number">0000</span>
<span class="hljs-number">0000010</span> 	<span class="hljs-number">106</span>a <span class="hljs-number">0000</span> 		d395 <span class="hljs-number">0001</span>     <span class="hljs-number">0000</span> 		  <span class="hljs-number">0000</span> 		<span class="hljs-number">0000</span> <span class="hljs-number">0000</span>
<span class="hljs-number">0000020</span> 	<span class="hljs-number">106</span>a <span class="hljs-number">0000</span> 		<span class="hljs-number">3328</span> <span class="hljs-number">0003</span>     <span class="hljs-number">0001</span> 		  <span class="hljs-number">000b</span> 		<span class="hljs-number">0000</span> <span class="hljs-number">0000</span>
<span class="hljs-number">0000030</span> 	<span class="hljs-number">106</span>a <span class="hljs-number">0000</span> 		<span class="hljs-number">3328</span> <span class="hljs-number">0003</span> 	  <span class="hljs-number">0000</span> 		  <span class="hljs-number">0000</span> 		<span class="hljs-number">0000</span> <span class="hljs-number">0000</span>
<span class="hljs-number">0000040</span> 	<span class="hljs-number">106</span>a <span class="hljs-number">0000</span> 		<span class="hljs-number">2f</span>af <span class="hljs-number">000</span>e 	  <span class="hljs-number">0001</span> 		  <span class="hljs-number">000b</span> 		<span class="hljs-number">0001</span> <span class="hljs-number">0000</span>
<span class="hljs-number">0000050</span> 	<span class="hljs-number">106</span>a <span class="hljs-number">0000</span> 		<span class="hljs-number">2f</span>af <span class="hljs-number">000</span>e 	  <span class="hljs-number">0000</span> 		  <span class="hljs-number">0000</span> 		<span class="hljs-number">0000</span> <span class="hljs-number">0000</span>
<span class="hljs-number">0000060</span> 	<span class="hljs-number">106b</span> <span class="hljs-number">0000</span> 		<span class="hljs-number">4</span>ce6 <span class="hljs-number">0000</span> 	  <span class="hljs-number">0001</span> 	   	  <span class="hljs-number">000b</span> 		<span class="hljs-number">0000</span> <span class="hljs-number">0000</span>
<span class="hljs-number">0000070</span> 	<span class="hljs-number">106b</span> <span class="hljs-number">0000</span> 		<span class="hljs-number">4</span>ce6 <span class="hljs-number">0000</span> 	  <span class="hljs-number">0000</span> 		  <span class="hljs-number">0000</span> 		<span class="hljs-number">0000</span> <span class="hljs-number">0000</span></code></pre></div>

<p>type 为事件类型，查看示例代码 可知，EV_KEY 事件值为 1，EV_SYN 事件值为0。因此第 1 行表示 EV_KEY 事件，第 2 行表示 EV_SYN 事件。code 为事件编码，也就是按键号，查看示例代码可以，KEY_0 这个按键编号为 11，对应的十六进制为 0xb，因此第1 行表示 KEY_0 这个按键事件，最后的 value 就是按键值，为 1 表示按下，为 0 的话表示松开。</p>
<p>综上所述，示例代码中的原始事件值含义如下：</p>
<ul>
<li>第 1 行，按键(KEY_0)按下事件。<br>第 2 行，EV_SYN 同步事件，因为每次上报按键事件以后都要同步的上报一个 EV_SYN 事件。<br>第 3 行，按键(KEY_0)松开事件。<br>第 4 行，EV_SYN 同步事件，和第 2 行一样。</li>
</ul>
<h2 id="四、Linux-自带按键驱动程序的使用"><a href="#四、Linux-自带按键驱动程序的使用" class="headerlink" title="四、Linux  自带按键驱动程序的使用"></a>四、Linux  自带按键驱动程序的使用</h2><h3 id="1-自带按键驱动程序源码简析"><a href="#1-自带按键驱动程序源码简析" class="headerlink" title="1| 自带按键驱动程序源码简析"></a>1| 自带按键驱动程序源码简析</h3><p>Linux 内核也自带了 KEY 驱动，如果要使用内核自带的 KEY 驱动的话需要配置 Linux 内核，不过 Linux 内核一般默认已经使能了 KEY 驱动，但是我们还是要检查一下。按照如下路径找到相应的配置选项：</p>
<div class="hljs code-wrapper"><pre><code class="hljs livescript">-&gt; Device Drivers
    -&gt; Input device support
        -&gt; Generic input layer <span class="hljs-function"><span class="hljs-params">(needed <span class="hljs-keyword">for</span> keyboard, mouse, ...)</span> <span class="hljs-params">(INPUT [=y])</span></span>
<span class="hljs-function">            -&gt;</span> Keyboards <span class="hljs-function"><span class="hljs-params">(INPUT_KEYBOARD [=y])</span></span>
<span class="hljs-function">                 -&gt;</span> GPIO Buttons</code></pre></div>

<p>选中“GPIO Buttons”选项，将其编译进 Linux 内核中，如图  所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829123547978.png" srcset="/img/loading.gif" lazyload alt="image-20200829123547978"></p>
<p>选中以后就会在.config 文件中出现“CONFIG_KEYBOARD_GPIO&#x3D;y”这一行，Linux 内核就会根据这一行来将 KEY 驱动文件编译进 Linux 内核。Linux 内核自带的 KEY 驱动文件为drivers&#x2F;input&#x2F;keyboard&#x2F;gpio_keys.c</p>
<p>具体详情参考正点原子IMX6UL驱动开发手册 58.5.1节</p>
<h3 id="2-自带按键驱动的使用"><a href="#2-自带按键驱动的使用" class="headerlink" title="2| 自带按键驱动的使用"></a>2| 自带按键驱动的使用</h3><p>要使用Linux内核自带的按键驱动程序很简单，只需要根据Documentation&#x2F;devicetree&#x2F;bindings&#x2F;input&#x2F;gpio-keys.txt 这个文件在设备树中添加指定的设备节点即可，节点要求如下：</p>
<ul>
<li>①、节点名字为“gpio-keys”。</li>
<li>②、gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。</li>
<li>③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己：<ul>
<li>gpios ：KEY 所连接的 GPIO 信息。</li>
<li>interrupts ：KEY 所使用 GPIO 中断信息，不是必须的，可以不写。</li>
<li>label：KEY 名字</li>
<li>linux,code：KEY 要模拟的按键</li>
</ul>
</li>
<li>④、如果按键要支持连按的话要加入 autorepeat。</li>
</ul>
<p>打开 imx6ull-lxg-emmc.dts，根据上面的要求创建对应的设备节点，设备节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> gpio-keys &#123;
<span class="hljs-number">2</span> 		compatible = <span class="hljs-string">&quot;gpio-keys&quot;</span>;
<span class="hljs-number">3</span> 		<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">4</span> 		<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
<span class="hljs-number">5</span> 		autorepeat;
<span class="hljs-number">6</span> 		key0 &#123;
<span class="hljs-number">7</span> 			label = <span class="hljs-string">&quot;GPIO Key Enter&quot;</span>;
<span class="hljs-number">8</span> 			linux,code = &lt;KEY_ENTER&gt;;
<span class="hljs-number">9</span> 			gpios = &lt;&amp;gpio1 <span class="hljs-number">18</span> GPIO_ACTIVE_LOW&gt;;
<span class="hljs-number">10</span> 		&#125;;
<span class="hljs-number">11</span> &#125;;</code></pre></div>

<p>第 5 行，autorepeat 表示按键支持连按。<br>第 6~10 行，ALPHA 开发板 KEY 按键信息，名字设置为“GPIO Key Enter”，这里我们将开发板上的 KEY 按键设置为“EKY_ENTER”这个按键，也就是回车键，效果和键盘上的回车键一样。后面学习 LCD 驱动的时候需要用到此按键，因为 Linux 内核设计的 10 分钟以后 LCD关闭，也就是黑屏，就跟我们用电脑或者手机一样，一定时间以后关闭屏幕。这里将开发板上的 KEY 按键注册为回车键，当 LCD 黑屏以后直接按一下 KEY 按键即可唤醒屏幕，就跟当电脑熄屏以后按下回车键即可重新打开屏幕一样。</p>
<p>最后设置 KEY 所使用的 IO 为 GPIO1_IO18，一定要检查一下设备树看看此 GPIO 有没有被用到其他外设上，如果有的话要删除掉相关代码！重新编译设备树，然后用新编译出来的 imx6ull-lxg-emmc.dtb 启动 Linux 系统，系统启动以后查看&#x2F;dev&#x2F;input 目录，看看都有哪些文件，结果如图所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829124758907.png" srcset="/img/loading.gif" lazyload alt="image-20200829124758907"></p>
<p>从图 可以看出存在 event1 这个文件，这个文件就是 KEY 对应的设备文件，使用hexdump 命令来查看&#x2F;dev&#x2F;input&#x2F;event1 文件，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">hexdump <span class="hljs-regexp">/dev/i</span>nput/event1</code></pre></div>

<p>然后按下 ALPHA 开发板上的按键，终端输出图 所示内容：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829124848591.png" srcset="/img/loading.gif" lazyload alt="image-20200829124848591"></p>
<p>如果按下 KEY 按键以后会在终端上输出图 所示的信息那么就表示 Linux 内核的按键驱动工作正常。至于图 中内容的含义大家就自行分析，这个已经在前面 小节详细的分析过了，这里就不再讲解了。</p>
<p>大家如果发现按下 KEY 按键以后没有反应，那么请检查一下三方面：<br>①、是否使能 Linux 内核 KEY 驱动。<br>②、设备树中 gpio-keys 节点是否创建成功。<br>③、在设备树中是否有其他外设也使用了 KEY 按键对应的 GPIO，但是我们并没有删除掉这些外设信息。检查 Linux 启动 log 信息，看看是否有类似下面这条信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">gpio-keys gpio_keys：Failed to request GPIO <span class="hljs-number">18</span>, error <span class="hljs-number">-16</span></code></pre></div>

<p>上述信息表示 GPIO 18 申请失败，失败的原因就是有其他的外设正在使用此 GPIO。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/14%E3%80%81Linux_MISC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">14| Linux MISC驱动实验</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">16| Linux LCD驱动实验</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
