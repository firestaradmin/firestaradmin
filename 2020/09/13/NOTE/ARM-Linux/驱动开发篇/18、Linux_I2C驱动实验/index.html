

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux I2C驱动实验I2C 是很常用的一个串行通信接口，用于连接各种外设、传感器等器件。本章我们来学习一下如何在 Linux 下开发 I2C 接口器件驱动，重点是学习 Linux 下的 I2C 驱动框架，按照指定的框架去编写 I2C 设备驱动。本章同样以 I.MX6U-ALPHA 开发板上的 AP3216C 这个三合一环境光传感器为例，通过 AP3216C 讲解一下如何编写 Linux 下的">
<meta property="og:type" content="article">
<meta property="og:title" content="18| Linux I2C驱动实验">
<meta property="og:url" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Linux I2C驱动实验I2C 是很常用的一个串行通信接口，用于连接各种外设、传感器等器件。本章我们来学习一下如何在 Linux 下开发 I2C 接口器件驱动，重点是学习 Linux 下的 I2C 驱动框架，按照指定的框架去编写 I2C 设备驱动。本章同样以 I.MX6U-ALPHA 开发板上的 AP3216C 这个三合一环境光传感器为例，通过 AP3216C 讲解一下如何编写 Linux 下的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830150606209.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830151556292.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830151629603.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830154214853.png">
<meta property="article:published_time" content="2020-09-12T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-12T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830150606209.png">
  
  
  <title>18| Linux I2C驱动实验 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="18| Linux I2C驱动实验">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-13 00:00" pubdate>
        2020年9月13日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      32k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      270 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">18| Linux I2C驱动实验</h1>
            
            <div class="markdown-body">
              <h1 id="Linux-I2C驱动实验"><a href="#Linux-I2C驱动实验" class="headerlink" title="Linux I2C驱动实验"></a>Linux I2C驱动实验</h1><p>I2C 是很常用的一个串行通信接口，用于连接各种外设、传感器等器件。本章我们来学习一下如何在 Linux 下开发 I2C 接口器件驱动，重点是学习 Linux 下的 I2C 驱动框架，按照指定的框架去编写 I2C 设备驱动。本章同样以 I.MX6U-ALPHA 开发板上的 AP3216C 这个三合一环境光传感器为例，通过 AP3216C 讲解一下如何编写 Linux 下的 I2C 设备驱动程序。</p>
<h2 id="1-Linux-I2C-驱动框架简介"><a href="#1-Linux-I2C-驱动框架简介" class="headerlink" title="1| Linux I2C  驱动框架简介"></a>1| Linux I2C  驱动框架简介</h2><p>想一下我们在裸机中是怎么编写 AP3216C 驱动的，我们编写了四个文件：bsp_i2c.c、bsp_i2c.h、bsp_ap3216c.c 和 bsp_ap3216c.h。</p>
<p>其中前两个是 I.MX6U 的 IIC 接口驱动，后两个文件是 AP3216C 这个 I2C 设备驱动文件。相当于有两部分驱动：<br>①、I2C 主机驱动。<br>②、I2C 设备驱动。</p>
<p>对于 I2C 主机驱动，一旦编写完成就不需要再做修改，其他的 I2C 设备直接调用主机驱动提供的 API 函数完成读写操作即可。这个正好符合 Linux 的驱动分离与分层的思想，因此 Linux内核也将 I2C 驱动分为两部分：</p>
<p>①、I2C 总线驱动，I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。<br>②、I2C 设备驱动，I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。</p>
<hr>
<h3 id="I2C-总线驱动"><a href="#I2C-总线驱动" class="headerlink" title="I2C  总线驱动"></a>I2C  总线驱动</h3><p>首先来看一下 I2C 总线，在讲 platform 的时候就说过，platform 是虚拟出来的一条总线，目的是为了实现总线、设备、驱动框架。</p>
<p>对于 I2C 而言，不需要虚拟出一条总线，直接使用 I2C总线即可。I2C 总线驱动重点是 I2C 适配器(也就是 SOC 的 I2C 接口控制器)驱动，这里要用到两个重要的数据结构：i2c_adapter 和 i2c_algorithm，Linux 内核将 SOC 的 I2C 适配器(控制器)抽象成 i2c_adapter，i2c_adapter 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">498</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> &#123;</span>
<span class="hljs-number">499</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span>
<span class="hljs-number">500</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* classes to allow probing for */</span>
<span class="hljs-number">501</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> *<span class="hljs-title">algo</span>;</span> <span class="hljs-comment">/*  总线访问算法 */</span>
<span class="hljs-number">502</span> 	<span class="hljs-type">void</span> *algo_data;
<span class="hljs-number">503</span>
<span class="hljs-number">504</span> 	<span class="hljs-comment">/* data fields that are valid for all devices */</span>
<span class="hljs-number">505</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mutex</span> <span class="hljs-title">bus_lock</span>;</span>
<span class="hljs-number">506</span>
<span class="hljs-number">507</span> 	<span class="hljs-type">int</span> timeout; <span class="hljs-comment">/* in jiffies */</span>
<span class="hljs-number">508</span> 	<span class="hljs-type">int</span> retries;
<span class="hljs-number">509</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span> <span class="hljs-comment">/* the adapter device */</span>
<span class="hljs-number">510</span>
<span class="hljs-number">511</span> 	<span class="hljs-type">int</span> nr;
<span class="hljs-number">512</span>	 	<span class="hljs-type">char</span> name[<span class="hljs-number">48</span>];
<span class="hljs-number">513</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> <span class="hljs-title">dev_released</span>;</span>
<span class="hljs-number">514</span>
<span class="hljs-number">515</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">userspace_clients_lock</span>;</span>
<span class="hljs-number">516</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">userspace_clients</span>;</span>
<span class="hljs-number">517</span>
<span class="hljs-number">518</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_bus_recovery_info</span> *<span class="hljs-title">bus_recovery_info</span>;</span>
<span class="hljs-number">519</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter_quirks</span> *<span class="hljs-title">quirks</span>;</span>
<span class="hljs-number">520</span> &#125;;</code></pre></div>

<p>第 501 行，i2c_algorithm 类型的指针变量 algo，对于一个 I2C 适配器，肯定要对外提供读写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。i2c_algorithm 就是 I2C 适配器与 IIC 设备进行通信的方法。<br>i2c_algorithm 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，内容如下(删除条件编译)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">391</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> &#123;</span>
......
<span class="hljs-number">398</span> 	<span class="hljs-type">int</span> (*master_xfer)(<span class="hljs-keyword">struct</span> i2c_adapter *adap, <span class="hljs-keyword">struct</span> i2c_msg *msgs,
<span class="hljs-number">399</span> 					   <span class="hljs-type">int</span> num);
<span class="hljs-number">400</span> 	<span class="hljs-type">int</span> (*smbus_xfer) (<span class="hljs-keyword">struct</span> i2c_adapter *adap, u16 addr,
<span class="hljs-number">401</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags, <span class="hljs-type">char</span> read_write,
<span class="hljs-number">402</span> 	u8 command, <span class="hljs-type">int</span> size, <span class="hljs-keyword">union</span> i2c_smbus_data *data);
<span class="hljs-number">403</span>
<span class="hljs-number">404</span> 	<span class="hljs-comment">/* To determine what the adapter supports */</span>
<span class="hljs-number">405</span> 	u32 (*functionality) (<span class="hljs-keyword">struct</span> i2c_adapter *);
......
<span class="hljs-number">411</span> &#125;;</code></pre></div>

<ul>
<li>第 398 行，master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之间的通信。</li>
<li>第 400 行，smbus_xfer 就是 SMBUS 总线的传输函数。</li>
</ul>
<p>综上所述，I2C 总线驱动，或者说 I2C 适配器驱动的主要工作就是初始化 i2c_adapter 结构体变量，然后设置 i2c_algorithm 中的 master_xfer 函数。完成以后通过 i2c_add_numbered_adapter或 i2c_add_adapter 这两个函数向系统注册设置好的 i2c_adapter，这两个函数的原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_numbered_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adap)</span></code></pre></div>

<p>这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter使用静态总线号。函数参数和返回值含义如下：</p>
<ul>
<li><strong>adapter 或 或 adap</strong>：要添加到 Linux 内核中的 i2c_adapter，也就是 I2C 适配器。</li>
<li><strong>返回值</strong>：0，成功；负值，失败。</li>
</ul>
<p>如果要删除 I2C 适配器的话使用 i2c_del_adapter 函数即可，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_del_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter * adap)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>adap</strong>：要删除的 I2C 适配器。<br><strong>返回值</strong>：无。</p>
<p>关于 I2C 的总线(控制器或适配器)驱动就讲解到这里，一般 SOC 的 I2C 总线驱动都是由半导体厂商编写的，比如 I.MX6U 的 I2C 适配器驱动 NXP 已经编写好了，这个不需要用户去编写。因此 I2C 总线驱动对我们这些 SOC 使用者来说是被屏蔽掉的，我们只要专注于 I2C 设备驱动即可。除非你是在半导体公司上班，工作内容就是写 I2C 适配器驱动.</p>
<h3 id="I2C-设备驱动"><a href="#I2C-设备驱动" class="headerlink" title="I2C 设备驱动"></a>I2C 设备驱动</h3><p>I2C 设备驱动重点关注两个数据结构：i2c_client 和 i2c_driver，根据总线、设备和驱动模型，I2C 总线上一小节已经讲了。还剩下设备和驱动，i2c_client 就是描述设备信息的，i2c_driver 描述驱动内容，类似于 platform_driver。</p>
<h4 id="1、i2c-client-结构体"><a href="#1、i2c-client-结构体" class="headerlink" title="1、i2c_client 结构体"></a>1、i2c_client 结构体</h4><p>i2c_client 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">217</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> &#123;</span>
<span class="hljs-number">218</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags; <span class="hljs-comment">/* 标志 */</span>
<span class="hljs-number">219</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> addr; <span class="hljs-comment">/* 芯片地址，7 位，存在低 7 位 */</span>
......
<span class="hljs-number">222</span> 	<span class="hljs-type">char</span> name[I2C_NAME_SIZE]; <span class="hljs-comment">/* 名字 */</span>
<span class="hljs-number">223</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> *<span class="hljs-title">adapter</span>;</span> <span class="hljs-comment">/* 对应的 I2C 适配器 */</span>
<span class="hljs-number">224</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span> <span class="hljs-comment">/* 设备结构体 */</span>
<span class="hljs-number">225</span> 	<span class="hljs-type">int</span> irq; <span class="hljs-comment">/* 中断 */</span>
<span class="hljs-number">226</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">detected</span>;</span>
......
<span class="hljs-number">230</span> &#125;;</code></pre></div>

<p>一个设备对应一个 i2c_client，每检测到一个 I2C 设备就会给这个 I2C 设备分配一个i2c_client。</p>
<h4 id="2-、i2c-driver-结构体"><a href="#2-、i2c-driver-结构体" class="headerlink" title="2 、i2c_driver  结构体"></a>2 、i2c_driver  结构体</h4><p>i2c_driver 类似 platform_driver，是我们编写 I2C 设备驱动重点要处理的内容，i2c_driver 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">161</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> &#123;</span>
<span class="hljs-number">162</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span>
<span class="hljs-number">163</span>
<span class="hljs-number">164</span> 	<span class="hljs-comment">/* Notifies the driver that a new bus has appeared. You should</span>
<span class="hljs-comment">165 	* avoid using this, it will be removed in a near future.</span>
<span class="hljs-comment">166 	*/</span>
<span class="hljs-number">167</span> 	<span class="hljs-type">int</span> (*attach_adapter)(<span class="hljs-keyword">struct</span> i2c_adapter *) __deprecated;
<span class="hljs-number">168</span>
<span class="hljs-number">169</span> 	<span class="hljs-comment">/* Standard driver model interfaces */</span>
<span class="hljs-number">170</span> 	<span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> i2c_client *, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *);
<span class="hljs-number">171</span> 	<span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> i2c_client *);
<span class="hljs-number">172</span>
<span class="hljs-number">173</span> 	<span class="hljs-comment">/* driver model interfaces that don&#x27;t relate to enumeration */</span>
<span class="hljs-number">174</span> 	<span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> i2c_client *);
<span class="hljs-number">175</span>
<span class="hljs-number">176</span> 	<span class="hljs-comment">/* Alert callback, for example for the SMBus alert protocol.</span>
<span class="hljs-comment">177 	* The format and meaning of the data value depends on the</span>
<span class="hljs-comment">178 	* protocol.For the SMBus alert protocol, there is a single bit</span>
<span class="hljs-comment">179 	* of data passed as the alert response&#x27;s low bit (&quot;event</span>
<span class="hljs-comment">180 	flag&quot;). */</span>
<span class="hljs-number">181</span> 	<span class="hljs-type">void</span> (*alert)(<span class="hljs-keyword">struct</span> i2c_client *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> data);
<span class="hljs-number">182</span>
<span class="hljs-number">183</span> 	<span class="hljs-comment">/* a ioctl like command that can be used to perform specific</span>
<span class="hljs-comment">184 	* functions with the device.</span>
<span class="hljs-comment">185 	*/</span>
<span class="hljs-number">186</span> 	<span class="hljs-type">int</span> (*command)(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">void</span> *arg);
<span class="hljs-number">187</span>
<span class="hljs-number">188</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span>
<span class="hljs-number">189</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> *<span class="hljs-title">id_table</span>;</span>
<span class="hljs-number">190</span>
<span class="hljs-number">191</span> 	<span class="hljs-comment">/* Device detection callback for automatic device creation */</span>
<span class="hljs-number">192</span> 	<span class="hljs-type">int</span> (*detect)(<span class="hljs-keyword">struct</span> i2c_client *, <span class="hljs-keyword">struct</span> i2c_board_info *);
<span class="hljs-number">193</span> 	<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *address_list;
<span class="hljs-number">194</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">clients</span>;</span>
<span class="hljs-number">195</span> &#125;;</code></pre></div>

<ul>
<li>第 170 行，当 I2C 设备和驱动匹配成功以后 probe 函数就会执行，和 platform 驱动一样。</li>
<li>第 188 行，device_driver 驱动结构体，如果使用设备树的话，需要设置 device_driver 的of_match_table 成员变量，也就是驱动的兼容(compatible)属性。</li>
<li>第 189 行，id_table 是传统的、未使用设备树的设备匹配 ID 表。</li>
</ul>
<p>对于我们 I2C 设备驱动编写人来说，重点工作就是构建 i2c_driver，构建完成以后需要向Linux 内核注册这个 i2c_driver。</p>
<p>i2c_driver 注册函数为 int i2c_register_driver，此函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *owner,</span>
<span class="hljs-params">                        <span class="hljs-keyword">struct</span> i2c_driver *driver)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>owner</strong> ：一般为 THIS_MODULE。<br><strong>driver</strong>：要注册的 i2c_driver。<br><strong>返回值</strong>：0，成功；负值，失败。</p>
<p>另外 i2c_add_driver 也常常用于注册 i2c_driver，i2c_add_driver 是一个宏，定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">587</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> i2c_add_driver(driver) \</span>
<span class="hljs-meta">588 	i2c_register_driver(THIS_MODULE, driver)</span></code></pre></div>

<p>2c_add_driver 就是对 i2c_register_driver 做了一个简单的封装，只有一个参数，就是要注册的 i2c_driver。</p>
<p>注销 I2C 设备驱动的时候需要将前面注册的 i2c_driver 从 Linux 内核中注销掉，需要用到i2c_del_driver 函数，此函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_del_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_driver *driver)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>driver</strong>：要注销的 i2c_driver。<br><strong>返回值</strong>：无。</p>
<p>i2c_driver 的注册示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* i2c 驱动的 probe 函数 */</span>
<span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>
3 &#123;
<span class="hljs-number">4</span> 		<span class="hljs-comment">/* 函数具体程序 */</span>
<span class="hljs-number">5</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">6</span> &#125;
<span class="hljs-number">7</span>
<span class="hljs-number">8</span> <span class="hljs-comment">/* i2c 驱动的 remove 函数 */</span>
<span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span>
10 &#123;
<span class="hljs-number">11</span> 		<span class="hljs-comment">/* 函数具体程序 */</span>
<span class="hljs-number">12</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">13</span> &#125;
<span class="hljs-number">14</span>
<span class="hljs-number">15</span> <span class="hljs-comment">/* 传统匹配方式 ID 列表 */</span>
<span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">xxx_id</span>[] =</span> &#123;
<span class="hljs-number">17</span> 		&#123;<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">0</span>&#125;,
<span class="hljs-number">18</span> 		&#123;&#125;
<span class="hljs-number">19</span> &#125;;
<span class="hljs-number">20</span>
<span class="hljs-number">21</span> <span class="hljs-comment">/* 设备树匹配列表 */</span>
<span class="hljs-number">22</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;
<span class="hljs-number">23</span> 		&#123; .compatible = <span class="hljs-string">&quot;xxx&quot;</span> &#125;,
<span class="hljs-number">24</span> 		&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;
<span class="hljs-number">25</span> &#125;;
<span class="hljs-number">26</span>
<span class="hljs-number">27</span> <span class="hljs-comment">/* i2c 驱动结构体 */</span>
<span class="hljs-number">28</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">xxx_driver</span> =</span> &#123;
<span class="hljs-number">29</span> 		.probe = xxx_probe,
<span class="hljs-number">30</span> 		.remove = xxx_remove,
<span class="hljs-number">31</span> 		.driver = &#123;
<span class="hljs-number">32</span> 		.owner = THIS_MODULE,
<span class="hljs-number">33</span> 		.name = <span class="hljs-string">&quot;xxx&quot;</span>,
<span class="hljs-number">34</span> 		.of_match_table = xxx_of_match,
<span class="hljs-number">35</span> &#125;,
<span class="hljs-number">36</span> .id_table = xxx_id,
<span class="hljs-number">37</span> &#125;;
<span class="hljs-number">38</span>
<span class="hljs-number">39</span> <span class="hljs-comment">/* 驱动入口函数 */</span>
<span class="hljs-number">40</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
41 &#123;
<span class="hljs-number">42</span> 		<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
<span class="hljs-number">43</span>
<span class="hljs-number">44</span> 		ret = i2c_add_driver(&amp;xxx_driver);
<span class="hljs-number">45</span> 		<span class="hljs-keyword">return</span> ret;
<span class="hljs-number">46</span> &#125;
<span class="hljs-number">47</span>
<span class="hljs-number">48</span> <span class="hljs-comment">/* 驱动出口函数 */</span>
<span class="hljs-number">49</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
50 &#123;
<span class="hljs-number">51</span> 		i2c_del_driver(&amp;xxx_driver);
<span class="hljs-number">52</span> &#125;
<span class="hljs-number">53</span>
<span class="hljs-number">54</span> module_init(xxx_init);
<span class="hljs-number">55</span> module_exit(xxx_exit);</code></pre></div>

<p>第 16<del>19 行，i2c_device_id，无设备树的时候匹配 ID 表。<br>第 22</del>25 行，of_device_id，设备树所使用的匹配表。<br>第 28~37 行，i2c_driver，当 I2C 设备和 I2C 驱动匹配成功以后 probe 函数就会执行，这些和 platform 驱动一样，probe 函数里面基本就是标准的字符设备驱动那一套了。</p>
<h3 id="3、I2C-设备和驱动匹配过程"><a href="#3、I2C-设备和驱动匹配过程" class="headerlink" title="3、I2C  设备和驱动匹配过程"></a>3、I2C  设备和驱动匹配过程</h3><p>I2C 设备和驱动的匹配过程是由 I2C 核心来完成的，drivers&#x2F;i2c&#x2F;i2c-core.c 就是 I2C 的核心部分，I2C 核心提供了一些与具体硬件无关的 API 函数，比如前面讲过的：</p>
<p><strong>1 、i2c_adapter  注册&#x2F; 注销函数</strong><br>int i2c_add_adapter(struct i2c_adapter *adapter)<br>int i2c_add_numbered_adapter(struct i2c_adapter *adap)<br>void i2c_del_adapter(struct i2c_adapter * adap)</p>
<p><strong>2 、i2c_driver  注册&#x2F; 注销函数</strong><br>int i2c_register_driver(struct module *owner, struct i2c_driver *driver)<br>int i2c_add_driver (struct i2c_driver *driver)<br>void i2c_del_driver(struct i2c_driver *driver)</p>
<p>设备和驱动的匹配过程也是由 I2C 总线完成的，I2C 总线的数据结构为 i2c_bus_type，定义在 drivers&#x2F;i2c&#x2F;i2c-core.c 文件，i2c_bus_type 内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">736</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">i2c_bus_type</span> =</span> &#123;
<span class="hljs-number">737</span> 	.name = <span class="hljs-string">&quot;i2c&quot;</span>,
<span class="hljs-number">738</span> 	.match = i2c_device_match,
<span class="hljs-number">739</span> 	.probe = i2c_device_probe,
<span class="hljs-number">740</span> 	.remove = i2c_device_remove,
<span class="hljs-number">741</span> 	.shutdown = i2c_device_shutdown,
<span class="hljs-number">742</span> &#125;;</code></pre></div>

<p>.match 就是 I2C 总线的设备和驱动匹配函数，在这里就是 i2c_device_match 这个函数，此函数内容如下</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">457</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_device_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span>
458 &#123;
<span class="hljs-number">459</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> i2c_verify_client(dev);
<span class="hljs-number">460</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> *<span class="hljs-title">driver</span>;</span>
<span class="hljs-number">461</span>
<span class="hljs-number">462</span> 	<span class="hljs-keyword">if</span> (!client)
<span class="hljs-number">463</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">464</span>
<span class="hljs-number">465</span> 	<span class="hljs-comment">/* Attempt an OF style match */</span>
<span class="hljs-number">466</span> 	<span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))
<span class="hljs-number">467</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
<span class="hljs-number">468</span>
<span class="hljs-number">469</span> 	<span class="hljs-comment">/* Then ACPI style match */</span>
<span class="hljs-number">470</span> 	<span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))
<span class="hljs-number">471</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
<span class="hljs-number">472</span>
<span class="hljs-number">473</span> 	driver = to_i2c_driver(drv);
<span class="hljs-number">474</span> 	<span class="hljs-comment">/* match on an id table if there is one */</span>
<span class="hljs-number">475</span> 	<span class="hljs-keyword">if</span> (driver-&gt;id_table)
<span class="hljs-number">476</span> 	<span class="hljs-keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="hljs-literal">NULL</span>;
<span class="hljs-number">477</span>
<span class="hljs-number">478</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">479</span> &#125;</code></pre></div>

<ul>
<li>第 466 行，of_driver_match_device 函数用于完成设备树设备和驱动匹配。比较 I2C 设备节点的 compatible 属性和 of_device_id 中的 compatible 属性是否相等，如果相当的话就表示 I2C设备和驱动匹配。</li>
<li>第 470 行，acpi_driver_match_device 函数用于 ACPI 形式的匹配。</li>
<li>第 476 行，i2c_match_id 函数用于传统的、无设备树的 I2C 设备和驱动匹配过程。比较 I2C设备名字和 i2c_device_id 的 name 字段是否相等，相等的话就说明 I2C 设备和驱动匹配。</li>
</ul>
<h2 id="2-I-MX6U-的-的-I2C-适配器驱动分析"><a href="#2-I-MX6U-的-的-I2C-适配器驱动分析" class="headerlink" title="2| I.MX6U 的 的 I2C 适配器驱动分析"></a>2| I.MX6U 的 的 I2C 适配器驱动分析</h2><p>上一小节我们讲解了Linux 下的 I2C 驱动框架，重点分为 I2C 适配器驱动和 I2C 设备驱动，其中 I2C 适配器驱动就是 SOC 的 I2C 控制器驱动。I2C 设备驱动是需要用户根据不同的 I2C 设备去编写，而 I2C 适配器驱动一般都是 SOC 厂商去编写的，比如 NXP 就编写好了 I.MX6U 的I2C 适配器驱动。在 imx6ull.dtsi 文件中找到 I.MX6U 的 I2C1 控制器节点，节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;
<span class="hljs-number">2</span> 	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">3</span> 	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>
<span class="hljs-number">4</span> 	compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;
<span class="hljs-number">5</span> 	reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;
<span class="hljs-number">6</span> 	interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;
<span class="hljs-number">7</span> 	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;
<span class="hljs-number">8</span> 	status = <span class="hljs-string">&quot;disabled&quot;</span>;
<span class="hljs-number">9</span> &#125;;</code></pre></div>

<p>重点关注 i2c1 节点的 compatible 属性值，因为通过 compatible 属性值可以在 Linux 源码里面找到对应的驱动文件。这里i2c1节点的compatible属性值有两个： “fsl,imx6ul-i2c”和“fsl,imx21-i2c”，在 Linux 源码中搜索这两个字符串即可找到对应的驱动文件。I.MX6U 的 I2C 适配器驱动驱动文件为drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-imx.c，在此文件中有如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">244</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> <span class="hljs-title">imx_i2c_devtype</span>[] =</span> &#123;
<span class="hljs-number">245</span> 	&#123;
<span class="hljs-number">246</span> 		.name = <span class="hljs-string">&quot;imx1-i2c&quot;</span>,
<span class="hljs-number">247</span> 		.driver_data = (<span class="hljs-type">kernel_ulong_t</span>)&amp;imx1_i2c_hwdata,
<span class="hljs-number">248</span> 	&#125;, &#123;
<span class="hljs-number">249</span> 		.name = <span class="hljs-string">&quot;imx21-i2c&quot;</span>,
<span class="hljs-number">250</span> 		.driver_data = (<span class="hljs-type">kernel_ulong_t</span>)&amp;imx21_i2c_hwdata,
<span class="hljs-number">251</span> 	&#125;, &#123;
<span class="hljs-number">252</span> 		<span class="hljs-comment">/* sentinel */</span>
<span class="hljs-number">253</span> 	&#125;
<span class="hljs-number">254</span> &#125;;
<span class="hljs-number">255</span> MODULE_DEVICE_TABLE(platform, imx_i2c_devtype);
<span class="hljs-number">256</span>
<span class="hljs-number">257</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">i2c_imx_dt_ids</span>[] =</span> &#123;
<span class="hljs-number">258</span> 	&#123; .compatible = <span class="hljs-string">&quot;fsl,imx1-i2c&quot;</span>, .data = &amp;imx1_i2c_hwdata, &#125;,
<span class="hljs-number">259</span> 	&#123; .compatible = <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>, .data = &amp;imx21_i2c_hwdata, &#125;,
<span class="hljs-number">260</span> 	&#123; .compatible = <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span>, .data = &amp;vf610_i2c_hwdata, &#125;,
<span class="hljs-number">261</span> 	&#123; <span class="hljs-comment">/* sentinel */</span> &#125;
<span class="hljs-number">262</span> &#125;;
<span class="hljs-number">263</span> MODULE_DEVICE_TABLE(of, i2c_imx_dt_ids);
......
<span class="hljs-number">1119</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">i2c_imx_driver</span> =</span> &#123;
<span class="hljs-number">1120</span> 	.probe = i2c_imx_probe,
<span class="hljs-number">1121</span> 	.remove = i2c_imx_remove,
<span class="hljs-number">1122</span> 	.driver = &#123;
<span class="hljs-number">1123</span> 		.name = DRIVER_NAME,
<span class="hljs-number">1124</span> 		.owner = THIS_MODULE,
<span class="hljs-number">1125</span> 		.of_match_table = i2c_imx_dt_ids,
<span class="hljs-number">1126</span> 		.pm = IMX_I2C_PM,
<span class="hljs-number">1127</span> 	&#125;,
<span class="hljs-number">1128</span> 	.id_table = imx_i2c_devtype,
<span class="hljs-number">1129</span> &#125;;
<span class="hljs-number">1130</span>
<span class="hljs-number">1131</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">i2c_adap_imx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
1132 &#123;
<span class="hljs-number">1133</span> 	<span class="hljs-keyword">return</span> platform_driver_register(&amp;i2c_imx_driver);
<span class="hljs-number">1134</span> &#125;
<span class="hljs-number">1135</span> subsys_initcall(i2c_adap_imx_init);
<span class="hljs-number">1136</span>
<span class="hljs-number">1137</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">i2c_adap_imx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
1138 &#123;
<span class="hljs-number">1139</span> 	platform_driver_unregister(&amp;i2c_imx_driver);
<span class="hljs-number">1140</span> &#125;
<span class="hljs-number">1141</span> module_exit(i2c_adap_imx_exit);</code></pre></div>

<p>从示例代码可以看出，I.MX6U 的 I2C 适配器驱动是个标准的 platform 驱动，由此可以看出，虽然 I2C 总线为别的设备提供了一种总线驱动框架，但是 I2C 适配器却是 platform驱动。就像你的部门老大是你的领导，你是他的下属，但是放到整个公司，你的部门老大却也是老板的下属。</p>
<p>第 259 行，“fsl,imx21-i2c”属性值，设备树中 i2c1 节点的 compatible 属性值就是与此匹配上的。因此 i2c-imx.c 文件就是 I.MX6U 的 I2C 适配器驱动文件。</p>
<p>第 1120 行，当设备和驱动匹配成功以后 i2c_imx_probe 函数就会执行，i2c_imx_probe 函数就会完成 I2C 适配器初始化工作。</p>
<p>i2c_imx_probe 函数内容如下所示(有省略)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">971</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_imx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span>
972 &#123;
<span class="hljs-number">973</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">of_id</span> =</span>
<span class="hljs-number">974</span> 	of_match_device(i2c_imx_dt_ids, &amp;pdev-&gt;dev);
<span class="hljs-number">975</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx_i2c_struct</span> *<span class="hljs-title">i2c_imx</span>;</span>
<span class="hljs-number">976</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">res</span>;</span>
<span class="hljs-number">977</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imxi2c_platform_data</span> *<span class="hljs-title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);
<span class="hljs-number">978</span> 	<span class="hljs-type">void</span> __iomem *base;
<span class="hljs-number">979</span> 	<span class="hljs-type">int</span> irq, ret;
<span class="hljs-number">980</span> 	<span class="hljs-type">dma_addr_t</span> phy_addr;
<span class="hljs-number">981</span>
<span class="hljs-number">982</span> 	dev_dbg(&amp;pdev-&gt;dev, <span class="hljs-string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);
<span class="hljs-number">983</span>
<span class="hljs-number">984</span> 	irq = platform_get_irq(pdev, <span class="hljs-number">0</span>);
......
<span class="hljs-number">990</span> 	res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number">0</span>);
<span class="hljs-number">991</span> 	base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);
<span class="hljs-number">992</span> 	<span class="hljs-keyword">if</span> (IS_ERR(base))
<span class="hljs-number">993</span> 		<span class="hljs-keyword">return</span> PTR_ERR(base);
<span class="hljs-number">994</span>
<span class="hljs-number">995</span> 	phy_addr = (<span class="hljs-type">dma_addr_t</span>)res-&gt;start;
<span class="hljs-number">996</span> 	i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="hljs-keyword">sizeof</span>(*i2c_imx), GFP_KERNEL);
<span class="hljs-number">997</span> 	<span class="hljs-keyword">if</span> (!i2c_imx)
<span class="hljs-number">998</span> 		<span class="hljs-keyword">return</span> -ENOMEM;
<span class="hljs-number">999</span>
<span class="hljs-number">1000</span> 	<span class="hljs-keyword">if</span> (of_id)
<span class="hljs-number">1001</span> 		i2c_imx-&gt;hwdata = of_id-&gt;data;
<span class="hljs-number">1002</span> 	<span class="hljs-keyword">else</span>
<span class="hljs-number">1003</span> 		i2c_imx-&gt;hwdata = (<span class="hljs-keyword">struct</span> imx_i2c_hwdata *)
<span class="hljs-number">1004</span> 	platform_get_device_id(pdev)-&gt;driver_data;
<span class="hljs-number">1005</span>
<span class="hljs-number">1006</span> 	<span class="hljs-comment">/* Setup i2c_imx driver structure */</span>
<span class="hljs-number">1007</span> 	strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name, <span class="hljs-keyword">sizeof</span>(i2c_imx-&gt;adapter.name));
<span class="hljs-number">1008</span> 	i2c_imx-&gt;adapter.owner = THIS_MODULE;
<span class="hljs-number">1009</span> 	i2c_imx-&gt;adapter.algo = &amp;i2c_imx_algo;
<span class="hljs-number">1010</span> 	i2c_imx-&gt;adapter.dev.parent = &amp;pdev-&gt;dev;
<span class="hljs-number">1011</span> 	i2c_imx-&gt;adapter.nr = pdev-&gt;id;
<span class="hljs-number">1012</span> 	i2c_imx-&gt;adapter.dev.of_node = pdev-&gt;dev.of_node;
<span class="hljs-number">1013</span> 	i2c_imx-&gt;base = base;
<span class="hljs-number">1014</span>
<span class="hljs-number">1015</span> 	<span class="hljs-comment">/* Get I2C clock */</span>
<span class="hljs-number">1016</span> 	i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="hljs-literal">NULL</span>);
......
<span class="hljs-number">1022</span> 	ret = clk_prepare_enable(i2c_imx-&gt;clk);
......
<span class="hljs-number">1027</span> 	<span class="hljs-comment">/* Request IRQ */</span>
<span class="hljs-number">1028</span> 	ret = devm_request_irq(&amp;pdev-&gt;dev, irq, i2c_imx_isr,
<span class="hljs-number">1029</span> 	IRQF_NO_SUSPEND, pdev-&gt;name, i2c_imx);
......
<span class="hljs-number">1035</span> 	<span class="hljs-comment">/* Init queue */</span>
<span class="hljs-number">1036</span> 	init_waitqueue_head(&amp;i2c_imx-&gt;<span class="hljs-built_in">queue</span>);
<span class="hljs-number">1037</span>
<span class="hljs-number">1038</span> 	<span class="hljs-comment">/* Set up adapter data */</span>
<span class="hljs-number">1039</span> 	i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);
<span class="hljs-number">1040</span>
<span class="hljs-number">1041</span> 	<span class="hljs-comment">/* Set up clock divider */</span>
<span class="hljs-number">1042</span> 	i2c_imx-&gt;bitrate = IMX_I2C_BIT_RATE;
<span class="hljs-number">1043</span> 	ret = of_property_read_u32(pdev-&gt;dev.of_node,
<span class="hljs-number">1044</span> 								<span class="hljs-string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);
<span class="hljs-number">1045</span> 	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)
<span class="hljs-number">1046</span> 		i2c_imx-&gt;bitrate = pdata-&gt;bitrate;
<span class="hljs-number">1047</span>
<span class="hljs-number">1048</span> 	<span class="hljs-comment">/* Set up chip registers to defaults */</span>
<span class="hljs-number">1049</span> 	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,
<span class="hljs-number">1050</span> 	i2c_imx, IMX_I2C_I2CR);
<span class="hljs-number">1051</span> 	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);
<span class="hljs-number">1052</span>
<span class="hljs-number">1053</span> 	<span class="hljs-comment">/* Add I2C adapter */</span>
<span class="hljs-number">1054</span> 	ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);
<span class="hljs-number">1055</span> 	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;
<span class="hljs-number">1056</span> 		dev_err(&amp;pdev-&gt;dev, <span class="hljs-string">&quot;registration failed\n&quot;</span>);
<span class="hljs-number">1057</span> 		<span class="hljs-keyword">goto</span> clk_disable;
<span class="hljs-number">1058</span> 	&#125;
<span class="hljs-number">1059</span>
<span class="hljs-number">1060</span> 	<span class="hljs-comment">/* Set up platform driver data */</span>
<span class="hljs-number">1061</span> 	platform_set_drvdata(pdev, i2c_imx);
<span class="hljs-number">1062</span> 	clk_disable_unprepare(i2c_imx-&gt;clk);
......
<span class="hljs-number">1070</span> 	<span class="hljs-comment">/* Init DMA config if supported */</span>
<span class="hljs-number">1071</span> 	i2c_imx_dma_request(i2c_imx, phy_addr);
<span class="hljs-number">1072</span>
<span class="hljs-number">1073</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* Return OK */</span>
<span class="hljs-number">1074</span>
<span class="hljs-number">1075</span> clk_disable:
<span class="hljs-number">1076</span> 	clk_disable_unprepare(i2c_imx-&gt;clk);
<span class="hljs-number">1077</span> 	<span class="hljs-keyword">return</span> ret;
<span class="hljs-number">1078</span> &#125;</code></pre></div>

<ul>
<li><p>第 984 行，调用 platform_get_irq 函数获取中断号。</p>
</li>
<li><p>第 990~991 行，调用 platform_get_resource 函数从设备树中获取 I2C1 控制器寄存器物理基地址，也就是 0X021A0000。获取到寄存器基地址以后使用 devm_ioremap_resource 函数对其进行内存映射，得到可以在 Linux 内核中使用的虚拟地址。</p>
</li>
<li><p>第 996 行，NXP 使用 imx_i2c_struct 结构体来表示 I.MX 系列 SOC 的 I2C 控制器，这里使用 devm_kzalloc 函数来申请内存。</p>
</li>
<li><p>第 1008~1013 行，imx_i2c_struct 结构体要有个叫做 adapter 的成员变量，adapter 就是i2c_adapter，这里初始化i2c_adapter。第1009行设置i2c_adapter的algo成员变量为i2c_imx_algo，也就是设置 i2c_algorithm。</p>
</li>
<li><p>第 1028~1029 行，注册 I2C 控制器中断，中断服务函数为 i2c_imx_isr。</p>
</li>
<li><p>第 1042~1044 行，设置 I2C 频率默认为 IMX_I2C_BIT_RATE&#x3D;100KHz，如果设备树节点设置了“clock-frequency”属性的话 I2C 频率就使用 clock-frequency 属性值。</p>
</li>
<li><p>第 1049~1051 行，设置 I2C1 控制的 I2CR 和 I2SR 寄存器。</p>
</li>
<li><p>第 1054 行，调用 i2c_add_numbered_adapter 函数向 Linux 内核注册 i2c_adapter。</p>
</li>
<li><p>第 1071 行，申请 DMA，看来 I.MX 的 I2C 适配器驱动采用了 DMA 方式。</p>
</li>
<li><p>i2c_imx_probe 函数主要的工作就是一下两点：</p>
<ul>
<li><p>①、初始化 i2c_adapter，设置 i2c_algorithm 为 i2c_imx_algo，最后向 Linux 内核注册i2c_adapter。</p>
</li>
<li><p>②、初始化 I2C1 控制器的相关寄存器。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>i2c_imx_algo 包含 I2C1 适配器与 I2C 设备的通信函数 master_xfer，i2c_imx_algo 结构体定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">966</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> <span class="hljs-title">i2c_imx_algo</span> =</span> &#123;
<span class="hljs-number">967</span> 	.master_xfer = i2c_imx_xfer,
<span class="hljs-number">968</span> 	.functionality = i2c_imx_func,
<span class="hljs-number">969</span> &#125;;</code></pre></div>

<p>我们先来看一下. functionality，functionality用于返回此I2C适配器支持什么样的通信协议，在这里 functionality 就是 i2c_imx_func 函数，i2c_imx_func 函数内容如下:</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> u32 <span class="hljs-title function_">i2c_imx_func</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter)</span>
&#123;
    <span class="hljs-keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL
        | I2C_FUNC_SMBUS_READ_BLOCK_DATA;
&#125;</code></pre></div>

<p>重点来看一下 i2c_imx_xfer 函数，因为最终就是通过此函数来完成与 I2C 设备通信的，此函数内容如下(有省略)：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">888</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_imx_xfer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter,</span>
<span class="hljs-params"><span class="hljs-number">889</span> <span class="hljs-keyword">struct</span> i2c_msg *msgs, <span class="hljs-type">int</span> num)</span>
890 &#123;
<span class="hljs-number">891</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i, temp;
<span class="hljs-number">892</span> 	<span class="hljs-type">int</span> result;
<span class="hljs-number">893</span> 	<span class="hljs-type">bool</span> is_lastmsg = <span class="hljs-literal">false</span>;
<span class="hljs-number">894</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx_i2c_struct</span> *<span class="hljs-title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);
<span class="hljs-number">895</span>
<span class="hljs-number">896</span> 	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="hljs-string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);
<span class="hljs-number">897</span>
<span class="hljs-number">898</span> 	<span class="hljs-comment">/* Start I2C transfer */</span>
<span class="hljs-number">899</span> 	result = i2c_imx_start(i2c_imx);
<span class="hljs-number">900</span> 	<span class="hljs-keyword">if</span> (result)
<span class="hljs-number">901</span> 		<span class="hljs-keyword">goto</span> fail0;
<span class="hljs-number">902</span>
<span class="hljs-number">903</span> 	<span class="hljs-comment">/* read/write data */</span>
<span class="hljs-number">904</span> 	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;
<span class="hljs-number">905</span> 	<span class="hljs-keyword">if</span> (i == num - <span class="hljs-number">1</span>)
<span class="hljs-number">906</span> 		is_lastmsg = <span class="hljs-literal">true</span>;
<span class="hljs-number">907</span>
<span class="hljs-number">908</span> 	<span class="hljs-keyword">if</span> (i) &#123;
<span class="hljs-number">909</span> 		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,
<span class="hljs-number">910</span> 		<span class="hljs-string">&quot;&lt;%s&gt; repeated start\n&quot;</span>, __func__);
<span class="hljs-number">911</span> 		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
<span class="hljs-number">912</span> 		temp |= I2CR_RSTA;
<span class="hljs-number">913</span> 		imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
<span class="hljs-number">914</span> 		result = i2c_imx_bus_busy(i2c_imx, <span class="hljs-number">1</span>);
<span class="hljs-number">915</span> 		<span class="hljs-keyword">if</span> (result)
<span class="hljs-number">916</span> 			<span class="hljs-keyword">goto</span> fail0;
<span class="hljs-number">917</span> 	&#125;
<span class="hljs-number">918</span> 	dev_dbg(&amp;i2c_imx-&gt;adapter.dev,
<span class="hljs-number">919</span> 	<span class="hljs-string">&quot;&lt;%s&gt; transfer message: %d\n&quot;</span>, __func__, i);
<span class="hljs-number">920</span> 	<span class="hljs-comment">/* write/read data */</span>
......
<span class="hljs-number">938</span> 	<span class="hljs-keyword">if</span> (msgs[i].flags &amp; I2C_M_RD)
<span class="hljs-number">939</span> 		result = i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg);
<span class="hljs-number">940</span> 	<span class="hljs-keyword">else</span> &#123;
<span class="hljs-number">941</span> 		<span class="hljs-keyword">if</span> (i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;= DMA_THRESHOLD)
<span class="hljs-number">942</span> 			result = i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);
<span class="hljs-number">943</span> 		<span class="hljs-keyword">else</span>
<span class="hljs-number">944</span> 			result = i2c_imx_write(i2c_imx, &amp;msgs[i]);
<span class="hljs-number">945</span> 	&#125;
<span class="hljs-number">946</span> 	<span class="hljs-keyword">if</span> (result)
<span class="hljs-number">947</span> 		<span class="hljs-keyword">goto</span> fail0;
<span class="hljs-number">948</span> 	&#125;
<span class="hljs-number">949</span>
<span class="hljs-number">950</span> fail0:
<span class="hljs-number">951</span> 	<span class="hljs-comment">/* Stop I2C transfer */</span>
<span class="hljs-number">952</span> 	i2c_imx_stop(i2c_imx);
<span class="hljs-number">953</span>
<span class="hljs-number">954</span> 	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="hljs-string">&quot;&lt;%s&gt; exit with: %s: %d\n&quot;</span>, __func__,
<span class="hljs-number">955</span> 			(result &lt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;error&quot;</span> : <span class="hljs-string">&quot;success msg&quot;</span>,
<span class="hljs-number">956</span> 			(result &lt; <span class="hljs-number">0</span>) ? result : num);
<span class="hljs-number">957</span> 	<span class="hljs-keyword">return</span> (result &lt; <span class="hljs-number">0</span>) ? result : num;
<span class="hljs-number">958</span> &#125;</code></pre></div>

<ul>
<li>第 899 行，调用 i2c_imx_start 函数开启 I2C 通信。</li>
<li>第 939 行，如果是从 I2C 设备读数据的话就调用 i2c_imx_read 函数。</li>
<li>第 941~945 行，向 I2C 设备写数据，如果要用 DMA 的话就使用 i2c_imx_dma_write 函数来完成写数据。如果不使用 DMA 的话就使用 i2c_imx_write 函数完成写数据。</li>
<li>第 952 行，I2C 通信完成以后调用 i2c_imx_stop 函数停止 I2C 通信。</li>
</ul>
<p>i2c_imx_start、i2c_imx_read、i2c_imx_write 和 i2c_imx_stop 这些函数就是 I2C 寄存器的具体操作函数，函数内容基本和我们裸机篇中讲的 I2C 驱动一样，这里我们就不详细的分析了.</p>
<h2 id="3-I2C-设备驱动编写流程"><a href="#3-I2C-设备驱动编写流程" class="headerlink" title="3|  I2C  设备驱动编写流程"></a>3|  I2C  设备驱动编写流程</h2><p>I2C 适配器驱动 SOC 厂商已经替我们编写好了，我们需要做的就是编写具体的设备驱动，本小节我们就来学习一下 I2C 设备驱动的详细编写流程。</p>
<h3 id="I2C-设备信息描述"><a href="#I2C-设备信息描述" class="headerlink" title="I2C 设备信息描述"></a>I2C 设备信息描述</h3><h4 id="1-未使用设备树的时候"><a href="#1-未使用设备树的时候" class="headerlink" title="1.未使用设备树的时候"></a>1.未使用设备树的时候</h4><p>首先肯定要描述 I2C 设备节点信息，先来看一下没有使用设备树的时候是如何在 BSP 里面描述 I2C 设备信息的，在未使用设备树的时候需要在 BSP 里面使用 i2c_board_info 结构体来描述一个具体的 I2C 设备。i2c_board_info 结构体如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">295</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_board_info</span> &#123;</span>
<span class="hljs-number">296</span> 	<span class="hljs-type">char</span> type[I2C_NAME_SIZE]; <span class="hljs-comment">/* I2C 设备名字 */</span>
<span class="hljs-number">297</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags; <span class="hljs-comment">/* 标志 */</span>
<span class="hljs-number">298</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> addr; <span class="hljs-comment">/* I2C 器件地址 */</span>
<span class="hljs-number">299</span> 	<span class="hljs-type">void</span> *platform_data;
<span class="hljs-number">300</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_archdata</span> *<span class="hljs-title">archdata</span>;</span>
<span class="hljs-number">301</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">of_node</span>;</span>
<span class="hljs-number">302</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fwnode_handle</span> *<span class="hljs-title">fwnode</span>;</span>
<span class="hljs-number">303</span> 	<span class="hljs-type">int</span> irq;
<span class="hljs-number">304</span> &#125;;</code></pre></div>

<p>type 和 addr 这两个成员变量是必须要设置的，一个是 I2C 设备的名字，一个是 I2C 设备的器件地址。打开 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-mx27_3ds.c 文件，此文件中关于 OV2640 的 I2C 设备信息描述如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">392</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_board_info</span> <span class="hljs-title">mx27_3ds_i2c_camera</span> =</span> &#123;
<span class="hljs-number">393</span> 	I2C_BOARD_INFO(<span class="hljs-string">&quot;ov2640&quot;</span>, <span class="hljs-number">0x30</span>),
<span class="hljs-number">394</span> &#125;;</code></pre></div>

<p>示例代码中使用 I2C_BOARD_INFO 来完成 mx27_3ds_i2c_camera 的初始化工作，I2C_BOARD_INFO 是一个宏，定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">316</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_BOARD_INFO(dev_type, dev_addr) \</span>
<span class="hljs-meta">317 	.type = dev_type, .addr = (dev_addr)</span></code></pre></div>

<p>可以看出， I2C_BOARD_INFO 宏其实就是设置 i2c_board_info 的 type 和 addr 这两个成员变量，因此示例代码的主要工作就是设置 I2C 设备名字为 ov2640，ov2640 的器件地址为 0X30。</p>
<p>大家可以在 Linux 源码里面全局搜索 i2c_board_info，会找到大量以 i2c_board_info 定义的I2C 设备信息，这些就是未使用设备树的时候 I2C 设备的描述方式，当采用了设备树以后就不会再使用i2c_board_info 来描述 I2C 设备了。</p>
<h4 id="2-使用设备树的时候"><a href="#2-使用设备树的时候" class="headerlink" title="2.使用设备树的时候"></a>2.使用设备树的时候</h4><p>使用设备树的时候 I2C 设备信息通过创建相应的节点就行了，比如 NXP 官方的 EVK 开发板在 I2C1 上接了 mag3110 这个磁力计芯片，因此必须在 i2c1 节点下创建 mag3110 子节点，然后在这个子节点内描述 mag3110 这个芯片的相关信息。打开 imx6ull-14x14-evk.dts 这个设备树文件，然后找到如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;i2c1 &#123;
<span class="hljs-number">2</span> 		clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;
<span class="hljs-number">3</span> 		pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">4</span> 		pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;
<span class="hljs-number">5</span> 		status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">6</span>
<span class="hljs-number">7</span> 		mag3110@<span class="hljs-number">0</span>e &#123;
<span class="hljs-number">8</span> 			compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;
<span class="hljs-number">9</span> 			reg = &lt;<span class="hljs-number">0x0e</span>&gt;;
<span class="hljs-number">10</span> 			position = &lt;<span class="hljs-number">2</span>&gt;;
<span class="hljs-number">11</span> 		&#125;;
......
<span class="hljs-number">20</span> &#125;;</code></pre></div>

<ul>
<li>第 7~11 行，向 i2c1 添加 mag3110 子节点，第 7 行“mag3110@0e”是子节点名字，“@”后面的“0e”就是 mag3110 的 I2C 器件地址。</li>
<li>第 8 行设置 compatible 属性值为“fsl,mag3110”。</li>
<li>第 9 行的 reg 属性也是设置 mag3110 的器件地址的，因此值为 0x0e。I2C 设备节点的创建重点是 compatible 属性和 reg 属性的设置，一个用于匹配驱动，一个用于设置器件地址。</li>
</ul>
<h3 id="I2C-设备数据收发处理流程"><a href="#I2C-设备数据收发处理流程" class="headerlink" title="I2C 设备数据收发处理流程"></a>I2C 设备数据收发处理流程</h3><p>在前面已经说过了，I2C 设备驱动首先要做的就是初始化 i2c_driver 并向 Linux 内核注册。当设备和驱动匹配以后 i2c_driver 里面的 probe 函数就会执行，probe 函数里面所做的就是字符设备驱动那一套了。</p>
<p>一般需要在 probe 函数里面初始化 I2C 设备，要初始化 I2C 设备就必须能够对 I2C 设备寄存器进行读写操作，这里就要用到 i2c_transfer 函数了。i2c_transfer 函数最终会调用 I2C 适配器中 i2c_algorithm 里面的 master_xfer 函数，对于 I.MX6U 而言就是i2c_imx_xfer 这个函数。i2c_transfer 函数原型如下</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_transfer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adap,</span>
<span class="hljs-params">                 <span class="hljs-keyword">struct</span> i2c_msg *msgs,</span>
<span class="hljs-params">                 <span class="hljs-type">int</span> num)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>adap</strong> ：所使用的 I2C 适配器，i2c_client 会保存其对应的 i2c_adapter。<br><strong>msgs</strong>：I2C 要发送的一个或多个消息。<br><strong>num</strong> ：消息数量，也就是 msgs 的数量。<br><strong>返回值</strong>：负值，失败，其他非负值，发送的 msgs 数量。</p>
<p>我们重点来看一下 msgs 这个参数，这是一个 i2c_msg 类型的指针参数，I2C 进行数据收发说白了就是消息的传递，Linux 内核使用 i2c_msg 结构体来描述一个消息。i2c_msg 结构体定义在 include&#x2F;uapi&#x2F;linux&#x2F;i2c.h 文件中，结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">68</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> &#123;</span>
<span class="hljs-number">69</span> 		__u16 addr; <span class="hljs-comment">/* 从机地址 */</span>
<span class="hljs-number">70</span> 		__u16 flags; <span class="hljs-comment">/* 标志 */</span>
<span class="hljs-number">71</span> 		<span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_TEN 0x0010</span>
<span class="hljs-number">72</span> 		<span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RD 0x0001</span>
<span class="hljs-number">73</span> 		<span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_STOP 0x8000</span>
<span class="hljs-number">74</span> 		<span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NOSTART 0x4000</span>
<span class="hljs-number">75</span> 		<span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_REV_DIR_ADDR 0x2000</span>
<span class="hljs-number">76</span> 		<span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_IGNORE_NAK 0x1000</span>
<span class="hljs-number">77</span> 		<span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NO_RD_ACK 0x0800</span>
<span class="hljs-number">78</span>	 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RECV_LEN 0x0400</span>
<span class="hljs-number">79</span> 		__u16 len; <span class="hljs-comment">/* 消息(本 msg)长度 */</span>
<span class="hljs-number">80</span> 		__u8 *buf; <span class="hljs-comment">/* 消息数据 */</span>
<span class="hljs-number">81</span> &#125;;</code></pre></div>

<p>使用 i2c_transfer 函数发送数据之前要先构建好 i2c_msg，使用 i2c_transfer 进行 I2C 数据收发的示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 设备结构体 */</span>
<span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> &#123;</span>
<span class="hljs-number">3</span> 		......
<span class="hljs-number">4</span> 		<span class="hljs-type">void</span> *private_data; <span class="hljs-comment">/* 私有数据，一般会设置为 i2c_client */</span>
<span class="hljs-number">5</span> &#125;;
<span class="hljs-number">6</span>
<span class="hljs-number">7</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">8 * @description  : 读取 I2C 设备多个寄存器数据</span>
<span class="hljs-comment">9 * @param – dev  : I2C 设备</span>
<span class="hljs-comment">10 * @param – reg  : 要读取的寄存器首地址</span>
<span class="hljs-comment">11 * @param – val  : 读取到的数据</span>
<span class="hljs-comment">12 * @param – len  : 要读取的数据长度</span>
<span class="hljs-comment">13 * @return : 操作结果</span>
<span class="hljs-comment">14 */</span>
<span class="hljs-number">15</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xxx_dev *dev, u8 reg, <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> len)</span>
16 &#123;
<span class="hljs-number">17</span> 		<span class="hljs-type">int</span> ret;
<span class="hljs-number">18</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>[2];</span>
<span class="hljs-number">19</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *) dev-&gt;private_data;
<span class="hljs-number">20</span>
<span class="hljs-number">21</span> 		<span class="hljs-comment">/* msg[0]，第一条写消息，发送要读取的寄存器首地址 */</span>
<span class="hljs-number">22</span> 		msg[<span class="hljs-number">0</span>].addr = client-&gt;addr; <span class="hljs-comment">/* I2C 器件地址 */</span>
<span class="hljs-number">23</span> 		msg[<span class="hljs-number">0</span>].flags = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 标记为发送数据 */</span>
<span class="hljs-number">24</span> 		msg[<span class="hljs-number">0</span>].buf = &amp;reg; <span class="hljs-comment">/* 读取的首地址 */</span>
<span class="hljs-number">25</span> 		msg[<span class="hljs-number">0</span>].len = <span class="hljs-number">1</span>; <span class="hljs-comment">/* reg 长度 */</span>
<span class="hljs-number">26</span>
<span class="hljs-number">27</span> 		<span class="hljs-comment">/* msg[1]，第二条读消息，读取寄存器数据 */</span>
<span class="hljs-number">28</span> 		msg[<span class="hljs-number">1</span>].addr = client-&gt;addr; <span class="hljs-comment">/* I2C 器件地址 */</span>
<span class="hljs-number">29</span> 		msg[<span class="hljs-number">1</span>].flags = I2C_M_RD; <span class="hljs-comment">/* 标记为读取数据  */</span>
<span class="hljs-number">30</span> 		msg[<span class="hljs-number">1</span>].buf = val; <span class="hljs-comment">/* 读取数据缓冲区 */</span>
<span class="hljs-number">31</span> 		msg[<span class="hljs-number">1</span>].len = len; <span class="hljs-comment">/* 要读取的数据长度 */</span>
<span class="hljs-number">32</span>
<span class="hljs-number">33</span> 		ret = i2c_transfer(client-&gt;adapter, msg, <span class="hljs-number">2</span>);
<span class="hljs-number">34</span> 		<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">2</span>) &#123;
<span class="hljs-number">35</span> 			ret = <span class="hljs-number">0</span>;
<span class="hljs-number">36</span> 		&#125; <span class="hljs-keyword">else</span> &#123;
<span class="hljs-number">37</span> 			ret = -EREMOTEIO;
<span class="hljs-number">38</span> 		&#125;
<span class="hljs-number">39</span> 		<span class="hljs-keyword">return</span> ret;
<span class="hljs-number">40</span> &#125;
<span class="hljs-number">41</span>
<span class="hljs-number">42</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">43 * @description  : 向 I2C 设备多个寄存器写入数据</span>
<span class="hljs-comment">44 * @param – dev  : 要写入的设备结构体</span>
<span class="hljs-comment">45 * @param – reg  : 要写入的寄存器首地址</span>
<span class="hljs-comment">46 * @param – val  : 要写入的数据缓冲区</span>
<span class="hljs-comment">47 * @param – len  : 要写入的数据长度</span>
<span class="hljs-comment">48 * @return : 操作结果</span>
<span class="hljs-comment">49 */</span>
<span class="hljs-number">50</span> <span class="hljs-type">static</span> s32 <span class="hljs-title function_">xxx_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xxx_dev *dev, u8 reg, u8 *buf, u8 len)</span>
51 &#123;
<span class="hljs-number">52</span> 		u8 b[<span class="hljs-number">256</span>];
<span class="hljs-number">53</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>;</span>
<span class="hljs-number">54</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *) dev-&gt;private_data;
<span class="hljs-number">55</span>
<span class="hljs-number">56</span> 		b[<span class="hljs-number">0</span>] = reg; <span class="hljs-comment">/* 寄存器首地址 */</span>
<span class="hljs-number">57</span> 		<span class="hljs-built_in">memcpy</span>(&amp;b[<span class="hljs-number">1</span>],buf,len); <span class="hljs-comment">/* 将要发送的数据拷贝到数组 b 里面  */</span>
<span class="hljs-number">58</span>
<span class="hljs-number">59</span> 		msg.addr = client-&gt;addr; <span class="hljs-comment">/* I2C 器件地址 */</span>
<span class="hljs-number">60</span> 		msg.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 标记为写数据 */</span>
<span class="hljs-number">61</span>
<span class="hljs-number">62</span> 		msg.buf = b; <span class="hljs-comment">/* 要发送的数据缓冲区 */</span>
<span class="hljs-number">63</span> 		msg.len = len + <span class="hljs-number">1</span>; <span class="hljs-comment">/* 要发送的数据长度 */</span>
<span class="hljs-number">64</span>
<span class="hljs-number">65</span> 		<span class="hljs-keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="hljs-number">1</span>);
<span class="hljs-number">66</span> &#125;</code></pre></div>

<ul>
<li><strong>第2~5行</strong>，设备结构体，在设备结构体里面添加一个执行void的指针成员变量private_data，此成员变量用于保存设备的私有数据。在 I2C 设备驱动中我们一般将其指向 I2C 设备对应的i2c_client。</li>
<li><strong>第 15~40 行</strong>，xxx_read_regs 函数用于读取 I2C 设备多个寄存器数据。第 18 行定义了一个i2c_msg 数组，2 个数组元素，因为 I2C 读取数据的时候要先发送要读取的寄存器地址，然后再读取数据，所以需要准备两个 i2c_msg。一个用于发送寄存器地址，一个用于读取寄存器值。对于 msg[0]，将 flags 设置为 0，表示写数据。msg[0]的 addr 是 I2C 设备的器件地址，msg[0]的 buf成员变量就是要读取的寄存器地址。对于 msg[1]，将 flags 设置为 I2C_M_RD，表示读取数据。msg[1]的 buf 成员变量用于保存读取到的数据，len 成员变量就是要读取的数据长度。调用i2c_transfer 函数完成 I2C 数据读操作。</li>
<li><strong>第 50~66 行</strong>，xxx_write_regs 函数用于向 I2C 设备多个寄存器写数据，I2C 写操作要比读操作简单一点，因此一个 i2c_msg 即可。数组 b 用于存放寄存器首地址和要发送的数据，第 59 行设置 msg 的 addr 为 I2C 器件地址。第 60 行设置 msg 的 flags 为 0，也就是写数据。第 62 行设置要发送的数据，也就是数组 b。第 63 行设置 msg 的 len 为 len+1，因为要加上一个字节的寄存器地址。最后通过 i2c_transfer 函数完成向 I2C 设备的写操作。</li>
</ul>
<p>另外还有两个API函数分别用于I2C数据的收发操作，这两个函数最终都会调用i2c_transfer。首先来看一下 I2C 数据发送函数 i2c_master_send，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_master_send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_client *client,</span>
<span class="hljs-params">                    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf,</span>
<span class="hljs-params">                    <span class="hljs-type">int</span> count)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>client</strong> ：I2C 设备对应的 i2c_client。<br><strong>buf</strong>：要发送的数据。<br><strong>count</strong> ：要发送的数据字节数，要小于 64KB，以为 i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据。<br><strong>返回值</strong>：负值，失败，其他非负值，发送的字节数。</p>
<p>I2C 数据接收函数为 i2c_master_recv，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_master_recv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_client *client,</span>
<span class="hljs-params">                    <span class="hljs-type">char</span> *buf,</span>
<span class="hljs-params">                    <span class="hljs-type">int</span> count)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>client</strong> ：I2C 设备对应的 i2c_client。<br><strong>buf</strong>：要接收的数据。<br><strong>count</strong> ：要接收的数据字节数，要小于 64KB，以为 i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据。<br><strong>返回值</strong>：负值，失败，其他非负值，发送的字节数。</p>
<p>关于 Linux 下 I2C 设备驱动的编写流程就讲解到这里，重点就是 i2c_msg 的构建和i2c_transfer 函数的调用，接下来我们就编写 AP3216C 这个 I2C 设备的 Linux 驱动。</p>
<h2 id="4-硬件原理图分析"><a href="#4-硬件原理图分析" class="headerlink" title="4| 硬件原理图分析"></a>4| 硬件原理图分析</h2><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830150606209.png" srcset="/img/loading.gif" lazyload alt="image-20200830150606209"></p>
<h2 id="5-实验程序编写"><a href="#5-实验程序编写" class="headerlink" title="5| 实验程序编写"></a>5| 实验程序编写</h2><h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1.修改设备树"></a>1.修改设备树</h3><h4 id="IO-修改或添加"><a href="#IO-修改或添加" class="headerlink" title="IO  修改或添加"></a>IO  修改或添加</h4><p>首先肯定是要修改 IO，AP3216C 用到了 I2C1 接口，I.MX6U-ALPHA 开发板上的 I2C1 接口使用到了 UART4_TXD 和 UART4_RXD，因此肯定要在设备树里面设置这两个 IO。如果要用到 AP3216C 的中断功能的话还需要初始化 AP_INT 对应的 GIO1_IO01 这个 IO，本章实验我们不使用中断功能。因此只需要设置 UART4_TXD 和 UART4_RXD 这两个 IO，NXP 其实已经将他这两个 IO 设置好了，打开 imx6ull-lxg-emmc.dts，然后找到如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_i2c1: i2c1grp &#123;
<span class="hljs-number">2</span> 	fsl,pins = &lt;
<span class="hljs-number">3</span> 		MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="hljs-number">0x4001b8b0</span>
<span class="hljs-number">4</span> 		MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="hljs-number">0x4001b8b0</span>
<span class="hljs-number">5</span> 	&gt;;
<span class="hljs-number">6</span> &#125;;</code></pre></div>

<p>pinctrl_i2c1 就是 I2C1 的 IO 节点，这里将 UART4_TXD 和 UART4_RXD 这两个 IO 分别复用为 I2C1_SCL 和 I2C1_SDA，电气属性都设置为 0x4001b8b0。</p>
<h4 id="在-i2c1-节点追加-ap3216c-子节点"><a href="#在-i2c1-节点追加-ap3216c-子节点" class="headerlink" title="在 i2c1  节点追加 ap3216c 子节点"></a>在 i2c1  节点追加 ap3216c 子节点</h4><p>AP3216C 是连接到 I2C1 上的，因此需要在 i2c1 节点下添加 ap3216c 的设备子节点，在imx6ull-lxg-emmc.dts 文件中找到 i2c1 节点，此节点默认内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;i2c1 &#123;
<span class="hljs-number">2</span> 		clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;
<span class="hljs-number">3</span> 		pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">4</span> 		pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;
<span class="hljs-number">5</span> 		status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">6</span>
<span class="hljs-number">7</span> 		mag3110@<span class="hljs-number">0</span>e &#123;
<span class="hljs-number">8</span> 			compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;
<span class="hljs-number">9</span> 			reg = &lt;<span class="hljs-number">0x0e</span>&gt;;
<span class="hljs-number">10</span> 			position = &lt;<span class="hljs-number">2</span>&gt;;
<span class="hljs-number">11</span> 		&#125;;
<span class="hljs-number">12</span>
<span class="hljs-number">13</span> 		fxls8471@<span class="hljs-number">1</span>e &#123;
<span class="hljs-number">14</span> 			compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;
<span class="hljs-number">15</span> 			reg = &lt;<span class="hljs-number">0x1e</span>&gt;;
<span class="hljs-number">16</span> 			position = &lt;<span class="hljs-number">0</span>&gt;;
<span class="hljs-number">17</span> 			interrupt-parent = &lt;&amp;gpio5&gt;;
<span class="hljs-number">18</span> 			interrupts = &lt;<span class="hljs-number">0</span> <span class="hljs-number">8</span>&gt;;
<span class="hljs-number">19</span> 		&#125;;
<span class="hljs-number">20</span> &#125;;</code></pre></div>

<ul>
<li>第 2 行，clock-frequency 属性为 I2C 频率，这里设置为 100KHz。</li>
<li>第 4 行，pinctrl-0 属性指定 I2C 所使用的 IO 为上一个示例代码 中的 pinctrl_i2c1 子节点。</li>
<li>第 7~11 行，mag3110 是个磁力计，NXP 官方的 EVK 开发板上接了 mag3110，因此 NXP在 i2c1 节点下添加了 mag3110 这个子节点。正点原子的 I.MX6U-ALPHA 开发板上没有用到mag3110，因此需要将此节点删除掉。</li>
<li>第 13~19 行，NXP 官方 EVK 开发板也接了一个 fxls8471，正点原子的 I.MX6U-ALPHA开发板同样没有此器件，所以也要将其删除掉。</li>
</ul>
<p>将 i2c1 节点里面原有的 mag3110 和 fxls8471 这两个 I2C 子节点删除，然后添加 ap3216c子节点信息，完成以后的 i2c1 节点内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> 	&amp;i2c1 &#123;
<span class="hljs-number">2</span> 		clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;
<span class="hljs-number">3</span> 		pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">4</span> 		pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;
<span class="hljs-number">5</span> 		status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">6</span>
<span class="hljs-number">7</span> 		ap3216c@<span class="hljs-number">1</span>e &#123;
<span class="hljs-number">8</span> 			compatible = <span class="hljs-string">&quot;lxg,ap3216c&quot;</span>;
<span class="hljs-number">9</span> 			reg = &lt;<span class="hljs-number">0x1e</span>&gt;;
<span class="hljs-number">10</span> 		&#125;;
<span class="hljs-number">11</span> 	&#125;;</code></pre></div>

<p>第 7 行，ap3216c 子节点，@后面的“1e”是 ap3216c 的器件地址。</p>
<p>第 8 行，设置 compatible 值为“lxg,ap3216c”。</p>
<p>第 9 行，reg 属性也是设置 ap3216c 器件地址的，因此 reg 设置为 0x1e。</p>
<p>设备树修改完成以后使用“make dtbs”重新编译一下，然后使用新的设备树启动 Linux 内核。&#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices 目录下存放着所有 I2C 设备，如果设备树修改正确的话，会在&#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices 目录下看到一个名为“0-001e”的子目录，如图所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830151556292.png" srcset="/img/loading.gif" lazyload alt="image-20200830151556292"></p>
<p>图中的“0-001e”就是 ap3216c 的设备目录，“1e”就是 ap3216c 器件地址。进入0-001e 目录，可以看到“name”文件，name 问价就保存着此设备名字，在这里就是“ap3216c”，如图  所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830151629603.png" srcset="/img/loading.gif" lazyload alt="image-20200830151629603"></p>
<h3 id="2-AP3216C-驱动编写"><a href="#2-AP3216C-驱动编写" class="headerlink" title="2.AP3216C  驱动编写"></a>2.AP3216C  驱动编写</h3><p>新建名为“21_iic”的文件夹，然后在 21_iic 文件夹里面创建 vscode 工程，工作区命名为“iic”。工程创建好以后新建 ap3216c.c 和 ap3216creg.h 这两个文件，ap3216c.c 为 AP3216C 的驱动代码，ap3216creg.h 是 AP3216C 寄存器头文件。先在 ap3216creg.h 中定义好 AP3216C 的寄存器，输入如下内容，</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> AP3216C_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_H</span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_ADDR    	0X1E	<span class="hljs-comment">/* AP3216C器件地址  */</span></span>

<span class="hljs-comment">/* AP3316C寄存器 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_SYSTEMCONG	0x00	<span class="hljs-comment">/* 配置寄存器       */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_INTSTATUS	0X01	<span class="hljs-comment">/* 中断状态寄存器   */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_INTCLEAR	0X02	<span class="hljs-comment">/* 中断清除寄存器   */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_IRDATALOW	0x0A	<span class="hljs-comment">/* IR数据低字节     */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_IRDATAHIGH	0x0B	<span class="hljs-comment">/* IR数据高字节     */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_ALSDATALOW	0x0C	<span class="hljs-comment">/* ALS数据低字节    */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_ALSDATAHIGH	0X0D	<span class="hljs-comment">/* ALS数据高字节    */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_PSDATALOW	0X0E	<span class="hljs-comment">/* PS数据低字节     */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_PSDATAHIGH	0X0F	<span class="hljs-comment">/* PS数据高字节     */</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>

<p>ap3216creg.h 没什么好讲的，就是一些寄存器宏定义。然后在 ap3216c.c 输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ap3216creg.h&quot;</span></span>



<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_CNT	1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_NAME	<span class="hljs-string">&quot;ap3216c&quot;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ap3216c_dev</span> &#123;</span>
	<span class="hljs-type">dev_t</span> devid;			<span class="hljs-comment">/* 设备号 	 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>		<span class="hljs-comment">/* cdev 	*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>	<span class="hljs-comment">/* 类 		*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>	<span class="hljs-comment">/* 设备 	 */</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>	*<span class="hljs-title">nd</span>;</span> <span class="hljs-comment">/* 设备节点 */</span>
	<span class="hljs-type">int</span> major;			<span class="hljs-comment">/* 主设备号 */</span>
	<span class="hljs-type">void</span> *private_data;	<span class="hljs-comment">/* 私有数据 */</span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ir, als, ps;		<span class="hljs-comment">/* 三个光传感器数据 */</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ap3216c_dev</span> <span class="hljs-title">ap3216cdev</span>;</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 从ap3216c读取多个寄存器数据</span>
<span class="hljs-comment"> * @param - dev:  ap3216c设备</span>
<span class="hljs-comment"> * @param - reg:  要读取的寄存器首地址</span>
<span class="hljs-comment"> * @param - val:  读取到的数据</span>
<span class="hljs-comment"> * @param - len:  要读取的数据长度</span>
<span class="hljs-comment"> * @return 		: 操作结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg, <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> len)</span>
&#123;
	<span class="hljs-type">int</span> ret;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>[2];</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;private_data;

	<span class="hljs-comment">/* msg[0]为发送要读取的首地址 */</span>
	msg[<span class="hljs-number">0</span>].addr = client-&gt;addr;			<span class="hljs-comment">/* ap3216c地址 */</span>
	msg[<span class="hljs-number">0</span>].flags = <span class="hljs-number">0</span>;					<span class="hljs-comment">/* 标记为发送数据 */</span>
	msg[<span class="hljs-number">0</span>].buf = &amp;reg;					<span class="hljs-comment">/* 读取的首地址 */</span>
	msg[<span class="hljs-number">0</span>].len = <span class="hljs-number">1</span>;						<span class="hljs-comment">/* reg长度*/</span>

	<span class="hljs-comment">/* msg[1]读取数据 */</span>
	msg[<span class="hljs-number">1</span>].addr = client-&gt;addr;			<span class="hljs-comment">/* ap3216c地址 */</span>
	msg[<span class="hljs-number">1</span>].flags = I2C_M_RD;			<span class="hljs-comment">/* 标记为读取数据*/</span>
	msg[<span class="hljs-number">1</span>].buf = val;					<span class="hljs-comment">/* 读取数据缓冲区 */</span>
	msg[<span class="hljs-number">1</span>].len = len;					<span class="hljs-comment">/* 要读取的数据长度*/</span>

	ret = i2c_transfer(client-&gt;adapter, msg, <span class="hljs-number">2</span>);
	<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">2</span>) &#123;
		ret = <span class="hljs-number">0</span>;
	&#125; <span class="hljs-keyword">else</span> &#123;
		printk(<span class="hljs-string">&quot;i2c rd failed=%d reg=%06x len=%d\n&quot;</span>,ret, reg, len);
		ret = -EREMOTEIO;
	&#125;
	<span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 向ap3216c多个寄存器写入数据</span>
<span class="hljs-comment"> * @param - dev:  ap3216c设备</span>
<span class="hljs-comment"> * @param - reg:  要写入的寄存器首地址</span>
<span class="hljs-comment"> * @param - val:  要写入的数据缓冲区</span>
<span class="hljs-comment"> * @param - len:  要写入的数据长度</span>
<span class="hljs-comment"> * @return 	  :   操作结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> s32 <span class="hljs-title function_">ap3216c_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span>
&#123;
	u8 b[<span class="hljs-number">256</span>];
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;private_data;
	
	b[<span class="hljs-number">0</span>] = reg;					<span class="hljs-comment">/* 寄存器首地址 */</span>
	<span class="hljs-built_in">memcpy</span>(&amp;b[<span class="hljs-number">1</span>],buf,len);		<span class="hljs-comment">/* 将要写入的数据拷贝到数组b里面 */</span>
		
	msg.addr = client-&gt;addr;	<span class="hljs-comment">/* ap3216c地址 */</span>
	msg.flags = <span class="hljs-number">0</span>;				<span class="hljs-comment">/* 标记为写数据 */</span>

	msg.buf = b;				<span class="hljs-comment">/* 要写入的数据缓冲区 */</span>
	msg.len = len + <span class="hljs-number">1</span>;			<span class="hljs-comment">/* 要写入的数据长度 */</span>

	<span class="hljs-keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 读取ap3216c指定寄存器值，读取一个寄存器</span>
<span class="hljs-comment"> * @param - dev:  ap3216c设备</span>
<span class="hljs-comment"> * @param - reg:  要读取的寄存器</span>
<span class="hljs-comment"> * @return 	  :   读取到的寄存器值</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">ap3216c_read_reg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg)</span>
&#123;
	u8 data = <span class="hljs-number">0</span>;

	ap3216c_read_regs(dev, reg, &amp;data, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">return</span> data;

<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;private_data;
	<span class="hljs-keyword">return</span> i2c_smbus_read_byte_data(client, reg);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 向ap3216c指定寄存器写入指定的值，写一个寄存器</span>
<span class="hljs-comment"> * @param - dev:  ap3216c设备</span>
<span class="hljs-comment"> * @param - reg:  要写的寄存器</span>
<span class="hljs-comment"> * @param - data: 要写入的值</span>
<span class="hljs-comment"> * @return   :    无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ap3216c_write_reg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 data)</span>
&#123;
	u8 buf = <span class="hljs-number">0</span>;
	buf = data;
	ap3216c_write_regs(dev, reg, &amp;buf, <span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 读取AP3216C的数据，读取原始数据，包括ALS,PS和IR, 注意！</span>
<span class="hljs-comment"> *				: 如果同时打开ALS,IR+PS的话两次数据读取的时间间隔要大于112.5ms</span>
<span class="hljs-comment"> * @param - ir	: ir数据</span>
<span class="hljs-comment"> * @param - ps 	: ps数据</span>
<span class="hljs-comment"> * @param - ps 	: als数据 </span>
<span class="hljs-comment"> * @return 		: 无。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">ap3216c_readdata</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i =<span class="hljs-number">0</span>;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">6</span>];
	
	<span class="hljs-comment">/* 循环读取所有传感器数据 */</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)	
    &#123;
        buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);	
    &#125;

    <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0X80</span>) 	<span class="hljs-comment">/* IR_OF位为1,则数据无效 */</span>
		dev-&gt;ir = <span class="hljs-number">0</span>;					
	<span class="hljs-keyword">else</span> 				<span class="hljs-comment">/* 读取IR传感器的数据   		*/</span>
		dev-&gt;ir = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)buf[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">2</span>) | (buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0X03</span>); 			
	
	dev-&gt;als = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)buf[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">2</span>];	<span class="hljs-comment">/* 读取ALS传感器的数据 			 */</span>  
	
    <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">4</span>] &amp; <span class="hljs-number">0x40</span>)	<span class="hljs-comment">/* IR_OF位为1,则数据无效 			*/</span>
		dev-&gt;ps = <span class="hljs-number">0</span>;    													
	<span class="hljs-keyword">else</span> 				<span class="hljs-comment">/* 读取PS传感器的数据    */</span>
		dev-&gt;ps = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)(buf[<span class="hljs-number">5</span>] &amp; <span class="hljs-number">0X3F</span>) &lt;&lt; <span class="hljs-number">4</span>) | (buf[<span class="hljs-number">4</span>] &amp; <span class="hljs-number">0X0F</span>); 
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 打开设备</span>
<span class="hljs-comment"> * @param - inode 	: 传递给驱动的inode</span>
<span class="hljs-comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span>
<span class="hljs-comment"> * 					  一般在open的时候将private_data指向设备结构体。</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	filp-&gt;private_data = &amp;ap3216cdev;

	<span class="hljs-comment">/* 初始化AP3216C */</span>
	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="hljs-number">0x04</span>);		<span class="hljs-comment">/* 复位AP3216C 			*/</span>
	mdelay(<span class="hljs-number">50</span>);														<span class="hljs-comment">/* AP3216C复位最少10ms 	*/</span>
	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="hljs-number">0X03</span>);		<span class="hljs-comment">/* 开启ALS、PS+IR 		*/</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 从设备读取数据 </span>
<span class="hljs-comment"> * @param - filp 	: 要打开的设备文件(文件描述符)</span>
<span class="hljs-comment"> * @param - buf 	: 返回给用户空间的数据缓冲区</span>
<span class="hljs-comment"> * @param - cnt 	: 要读取的数据长度</span>
<span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span>
<span class="hljs-comment"> * @return 			: 读取的字节数，如果为负值，表示读取失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">ap3216c_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *off)</span>
&#123;
	<span class="hljs-type">short</span> data[<span class="hljs-number">3</span>];
	<span class="hljs-type">long</span> err = <span class="hljs-number">0</span>;

	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ap3216c_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> ap3216c_dev *)filp-&gt;private_data;
	
	ap3216c_readdata(dev);

	data[<span class="hljs-number">0</span>] = dev-&gt;ir;
	data[<span class="hljs-number">1</span>] = dev-&gt;als;
	data[<span class="hljs-number">2</span>] = dev-&gt;ps;
	err = copy_to_user(buf, data, <span class="hljs-keyword">sizeof</span>(data));
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 关闭/释放设备</span>
<span class="hljs-comment"> * @param - filp 	: 要关闭的设备文件(文件描述符)</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* AP3216C操作函数 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">ap3216c_ops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.open = ap3216c_open,
	.read = ap3216c_read,
	.release = ap3216c_release,
&#125;;

 <span class="hljs-comment">/*</span>
<span class="hljs-comment">  * @description     : i2c驱动的probe函数，当驱动与</span>
<span class="hljs-comment">  *                    设备匹配以后此函数就会执行</span>
<span class="hljs-comment">  * @param - client  : i2c设备</span>
<span class="hljs-comment">  * @param - id      : i2c设备ID</span>
<span class="hljs-comment">  * @return          : 0，成功;其他负值,失败</span>
<span class="hljs-comment">  */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>
&#123;
	<span class="hljs-comment">/* 1、构建设备号 */</span>
	<span class="hljs-keyword">if</span> (ap3216cdev.major) &#123;
		ap3216cdev.devid = MKDEV(ap3216cdev.major, <span class="hljs-number">0</span>);
		register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);
	&#125; <span class="hljs-keyword">else</span> &#123;
		alloc_chrdev_region(&amp;ap3216cdev.devid, <span class="hljs-number">0</span>, AP3216C_CNT, AP3216C_NAME);
		ap3216cdev.major = MAJOR(ap3216cdev.devid);
	&#125;

	<span class="hljs-comment">/* 2、注册设备 */</span>
	cdev_init(&amp;ap3216cdev.cdev, &amp;ap3216c_ops);
	cdev_add(&amp;ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);

	<span class="hljs-comment">/* 3、创建类 */</span>
	ap3216cdev.class = class_create(THIS_MODULE, AP3216C_NAME);
	<span class="hljs-keyword">if</span> (IS_ERR(ap3216cdev.class)) &#123;
		<span class="hljs-keyword">return</span> PTR_ERR(ap3216cdev.class);
	&#125;

	<span class="hljs-comment">/* 4、创建设备 */</span>
	ap3216cdev.device = device_create(ap3216cdev.class, <span class="hljs-literal">NULL</span>, ap3216cdev.devid, <span class="hljs-literal">NULL</span>, AP3216C_NAME);
	<span class="hljs-keyword">if</span> (IS_ERR(ap3216cdev.device)) &#123;
		<span class="hljs-keyword">return</span> PTR_ERR(ap3216cdev.device);
	&#125;

	ap3216cdev.private_data = client;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span>
<span class="hljs-comment"> * @param - client 	: i2c设备</span>
<span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span>
&#123;
	<span class="hljs-comment">/* 删除设备 */</span>
	cdev_del(&amp;ap3216cdev.cdev);
	unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);

	<span class="hljs-comment">/* 注销掉类和设备 */</span>
	device_destroy(ap3216cdev.class, ap3216cdev.devid);
	class_destroy(ap3216cdev.class);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* 传统匹配方式ID列表 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">ap3216c_id</span>[] =</span> &#123;
	&#123;<span class="hljs-string">&quot;lxg,ap3216c&quot;</span>, <span class="hljs-number">0</span>&#125;,  
	&#123;&#125;
&#125;;

<span class="hljs-comment">/* 设备树匹配列表 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">ap3216c_of_match</span>[] =</span> &#123;
	&#123; .compatible = <span class="hljs-string">&quot;lxg,ap3216c&quot;</span> &#125;,
	&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;
&#125;;

<span class="hljs-comment">/* i2c驱动结构体 */</span>	
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">ap3216c_driver</span> =</span> &#123;
	.probe = ap3216c_probe,
	.remove = ap3216c_remove,
	.driver = &#123;
			.owner = THIS_MODULE,
		   	.name = <span class="hljs-string">&quot;ap3216c&quot;</span>,
		   	.of_match_table = ap3216c_of_match, 
		   &#125;,
	.id_table = ap3216c_id,
&#125;;
		   
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动入口函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ap3216c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	ret = i2c_add_driver(&amp;ap3216c_driver);
	<span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动出口函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">ap3216c_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	i2c_del_driver(&amp;ap3216c_driver);
&#125;

<span class="hljs-comment">/* module_i2c_driver(ap3216c_driver) */</span>

module_init(ap3216c_init);
module_exit(ap3216c_exit);
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>具体分析参考正点原子IMX6UL驱动开发指南61.5节</p>
<h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3.编写测试 APP"></a>3.编写测试 APP</h3><p>新建 ap3216cApp.c 文件，然后在里面输入如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/ioctl.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: main主程序</span>
<span class="hljs-comment"> * @param - argc 	: argv数组元素个数</span>
<span class="hljs-comment"> * @param - argv 	: 具体参数</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
&#123;
	<span class="hljs-type">int</span> fd;
	<span class="hljs-type">char</span> *filename;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> databuf[<span class="hljs-number">3</span>];
	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ir, als, ps;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;

	filename = argv[<span class="hljs-number">1</span>];
	fd = open(filename, O_RDWR);
	<span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;

	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
		ret = read(fd, databuf, <span class="hljs-keyword">sizeof</span>(databuf));
		<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123; 			<span class="hljs-comment">/* 数据读取成功 */</span>
			ir =  databuf[<span class="hljs-number">0</span>]; 	<span class="hljs-comment">/* ir传感器数据 */</span>
			als = databuf[<span class="hljs-number">1</span>]; 	<span class="hljs-comment">/* als传感器数据 */</span>
			ps =  databuf[<span class="hljs-number">2</span>]; 	<span class="hljs-comment">/* ps传感器数据 */</span>
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ir = %d, als = %d, ps = %d\r\n&quot;</span>, ir, als, ps);
		&#125;
		usleep(<span class="hljs-number">200000</span>); <span class="hljs-comment">/*100ms */</span>
	&#125;
	close(fd);	<span class="hljs-comment">/* 关闭文件 */</span>	
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>ap3216cApp.c 文件内容很简单，就是在 while 循环中不断的读取 AP3216C 的设备文件，从而得到 ir、als 和 ps 这三个数据值，然后将其输出到终端上。</p>
<h2 id="6-运行测试"><a href="#6-运行测试" class="headerlink" title="6| 运行测试"></a>6| 运行测试</h2><p>编译运行。</p>
<p>当驱动模块加载成功以后使用 ap3216cApp 来测试，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">./ap3216cApp /dev/ap3216c</code></pre></div>

<p>测试 APP 会不断的从 AP3216C 中读取数据，然后输出到终端上，如图  所示：</p>
<p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830154214853.png" srcset="/img/loading.gif" lazyload alt="image-20200830154214853"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/17%E3%80%81Linux_RTC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">17| Linux RTC驱动</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/12/NOTE/ARM/ESP/1%E3%80%81esp-idf%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">
                        <span class="hidden-mobile">1、esp-idf应用程序启动流程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
