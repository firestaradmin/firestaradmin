

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="根文件系统rootfs构建Linux“三巨头”除了uboot、linux-kernel，就剩最后一个 rootfs(根文件系统)了 这里我们就来学习一下根文件系统的组成以及如何构建根文件系统，这是 Linux 移植的最后一步。根文件系统构建好以后就意味着我们已经拥有了一个完整的、可以运行的最小系统。 以后我们就在这个最小系统上编写、测试 Linux 驱动，移植一些第三方组件，逐步的完善这个最小系统">
<meta property="og:type" content="article">
<meta property="og:title" content="9| BusyBox根文件系统rootfs构建">
<meta property="og:url" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="根文件系统rootfs构建Linux“三巨头”除了uboot、linux-kernel，就剩最后一个 rootfs(根文件系统)了 这里我们就来学习一下根文件系统的组成以及如何构建根文件系统，这是 Linux 移植的最后一步。根文件系统构建好以后就意味着我们已经拥有了一个完整的、可以运行的最小系统。 以后我们就在这个最小系统上编写、测试 Linux 驱动，移植一些第三方组件，逐步的完善这个最小系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819184433558.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819185354041.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819185410941.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819185909349.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819191938958.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192134684.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192414064.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192630679.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192900203.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819193104374.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819193855569.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819193944234.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819194904576.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819195259649.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819195519385.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819195915564.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819200024505.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819200209958.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819200416444.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819221525029.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819223835685.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819224700923.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819231003064.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232015712.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232131493.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232935309.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232952811.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819233330591.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819233513402.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819233819089.png">
<meta property="article:published_time" content="2020-09-07T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-07T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="rootfs">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819184433558.png">
  
  
  <title>9| BusyBox根文件系统rootfs构建 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="9| BusyBox根文件系统rootfs构建">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-08 00:00" pubdate>
        2020年9月8日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      149 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">9| BusyBox根文件系统rootfs构建</h1>
            
            <div class="markdown-body">
              <h1 id="根文件系统rootfs构建"><a href="#根文件系统rootfs构建" class="headerlink" title="根文件系统rootfs构建"></a>根文件系统rootfs构建</h1><p>Linux“三巨头”除了uboot、linux-kernel，就剩最后一个 rootfs(根文件系统)了</p>
<p>这里我们就来学习一下根文件系统的组成以及如何构建根文件系统，这是 Linux 移植的最后一步。根文件系统构建好以后就意味着我们已经拥有了一个完整的、可以运行的最小系统。</p>
<p>以后我们就在这个最小系统上编写、测试 Linux 驱动，移植一些第三方组件，逐步的完善这个最小系统。最终得到一个功能完善、驱动齐全、相对完善的操作系统。</p>
<h2 id="一、根文件系统简介"><a href="#一、根文件系统简介" class="headerlink" title="一、根文件系统简介"></a>一、根文件系统简介</h2><p>根文件系统一般也叫做 <strong>rootfs</strong>，那么什么叫根文件系统？看到“文件系统”这四个字，很多人，包括我第一反应就是 FATFS、FAT、EXT4、YAFFS 和 NTFS 等这样的文件系统。</p>
<p><strong>在这里，文件系统并不是 FATFS 这样的文件系统代码</strong>，EXT4 这样的文件系统代码属于 Linux 内核的一部分。</p>
<p>Linux 中的根文件系统更像是一个文件夹或者叫做目录(在我看来就是一个文件夹，只不过是特殊的文件夹)，在这个目录里面会有很多的子目录。根目录下和子目录中会有很多的文件，这些文件是 <strong>Linux 运行所必须</strong>的，比如<strong>库</strong>、<strong>常用的软件和命令</strong>、<strong>设备文件</strong>、<strong>配置文件</strong>等等。以后我们说到文件系统，如果不特别指明，统一表示根文件系统。</p>
<p>对于根文件系统专业的解释，百度百科上是这么说的：</p>
<blockquote>
<p>根文件系统首先是内核启动时所 mount(挂载)的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。</p>
</blockquote>
<p>百度百科上说内核代码镜像文件保存在根文件系统中，但是我们嵌入式 Linux 并没有将内核代码镜像保存在根文件系统中，而是保存到了其他地方。比如 NAND Flash 的指定存储地址、EMMC 专用分区中。根文件系统是 Linux 内核启动以后挂载(mount)的第一个文件系统，然后从根文件系统中读取初始化脚本，比如 rcS，inittab 等。</p>
<p>根文件系统和 Linux 内核是分开的，单独的 Linux 内核是没法正常工作的，必须要搭配根文件系统。如果不提供根文件系统，Linux 内核在启动的时候就会提示内核崩溃(Kernel panic)的提示。</p>
<p>根文件系统的这个“根”字就说明了这个文件系统的重要性，它是其他文件系统的根，没有这个“根”，其他的文件系统或者软件就别想工作。比如我们常用的 ls、mv、ifconfig 等命令其实就是一个个小软件，只是这些软件没有图形界面，而且需要输入命令来运行。这些小软件就保存在根文件系统中，这些小软件是怎么来的呢？这个就是我们本章教程的目的，教大家来构建自己的根文件系统，这个根文件系统是满足 Linux 运行的最小根文件系统，后续我们可以根据自己的实际工作需求不断的去填充这个最小根文件系统，最终使其成为一个相对完善的根文件系统。</p>
<p>在构建根文件系统之前，我们先来看一下根文件系统里面大概都有些什么内容，以 Ubuntu为例，根文件系统的目录名字为‘&#x2F;’，没看错就是一个斜杠，所以输入如下命令就可以进入根目录中：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> / <span class="hljs-string">//</span>进入根目录</code></pre></div>

<p>进入根目录以后输入“ls”命令查看根目录下的内容都有哪些，结果如图所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819184433558.png" srcset="/img/loading.gif" lazyload alt="image-20200819184433558"></p>
<p>图中根目录下子目录和文件不少，但是这些都是 Ubuntu 所需要的，其中有很多子目录和文件我们嵌入式 Linux 是用不到的，所以这里就讲解一些常用的子目录：</p>
<ul>
<li><p><strong>1 、&#x2F;bin  目录</strong></p>
<p>看到“bin”大家应该能想到 bin 文件，bin 文件就是可执行文件。所以此目录下存放着系统需要的可执行文件，一般都是一些命令，比如 ls、mv 等命令。此目录下的命令所有的客户都可以使用。</p>
</li>
<li><p><strong>2 、&#x2F;dev  目录</strong></p>
<p>dev 是 device 的缩写，所以此目录下的文件都是和设备有关的，此目录下的文件都是设备文件。在 Linux 下一切皆文件，即使是硬件设备，也是以文件的形式存在的，比如 <strong>&#x2F;dev&#x2F;ttymxc0</strong>(I.MX6ULL 根目录会有此文件)就表示 I.MX6ULL 的串口 0，我们要想通过串口 0发送或者接收数据就要操作文件&#x2F;dev&#x2F;ttymxc0，通过对文件&#x2F;dev&#x2F;ttymxc0 的读写操作来实现串口0 的数据收发。</p>
</li>
<li><p><strong>3 、&#x2F;etc  目录</strong></p>
<p>此目录下存放着各种配置文件，大家可以进入 Ubuntu 的 etc 目录看一下，里面的配置文件非常多！但是在嵌入式 Linux 下此目录会很简洁。</p>
</li>
<li><p><strong>4 、&#x2F;lib  目录</strong></p>
<p>lib 是 library 的简称，也就是库的意思，因此此目录下存放着 Linux 所必须的库文件。这些库文件是共享库，命令和用户编写的应用程序要使用这些库文件。</p>
</li>
<li><p><strong>5 、&#x2F;mnt  目录</strong></p>
<p>临时挂载目录，一般是空目录，可以在此目录下创建空的子目录，比如&#x2F;mnt&#x2F;sd、&#x2F;mnt&#x2F;usb，这样就可以将 SD 卡或者 U 盘挂载到&#x2F;mnt&#x2F;sd 或者&#x2F;mnt&#x2F;usb 目录中。</p>
</li>
<li><p><strong>6 、&#x2F;proc  目录</strong></p>
<p>此目录一般是空的，当 Linux 系统启动以后会将此目录作为 proc 文件系统的挂载点，proc是个虚拟文件系统，没有实际的存储设备。proc 里面的文件都是临时存在的，一般用来存储系统运行信息文件。</p>
</li>
<li><p><strong>7 、&#x2F;usr  目录</strong></p>
<p>要注意，usr 不是 user 的缩写，而是 Unix Software Resource 的缩写，也就是 Unix 操作系统软件资源目录。这里有个小知识点，那就是 Linux 一般被称为类 Unix 操作系统，苹果的 MacOS也是类 Unix 操作系统。关于 Linux 和 Unix 操作系统的渊源大家可以直接在网上找 Linux 的发展历史来看。既然是软件资源目录，因此&#x2F;usr 目录下也存放着很多软件，一般系统安装完成以后此目录占用的空间最多。</p>
</li>
<li><p><strong>8 、&#x2F;var  目录</strong></p>
<p>此目录存放一些可以改变的数据。</p>
</li>
<li><p><strong>9 、&#x2F;sbin  目录</strong></p>
<p>此目录页用户存放一些可执行文件，但是此目录下的文件或者说命令只有管理员才能使用，主要用户系统管理。</p>
</li>
<li><p><strong>10 、&#x2F;sys  目录</strong></p>
<p>系统启动以后此目录作为 sysfs 文件系统的挂载点，sysfs 是一个类似于 proc 文件系统的特殊文件系统，sysfs 也是基于 ram 的文件系统，也就是说它也没有实际的存储设备。此目录是系统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息。</p>
</li>
<li><p><strong>11 、&#x2F;opt</strong></p>
<p>可选的文件、软件存放区，由用户选择将哪些文件或软件放到此目录中。</p>
</li>
</ul>
<p>关于 Linux 的根目录就介绍到这里，接下来的构建根文件系统就是研究如何创建上面这些子目<br>录以及子目录中的文件。</p>
<h2 id="二、BusyBox-构建根文件系统"><a href="#二、BusyBox-构建根文件系统" class="headerlink" title="二、BusyBox  构建根文件系统"></a>二、BusyBox  构建根文件系统</h2><h3 id="1、BusyBox-简介"><a href="#1、BusyBox-简介" class="headerlink" title="1、BusyBox  简介"></a>1、BusyBox  简介</h3><p>上面说了，根文件系统里面就是一堆的可执行文件和其他文件组成的？难道我们得一个一个的从网上去下载这些文件？显然这是不现实的！那么有没有人或者组织专门干这个事呢？他们负责“收集”这些文件，然后将其打包，像我们这样的开发者可以直接拿来用。</p>
<p>答案是有的，它就叫做 <strong>BusyBox</strong>！其名字分为“Busy”和“Box”，也就是忙碌的盒子。盒子是用来放东西的，忙碌的是因为它要提供根文件系统所需的文件，所以忙碌。BusyBox 是一个集成了大量的 Linux 命令和工具的软件，像 ls、mv、ifconfig 等命令 BusyBox 都会提供。BusyBox 就是一个大的工具箱，这个工具箱里面集成了 Linux 的许多工具和命令。一般下载 BusyBox 的源码，然后配置 BusyBox，选择自己想要的功能，最后编译即可。</p>
<p><strong>BusyBox</strong> 可以在其官网下载到，官网地址为：<a target="_blank" rel="noopener" href="https://busybox.net/%EF%BC%8C%E5%AE%98%E7%BD%91%E6%AF%94%E8%BE%83%E7%AE%80%E9%99%8B%EF%BC%8C%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">https://busybox.net/，官网比较简陋，如图所示：</a></p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819185354041.png" srcset="/img/loading.gif" lazyload alt="image-20200819185354041"></p>
<p>在官网左侧的“Get BusyBox”栏有一行“Download Source”，点击“Download Source”即可打开 BusyBox 的下载页，如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819185410941.png" srcset="/img/loading.gif" lazyload alt="image-20200819185410941"></p>
<p>BusyBox 准备好以后就可以构建根文件系统了。</p>
<h3 id="2、编译-BusyBox-构建根文件系统"><a href="#2、编译-BusyBox-构建根文件系统" class="headerlink" title="2、编译 BusyBox  构建根文件系统"></a>2、编译 BusyBox  构建根文件系统</h3><p>一般我们在 Linux 驱动开发的时候都是通过 nfs 挂载根文件系统的，当产品最终上市开卖的时候才会将根文件系统烧写到 EMMC 或者 NAND 中。</p>
<p>所以要根据之前的教程，设置的 nfs 服务器目录，我们在nfs目录中创建一个名为 rootfs 的子目录(名字大家可以随意起，为了方便就用了 rootfs)，比如我的电脑中“&#x2F;home&#x2F;firestaradmin&#x2F;linux&#x2F;nfs”就是我设置的 NFS 服务器目录，使用如下命令创建名为rootfs 的子目录：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> rootfs</code></pre></div>

<p>创建好的 rootfs 子目录就用来存放我们的根文件系统了。将 busybox-1.29.0.tar.bz2 发送到 Ubuntu 中，存放位置大家随便选择。然后使用如下命令将其解压：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">tar -vxjf busybox-1.29.0.tar.bz2</code></pre></div>

<p>解压完成以后进入到 busybox-1.29.0 目录中，此目录中的文件和文件夹如图所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819185909349.png" srcset="/img/loading.gif" lazyload alt="image-20200819185909349"></p>
<h4 id="1-、修改-Makefile-，添加编译器"><a href="#1-、修改-Makefile-，添加编译器" class="headerlink" title="1 、修改 Makefile ，添加编译器"></a>1 、修改 Makefile ，添加编译器</h4><p>同 Uboot 和 Linux 移植一样，打开 busybox 的顶层 Makefile，添加 ARCH 和CROSS_COMPILE的值，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs"></code></pre></div>

<h4 id="2-、busybox-中文字符支持"><a href="#2-、busybox-中文字符支持" class="headerlink" title="2 、busybox  中文字符支持"></a>2 、busybox  中文字符支持</h4><p>如果默认直接编译 busybox 的话，在使用 一些串口终端的时候中文字符是显示不正常的，中文字符会显示为“?”，比如你的中文目录，中文文件都显示为“?”。不知道从哪个版本开始busybox中的 shell 命令对中文输入即显示做了限制，即使内核支持中文但在 shell 下也依然无法正确显示。所以我们需要修改 busybox 源码，取消 busybox 对中文显示的限制，打开文件 busybox-1.29.0&#x2F;libbb&#x2F;printable_string.c，找到函数 printable_string，函数内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* FAST_FUNC <span class="hljs-title function_">printable_string</span><span class="hljs-params">(<span class="hljs-type">uni_stat_t</span> *stats, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span>
&#123;
	<span class="hljs-type">char</span> *dst;
	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s;

	s = str;
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
		<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *s;
		<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;
			<span class="hljs-comment">/* 99+% of inputs do not need conversion */</span>
			<span class="hljs-keyword">if</span> (stats) &#123;
......
			&#125;
			<span class="hljs-keyword">return</span> str;
		&#125;
		<span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span>)
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">0x7f</span>)
			<span class="hljs-keyword">break</span>;
		s++;
	&#125;

<span class="hljs-meta">#<span class="hljs-keyword">if</span> ENABLE_UNICODE_SUPPORT</span>
	dst = unicode_conv_to_printable(stats, str);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
	&#123;
		<span class="hljs-type">char</span> *d = dst = xstrdup(str);
		<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
			<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;
			<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>)
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> || c &gt;= <span class="hljs-number">0x7f</span>)
				*d = <span class="hljs-string">&#x27;?&#x27;</span>;
			d++;
		&#125;
......
	&#125;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
	<span class="hljs-keyword">return</span> auto_string(dst);
&#125;</code></pre></div>

<p>这里第一部分当字符大于 0X7F 以后就跳出去了。</p>
<p>第二部分，如果支持 UNICODE 码的话，当字符大于 0X7F 就直接输出‘?’。</p>
<p>所以我们需要对这两部分代码进行修改，修改以后如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* FAST_FUNC <span class="hljs-title function_">printable_string</span><span class="hljs-params">(<span class="hljs-type">uni_stat_t</span> *stats, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span>
&#123;
	<span class="hljs-type">char</span> *dst;
	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s;

	s = str;
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
		<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *s;
		<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;
			<span class="hljs-comment">/* 99+% of inputs do not need conversion */</span>
......
			<span class="hljs-keyword">return</span> str;
		&#125;
		<span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span>)
			<span class="hljs-keyword">break</span>;
		<span class="hljs-comment">/* 注释掉以下代码以支持中文 */</span>
		<span class="hljs-comment">/*</span>
<span class="hljs-comment">		if (c &gt;= 0x7f)</span>
<span class="hljs-comment">			break; */</span>
		s++;
	&#125;

<span class="hljs-meta">#<span class="hljs-keyword">if</span> ENABLE_UNICODE_SUPPORT</span>
	dst = unicode_conv_to_printable(stats, str);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
	&#123;
		<span class="hljs-type">char</span> *d = dst = xstrdup(str);
		<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
			<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;
			<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>)
				<span class="hljs-keyword">break</span>;
			
			<span class="hljs-comment">/* 修改以下代码，以支持中文 */</span>
			<span class="hljs-comment">/* 原代码为：</span>
<span class="hljs-comment">			if (c &lt; &#x27; &#x27; || c &gt;= 0x7f)</span>
<span class="hljs-comment">				*d = &#x27;?&#x27;; */</span>
			<span class="hljs-keyword">if</span>(c &lt; <span class="hljs-string">&#x27; &#x27;</span>)
				*d = <span class="hljs-string">&#x27;?&#x27;</span>;
			d++;
		&#125;
......
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
	<span class="hljs-keyword">return</span> auto_string(dst);
&#125;</code></pre></div>

<p>接着打开文件 <strong>busybox-1.29.0&#x2F;libbb&#x2F;unicode.c</strong>，找到如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span>* FAST_FUNC <span class="hljs-title function_">unicode_conv_to_printable2</span><span class="hljs-params">(<span class="hljs-type">uni_stat_t</span> *stats, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">unsigned</span> width, <span class="hljs-type">int</span> flags)</span>
&#123;
	<span class="hljs-type">char</span> *dst;
	<span class="hljs-type">unsigned</span> dst_len;
	<span class="hljs-type">unsigned</span> uni_count;
	<span class="hljs-type">unsigned</span> uni_width;

	<span class="hljs-keyword">if</span> (unicode_status != UNICODE_ON) &#123;
		<span class="hljs-type">char</span> *d;
		<span class="hljs-keyword">if</span> (flags &amp; UNI_FLAG_PAD) &#123;
			d = dst = xmalloc(width + <span class="hljs-number">1</span>);
......
				*d++ = (c &gt;= <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; c &lt; <span class="hljs-number">0x7f</span>) ? c : <span class="hljs-string">&#x27;?&#x27;</span>;
				src++;
			&#125;
			*d = <span class="hljs-string">&#x27;\0&#x27;</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			d = dst = xstrndup(src, width);
			<span class="hljs-keyword">while</span> (*d) &#123;
				<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;
				<span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> || c &gt;= <span class="hljs-number">0x7f</span>)
					*d = <span class="hljs-string">&#x27;?&#x27;</span>;
				d++;
			&#125;
		&#125;
......
		<span class="hljs-keyword">return</span> dst;
	&#125;
......
	<span class="hljs-keyword">return</span> dst;
&#125;</code></pre></div>

<p>修改为：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span>* FAST_FUNC <span class="hljs-title function_">unicode_conv_to_printable2</span><span class="hljs-params">(<span class="hljs-type">uni_stat_t</span> *stats, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">unsigned</span> width, <span class="hljs-type">int</span> flags)</span>
&#123;
	<span class="hljs-type">char</span> *dst;
	<span class="hljs-type">unsigned</span> dst_len;
	<span class="hljs-type">unsigned</span> uni_count;
	<span class="hljs-type">unsigned</span> uni_width;

	<span class="hljs-keyword">if</span> (unicode_status != UNICODE_ON) &#123;
		<span class="hljs-type">char</span> *d;
		<span class="hljs-keyword">if</span> (flags &amp; UNI_FLAG_PAD) &#123;
			d = dst = xmalloc(width + <span class="hljs-number">1</span>);
......
    			<span class="hljs-comment">/* 修改下面一行代码，以支持中文 */</span>
    			<span class="hljs-comment">/* *d++ = (c &gt;= &#x27; &#x27; &amp;&amp; c &lt; 0x7f) ? c : &#x27;?&#x27;; */</span>
				*d++ = (c &gt;= <span class="hljs-string">&#x27; &#x27;</span>) ? c : <span class="hljs-string">&#x27;?&#x27;</span>;
				src++;
			&#125;
			*d = <span class="hljs-string">&#x27;\0&#x27;</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			d = dst = xstrndup(src, width);
			<span class="hljs-keyword">while</span> (*d) &#123;
				<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;
                <span class="hljs-comment">/* 修改下面一行代码，以支持中文 */</span>
				<span class="hljs-comment">/* if (c &lt; &#x27; &#x27; || c &gt;= 0x7f) */</span>
                <span class="hljs-keyword">if</span>(c &lt; <span class="hljs-string">&#x27; &#x27;</span>)
					*d = <span class="hljs-string">&#x27;?&#x27;</span>;
				d++;
			&#125;
		&#125;
......
		<span class="hljs-keyword">return</span> dst;
	&#125;
......
	<span class="hljs-keyword">return</span> dst;
&#125;</code></pre></div>

<p>修改以后的代码，同样主要是禁止字符大于 0X7F 的时候设置为‘?’。busybox 中文字符支持跟代码修改有关的就改好了，最后还需要配置 busybox来使能 unicode 码，这个稍后我们配置 busybox 的时候在设置。</p>
<h4 id="3、配置BusyBox"><a href="#3、配置BusyBox" class="headerlink" title="3、配置BusyBox"></a>3、配置BusyBox</h4><p>根我们编译 Uboot、Linux kernel 一样，我们要先对 <strong>busybox</strong> 进行默认的配置，有以下几种配置选项：</p>
<ul>
<li>①、<strong>defconfig</strong>，缺省配置，也就是默认配置选项。</li>
<li>②、<strong>allyesconfig</strong>，全选配置，也就是选中 busybox 的所有功能。</li>
<li>③、<strong>allnoconfig</strong>，最小配置。</li>
</ul>
<p>我们一般使用默认配置即可，因此使用如下命令先使用默认配置来配置一下 busybox：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make defconfig</span></code></pre></div>

<p><strong>busybox</strong> 也支持图形化配置，通过图形化配置我们可以进一步选择自己想要的功能，输入如下命令打开图形化配置界面：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span></code></pre></div>

<p>打开以后如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819191938958.png" srcset="/img/loading.gif" lazyload alt="image-20200819191938958"></p>
<p>配置路径如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs livescript">Location:
	-&gt; Settings
		-&gt; Build <span class="hljs-keyword">static</span> binary (<span class="hljs-literal">no</span> shared libs)</code></pre></div>

<p>选项“**Build static binary (no shared libs)**”用来决定是静态编译 busybox 还是动态编译，静态编译的话就不需要库文件，但是编译出来的库会很大。动态编译的话要求根文件系统中有库文件，但是编译出来的 busybox 会小很多。</p>
<p>这里我们不能采用静态编译！因为采用静态编译的话 DNS 会出问题！无法进行域名解析，配置如图所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192134684.png" srcset="/img/loading.gif" lazyload alt="image-20200819192134684"></p>
<p>继续配置如下路径配置项：</p>
<div class="hljs code-wrapper"><pre><code class="hljs clean">Location:
	-&gt; Settings
		-&gt; vi-style line editing commands</code></pre></div>

<p>结果如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192414064.png" srcset="/img/loading.gif" lazyload alt="image-20200819192414064"></p>
<p>继续配置如下路径配置项：</p>
<div class="hljs code-wrapper"><pre><code class="hljs coq">Location:
	-&gt; Linux <span class="hljs-keyword">Module</span> Utilities
		-&gt; Simplified modutils</code></pre></div>

<p>默认会选中“<strong>Simplified modutils</strong>”，这里我们要取消勾选！！结果如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192630679.png" srcset="/img/loading.gif" lazyload alt="image-20200819192630679"></p>
<p>继续配置如下路径配置项：</p>
<div class="hljs code-wrapper"><pre><code class="hljs clean">Location:
	-&gt; Linux System Utilities
		-&gt; mdev (<span class="hljs-number">16</span> kb) <span class="hljs-comment">//确保下面的全部选中，默认都是选中的</span></code></pre></div>

<p>结果如图：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192900203.png" srcset="/img/loading.gif" lazyload alt="image-20200819192900203"></p>
<p>最后就是使能 busybox 的 unicode 编码以支持中文，配置路径如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">Location:
	-&gt; Settings
		-&gt; Support Unicode <span class="hljs-regexp">//</span>选中
			-&gt; Check <span class="hljs-variable">$LC_ALL</span>, <span class="hljs-variable">$LC_CTYPE</span> and <span class="hljs-variable">$LANG</span> environment variables  <span class="hljs-regexp">//</span>选中</code></pre></div>

<p>结果如图所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819193104374.png" srcset="/img/loading.gif" lazyload alt="image-20200819193104374"></p>
<p>busybox 的配置就到此结束了，大家也可以根据自己的实际需求选择配置其他的选项，不过对于初学者笔者不建议再做其他的修改，可能会出现编译出错的情况发生。</p>
<h4 id="4、编译BusyBox"><a href="#4、编译BusyBox" class="headerlink" title="4、编译BusyBox"></a>4、编译BusyBox</h4><p>配置好 busybox 以后就可以编译了，我们可以指定编译结果的存放目录，我们肯定要将编译结果存放到前面创建的 rootfs 目录中，输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">make
make install CONFIG_PREFIX=/home/firestaradmin/linux/nfs/rootfs</code></pre></div>

<p>COFIG_PREFIX指定编译结果的存放目录，比如我存放到“&#x2F;home&#x2F;firestaradmin&#x2F;linux&#x2F;nfs&#x2F;rootfs”目录中，等待编译完成。</p>
<p>编译完成以后如图所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819193855569.png" srcset="/img/loading.gif" lazyload alt="image-20200819193855569"></p>
<p>编译完成以后会在 busybox 的所有工具和文件就会被安装到 rootfs 目录中.</p>
<p>rootfs 目录内容如图所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819193944234.png" srcset="/img/loading.gif" lazyload alt="image-20200819193944234"></p>
<p>从图 可以看出，rootfs 目录下有 bin、sbin 和 usr 这三个目录，以及 linuxrc 这个文件。前面说过 Linux 内核 init 进程最后会查找用户空间的 init 程序，找到以后就会运行这个用户空间的 init 程序，从而切换到用户态。</p>
<p>如果 bootargs 设置 init&#x3D;&#x2F;linuxrc，那么 linuxrc 就是可以作为用户空间的 init 程序，所以用户态空间的 init 程序是 busybox 来生成的。</p>
<p>busybox 的工作就完成了，但是此时的根文件系统还不能使用，还需要一些其他的文件，我<br>们继续来完善 rootfs。</p>
<h4 id="5、向根文件系统添加-lib-库"><a href="#5、向根文件系统添加-lib-库" class="headerlink" title="5、向根文件系统添加 lib 库"></a>5、向根文件系统添加 lib 库</h4><h5 id="1-、向-rootfs-的“-x2F-lib-”目录添加库文件"><a href="#1-、向-rootfs-的“-x2F-lib-”目录添加库文件" class="headerlink" title="1 、向 rootfs  的“&#x2F;lib ”目录添加库文件"></a>1 、向 rootfs  的“&#x2F;lib ”目录添加库文件</h5><p>Linux 中的应用程序一般都是需要动态库的，当然你也可以编译成静态的，但是静态的可执行文件会很大。如果编译为动态的话就需要动态库，所以我们需要先根文件系统中添加动态库。在 rootfs 中创建一个名为“lib”的文件夹，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> lib</code></pre></div>

<p>lib 文件夹创建好了，库文件从哪里来呢？<strong>lib 库文件从交叉编译器中获取</strong>，前面我们搭建交叉编译环境的时候将交叉编译器存放到了“&#x2F;usr&#x2F;local&#x2F;arm&#x2F;”目录中。交叉编译器里面有很多的库文件，这些库文件具体是做什么的我们作为初学者肯定不知道，既然我不知道那就简单粗暴的把所有的库文件都放到我们的根文件系统中。这样做出来的根文件系统肯定很大，但是我们现在是学习阶段，还做不了裁剪。</p>
<p>进入arm交叉编译器路径对应的目录：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/arm/g</span>cc-linaro-<span class="hljs-number">4.9</span>.<span class="hljs-number">4</span>-<span class="hljs-number">2017.01</span>-x86_64_arm-linux-gnueabihf<span class="hljs-regexp">/arm-linux-gnueabihf/</span>libc/lib</code></pre></div>

<p>此目录下有很多的<em>so</em>(<em>是通配符)和.a 文件，这些就是库文件，将此目录下所有的</em>so*和.a文件都拷贝到 rootfs&#x2F;lib 目录中，拷贝命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> *so* *.a /home/firestaradmin/linux/nfs/rootfs/lib/ -d</code></pre></div>

<p><strong>后面的“-d”表示拷贝符号链接</strong>，这里有个比较特殊的库文件：ld-linux-armhf.so.3，此库文件也是个符号链接，相当于 Windows 下的快捷方式。会链接到库 ld-2.19-2014.08-1-git.so 上，输入命令“ls ld-linux-armhf.so.3 -l”查看此文件详细信息，如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819194904576.png" srcset="/img/loading.gif" lazyload alt="image-20200819194904576"></p>
<p>从图  可以看出，<strong>ld-linux-armhf.so.3</strong> 后面有个“-&gt;”，表示其是个软连接文件，链接到文件 <strong>ld-2.19-2014.08-1-git.so</strong>，因为其是一个“快捷方式”，因此大小只有 24B。但是，ld-linux-armhf.so.3 不能作为符号链接，否则的话在根文件系统中执行程序无法执行！所以我们需要 ld-linux-armhf.so.3 完成逆袭，由“快捷方式”变为“本尊”，方法很简单，那就是重新复制 ld-linux-armhf.so.3，只是不复制软链接即可，先将 rootfs&#x2F;lib 中的 ld-linux-armhf.so.3 文件删除掉，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">rm</span> ld-linux-armhf.so.3</code></pre></div>

<p>然后重新进入到 <strong>&#x2F;usr&#x2F;local&#x2F;arm&#x2F;gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf&#x2F;arm-linux-gnueabihf&#x2F;libc&#x2F;lib</strong> 目录中，重新拷贝 ld-linux-armhf.so.3，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> ld-linux-armhf.so.3 /home/firestaradmin/linux/nfs/rootfs/lib/</code></pre></div>

<p>拷贝完成以后再到 rootfs&#x2F;lib 目录下查看 ld-linux-armhf.so.3 文件详细信息，如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819195259649.png" srcset="/img/loading.gif" lazyload alt="image-20200819195259649"></p>
<p>从图 可以看出，此时 ld-linux-armhf.so.3 已经不是软连接了，而是实实在在的一个库文件，而且文件大小为 724392B。</p>
<p>继续进入如下目录中：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/arm/g</span>cc-linaro-<span class="hljs-number">4.9</span>.<span class="hljs-number">4</span>-<span class="hljs-number">2017.01</span>-x86_64_arm-linux-gnueabihf<span class="hljs-regexp">/arm-linux-gnueabihf/</span>lib</code></pre></div>

<p>此目录下也有很多的的<em>so</em>和.a 库文件，我们将其也拷贝到 rootfs&#x2F;lib 目录中，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">cp *so* *.a <span class="hljs-regexp">/home/</span>zuozhongkai<span class="hljs-regexp">/linux/</span>nfs<span class="hljs-regexp">/rootfs/</span>lib/ -d</code></pre></div>

<p>rootfs&#x2F;lib 目录的库文件就这些了，完成以后的 rootfs&#x2F;lib 目录如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819195519385.png" srcset="/img/loading.gif" lazyload alt="image-20200819195519385"></p>
<h5 id="2-、向-rootfs-的“usr-x2F-lib-”目录添加库文件"><a href="#2-、向-rootfs-的“usr-x2F-lib-”目录添加库文件" class="headerlink" title="2 、向 rootfs  的“usr&#x2F;lib ”目录添加库文件"></a>2 、向 rootfs  的“usr&#x2F;lib ”目录添加库文件</h5><p>在 rootfs 的 usr 目录下创建一个名为 lib 的目录，将如下目录中的库文件拷贝到 <strong>rootfs&#x2F;usr&#x2F;lib</strong>目录下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/arm/g</span>cc-linaro-<span class="hljs-number">4.9</span>.<span class="hljs-number">4</span>-<span class="hljs-number">2017.01</span>-x86_64_arm-linux-gnueabihf<span class="hljs-regexp">/arm-linux-gnueabihf/</span>libc<span class="hljs-regexp">/usr/</span>lib</code></pre></div>

<p>将此目录下的 so 和.a 库文件都拷贝到 <strong>rootfs&#x2F;usr&#x2F;lib</strong> 目录中，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> *so* *.a /home/firestaradmin/linux/nfs/rootfs/usr/lib/ -d</code></pre></div>

<p>完成以后的 rootfs&#x2F;usr&#x2F;lib 目录如图所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819195915564.png" srcset="/img/loading.gif" lazyload alt="image-20200819195915564"></p>
<p>至此，根文件系统的库文件就全部添加好了，可以使用“du”命令来查看一下 <strong>rootfs&#x2F;lib</strong> 和<strong>rootfs&#x2F;usr&#x2F;lib</strong> 这两个目录的大小，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> rootfs 
<span class="hljs-built_in">du</span> ./lib ./usr/lib/ -sh</code></pre></div>

<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819200024505.png" srcset="/img/loading.gif" lazyload alt="image-20200819200024505"></p>
<p>可以看出lib和usr&#x2F;lib这两个文件的大小分别为57MB和67MB，加起来就是57+67&#x3D;124MB。非常大！</p>
<h5 id="3、创建其他文件夹"><a href="#3、创建其他文件夹" class="headerlink" title="3、创建其他文件夹"></a>3、创建其他文件夹</h5><p>在根文件系统中创建其他文件夹，如 dev、proc、mnt、sys、tmp 和 root 等，创建完成以后如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819200209958.png" srcset="/img/loading.gif" lazyload alt="image-20200819200209958"></p>
<p>目前来看，这个根文件系统好像已经准备好了，究竟有没有准备好，直接测一下就知道了！</p>
<h2 id="三、根文件系统初步测试"><a href="#三、根文件系统初步测试" class="headerlink" title="三、根文件系统初步测试"></a>三、根文件系统初步测试</h2><p>接下来我们使用测试一下前面创建好的根文件系统 rootfs，测试方法就是使用 <strong>NFS 挂载</strong>。</p>
<p>uboot 里面的 bootargs 环境变量会设置“root”的值，所以我们将 root 的值改为 NFS 挂载即可。在 Linux 内核源码里面有相应的文档讲解如何设置，文档为Documentation&#x2F;filesystems&#x2F;nfs&#x2F;nfsroot.txt，格式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ruby">root=<span class="hljs-regexp">/dev/nfs</span> nfsroot=[&lt;server-ip&gt;<span class="hljs-symbol">:</span>]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;<span class="hljs-symbol">:&lt;server-ip&gt;</span><span class="hljs-symbol">:&lt;gw-ip&gt;</span><span class="hljs-symbol">:&lt;netmask&gt;</span><span class="hljs-symbol">:&lt;hostname&gt;</span><span class="hljs-symbol">:&lt;device&gt;</span><span class="hljs-symbol">:&lt;autoconf&gt;</span><span class="hljs-symbol">:&lt;dns0-ip&gt;</span><span class="hljs-symbol">:&lt;dns1-ip&gt;</span></code></pre></div>

<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819200416444.png" srcset="/img/loading.gif" lazyload alt="image-20200819200416444"></p>
<p>根据上面的格式 bootargs 环境变量的 root 值如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">root=/dev/nfs nfsroot=192.168.0.111:/home/firestaradmin/linux/nfs/rootfs,proto=tcp rw ip=192.168.0.112:192.168.0.111:192.168.0.1:255.255.255.0::eth0:off</code></pre></div>

<p>“proto&#x3D;tcp”表示使用 TCP 协议，“rw”表示 nfs 挂载的根文件系统为可读可写。启动开发<br>板，进入 uboot 命令行模式，然后重新设置 bootargs 环境变量，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">setenv bootargs <span class="hljs-string">&#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.0.111:/home/firestaradmin/linux/nfs/rootfs,proto=tcp rw ip=192.168.0.113:192.168.0.111:192.168.0.1:255.255.255.0::eth0:off&#x27;</span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">saveenv</span></code></pre></div>

<p>设置好以后使用“boot”命令启动 Linux 内核，结果如图  所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819221525029.png" srcset="/img/loading.gif" lazyload alt="image-20200819221525029"></p>
<p>从图可以看出，我们进入了根文件系统，说明我们的根文件系统工作了！如果没有启动进入根文件系统的话可以重启一次开发板试试。</p>
<p>大家注意，在进入根文件系统的时候会有下面这一行错误提示：</p>
<p><code>can&#39;t run &#39;/etc/init.d/rcS&#39;: No such file or directory</code></p>
<p>提示很简单，说是无法运行“&#x2F;etc&#x2F;init.d&#x2F;rcS”这个文件，因为这个文件不存在。</p>
<h2 id="四、完善根文件系统"><a href="#四、完善根文件系统" class="headerlink" title="四、完善根文件系统"></a>四、完善根文件系统</h2><h3 id="1、创建-x2F-etc-x2F-init-d-x2F-rcS-文件"><a href="#1、创建-x2F-etc-x2F-init-d-x2F-rcS-文件" class="headerlink" title="1、创建&#x2F;etc&#x2F;init.d&#x2F;rcS  文件"></a>1、创建&#x2F;etc&#x2F;init.d&#x2F;rcS  文件</h3><p>rcS 是个 shell 脚本，Linux 内核启动以后需要启动一些服务，而 rcS 就是规定启动哪些文件的脚本文件。在 rootfs 中创建&#x2F;etc&#x2F;init.d&#x2F;rcS 文件，然后在 rcS 中输入如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"> 1 <span class="hljs-comment">#!/bin/bash</span>
 2 PATH=/sbin:/bin:/usr/sbin:/usr/bin:<span class="hljs-variable">$PATH</span>
 3 LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/lib:/usr/lib
 4 <span class="hljs-built_in">export</span> PATH LD_LIBRARY_PATH
 5 
 6 mount -a
 7 <span class="hljs-built_in">mkdir</span> /dev/pts
 8 mount -t devpts devpts /dev/pts
 9 
10 <span class="hljs-built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug
11 mdev -s</code></pre></div>

<p>第 1 行，表示这是一个 shell 脚本。<br>第 2 行，PATH 环境变量保存着可执行文件可能存在的目录，这样我们在执行一些命令或者可执行文件的时候就不会提示找不到文件这样的错误。<br>第 3 行，LD_LIBRARY_PATH 环境变量保存着库文件所在的目录。<br>第 4 行，使用 export 来导出上面这些环境变量，相当于声明一些“全局变量”。<br>第 6 行，使用 mount 命令来挂载所有的文件系统，这些文件系统由文件&#x2F;etc&#x2F;fstab 来指定，所以我们一会还要创建&#x2F;etc&#x2F;fstab 文件。<br>第 7 和 8 行，创建目录&#x2F;dev&#x2F;pts，然后将 devpts 挂载到&#x2F;dev&#x2F;pts 目录中。<br>第 10 和 11 行，使用 mdev 来管理热插拔设备，通过这两行，Linux 内核就可以在&#x2F;dev 目录下自动创建设备节点。关于 mdev 的详细内容可以参考 busybox 中的 docs&#x2F;mdev.txt 文档。示例代码 中的 rcS 文件内容是最精简的，大家如果去看 Ubuntu 或者其他大型 Linux操作系统中的 rcS 文件，就会发现其非常复杂。因为我们是初次学习，所以不用搞这么复杂的，而且这么复杂的 rcS 文件也是借助其他工具创建的，比如 buildroot 等。</p>
<p><strong>创建好文件&#x2F;etc&#x2F;init.d&#x2F;rcS 以后一定要给其可执行权限！</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 rcS</code></pre></div>

<p>重启内核：如图：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819223835685.png" srcset="/img/loading.gif" lazyload alt="image-20200819223835685"></p>
<p>从图可以看到，提示找不到&#x2F;etc&#x2F;fstab 文件，还有一些其他的错误，我们先把&#x2F;etc&#x2F;fstab这个错误解决了。说不定把这个问题解决以后其他的错误也就解决了。</p>
<p>前面我们说了“mount -a”挂载所有根文件系统的时候需要读取&#x2F;etc&#x2F;fstab，因为&#x2F;etc、fstab 里面定义了该挂载哪些文件，好了，接下来就是创建&#x2F;etc&#x2F;fstab 文件。</p>
<h3 id="2、创建-x2F-etc-x2F-fstab-文件"><a href="#2、创建-x2F-etc-x2F-fstab-文件" class="headerlink" title="2、创建&#x2F;etc&#x2F;fstab 文件"></a>2、创建&#x2F;etc&#x2F;fstab 文件</h3><p>在 rootfs中创建&#x2F;etc&#x2F;fstab 文件，fstab在Linux开机以后自动配置哪些需要自动挂载的分区，格式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-section">&lt;file system&gt;</span> <span class="hljs-section">&lt;mount point&gt;</span> <span class="hljs-section">&lt;type&gt;</span> <span class="hljs-section">&lt;options&gt;</span> <span class="hljs-section">&lt;dump&gt;</span> <span class="hljs-section">&lt;pass&gt;</span></code></pre></div>

<p><code>&lt;file system&gt;</code>：要挂载的特殊的设备，也可以是块设备，比如&#x2F;dev&#x2F;sda 等等。</p>
<p><code>&lt;mount point&gt;</code>：挂载点。</p>
<p><code>&lt;type&gt;</code>：文件系统类型，比如 ext2、ext3、proc、romfs、tmpfs 等等。</p>
<p><code>&lt;options&gt;</code>：挂载选项，在 Ubuntu 中输入“man mount”命令可以查看具体的选项。一般使用 defaults，也就是默认选项，defaults 包含了 rw、suid、 dev、 exec、 auto、 nouser 和 async。</p>
<p><code>&lt;dump&gt;</code>：为 1 的话表示允许备份，为 0 不备份，一般不备份，因此设置为 0。</p>
<p><code>&lt;pass&gt;</code>：磁盘检查设置，为 0 表示不检查。根目录‘&#x2F;’设置为 1，其他的都不能设置为 1，其他的分区从 2 开始。一般不在 fstab 中挂载根目录，因此这里一般设置为 0。</p>
<p>按照上述格式，在 fstab 文件中输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>#&lt;file <span class="hljs-keyword">system</span>&gt;  &lt;mount <span class="hljs-keyword">point</span>&gt;   &lt;type&gt;  &lt;options&gt;   &lt;dump&gt;  &lt;pass&gt;
<span class="hljs-symbol">2 </span>proc            /proc           proc    defaults    <span class="hljs-number">0</span>       <span class="hljs-number">0</span>
<span class="hljs-symbol">3 </span>tmpfs          /tmp            	tmpfs  	defaults    <span class="hljs-number">0</span>       <span class="hljs-number">0</span>
<span class="hljs-symbol">4 </span>sysfs           /sys            sysfs   defaults    <span class="hljs-number">0</span>       <span class="hljs-number">0</span></code></pre></div>

<p>fstab 文件创建完成以后重新启动 Linux，结果如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819224700923.png" srcset="/img/loading.gif" lazyload alt="image-20200819224700923"></p>
<p>从图可以看出，启动成功，而且没有任何错误提示。但是我们要还需要创建一个文件&#x2F;etc&#x2F;inittab。</p>
<h3 id="3、创建-x2F-etc-x2F-inittab-文件"><a href="#3、创建-x2F-etc-x2F-inittab-文件" class="headerlink" title="3、创建&#x2F;etc&#x2F;inittab 文件"></a>3、创建&#x2F;etc&#x2F;inittab 文件</h3><p>inittab 的详细内容可以参考 busybox 下的文件 examples&#x2F;inittab。init 程序会读取**&#x2F;etc&#x2F;inittab**这个文件，inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成，格式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs elixir">&lt;id&gt;<span class="hljs-symbol">:&lt;runlevels&gt;</span><span class="hljs-symbol">:&lt;action&gt;</span><span class="hljs-symbol">:&lt;process&gt;</span></code></pre></div>

<p><code>&lt;id&gt;</code>：每个指令的标识符，不能重复。但是对于 busybox 的 init 来说，<code>&lt;id&gt;</code>有着特殊意义。对于 busybox 而言<code>&lt;id&gt;</code>用来指定启动进程的控制 tty，一般我们将串口或者 LCD 屏幕设置为控制 tty。<br><code>&lt;runlevels&gt;</code> ：对 busybox 来说此项完全没用，所以空着。<br><code>&lt;action&gt;</code>：动作，用于指定<code>&lt;process&gt;</code>可能用到的动作。</p>
<p>busybox 支持的动作如图所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819231003064.png" srcset="/img/loading.gif" lazyload alt="image-20200819231003064"></p>
<p><code>&lt;process&gt;</code> ：具体的动作，比如程序、脚本或命令等。<br>参考 busybox 的 examples&#x2F;inittab 文件，我们也创建一个&#x2F;etc&#x2F;inittab，在里面输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">1 <span class="hljs-comment">#etc/inittab</span>
2 ::sysinit:/etc/init.d/rcS
3 console::askfirst:-/bin/sh
4 ::restart:/sbin/init
5 ::ctrlaltdel:/sbin/reboot
6 ::shutdown:/bin/umount -a -r
7 ::shutdown:/sbin/swapoff -a</code></pre></div>

<p>第 2 行，系统启动以后运行&#x2F;etc&#x2F;init.d&#x2F;rcS 这个脚本文件。<br>第 3 行，将 console 作为控制台终端，也就是 ttymxc0。<br>第 4 行，重启的话运行&#x2F;sbin&#x2F;init。<br>第 5 行，按下 ctrl+alt+del 组合键的话就运行&#x2F;sbin&#x2F;reboot，看来 ctrl+alt+del 组合键用于重启系统。<br>第 6 行，关机的时候执行&#x2F;bin&#x2F;umount，也就是卸载各个文件系统。<br>第 7 行，关机的时候执行&#x2F;sbin&#x2F;swapoff，也就是关闭交换分区。</p>
<p><strong>&#x2F;etc&#x2F;initta</strong> 文件创建好以后就可以重启开发板即可，至此！根文件系统要创建的文件就已经全部完成了。接下来就要对根文件系统进行其他的测试，比如是我们自己编写的软件运行是否正常、是否支持软件开机自启动、中文支持是否正常以及能不能链接等。</p>
<h3 id="4、根文件系统其他功能测试"><a href="#4、根文件系统其他功能测试" class="headerlink" title="4、根文件系统其他功能测试"></a>4、根文件系统其他功能测试</h3><h4 id="1、软件运行测试"><a href="#1、软件运行测试" class="headerlink" title="1、软件运行测试"></a>1、软件运行测试</h4><p>我们使用 Linux 的目的就是运行我们自己的软件，我们编译的应用软件一般都使用动态库，使用动态库的话应用软件体积就很小，但是得提供库文件，库文件我们已经添加到了根文件系统中。我们编写一个小小的测试软件来测试一下库文件是否工作正常，在根文件系统下创建一个名为“drivers”的文件夹，以后我们学习 Linux 驱动的时候就把所有的实验文件放到这个文件夹里面。</p>
<p>在 ubuntu 下使用 vim 编辑器新建一个 hello.c 文件，在 hello.c 里面输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
 <span class="hljs-number">2</span> 
 <span class="hljs-number">3</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
 4 &#123;
 <span class="hljs-number">5</span>     <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
 <span class="hljs-number">6</span>     &#123;
 <span class="hljs-number">7</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\r\n&quot;</span>);
 <span class="hljs-number">8</span>         sleep(<span class="hljs-number">2</span>);
 <span class="hljs-number">9</span>     &#125;
<span class="hljs-number">10</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">11</span> &#125;</code></pre></div>

<p>hello.c 内容很简单，就是循环输出“hello world”，sleep 相当于 Linux 的延时函数，单位为秒，所以 sleep(2)就是延时 2 秒。编写好以后就是编译，因为我们是要在 ARM 芯片上运行的，所以要用交叉编译器去编译，也就是使用 arm-linux-gnueabihf-gcc 编译，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-gcc hello.c -o hello</code></pre></div>

<p>使用 arm-linux-gnueabihf-gcc 将 hello.c 编译为 hello 可执行文件。这个 hello 可执行文件究<br>竟是不是 ARM 使用的呢？使用“file”命令查看文件类型以及编码格式：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">file hello</code></pre></div>

<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232015712.png" srcset="/img/loading.gif" lazyload alt="image-20200819232015712"></p>
<p>从图  可以看出，输入“file hello”输入了如下所示信息：<br><code>hello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked……</code><br>hello 是个 32 位的 LSB 可执行文件，ARM 架构的，并且是动态链接的。所以我们编译出来的 hello 文件没有问题。将其拷贝到 rootfs&#x2F;drivers 目录下，在开发板中输入如下命令来执行这<br>个可执行文件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /drivers  
./hello</code></pre></div>

<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232131493.png" srcset="/img/loading.gif" lazyload alt="image-20200819232131493"></p>
<p>可以看出，hello 这个软件运行正常，说明我们的根文件系统中的共享库是没问题的，要想终止 hello 的运行，按下“ctrl+c”组合键即可。</p>
<p>此时大家应该能感觉到，hello 执行的时候终端是没法用的，除非使用“ctrl+c”来关闭 hello，那么有没有办法既能让 hello 正常运行，而且终端能够正常使用？那肯定是有的，让 hello 进入后台运行就行了，让一个软件进入后台的方法很简单，运行软件的时候加上“&amp;”即可，比如<strong>“.&#x2F;hello &amp;”</strong>就是让 hello 在后台运行。</p>
<p>在后台运行的软件可以使用<strong>“kill -9 pid(进程 ID)”</strong>命令来关闭掉，首先使用<strong>“ps”</strong>命令查看要关闭的软件 PID 是多少，ps 命令用于查看所有当前正在运行的进程，并且会给出进程的 PID。</p>
<h4 id="2、中文字符测试"><a href="#2、中文字符测试" class="headerlink" title="2、中文字符测试"></a>2、中文字符测试</h4><p>在 ubuntu 中向在 rootfs 目录新建一个名为“中文测试”的文件夹，然后在串口终端 下查看中文名能不能显示正确。输入“ls”命令，结果如图所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232935309.png" srcset="/img/loading.gif" lazyload alt="image-20200819232935309"></p>
<p>可以看出“中文测试”这个文件夹显示正常，接着“touch”命令在“中文测试”文件夹中新建一个名为“测试文档.txt”的文件，并且使用 vim 编辑器在其中输入“这是一个中文测试文件”，借此来测试一下中文文件名和中文内容显示是否正常。结果如图 38.5.2.3 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232952811.png" srcset="/img/loading.gif" lazyload alt="image-20200819232952811"></p>
<p>从图  可以看出，“测试文档.txt”的中文内容显示正确，而且中文路径也完全正常，说明我们的根文件系统已经完美支持中文了！</p>
<h4 id="3、开机自启动测试"><a href="#3、开机自启动测试" class="headerlink" title="3、开机自启动测试"></a>3、开机自启动测试</h4><p>在前面测试 hello 软件的时候都是等 Linux 启动进入根文件系统以后手动输入命令“.&#x2F;hello”来完成的。我们一般做好产品以后都是需要开机自动启动相应的软件，本节我们就以hello 这个软件为例，讲解一下如何实现开机自启动。前面我们说过了，进入根文件系统的时候会运行&#x2F;etc&#x2F;init.d&#x2F;rcS 这个 shell 脚本，因此我们可以在这个脚本里面添加自启动相关内容。添加<br>完成以后的&#x2F;etc&#x2F;init.d&#x2F;rcS 文件内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh"> 1 <span class="hljs-comment">#!/bin/sh</span>
 2 PATH=/sbin:/bin:/usr/sbin:/usr/bin:<span class="hljs-variable">$PATH</span>
 3 LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/lib:/usr/lib
 4 <span class="hljs-built_in">export</span> PATH LD_LIBRARY_PATH
 5 
 6 mount -a
 7 <span class="hljs-built_in">mkdir</span> /dev/pts
 8 mount -t devpts devpts /dev/pts
 9 
10 <span class="hljs-built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug
11 mdev -s
12 
13 <span class="hljs-comment">#开机自启动</span>
14 <span class="hljs-built_in">cd</span> /drivers
15 ./hello &amp;
16 <span class="hljs-built_in">cd</span> /</code></pre></div>

<p>自启动代码添加完成以后就可以重启开发板，看看 hello 这个软件会不会自动运行。结果如图 所示:</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819233330591.png" srcset="/img/loading.gif" lazyload alt="image-20200819233330591"></p>
<p>从图可以看出，hello 开机自动运行了，说明开机自启动成功。</p>
<h4 id="4、连接外网测试"><a href="#4、连接外网测试" class="headerlink" title="4、连接外网测试"></a>4、连接外网测试</h4><p>这里说的外网不是外国哪些 404 网站的连接测试，而是百度、淘宝等这些网站的测试。也就是说看看我们的开发板能不能上网，能不能和我们的局域网外的这些网站进行通信。测试方法很简单，就是通过 ping 命令来 ping 一下百度的官网：<code>www.baidu.com</code>。输入如下命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">ping www.baidu.com</code></pre></div>

<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819233513402.png" srcset="/img/loading.gif" lazyload alt="image-20200819233513402"></p>
<p>可以看出，测试失败，提示 <code>www.baidu.com</code> 是个“bad address”，也就是地址不对，显然我们的地址是正确的。之所以出现这个错误提示是因为<code> www.baidu.com</code> 的地址解析失败了，并没有解析出其对应的 IP 地址。</p>
<p>我们需要配置域名解析服务器的 IP 地址，一般域名解析地址可以设置为所处网络的网关地址，比如 192.168.0.1。也可以设置为 114.114.1144.114，这个是运营商的域名解析服务器地址。</p>
<p>在 rootfs 中新建文件**&#x2F;etc&#x2F;resolv.conf**，然后在里面输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>nameserver <span class="hljs-number">114.114</span>.<span class="hljs-number">114.114</span>
<span class="hljs-symbol">2 </span>nameserver <span class="hljs-number">192.168</span>.<span class="hljs-number">0.1</span></code></pre></div>

<p>设置很简单，nameserver 表示这是个域名服务器，设置了两个域名服务器地址：</p>
<p><code>114.114.114.114</code> 和 <code>192.168.0.1</code></p>
<p>大家也可以改为其他的域名服务器试试。如果使用“udhcpc”命令自动获取 IP 地址，“udhcpc”命令会修改 nameserver 的值，一般是将其设置为对应的网关地址。</p>
<p>修改好以后保存退出，重启开发板！重启以后重新 ping 一下百度官网，结果如图 所示：</p>
<p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819233819089.png" srcset="/img/loading.gif" lazyload alt="image-20200819233819089"></p>
<p>可以看出 ping 百度官网成功了！域名也成功的解析了，至此！我们的根文件系统就彻底的制作完成，这个根文件系统最好打包保存一下，防止以后做实验不小心破坏了根文件系统而功亏一篑，又得从头制作根文件系统。</p>
<p>uboot、Linux kernel、rootfs 这三个共同构成了一个完整的Linux 系统，现在的系统至少是一个可以正常运行的系统，后面我们就可以在这个系统上完成Linux 驱动开发的学习。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/">环境搭建系统移植篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/rootfs/">rootfs</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/09/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/10.linux%E4%B8%8B%E7%83%A7%E5%BD%95%E8%87%B3SD%E5%8D%A1%E5%90%AF%E5%8A%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">10| linux下烧录至SD卡启动</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/">
                        <span class="hidden-mobile">8| linux内核移植</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
