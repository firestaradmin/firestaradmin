

<!DOCTYPE html>
<html lang="zh-cn" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux阻塞非阻塞IO实验阻塞和非阻塞 IO 是 Linux 驱动开发里面很常见的两种设备访问模式，在编写驱动的时候一定要考虑到阻塞和非阻塞。本章我们就来学习一下阻塞和非阻塞 IO，以及如何在驱动程序中处理阻塞与非阻塞，如何在驱动程序使用等待队列和 poll 机制。 一、阻塞和非阻塞IO1|阻塞和非阻塞简介这里的“IO”并不是我们学习 STM32 或者其他单片机的时候所说的“GPIO”(也就是引">
<meta property="og:type" content="article">
<meta property="og:title" content="10| Linux阻塞非阻塞IO实验">
<meta property="og:url" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Linux阻塞非阻塞IO实验阻塞和非阻塞 IO 是 Linux 驱动开发里面很常见的两种设备访问模式，在编写驱动的时候一定要考虑到阻塞和非阻塞。本章我们就来学习一下阻塞和非阻塞 IO，以及如何在驱动程序中处理阻塞与非阻塞，如何在驱动程序使用等待队列和 poll 机制。 一、阻塞和非阻塞IO1|阻塞和非阻塞简介这里的“IO”并不是我们学习 STM32 或者其他单片机的时候所说的“GPIO”(也就是引">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826141315957.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826141512429.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826142839512.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826142846893.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827114714058.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827121431518.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827121452839.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827124533321.png">
<meta property="article:published_time" content="2020-09-11T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-11T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826141315957.png">
  
  
  <title>10| Linux阻塞非阻塞IO实验 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="10| Linux阻塞非阻塞IO实验">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-12 00:00" pubdate>
        2020年9月12日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      28k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      237 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">10| Linux阻塞非阻塞IO实验</h1>
            
            <div class="markdown-body">
              <h1 id="Linux阻塞非阻塞IO实验"><a href="#Linux阻塞非阻塞IO实验" class="headerlink" title="Linux阻塞非阻塞IO实验"></a>Linux阻塞非阻塞IO实验</h1><p>阻塞和非阻塞 IO 是 Linux 驱动开发里面很常见的两种<strong>设备访问模式</strong>，在编写驱动的时候一定要考虑到阻塞和非阻塞。本章我们就来学习一下阻塞和非阻塞 IO，以及如何在驱动程序中处理阻塞与非阻塞，如何在驱动程序使用等待队列和 poll 机制。</p>
<h2 id="一、阻塞和非阻塞IO"><a href="#一、阻塞和非阻塞IO" class="headerlink" title="一、阻塞和非阻塞IO"></a>一、阻塞和非阻塞IO</h2><h3 id="1-阻塞和非阻塞简介"><a href="#1-阻塞和非阻塞简介" class="headerlink" title="1|阻塞和非阻塞简介"></a>1|阻塞和非阻塞简介</h3><p>这里的“IO”并不是我们学习 STM32 或者其他单片机的时候所说的“GPIO”(也就是引脚)。这里的 IO 指的是 Input&#x2F;Output，也就是输入&#x2F;输出，是应用程序对驱动设备的输入&#x2F;输出操作。当<br>应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。</p>
<p><strong>阻塞式 IO 如图所示：</strong></p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826141315957.png" srcset="/img/loading.gif" lazyload alt="image-20200826141315957"></p>
<p>图 52.1.1.1 中应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。</p>
<p><strong>非阻塞 IO 如图所示：</strong></p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826141512429.png" srcset="/img/loading.gif" lazyload alt="image-20200826141512429"></p>
<p>从图 52.1.1.2 可以看出，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。</p>
<p>应用程序可以使用如下所示示例代码来实现阻塞访问：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> fd;
<span class="hljs-number">2</span> <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;
<span class="hljs-number">3</span>
<span class="hljs-number">4</span> fd = open(<span class="hljs-string">&quot;/dev/xxx_dev&quot;</span>, O_RDWR); <span class="hljs-comment">/* 阻塞方式打开 */</span>
<span class="hljs-number">5</span> ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data)); <span class="hljs-comment">/* 读取数据 */</span></code></pre></div>

<p>从示例代码 可以看出，对于设备驱动文件的默认读取方式就是阻塞式的，所以我们前面所有的例程测试 APP 都是采用阻塞 IO。如果应用程序要采用非阻塞的方式来访问驱动设备文件，可以使用如下所示代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> fd;
<span class="hljs-number">2</span> <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;
<span class="hljs-number">3</span>
<span class="hljs-number">4</span> fd = open(<span class="hljs-string">&quot;/dev/xxx_dev&quot;</span>, O_RDWR | O_NONBLOCK);  <span class="hljs-comment">/* 非阻塞方式打开 */</span>
<span class="hljs-number">5</span> ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data)); <span class="hljs-comment">/* 读取数据 */</span></code></pre></div>

<p>第 4 行使用 open 函数打开“&#x2F;dev&#x2F;xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候就是非阻塞方式的了。</p>
<h3 id="2-等待队列"><a href="#2-等待队列" class="headerlink" title="2|等待队列"></a>2|等待队列</h3><h4 id="1-等待队列头"><a href="#1-等待队列头" class="headerlink" title="1.等待队列头"></a><strong>1.等待队列头</strong></h4><p><strong>阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来</strong>。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。Linux 内核提供了等待队列(wait queue)来实现阻塞进程的唤醒工作，如果我们要在驱动中使用等待队列，必须创建并初始化一个等待队列头，等待队列头使用结构体wait_queue_head_t 表示，wait_queue_head_t 结构体定义在文件 include&#x2F;linux&#x2F;wait.h中，结构体内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">39</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue_head</span> &#123;</span>
<span class="hljs-number">40</span> 		<span class="hljs-type">spinlock_t</span> lock;
<span class="hljs-number">41</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">task_list</span>;</span>
<span class="hljs-number">42</span> &#125;;
<span class="hljs-number">43</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue_head</span> <span class="hljs-title">wait_queue_head_t</span>;</span></code></pre></div>

<p>定义好等待队列头以后需要初始化，使用 init_waitqueue_head 函数初始化等待队列头，函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init_waitqueue_head</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q)</span></code></pre></div>

<p>参数 q 就是要初始化的等待队列头。</p>
<p>也可以使用宏 <strong>DECLARE_WAIT_QUEUE_HEAD</strong> 来一次性完成等待队列头的定义的初始化。</p>
<hr>
<h4 id="2-等待队列项"><a href="#2-等待队列项" class="headerlink" title="2.等待队列项"></a><strong>2.等待队列项</strong></h4><p>等待队列头就是一个等待队列的头部，每个访问设备的进程都是一个队列项，当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面。结构体 wait_queue_t 表示等待队列项，结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue</span> &#123;</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> 		flags;
    <span class="hljs-type">void</span> 				*private;
    <span class="hljs-type">wait_queue_func_t</span> 	func;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> 	<span class="hljs-title">task_list</span>;</span>
&#125;;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue</span> <span class="hljs-title">wait_queue_t</span>;</span></code></pre></div>

<p>使用宏 <strong>DECLARE_WAITQUEUE</strong> 定义并初始化一个等待队列项，宏的内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">DECLARE_WAITQUEUE(name, tsk)</code></pre></div>

<p><strong>name</strong> 就是等待队列项的名字，<strong>tsk</strong> 表示这个等待队列项属于哪个任务(进程)，一般设置为current ， 在 Linux 内 核 中 current 相 当 于 一 个 全 局 变 量 ， 表 示 当 前 进 程 。 因 此 宏DECLARE_WAITQUEUE 就是给当前正在运行的进程创建并初始化了一个等待队列项。</p>
<hr>
<h4 id="3-将队列项添加-x2F-移除等待队列头"><a href="#3-将队列项添加-x2F-移除等待队列头" class="headerlink" title="3.将队列项添加&#x2F;移除等待队列头"></a><strong>3.将队列项添加&#x2F;移除等待队列头</strong></h4><p>当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，只有添加到等待队列头中以后进程才能进入休眠态。当设备可以访问以后再将进程对应的等待队列项从等待队列头中移除即可，等待队列项添加 API 函数如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">add_wait_queue</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q,</span>
<span class="hljs-params">                    <span class="hljs-type">wait_queue_t</span> *wait)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><strong>q</strong> ：等待队列项要加入的等待队列头。<br><strong>wait</strong>：要加入的等待队列项。<br><strong>返回值</strong>：无。</li>
</ul>
<p>等待队列项移除 API 函数如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">remove_wait_queue</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q,</span>
<span class="hljs-params">                       <span class="hljs-type">wait_queue_t</span> *wait)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><strong>q</strong> ：要删除的等待队列项所处的等待队列头。<br><strong>wait</strong>：要删除的等待队列项。<br><strong>返回值</strong>：无。</li>
</ul>
<hr>
<h4 id="4-等待唤醒"><a href="#4-等待唤醒" class="headerlink" title="4.等待唤醒"></a><strong>4.等待唤醒</strong></h4><p>当设备可以使用的时候就要唤醒进入休眠态的进程，唤醒可以使用如下两个函数：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">wake_up</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">wake_up_interruptible</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q)</span></code></pre></div>

<p>参数 q 就是要唤醒的等待队列头，这两个函数会<strong>将这个等待队列头中的所有进程都唤醒</strong>。<strong>wake_up</strong> 函数可以唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 状态的进程，而 <strong>wake_up_interruptible</strong> 函数只能唤醒处于 TASK_INTERRUPTIBLE 状态的进程。</p>
<hr>
<h4 id="5-等待事件"><a href="#5-等待事件" class="headerlink" title="5.等待事件"></a><strong>5.等待事件</strong></h4><p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程，和等待事件有关的 API 函数如表  所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826142839512.png" srcset="/img/loading.gif" lazyload alt="image-20200826142839512"></p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826142846893.png" srcset="/img/loading.gif" lazyload alt="image-20200826142846893"></p>
<h3 id="3-轮询"><a href="#3-轮询" class="headerlink" title="3|轮询"></a>3|轮询</h3><p>如果用户应用程序以非阻塞的方式访问设备，设备驱动程序就要提供非阻塞的处理方式，也就是轮询。<strong>poll、epoll 和 select 可以用于处理轮询</strong>，应用程序通过 select、epoll 或 poll 函数来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。当应用程序调用 select、epoll 或 poll 函数的时候设备驱动程序中的 poll 函数就会执行，因此需要在设备驱动程序中编写 poll 函数。我们先来看一下应用程序中使用的 select、poll 和 epoll这三个函数。</p>
<h4 id="1-select-函数"><a href="#1-select-函数" class="headerlink" title="1.select  函数"></a>1.select  函数</h4><p>select 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,</span>
<span class="hljs-params">           fd_set *readfds,</span>
<span class="hljs-params">           fd_set *writefds,</span>
<span class="hljs-params">           fd_set *exceptfds,</span>
<span class="hljs-params">           <span class="hljs-keyword">struct</span> timeval *timeout)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><p><strong>nfds</strong> ：所要监视的这三类文件描述集合中，最大文件描述符加 1。</p>
</li>
<li><p><strong>readfds 、writefds 和 和 exceptfds</strong>：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，这三个参数都是 fd_set 类型的，fd_set 类型变量的每一个位都代表了一个文件描述符。readfds 用于监视指定描述符集的读变化，也就是监视这些文件是否可以读取，只要这些集合里面有一个文件可以读取那么 seclect 就会返回一个大于 0 的值表示文件可以读取。如果没有文件可以读取，那么就会根据 timeout 参数来判断是否超时。可以将 readfs设置为 NULL，表示不关心任何文件的读变化。writefds 和 readfs 类似，只是 writefs 用于监视这些文件是否可以进行写操作。exceptfds 用于监视这些文件的异常。</p>
<p>比如我们现在要从一个设备文件中读取数据，那么就可以定义一个 fd_set 变量，这个变量要传递给参数 readfds。当我们定义好一个 fd_set 变量以后可以使用如下所示几个宏进行操作：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FD_ZERO</span><span class="hljs-params">(fd_set *<span class="hljs-built_in">set</span>)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">FD_SET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">FD_CLR</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span></code></pre></div>

<p><strong>FD_ZERO</strong> 用于将 fd_set 变量的所有位都清零，<strong>FD_SET</strong> 用于将 fd_set 变量的某个位置 1，也就是向 fd_set 添加一个文件描述符，参数 fd 就是要加入的文件描述符。<strong>FD_CLR</strong> 用户将 fd_set变量的某个位清零，也就是将一个文件描述符从 fd_set 中删除，参数 fd 就是要删除的文件描述符。<strong>FD_ISSET</strong> 用于测试一个文件是否属于某个集合，参数 fd 就是要判断的文件描述符。</p>
</li>
<li><p><strong>timeout</strong> :超时时间，当我们调用 select 函数等待某些文件描述符可以设置超时时间，超时时间使用结构体 timeval 表示，结构体定义如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span>
    <span class="hljs-type">long</span> tv_sec; <span class="hljs-comment">/* 秒 */</span>
    <span class="hljs-type">long</span> tv_usec; <span class="hljs-comment">/* 微妙 */</span> 
&#125;;</code></pre></div>

<p>当 timeout 为 NULL 的时候就表示无限期的等待。</p>
</li>
<li><p><strong>返回值</strong>：0，表示的话就表示超时发生，但是没有任何文件描述符可以进行操作；-1，发生错误；其他值，可以进行操作的文件描述符个数。</p>
</li>
</ul>
<p>使用 select 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
2 &#123;
<span class="hljs-number">3</span> 	<span class="hljs-type">int</span> ret, fd; <span class="hljs-comment">/* 要监视的文件描述符 */</span>
<span class="hljs-number">4</span> 	fd_set readfds; <span class="hljs-comment">/* 读操作文件描述符集 */</span>
<span class="hljs-number">5</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span> <span class="hljs-comment">/* 超时结构体 */</span>
<span class="hljs-number">6</span>
<span class="hljs-number">7</span> 	fd = open(<span class="hljs-string">&quot;dev_xxx&quot;</span>, O_RDWR | O_NONBLOCK); <span class="hljs-comment">/* 非阻塞式访问 */</span>
<span class="hljs-number">8</span>
<span class="hljs-number">9</span>	FD_ZERO(&amp;readfds); <span class="hljs-comment">/* 清除 readfds */</span>
<span class="hljs-number">10</span> 	FD_SET(fd, &amp;readfds); <span class="hljs-comment">/* 将 fd 添加到 readfds 里面 */</span>
<span class="hljs-number">11</span>
<span class="hljs-number">12</span> 	<span class="hljs-comment">/* 构造超时时间 */</span>
<span class="hljs-number">13</span> 	timeout.tv_sec = <span class="hljs-number">0</span>;
<span class="hljs-number">14</span> 	timeout.tv_usec = <span class="hljs-number">500000</span>; <span class="hljs-comment">/* 500ms */</span>
<span class="hljs-number">15</span>
<span class="hljs-number">16</span> 	ret = select(fd + <span class="hljs-number">1</span>, &amp;readfds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;timeout);
<span class="hljs-number">17</span> 	<span class="hljs-keyword">switch</span> (ret) &#123;
<span class="hljs-number">18</span> 		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* 超时 */</span>
<span class="hljs-number">19</span> 			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timeout!\r\n&quot;</span>);
<span class="hljs-number">20</span> 			<span class="hljs-keyword">break</span>;
<span class="hljs-number">21</span> 		<span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>: <span class="hljs-comment">/* 错误 */</span>
<span class="hljs-number">22</span> 			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error!\r\n&quot;</span>);
<span class="hljs-number">23</span> 			<span class="hljs-keyword">break</span>;
<span class="hljs-number">24</span> 		<span class="hljs-keyword">default</span>: <span class="hljs-comment">/* 可以读取数据 */</span>
<span class="hljs-number">25</span> 			<span class="hljs-keyword">if</span>(FD_ISSET(fd, &amp;readfds)) &#123; <span class="hljs-comment">/* 判断是否为 fd 文件描述符 */</span>
<span class="hljs-number">26</span> 				<span class="hljs-comment">/* 使用 read 函数读取数据 */</span>
<span class="hljs-number">27</span> 			&#125;
<span class="hljs-number">28</span> 			<span class="hljs-keyword">break</span>;
<span class="hljs-number">29</span> 	&#125;
<span class="hljs-number">30</span> &#125;</code></pre></div>

<h4 id="2-poll-函数"><a href="#2-poll-函数" class="headerlink" title="2.poll  函数"></a>2.poll  函数</h4><p>在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，可以<br>修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使用 poll 函数，poll 函数本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制，Linux 应用程序中 poll 函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds,</span>
<span class="hljs-params">         <span class="hljs-type">nfds_t</span> nfds,</span>
<span class="hljs-params">         <span class="hljs-type">int</span> timeout)</span></code></pre></div>

<ul>
<li><p>函数参数和返回值含义如下：<br><strong>fds</strong> ：要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的，pollfd 结构体如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span>
    <span class="hljs-type">int</span> fd; <span class="hljs-comment">/* 文件描述符 */</span>
    <span class="hljs-type">short</span> events; <span class="hljs-comment">/* 请求的事件 */</span>
    <span class="hljs-type">short</span> revents; <span class="hljs-comment">/* 返回的事件 */</span>
&#125;;</code></pre></div>

<p>fd 是要监视的文件描述符，如果 fd 无效的话那么 events 监视事件也就无效，并且 revents返回 0。events 是要监视的事件，可监视的事件类型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">POLLIN 		有数据可以读取。
POLLPRI 	有紧急的数据需要读取。
POLLOUT  	可以写数据。
POLLERR  	指定的文件描述符发生错误。
POLLHUP  	指定的文件描述符挂起。
POLLNVAL 	无效的请求。
POLLRDNORM  等同于 POLLIN</code></pre></div>

<p>revents 是返回参数，也就是返回的事件，由 Linux 内核设置具体的返回事件。</p>
</li>
<li><p><strong>nfds</strong>：poll 函数要监视的文件描述符数量。</p>
</li>
<li><p><strong>timeout</strong> ：超时时间，单位为 ms。</p>
</li>
<li><p><strong>返回值</strong>：返回 revents 域中不为 0 的 pollfd 结构体个数，也就是发生事件或错误的文件描述符数量；0，超时；-1，发生错误，并且设置 errno 为错误类型。</p>
</li>
</ul>
<p>使用 poll 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
2 &#123;
<span class="hljs-number">3</span> 		<span class="hljs-type">int</span> ret;
<span class="hljs-number">4</span> 		<span class="hljs-type">int</span> fd; <span class="hljs-comment">/* 要监视的文件描述符 */</span>
<span class="hljs-number">5</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>;</span>
<span class="hljs-number">6</span>
<span class="hljs-number">7</span> 		fd = open(filename, O_RDWR | O_NONBLOCK); <span class="hljs-comment">/* 非阻塞式访问 */</span>
<span class="hljs-number">8</span>
<span class="hljs-number">9</span> 		<span class="hljs-comment">/* 构造结构体 */</span>
<span class="hljs-number">10</span> 		fds.fd = fd;
<span class="hljs-number">11</span> 		fds.events = POLLIN; <span class="hljs-comment">/* 监视数据是否可以读取 */</span>
<span class="hljs-number">12</span>
<span class="hljs-number">13</span> 		ret = poll(&amp;fds, <span class="hljs-number">1</span>, <span class="hljs-number">500</span>); <span class="hljs-comment">/* 轮询文件是否可操作，超时 500ms */</span>
<span class="hljs-number">14</span> 		<span class="hljs-keyword">if</span> (ret) &#123; <span class="hljs-comment">/* 数据有效 */</span>
<span class="hljs-number">15</span> 			......
<span class="hljs-number">16</span> 			<span class="hljs-comment">/* 读取数据 */</span>
<span class="hljs-number">17</span> 			......
<span class="hljs-number">18</span> 		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 超时 */</span>
<span class="hljs-number">19</span> 			......
<span class="hljs-number">20</span> 		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 错误 */</span>
<span class="hljs-number">21</span> 			......
<span class="hljs-number">22</span> 		&#125;
<span class="hljs-number">23</span> &#125;</code></pre></div>

<h4 id="3-epoll-函数"><a href="#3-epoll-函数" class="headerlink" title="3.epoll  函数"></a>3.epoll  函数</h4><p>传统的 selcet 和 poll 函数都会随着所监听的 fd 数量的增加，出现效率低下的问题，而且poll 函数每次必须遍历所有的描述符来检查就绪的描述符，这个过程很浪费时间。为此，epoll应运而生，epoll 就是为处理大并发而准备的，一般常常在网络编程中使用 epoll 函数。应用程序需要先使用 epoll_create 函数创建一个 epoll 句柄，epoll_create 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><strong>size</strong> ：从 Linux2.6.8 开始此参数已经没有意义了，随便填写一个大于 0 的值就可以。</li>
<li><strong>返回值</strong>：epoll 句柄，如果为-1 的话表示创建失败。</li>
</ul>
<p>epoll 句柄创建成功以后使用 epoll_ctl 函数向其中添加要监视的文件描述符以及监视的事<br>件，epoll_ctl 函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd,</span>
<span class="hljs-params">              <span class="hljs-type">int</span> op,</span>
<span class="hljs-params">              <span class="hljs-type">int</span>  fd,</span>
<span class="hljs-params">              <span class="hljs-keyword">struct</span> epoll_event *event)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><p><strong>epfd</strong> ：要操作的 epoll 句柄，也就是使用 epoll_create 函数创建的 epoll 句柄。</p>
</li>
<li><p><strong>op</strong> ：表示要对 epfd(epoll 句柄)进行的操作，可以设置为：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">EPOLL_CTL_ADD  	向 epfd 添加文件参数 fd 表示的描述符。
EPOLL_CTL_MOD  	修改参数 fd 的 event 事件。
EPOLL_CTL_DEL 	从 epfd 中删除 fd 描述符。</code></pre></div>
</li>
<li><p><strong>fd</strong>：要监视的文件描述符。</p>
</li>
<li><p><strong>event</strong> ：要监视的事件类型，为 epoll_event 结构体类型指针，epoll_event 结构体类型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span>
    <span class="hljs-type">uint32_t</span> events; <span class="hljs-comment">/* epoll 事件 */</span>
    <span class="hljs-type">epoll_data_t</span> data; <span class="hljs-comment">/* 用户数据 */</span>
&#125;;</code></pre></div>

<p>结构体 epoll_event 的 events 成员变量表示要监视的事件，可选的事件如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">EPOLLIN</span>  有数据可以读取。
EPOLLOUT 可以写数据。
EPOLLPRI 有紧急的数据需要读取。
EPOLLERR 指定的文件描述符发生错误。
EPOLLHUP 指定的文件描述符挂起。
EPOLLET  设置 <span class="hljs-literal">epoll</span> 为边沿触发，默认触发模式为水平触发。
EPOLLONESHOT 一次性的监视，当监视完成以后还需要再次监视某个 fd，那么就需要将
fd 重新添加到 <span class="hljs-literal">epoll</span> 里面。</code></pre></div>

<p>上面这些事件可以进行“或”操作，也就是说可以设置监视多个事件。</p>
</li>
<li><p>返回值：0，成功；-1，失败，并且设置 errno 的值为相应的错误码。</p>
</li>
</ul>
<p>一切都设置好以后应用程序就可以通过 epoll_wait 函数来等待事件的发生，类似 select 函数。epoll_wait 函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd,</span>
<span class="hljs-params">               <span class="hljs-keyword">struct</span> epoll_event *events,</span>
<span class="hljs-params">               <span class="hljs-type">int</span> maxevents,</span>
<span class="hljs-params">               <span class="hljs-type">int</span> timeout)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><strong>epfd</strong> ：要等待的 epoll。</li>
<li><strong>events</strong> ：指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调用者可以根据 events 判断发生了哪些事件。</li>
<li><strong>maxevents</strong>：events 数组大小，必须大于 0。</li>
<li><strong>timeout</strong> ：超时时间，单位为 ms。</li>
<li><strong>返回值</strong>：0，超时；-1，错误；其他值，准备就绪的文件描述符数量。</li>
</ul>
<p>epoll 更多的是用在大规模的并发服务器上，因为在这种场合下 select 和 poll 并不适合。当设计到的文件描述符(fd)比较少的时候就适合用 selcet 和 poll，本章我们就使用 sellect 和poll 这两个函数.</p>
<h3 id="4-Linux-驱动下的-poll-操作函数"><a href="#4-Linux-驱动下的-poll-操作函数" class="headerlink" title="4| Linux  驱动下的 poll  操作函数"></a>4| Linux  驱动下的 poll  操作函数</h3><p>当应用程序调用 select 或 poll 函数来对驱动程序进行非阻塞访问的时候，驱动程序file_operations 操作集中的 poll 函数就会执行。所以驱动程序的编写者需要提供对应的 poll 函数，poll 函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-keyword">struct</span> poll_table_struct *wait)</span></code></pre></div>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><p><strong>filp</strong> ：要打开的设备文件(文件描述符)。</p>
</li>
<li><p><strong>wait</strong> ：结构体 poll_table_struct 类型指针，由应用程序传递进来的。一般将此参数传递给poll_wait 函数。</p>
</li>
<li><p><strong>返回值</strong>:向应用程序返回设备或者资源状态，可以返回的资源状态如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">POLLIN</span> 有数据可以读取。
POLLPRI 有紧急的数据需要读取。
POLLOUT  可以写数据。
POLLERR  指定的文件描述符发生错误。
POLLHUP  指定的文件描述符挂起。
POLLNVAL 无效的请求。
POLLRDNORM  等同于 POLLIN，普通数据可读</code></pre></div></li>
</ul>
<p>我们需要在驱动程序的 poll 函数中调用 poll_wait 函数，poll_wait 函数不会引起阻塞，只是将应用程序添加到 poll_table 中，poll_wait 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">poll_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file * filp, <span class="hljs-type">wait_queue_head_t</span> * wait_address, poll_table *p)</span></code></pre></div>

<p>参数 wait_address 是要添加到 poll_table 中的等待队列头，参数 p 就是 poll_table，就是file_operations 中 poll 函数的 wait 参数。</p>
<h2 id="二、阻塞-IO-实验"><a href="#二、阻塞-IO-实验" class="headerlink" title="二、阻塞 IO  实验"></a>二、阻塞 IO  实验</h2><p>在上一章 Linux 中断实验中，我们直接在应用程序中通过 read 函数不断的读取按键状态，当按键有效的时候就打印出按键值。这种方法有个缺点，那就是 imx6uirqApp 这个测试应用程序拥有很高的 CPU 占用率，大家可以在开发板中加载上一章的驱动程序模块 imx6uirq.ko，然后以后台运行模式打开 imx6uirqApp 这个测试软件，命令如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">./imx6uirqApp /dev/imx6uirq &amp;</code></pre></div>

<p>测试驱动是否正常工作，如果驱动工作正常的话输入“top”命令查看 imx6uirqApp 这个应用程序的 CPU 使用率，结果如图  所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827114714058.png" srcset="/img/loading.gif" lazyload alt="image-20200827114714058"></p>
<p>从图可以看出，imx6uirqApp 这个应用程序的 CPU 使用率竟然高达 99.6%，这仅仅是一个读取按键值的应用程序，这么高的 CPU 使用率显然是有问题的！原因就在于我们是直接在 while 循环中通过 read 函数读取按键值，因此 imx6uirqApp 这个软件会一直运行，一直读取按键值，CPU 使用率肯定就会很高。最好的方法就是在没有有效的按键事件发生的时候，imx6uirqApp 这个应用程序应该处于休眠状态，当有按键事件发生以后 imx6uirqApp 这个应用程序才运行，打印出按键值，这样就会降低 CPU 使用率，本小节我们就使用阻塞 IO 来实现此功能。</p>
<h3 id="1-驱动程序编写"><a href="#1-驱动程序编写" class="headerlink" title="1|驱动程序编写"></a>1|驱动程序编写</h3><p>本章实验我们在上一章的“13_irq”实验的基础上完成，主要是对其添加阻塞访问相关的代码。新建名为“14_blockio”的文件夹，然后在 14_blockio 文件夹里面创建 vscode 工程，工作区命名为“blockio”。将“13_irq”实验中的 imx6uirq.c 复制到 14_blockio 文件夹中，并重命名为 blockio.c。</p>
<p>接下来我们就修改 blockio.c 这个文件，在其中添加阻塞相关的代码，完成以后的blockio.c 内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CNT 	1			<span class="hljs-comment">/* 设备号个数 */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_NAME <span class="hljs-string">&quot;blockio&quot;</span>		<span class="hljs-comment">/* 设备名 */</span></span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE 	0X01 <span class="hljs-comment">/* KEY0 按键值 */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY 	0XFF <span class="hljs-comment">/* 无效的按键值 */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_CNT 	1 	 <span class="hljs-comment">/* 按键数量 */</span></span>


<span class="hljs-comment">/* 中断 IO 描述结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> &#123;</span>
	<span class="hljs-type">int</span> gpio; 				<span class="hljs-comment">/* gpio */</span>
	<span class="hljs-type">int</span> irqnum; 			<span class="hljs-comment">/* 中断号 */</span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value; 	<span class="hljs-comment">/* 按键对应的键值  */</span>
	<span class="hljs-type">char</span> name[<span class="hljs-number">10</span>]; 			<span class="hljs-comment">/* 名字 */</span>
	<span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *); <span class="hljs-comment">/* 中断服务函数 */</span>
&#125;;




<span class="hljs-comment">/* imx6uirq设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> &#123;</span>	
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>
	<span class="hljs-type">dev_t</span> devid;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>
	<span class="hljs-type">int</span> major;
	<span class="hljs-type">int</span> minor;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span>		<span class="hljs-comment">/* 设备树节点 */</span>
	<span class="hljs-type">atomic_t</span> keyvalue; 			<span class="hljs-comment">/* 有效的按键键值 */</span>
	<span class="hljs-type">atomic_t</span> releasekey; 		<span class="hljs-comment">/* 标记是否完成一次完成的按键*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> 	<span class="hljs-comment">/* 定义一个定时器*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> <span class="hljs-title">irqkeydesc</span>[<span class="hljs-title">KEY_CNT</span>];</span> <span class="hljs-comment">/* 按键描述数组 */</span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> curkeynum; 	<span class="hljs-comment">/* 当前的按键号 */</span>

	<span class="hljs-type">wait_queue_head_t</span> r_wait;	<span class="hljs-comment">/* 读等待对列头 */</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> <span class="hljs-title">imx6uirq</span>;</span>


<span class="hljs-comment">/* @description : 中断服务函数，开启定时器，延时 10ms，</span>
<span class="hljs-comment"> * 定时器用于按键消抖。</span>
<span class="hljs-comment"> * @param - irq : 中断号</span>
<span class="hljs-comment"> * @param - dev_id : 设备结构。</span>
<span class="hljs-comment"> * @return : 中断执行结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">key0_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)dev_id;

	dev-&gt;curkeynum = <span class="hljs-number">0</span>;
	dev-&gt;timer.data = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span>)dev_id;
	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="hljs-number">10</span>));
	<span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);
&#125;

<span class="hljs-comment">/* @description : 定时器服务函数，用于按键消抖，定时器到了以后</span>
<span class="hljs-comment"> * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span>
<span class="hljs-comment"> * @param – arg  : 设备结构变量</span>
<span class="hljs-comment"> * @return : 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> *<span class="hljs-title">keydesc</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)arg;

	num = dev-&gt;curkeynum;
	keydesc = &amp;dev-&gt;irqkeydesc[num];
	value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/* 读取 IO 值 */</span>
	<span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span>
		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);
	&#125;
	<span class="hljs-keyword">else</span>&#123; 			<span class="hljs-comment">/* 按键松开 */</span>
		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="hljs-number">0x80</span> | keydesc-&gt;value);
		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 标记松开按键 */</span>
	&#125;

	<span class="hljs-comment">/*  唤醒进程 */</span>
	<span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey))&#123; <span class="hljs-comment">/*  完成一次按键过程 */</span>
		<span class="hljs-comment">/* wake_up(&amp;dev-&gt;r_wait); */</span>
		wake_up_interruptible(&amp;dev-&gt;r_wait);
	&#125;
&#125;


<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description : 按键 IO 初始化</span>
<span class="hljs-comment"> * @param : 无</span>
<span class="hljs-comment"> * @return : 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;

	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	imx6uirq.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);
	<span class="hljs-keyword">if</span> (imx6uirq.nd == <span class="hljs-literal">NULL</span>)
	&#123;
		printk(<span class="hljs-string">&quot;k:key node not find!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> -EINVAL;
	&#125;

	<span class="hljs-comment">/* 提取 GPIO */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)
	&#123;
		imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd,
														<span class="hljs-string">&quot;key-gpios&quot;</span>, i);
		<span class="hljs-keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="hljs-number">0</span>)
		&#123;
			printk(<span class="hljs-string">&quot;k:can&#x27;t get key%d\r\n&quot;</span>, i);
		&#125;
	&#125;

	<span class="hljs-comment">/* 初始化 key 所使用的 IO，并且设置成中断模式 */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)
	&#123;
		<span class="hljs-built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-number">0</span>,
			   <span class="hljs-keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));
		<span class="hljs-built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-string">&quot;KEY%d&quot;</span>, i);
		gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);
		gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);
		imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(
			imx6uirq.nd, i);
<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(
imx6uirq.irqkeydesc[i].gpio);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
		printk(<span class="hljs-string">&quot;k:key%d:gpio=%d, irqnum=%d\r\n&quot;</span>, i,
			   imx6uirq.irqkeydesc[i].gpio,
			   imx6uirq.irqkeydesc[i].irqnum);
	&#125;
	<span class="hljs-comment">/* 申请中断 */</span>
	imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].handler = key0_handler;
	imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].value = KEY0VALUE;

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)
	&#123;
		ret = request_irq(imx6uirq.irqkeydesc[i].irqnum,
						  imx6uirq.irqkeydesc[i].handler,
						  IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
						  imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);
		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)
		&#123;
			printk(<span class="hljs-string">&quot;k:irq %d request failed!\r\n&quot;</span>,
				   imx6uirq.irqkeydesc[i].irqnum);
			<span class="hljs-keyword">return</span> -EFAULT;
		&#125;
	&#125;

	<span class="hljs-comment">/* 创建定时器 */</span>
	init_timer(&amp;imx6uirq.timer);
	imx6uirq.timer.function = timer_function;


	<span class="hljs-comment">/*  初始化等待队列头 */</span>
	init_waitqueue_head(&amp;imx6uirq.r_wait);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	filp-&gt;private_data = &amp;imx6uirq; <span class="hljs-comment">/* 设置私有数据 */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description : 从设备读取数据</span>
<span class="hljs-comment"> * @param – filp : 要打开的设备文件(文件描述符)</span>
<span class="hljs-comment"> * @param – buf : 返回给用户空间的数据缓冲区</span>
<span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span>
<span class="hljs-comment"> * @param – offt : 相对于文件首地址的偏移</span>
<span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">imx6uirq_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf,</span>
<span class="hljs-params">							 <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> keyvalue = <span class="hljs-number">0</span>;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> releasekey = <span class="hljs-number">0</span>;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)
								   filp-&gt;private_data;


<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
	<span class="hljs-comment">/*  加入等待队列，等待被唤醒, 也就是有按键按下 */</span>
	ret = wait_event_interruptible(dev-&gt;r_wait,
								   <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey));
	<span class="hljs-keyword">if</span> (ret) &#123;
		<span class="hljs-keyword">goto</span> wait_error;
	&#125;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

	DECLARE_WAITQUEUE(wait, current); <span class="hljs-comment">/*  定义一个等待队列 */</span>
	<span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey) == <span class="hljs-number">0</span>) &#123;											 <span class="hljs-comment">/*  没有按键按下 */</span>
		add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);	 <span class="hljs-comment">/*  添加到等待队列头 */</span>
		__set_current_state(TASK_INTERRUPTIBLE); <span class="hljs-comment">/*  设置任务状态 */</span>
		schedule();								 <span class="hljs-comment">/*  进行一次任务切换 */</span>
		<span class="hljs-keyword">if</span> (signal_pending(current))
		&#123; <span class="hljs-comment">/*  判断是否为信号引起的唤醒 */</span>
			ret = -ERESTARTSYS;
			<span class="hljs-keyword">goto</span> wait_error;
		&#125;
		__set_current_state(TASK_RUNNING);		<span class="hljs-comment">/* 设置为运行状态 */</span>
		remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait); <span class="hljs-comment">/* 将等待队列移除 */</span>
	&#125;

	keyvalue = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;keyvalue);
	releasekey = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey);

	<span class="hljs-keyword">if</span> (releasekey)
	&#123; <span class="hljs-comment">/* 有按键按下 */</span>
		<span class="hljs-keyword">if</span> (keyvalue &amp; <span class="hljs-number">0x80</span>)
		&#123;
			keyvalue &amp;= ~<span class="hljs-number">0x80</span>;
			ret = copy_to_user(buf, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));
		&#125;
		<span class="hljs-keyword">else</span>
		&#123;
			<span class="hljs-keyword">goto</span> data_error;
		&#125;
		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 按下标志清零 */</span>
	&#125;
	<span class="hljs-keyword">else</span>
	&#123;
		<span class="hljs-keyword">goto</span> data_error;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

wait_error:
	set_current_state(TASK_RUNNING);		<span class="hljs-comment">/*  设置任务为运行态 */</span>
	remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait); <span class="hljs-comment">/*  将等待队列移除 */</span>
	<span class="hljs-keyword">return</span> ret;

data_error:
	<span class="hljs-keyword">return</span> -EINVAL;
&#125;

<span class="hljs-comment">/* 设备操作函数 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">imx6uirq_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.open = imx6uirq_open,
	.read = imx6uirq_read,

&#125;;




<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">imx6uirq_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;


	<span class="hljs-comment">/* 注册设备号 */</span>
	imx6uirq.major = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(imx6uirq.major)&#123;
		imx6uirq.devid = MKDEV(imx6uirq.major, imx6uirq.minor);
		ret = register_chrdev_region(imx6uirq.devid, DEV_CNT, DEV_NAME);
	&#125;
	<span class="hljs-keyword">else</span>&#123;
		ret = alloc_chrdev_region(&amp;imx6uirq.devid, <span class="hljs-number">0</span>, DEV_CNT, DEV_NAME);
	&#125;
	imx6uirq.major = MAJOR(imx6uirq.devid);
	imx6uirq.minor = MINOR(imx6uirq.devid);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;k:register devid failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_devid;
	&#125;
	printk(<span class="hljs-string">&quot;k:imx6uirq  MAJOR:%d  MINOR:%d\r\n&quot;</span>, imx6uirq.major, imx6uirq.minor);

	<span class="hljs-comment">/* 添加字符设备 */</span>
	imx6uirq.cdev.owner = imx6uirq_fops.owner;
	cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);
	ret = cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, DEV_CNT);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;k:register chrdev failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_cdev;
	&#125;
	<span class="hljs-comment">/* 创建设备节点 */</span>
	<span class="hljs-comment">/* 	1.创建类 */</span>
	imx6uirq.class = class_create(THIS_MODULE, DEV_NAME);
	<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.class))&#123;
		printk(<span class="hljs-string">&quot;k:fail to create class!\r\n&quot;</span>);
		result = PTR_ERR(imx6uirq.class);
		<span class="hljs-keyword">goto</span> fail_class;
	&#125;
	<span class="hljs-comment">/*	2.创建设备*/</span>
	imx6uirq.device = device_create(imx6uirq.class, <span class="hljs-literal">NULL</span>, imx6uirq.devid, <span class="hljs-literal">NULL</span>, DEV_NAME);
	<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.device))&#123;
		printk(<span class="hljs-string">&quot;k:fail to create device!\r\n&quot;</span>);
		result = PTR_ERR(imx6uirq.device);
		<span class="hljs-keyword">goto</span> fail_device;
	&#125;
		
	<span class="hljs-comment">/* 5、初始化按键 */</span>
	<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);
	<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="hljs-number">0</span>);
	keyio_init();

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;


fail_device:
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(imx6uirq.class);
fail_class:
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;imx6uirq.cdev);
fail_register_cdev:
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(imx6uirq.devid, DEV_CNT);
fail_register_devid:
	<span class="hljs-keyword">return</span> result;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">imx6uirq_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;

	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;

	<span class="hljs-comment">/* 删除定时器 */</span>
	del_timer_sync(&amp;imx6uirq.timer);

	<span class="hljs-comment">/* 释放中断 */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)
	&#123;
		free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);
	&#125;

	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(imx6uirq.class, imx6uirq.devid);
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(imx6uirq.class);
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;imx6uirq.cdev);
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(imx6uirq.devid, DEV_CNT);

&#125;

<span class="hljs-comment">/* 驱动入口和出口 */</span>
module_init(imx6uirq_init);
module_exit(imx6uirq_exit);

<span class="hljs-comment">/* 许可 */</span>
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-comment">/* 作者信息 */</span>
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<ul>
<li>修改设备文件名字为“blockio”，当驱动程序加载成功以后就会在根文件系统中出现一个名为“&#x2F;dev&#x2F;blockio”的文件。</li>
<li>在设备结构体中添加一个等待队列头 r_wait，因为在 Linux 驱动中处理阻塞 IO需要用到等待队列.</li>
<li>定时器中断处理函数执行，表示有按键按下，先判断一下是否是一次有效的按键，如果是的话就通过 wake_up 或者 wake_up_interruptible 函数来唤醒等待队列r_wait。</li>
<li>keyio_init中调用 init_waitqueue_head 函数初始化等待队列头 r_wait。</li>
<li>read函数中采用等待事件来处理 read 的阻塞访问，wait_event_interruptible 函数等待releasekey 有效，也就是有按键按下。如果按键没有按下的话进程就会进入休眠状态，因为采用了 wait_event_interruptible 函数，因此进入休眠态的进程可以被信号打断。</li>
<li>首先使用 DECLARE_WAITQUEUE 宏定义一个等待队列，如果没有按键按下的话就使用add_wait_queue 函数将当前任务的等待队列添加到等待队列头 r_wait 中。随后调用__set_current_state 函数设置当前进程的状态为 TASK_INTERRUPTIBLE，也就是可以被信号打断。接下来调用 schedule 函数进行一次任务切换，当前进程就会进入到休眠态。如果有按键按下，那么进入休眠态的进程就会唤醒，然后接着从休眠点开始运行。被唤醒后首先通过 signal_pending 函数判断一下进程是不是由信号唤醒的，如果是由信号唤醒的话就直接返回-ERESTARTSYS 这个错误码。如果不是由信号唤醒的(也就是被按键唤醒的)那么就调用__set_current_state 函数将任务状态设置为 TASK_RUNNING，然后调用remove_wait_queue 函数将进程从等待队列中删除。</li>
</ul>
<p>使用等待队列实现阻塞访问重点注意两点：<br>①、将任务或者进程加入到等待队列头，<br>②、在合适的点唤醒等待队列，一般都是中断处理函数里面。</p>
<h3 id="2-APP编写"><a href="#2-APP编写" class="headerlink" title="2|APP编写"></a>2|APP编写</h3><p>测试 APP 直接使用前面所编写的 imx6uirqApp.c，将 imx6uirqApp.c 复制到本节实验文件夹下，并且重命名为 blockioApp.c，不需要修改任何内容。</p>
<h3 id="3-运行测试"><a href="#3-运行测试" class="headerlink" title="3|运行测试"></a>3|运行测试</h3><p>编译运行。</p>
<p>驱动加载成功以后使用如下命令打开 blockioApp 这个测试 APP，并且以后台模式运行：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">./blockioApp /dev/blockio &amp;</code></pre></div>

<p>按下开发板上的 KEY0 按键，结果如图 所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827121431518.png" srcset="/img/loading.gif" lazyload alt="image-20200827121431518"></p>
<p>输入“top”命令，查看 blockioAPP 这个应用 APP 的 CPU 使用率，如图  所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827121452839.png" srcset="/img/loading.gif" lazyload alt="image-20200827121452839"></p>
<p>可以看出，当我们在按键驱动程序里面加入阻塞访问以后，blockioApp 这个应用程序的 CPU 使用率从 99.6%降低到了 0.0%。大家注意，这里的 0.0%并不是说 blockioApp 这个应用程序不使用 CPU 了，只是因为使用率太小了，CPU 使用率可能为0.00001%，但是图只能显示出小数点后一位，因此就显示成了 0.0%。</p>
<h2 id="三、非阻塞-IO-实验"><a href="#三、非阻塞-IO-实验" class="headerlink" title="三、非阻塞 IO 实验"></a>三、非阻塞 IO 实验</h2><h3 id="1-驱动程序编写-1"><a href="#1-驱动程序编写-1" class="headerlink" title="1|驱动程序编写"></a>1|驱动程序编写</h3><p>本实验我们在“14_blockio”实验的基础上完成，上一小节实验我们已经在驱动中添加了阻塞 IO 的代码，本小节我们继续完善驱动，加入非阻塞 IO 驱动代码。新建名为“15_noblockio”的文件夹，然后在 15_noblockio 文件夹里面创建 vscode 工程，工作区命名为“noblockio”。将“14_blockio”实验中的 blockio.c 复制到 15_noblockio 文件夹中，并重命名为 noblockio.c。</p>
<p>接下来我们就修改 noblockio.c 这个文件，在其中添加非阻塞相关的代码，完成以后的 noblockio.c 内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CNT 	1			<span class="hljs-comment">/* 设备号个数 */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_NAME <span class="hljs-string">&quot;noblockio&quot;</span>		<span class="hljs-comment">/* 设备名 */</span></span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE 	0X01 <span class="hljs-comment">/* KEY0 按键值 */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY 	0XFF <span class="hljs-comment">/* 无效的按键值 */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_CNT 	1 	 <span class="hljs-comment">/* 按键数量 */</span></span>


<span class="hljs-comment">/* 中断 IO 描述结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> &#123;</span>
	<span class="hljs-type">int</span> gpio; 				<span class="hljs-comment">/* gpio */</span>
	<span class="hljs-type">int</span> irqnum; 			<span class="hljs-comment">/* 中断号 */</span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value; 	<span class="hljs-comment">/* 按键对应的键值  */</span>
	<span class="hljs-type">char</span> name[<span class="hljs-number">10</span>]; 			<span class="hljs-comment">/* 名字 */</span>
	<span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *); <span class="hljs-comment">/* 中断服务函数 */</span>
&#125;;




<span class="hljs-comment">/* imx6uirq设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> &#123;</span>	
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>
	<span class="hljs-type">dev_t</span> devid;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>
	<span class="hljs-type">int</span> major;
	<span class="hljs-type">int</span> minor;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span>		<span class="hljs-comment">/* 设备树节点 */</span>
	<span class="hljs-type">atomic_t</span> keyvalue; 			<span class="hljs-comment">/* 有效的按键键值 */</span>
	<span class="hljs-type">atomic_t</span> releasekey; 		<span class="hljs-comment">/* 标记是否完成一次完成的按键*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> 	<span class="hljs-comment">/* 定义一个定时器*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> <span class="hljs-title">irqkeydesc</span>[<span class="hljs-title">KEY_CNT</span>];</span> <span class="hljs-comment">/* 按键描述数组 */</span>
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> curkeynum; 	<span class="hljs-comment">/* 当前的按键号 */</span>

	<span class="hljs-type">wait_queue_head_t</span> r_wait;	<span class="hljs-comment">/* 读等待对列头 */</span>
&#125;;

<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> <span class="hljs-title">imx6uirq</span>;</span>


<span class="hljs-comment">/* @description : 中断服务函数，开启定时器，延时 10ms，</span>
<span class="hljs-comment"> * 定时器用于按键消抖。</span>
<span class="hljs-comment"> * @param - irq : 中断号</span>
<span class="hljs-comment"> * @param - dev_id : 设备结构。</span>
<span class="hljs-comment"> * @return : 中断执行结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">key0_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>
&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)dev_id;

	dev-&gt;curkeynum = <span class="hljs-number">0</span>;
	dev-&gt;timer.data = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span>)dev_id;
	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="hljs-number">10</span>));
	<span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);
&#125;

<span class="hljs-comment">/* @description : 定时器服务函数，用于按键消抖，定时器到了以后</span>
<span class="hljs-comment"> * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span>
<span class="hljs-comment"> * @param – arg  : 设备结构变量</span>
<span class="hljs-comment"> * @return : 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> *<span class="hljs-title">keydesc</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)arg;

	num = dev-&gt;curkeynum;
	keydesc = &amp;dev-&gt;irqkeydesc[num];
	value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/* 读取 IO 值 */</span>
	<span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span>
		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);
	&#125;
	<span class="hljs-keyword">else</span>&#123; 			<span class="hljs-comment">/* 按键松开 */</span>
		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="hljs-number">0x80</span> | keydesc-&gt;value);
		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 标记松开按键 */</span>
	&#125;

	<span class="hljs-comment">/*  唤醒进程 */</span>
	<span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey))&#123; <span class="hljs-comment">/*  完成一次按键过程 */</span>
		<span class="hljs-comment">/* wake_up(&amp;dev-&gt;r_wait); */</span>
		wake_up_interruptible(&amp;dev-&gt;r_wait);
	&#125;
&#125;


<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description : 按键 IO 初始化</span>
<span class="hljs-comment"> * @param : 无</span>
<span class="hljs-comment"> * @return : 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;

	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;

	imx6uirq.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);
	<span class="hljs-keyword">if</span> (imx6uirq.nd == <span class="hljs-literal">NULL</span>)
	&#123;
		printk(<span class="hljs-string">&quot;k:key node not find!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> -EINVAL;
	&#125;

	<span class="hljs-comment">/* 提取 GPIO */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)
	&#123;
		imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd,
														<span class="hljs-string">&quot;key-gpios&quot;</span>, i);
		<span class="hljs-keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="hljs-number">0</span>)
		&#123;
			printk(<span class="hljs-string">&quot;k:can&#x27;t get key%d\r\n&quot;</span>, i);
		&#125;
	&#125;

	<span class="hljs-comment">/* 初始化 key 所使用的 IO，并且设置成中断模式 */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)
	&#123;
		<span class="hljs-built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-number">0</span>,
			   <span class="hljs-keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));
		<span class="hljs-built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-string">&quot;KEY%d&quot;</span>, i);
		gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);
		gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);
		imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(
			imx6uirq.nd, i);
<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(
imx6uirq.irqkeydesc[i].gpio);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
		printk(<span class="hljs-string">&quot;k:key%d:gpio=%d, irqnum=%d\r\n&quot;</span>, i,
			   imx6uirq.irqkeydesc[i].gpio,
			   imx6uirq.irqkeydesc[i].irqnum);
	&#125;
	<span class="hljs-comment">/* 申请中断 */</span>
	imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].handler = key0_handler;
	imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].value = KEY0VALUE;

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)
	&#123;
		ret = request_irq(imx6uirq.irqkeydesc[i].irqnum,
						  imx6uirq.irqkeydesc[i].handler,
						  IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
						  imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);
		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)
		&#123;
			printk(<span class="hljs-string">&quot;k:irq %d request failed!\r\n&quot;</span>,
				   imx6uirq.irqkeydesc[i].irqnum);
			<span class="hljs-keyword">return</span> -EFAULT;
		&#125;
	&#125;

	<span class="hljs-comment">/* 创建定时器 */</span>
	init_timer(&amp;imx6uirq.timer);
	imx6uirq.timer.function = timer_function;


	<span class="hljs-comment">/*  初始化等待队列头 */</span>
	init_waitqueue_head(&amp;imx6uirq.r_wait);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	filp-&gt;private_data = &amp;imx6uirq; <span class="hljs-comment">/* 设置私有数据 */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description : 从设备读取数据</span>
<span class="hljs-comment"> * @param – filp : 要打开的设备文件(文件描述符)</span>
<span class="hljs-comment"> * @param – buf : 返回给用户空间的数据缓冲区</span>
<span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span>
<span class="hljs-comment"> * @param – offt : 相对于文件首地址的偏移</span>
<span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">imx6uirq_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf,</span>
<span class="hljs-params">							 <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> keyvalue = <span class="hljs-number">0</span>;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> releasekey = <span class="hljs-number">0</span>;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)
								   filp-&gt;private_data;

	<span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK)&#123;			<span class="hljs-comment">/*  非阻塞访问 */</span>
		<span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey) == <span class="hljs-number">0</span>) <span class="hljs-comment">/*  没有按键按下 */</span>
			<span class="hljs-keyword">return</span> -EAGAIN;
	&#125;
	<span class="hljs-keyword">else</span>&#123;	<span class="hljs-comment">/* 阻塞访问 */</span>
		<span class="hljs-comment">/* 加入等待队列，等待被唤醒,也就是有按键按下 */</span>
		ret = wait_event_interruptible(dev-&gt;r_wait,
									   <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey));
		<span class="hljs-keyword">if</span> (ret)
		&#123;
			<span class="hljs-keyword">goto</span> wait_error;
		&#125;
	&#125;


	keyvalue = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;keyvalue);
	releasekey = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey);

	<span class="hljs-keyword">if</span> (releasekey)
	&#123; <span class="hljs-comment">/* 有按键按下 */</span>
		<span class="hljs-keyword">if</span> (keyvalue &amp; <span class="hljs-number">0x80</span>)
		&#123;
			keyvalue &amp;= ~<span class="hljs-number">0x80</span>;
			ret = copy_to_user(buf, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));
		&#125;
		<span class="hljs-keyword">else</span>
		&#123;
			<span class="hljs-keyword">goto</span> data_error;
		&#125;
		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 按下标志清零 */</span>
	&#125;
	<span class="hljs-keyword">else</span>
	&#123;
		<span class="hljs-keyword">goto</span> data_error;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

wait_error:
	<span class="hljs-keyword">return</span> ret;

data_error:
	<span class="hljs-keyword">return</span> -EINVAL;
&#125;

 <span class="hljs-comment">/*</span>
<span class="hljs-comment">  * @description     : poll函数，用于处理非阻塞访问</span>
<span class="hljs-comment">  * @param - filp    : 要打开的设备文件(文件描述符)</span>
<span class="hljs-comment">  * @param - wait    : 等待列表(poll_table)</span>
<span class="hljs-comment">  * @return          : 设备或者资源状态，</span>
<span class="hljs-comment">  */</span>
<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-keyword">struct</span> poll_table_struct *wait)</span>
&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;

	poll_wait(filp, &amp;dev-&gt;r_wait, wait);	<span class="hljs-comment">/* 将等待队列头添加到poll_table中 */</span>
	
	<span class="hljs-keyword">if</span>(<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey)) &#123;		<span class="hljs-comment">/* 按键按下 */</span>
		mask = POLLIN | POLLRDNORM;			<span class="hljs-comment">/* 返回PLLIN */</span>
	&#125;
	<span class="hljs-keyword">return</span> mask;
&#125;

<span class="hljs-comment">/* 设备操作函数 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">imx6uirq_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.open = imx6uirq_open,
	.read = imx6uirq_read,
	.poll = imx6uirq_poll,
&#125;;




<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">imx6uirq_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;


	<span class="hljs-comment">/* 注册设备号 */</span>
	imx6uirq.major = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(imx6uirq.major)&#123;
		imx6uirq.devid = MKDEV(imx6uirq.major, imx6uirq.minor);
		ret = register_chrdev_region(imx6uirq.devid, DEV_CNT, DEV_NAME);
	&#125;
	<span class="hljs-keyword">else</span>&#123;
		ret = alloc_chrdev_region(&amp;imx6uirq.devid, <span class="hljs-number">0</span>, DEV_CNT, DEV_NAME);
	&#125;
	imx6uirq.major = MAJOR(imx6uirq.devid);
	imx6uirq.minor = MINOR(imx6uirq.devid);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;k:register devid failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_devid;
	&#125;
	printk(<span class="hljs-string">&quot;k:imx6uirq  MAJOR:%d  MINOR:%d\r\n&quot;</span>, imx6uirq.major, imx6uirq.minor);

	<span class="hljs-comment">/* 添加字符设备 */</span>
	imx6uirq.cdev.owner = imx6uirq_fops.owner;
	cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);
	ret = cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, DEV_CNT);
	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;
		printk(<span class="hljs-string">&quot;k:register chrdev failed!\r\n&quot;</span>);
		result = -EINVAL;
		<span class="hljs-keyword">goto</span> fail_register_cdev;
	&#125;
	<span class="hljs-comment">/* 创建设备节点 */</span>
	<span class="hljs-comment">/* 	1.创建类 */</span>
	imx6uirq.class = class_create(THIS_MODULE, DEV_NAME);
	<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.class))&#123;
		printk(<span class="hljs-string">&quot;k:fail to create class!\r\n&quot;</span>);
		result = PTR_ERR(imx6uirq.class);
		<span class="hljs-keyword">goto</span> fail_class;
	&#125;
	<span class="hljs-comment">/*	2.创建设备*/</span>
	imx6uirq.device = device_create(imx6uirq.class, <span class="hljs-literal">NULL</span>, imx6uirq.devid, <span class="hljs-literal">NULL</span>, DEV_NAME);
	<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.device))&#123;
		printk(<span class="hljs-string">&quot;k:fail to create device!\r\n&quot;</span>);
		result = PTR_ERR(imx6uirq.device);
		<span class="hljs-keyword">goto</span> fail_device;
	&#125;
		
	<span class="hljs-comment">/* 5、初始化按键 */</span>
	<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);
	<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="hljs-number">0</span>);
	keyio_init();

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;


fail_device:
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(imx6uirq.class);
fail_class:
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;imx6uirq.cdev);
fail_register_cdev:
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(imx6uirq.devid, DEV_CNT);
fail_register_devid:
	<span class="hljs-keyword">return</span> result;
&#125;


<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">imx6uirq_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;

	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;

	<span class="hljs-comment">/* 删除定时器 */</span>
	del_timer_sync(&amp;imx6uirq.timer);

	<span class="hljs-comment">/* 释放中断 */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)
	&#123;
		free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);
	&#125;

	<span class="hljs-comment">/* 摧毁设备 */</span>
	device_destroy(imx6uirq.class, imx6uirq.devid);
	<span class="hljs-comment">/* 摧毁类 */</span>
	class_destroy(imx6uirq.class);
	<span class="hljs-comment">/* 注销字符设备 */</span>
	cdev_del(&amp;imx6uirq.cdev);
	<span class="hljs-comment">/* 注销设备号 */</span>
	unregister_chrdev_region(imx6uirq.devid, DEV_CNT);

&#125;

<span class="hljs-comment">/* 驱动入口和出口 */</span>
module_init(imx6uirq_init);
module_exit(imx6uirq_exit);

<span class="hljs-comment">/* 许可 */</span>
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-comment">/* 作者信息 */</span>
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<ul>
<li>修改设备文件名字为“noblockio”，当驱动程序加载成功以后就会在根文件系统中出现一个名为“&#x2F;dev&#x2F;noblockio”的文件。</li>
<li>判断是否为非阻塞式读取访问，如果是的话就判断按键是否有效，也就是判断一下有没有按键按下，如果没有的话就返回-EAGAIN。</li>
<li>imx6uirq_poll 函数就是 file_operations 驱动操作集中的 poll 函数，当应用程序调用 select 或者 poll 函数的时候 imx6uirq_poll 函数就会执行。调用 poll_wait 函数将等待队列头添加到 poll_table 中，判断按键是否有效，如果按键有效的话就向应用程序返回 POLLIN 这个事件，表示有数据可以读取。</li>
</ul>
<h3 id="2-编写测试APP"><a href="#2-编写测试APP" class="headerlink" title="2|编写测试APP"></a>2|编写测试APP</h3><p>新建名为 noblockioApp.c 测试 APP 文件，然后在其中输入如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/ioctl.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;poll.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/select.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/time.h&quot;</span></span>




<span class="hljs-comment">/*</span>
<span class="hljs-comment">* @description : main 主程序</span>
<span class="hljs-comment">* @param - argc : argv 数组元素个数</span>
<span class="hljs-comment">* @param - argv : 具体参数</span>
<span class="hljs-comment">* @return : 0 成功;其他 失败</span>
<span class="hljs-comment">*/</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
&#123;
    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, fd = <span class="hljs-number">0</span>;
    <span class="hljs-type">char</span> *filename;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>;</span>
    fd_set readfds;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span>


    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)
    &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;

    filename = argv[<span class="hljs-number">1</span>];
    <span class="hljs-comment">/* 打开驱动文件 */</span>
    fd =  open(filename, O_RDWR | O_NONBLOCK);  <span class="hljs-comment">/* 非阻塞访问 */</span>
    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;


<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
    <span class="hljs-comment">/* POLL */</span>
	<span class="hljs-comment">/* 构造结构体 */</span>
	fds.fd = fd;
	fds.events = POLLIN;
		
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
		ret = poll(&amp;fds, <span class="hljs-number">1</span>, <span class="hljs-number">500</span>);
		<span class="hljs-keyword">if</span> (ret) &#123;	<span class="hljs-comment">/* 数据有效 */</span>
			ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data));
			<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;
				<span class="hljs-comment">/* 读取错误 */</span>
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-keyword">if</span>(data)
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key value = %d \r\n&quot;</span>, data);
			&#125; 	
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123; 	<span class="hljs-comment">/* 超时 */</span>
			<span class="hljs-comment">/* 用户自定义超时处理 */</span>
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;	<span class="hljs-comment">/* 错误 */</span>
			<span class="hljs-comment">/* 用户自定义错误处理 */</span>
		&#125;
	&#125;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
    <span class="hljs-comment">/* SELECT */</span>
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;	
		FD_ZERO(&amp;readfds);
		FD_SET(fd, &amp;readfds);
		<span class="hljs-comment">/* 构造超时时间 */</span>
		timeout.tv_sec = <span class="hljs-number">0</span>;
		timeout.tv_usec = <span class="hljs-number">500000</span>; <span class="hljs-comment">/* 500ms */</span>
		ret = select(fd + <span class="hljs-number">1</span>, &amp;readfds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;timeout);
		<span class="hljs-keyword">switch</span> (ret) &#123;
			<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: 	<span class="hljs-comment">/* 超时 */</span>
				<span class="hljs-comment">/* 用户自定义超时处理 */</span>
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:	<span class="hljs-comment">/* 错误 */</span>
				<span class="hljs-comment">/* 用户自定义错误处理 */</span>
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">default</span>:  <span class="hljs-comment">/* 可以读取数据 */</span>
				<span class="hljs-keyword">if</span>(FD_ISSET(fd, &amp;readfds)) &#123;
					ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data));
					<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;
						<span class="hljs-comment">/* 读取错误 */</span>
					&#125; <span class="hljs-keyword">else</span> &#123;
						<span class="hljs-keyword">if</span> (data)
							<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key value=%d\r\n&quot;</span>, data);
					&#125;
				&#125;
				<span class="hljs-keyword">break</span>;
		&#125;	
	&#125;

	close(fd);
	<span class="hljs-keyword">return</span> ret;

&#125;</code></pre></div>

<p>前面注释的使用 poll 函数来实现非阻塞访问，在 while 循环中使用 poll 函数不断的轮询，检查驱动程序是否有数据可以读取，如果可以读取的话就调用 read 函数读取按键数据。</p>
<p>后面一段代码使用 select 函数来实现非阻塞访问。</p>
<h3 id="3-运行测试-1"><a href="#3-运行测试-1" class="headerlink" title="3|运行测试"></a>3|运行测试</h3><p>编译运行。</p>
<p>输入“top”命令，查看 noblockioAPP 这个应用 APP 的 CPU 使用率，如图 所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827124533321.png" srcset="/img/loading.gif" lazyload alt="image-20200827124533321"></p>
<p>可以看出，采用非阻塞方式读处理以后，noblockioApp 的 CPU 占用率也低至0.0%，和中的 blockioApp 一样，这里的 0.0%并不是说 noblockioApp 这个应用程序不使用 CPU 了，只是因为使用率太小了，而图中只能显示出小数点后一位，因此就显示成了0.0%。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/12/NOTE/ARM/ESP/1%E3%80%81esp-idf%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">1、esp-idf应用程序启动流程</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/11%E3%80%81%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">11| Linux异步通知实验</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
