

<!DOCTYPE html>
<html lang="zh-cn" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="firestaradmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Platform 设备驱动实验我们在前面几章编写的设备驱动都非常的简单，都是对IO进行最简单的读写操作。像I2C、SPI、LCD 等这些复杂外设的驱动就不能这么去写了，Linux 系统要考虑到驱动的可重用性，因此提出了驱动的分离与分层这样的软件思路，在这个思路下诞生了我们将来最常打交道的platform 设备驱动，也叫做平台设备驱动。本章我们就来学习一下 Linux 下的驱动分离与分层，以及 pl">
<meta property="og:type" content="article">
<meta property="og:title" content="12| Platform 设备驱动实验">
<meta property="og:url" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="firestaradmin&#39;s Fortune">
<meta property="og:description" content="Platform 设备驱动实验我们在前面几章编写的设备驱动都非常的简单，都是对IO进行最简单的读写操作。像I2C、SPI、LCD 等这些复杂外设的驱动就不能这么去写了，Linux 系统要考虑到驱动的可重用性，因此提出了驱动的分离与分层这样的软件思路，在这个思路下诞生了我们将来最常打交道的platform 设备驱动，也叫做平台设备驱动。本章我们就来学习一下 Linux 下的驱动分离与分层，以及 pl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144020801.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144129336.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144146616.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144329833.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828154257279.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828154439288.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828154419442.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828160111754.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828160034597.png">
<meta property="og:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828160050525.png">
<meta property="article:published_time" content="2020-09-11T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-11T16:00:00.000Z">
<meta property="article:author" content="firestaradmin">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144020801.png">
  
  
  <title>12| Platform 设备驱动实验 - firestaradmin&#39;s Fortune</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>firestaradmin&#39;s fortune</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页啦
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="12| Platform 设备驱动实验">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      firestaradmin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-12 00:00" pubdate>
        2020年9月12日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      32k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      271 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">12| Platform 设备驱动实验</h1>
            
            <div class="markdown-body">
              <h1 id="Platform-设备驱动实验"><a href="#Platform-设备驱动实验" class="headerlink" title="Platform 设备驱动实验"></a>Platform 设备驱动实验</h1><p>我们在前面几章编写的设备驱动都非常的简单，都是对IO进行最简单的读写操作。像I2C、SPI、LCD 等这些复杂外设的驱动就不能这么去写了，Linux 系统要考虑到驱动的可重用性，因此提出了驱动的分离与分层这样的软件思路，在这个思路下诞生了我们将来最常打交道的platform 设备驱动，也叫做平台设备驱动。本章我们就来学习一下 Linux 下的驱动分离与分层，以及 platform 框架下的设备驱动该如何编写。</p>
<h2 id="一、-Linux-驱动的分离与分层"><a href="#一、-Linux-驱动的分离与分层" class="headerlink" title="一、 Linux 驱动的分离与分层"></a>一、 Linux 驱动的分离与分层</h2><h3 id="驱动的分隔与分离"><a href="#驱动的分隔与分离" class="headerlink" title="驱动的分隔与分离"></a>驱动的分隔与分离</h3><p>对于 Linux 这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在 Linux 内核中存在大量无意义的重复代码。尤其是驱动程序，因为驱动程序占用了 Linux内核代码量的大头，如果不对驱动程序加以管理，任由重复的代码肆意增加，那么用不了多久Linux 内核的文件数量就庞大到无法接受的地步。</p>
<p>假如现在有三个平台 A、B 和 C，这三个平台(这里的平台说的是 SOC)上都有 MPU6050 这个I2C接口的六轴传感器，按照我们写裸机I2C驱动的时候的思路，每个平台都有一个MPU6050<br>的驱动，因此编写出来的最简单的驱动框架如图  所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144020801.png" srcset="/img/loading.gif" lazyload alt="image-20200828144020801"></p>
<p>从图可以看出，每种平台下都有一个主机驱动和设备驱动，主机驱动肯定是必须要的，毕竟不同的平台其 I2C 控制器不同。但是右侧的设备驱动就没必要每个平台都写一个，因为不管对于那个 SOC 来说，MPU6050 都是一样，通过 I2C 接口读写数据就行了，只需要一个MPU6050 的驱动程序即可。如果再来几个 I2C 设备，比如 AT24C02、FT5206(电容触摸屏)等，如果按照图  中的写法，那么设备端的驱动将会重复的编写好几次。显然在 Linux 驱动程序中这种写法是不推荐的，最好的做法就是每个平台的 I2C 控制器都提供一个统一的接口(也叫做主机驱动)，每个设备的话也只提供一个驱动程序(设备驱动)，每个设备通过统一的 I2C接口驱动来访问，这样就可以大大简化驱动文件，比如 三种平台下的 MPU6050 驱动框架就可以简化为图  所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144129336.png" srcset="/img/loading.gif" lazyload alt="image-20200828144129336"></p>
<p>实际的 I2C 驱动设备肯定有很多种，不止 MPU6050 这一个，那么实际的驱动架构如图所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144146616.png" srcset="/img/loading.gif" lazyload alt="image-20200828144146616"></p>
<p>这个就是驱动的分隔，也就是将主机驱动和设备驱动分隔开来，比如 I2C、SPI 等等都会采用驱动分隔的方式来简化驱动的开发。</p>
<p>在实际的驱动开发中，一般 I2C 主机控制器驱动已经由半导体厂家编写好了，而设备驱动一般也由设备器件的厂家编写好了，我们只需要提供设备信息即可，比如 I2C 设备的话提供设备连接到了哪个 I2C 接口上，I2C 的速度是多少等等。相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于驱动只负责驱动，设备只负责设备，想办法将两者进行匹配即可。这个就是 Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。总线就是驱动和设备信息的月老，负责给两者牵线搭桥，如图 所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144329833.png" srcset="/img/loading.gif" lazyload alt="image-20200828144329833"></p>
<p>当我们向系统注册一个驱动的时候，总线就会在右侧的设备中查找，看看有没有与之匹配的设备，如果有的话就将两者联系起来。同样的，当向系统中注册一个设备的时候，总线就会在左侧的驱动中查找看有没有与之匹配的设备，有的话也联系起来。Linux 内核中大量的驱动程序都采用总线、驱动和设备模式，我们一会要重点讲解的 platform 驱动就是这一思想下的产物。</p>
<h3 id="驱动的分层"><a href="#驱动的分层" class="headerlink" title="驱动的分层"></a>驱动的分层</h3><p>上一小节讲了驱动的分隔与分离，本节我们来简单看一下驱动的分层，大家应该听说过网络的 7 层模型，不同的层负责不同的内容。同样的，Linux 下的驱动往往也是分层的，分层的目的也是为了在不同的层处理不同的内容。以其他书籍或者资料常常使用到的input(输入子系统，后面会有专门的章节详细的讲解)为例，简单介绍一下驱动的分层。</p>
<p>input 子系统负责管理所有跟输入有关的驱动，包括键盘、鼠标、触摸等，最底层的就是设备原始驱动，负责获取输入设备的原始值，获取到的输入事件上报给 input 核心层。input 核心层会处理各种 IO 模型，并且提供 file_operations 操作集合。我们在编写输入设备驱动的时候只需要处理好输入事件的上报即可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。可以看出借助分层模型可以极大的简化我们的驱动编写，对于驱动编写来说非常的友好。</p>
<h2 id="二、platform-平台驱动模型简介"><a href="#二、platform-平台驱动模型简介" class="headerlink" title="二、platform  平台驱动模型简介"></a>二、platform  平台驱动模型简介</h2><p>前面我们讲了设备驱动的分离，并且引出了总线(bus)、驱动(driver)和设备(device)模型，比如 I2C、SPI、USB 等总线。但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？为了解决此问题，Linux 提出了 platform 这个虚拟总线，相应的就有 platform_driver 和 platform_device。</p>
<h3 id="1-platform总线"><a href="#1-platform总线" class="headerlink" title="1| platform总线"></a>1| platform总线</h3><p>Linux系统内核使用bus_type结构体表示总线，此结构体定义在文件include&#x2F;linux&#x2F;device.h，bus_type 结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> &#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">/* 总线名字 */</span>
<span class="hljs-number">3</span> 		<span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name;
<span class="hljs-number">4</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev_root</span>;</span>
<span class="hljs-number">5</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_attribute</span> *<span class="hljs-title">dev_attrs</span>;</span>
<span class="hljs-number">6</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">bus_groups</span>;</span> <span class="hljs-comment">/* 总线属性 */</span>
<span class="hljs-number">7</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">dev_groups</span>;</span> <span class="hljs-comment">/* 设备属性 */</span>
<span class="hljs-number">8</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">drv_groups</span>;</span> <span class="hljs-comment">/* 驱动属性 */</span>
<span class="hljs-number">9</span>
<span class="hljs-number">10</span> 		<span class="hljs-type">int</span> (*match)(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv);
<span class="hljs-number">11</span> 		<span class="hljs-type">int</span> (*uevent)(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> kobj_uevent_env *env);
<span class="hljs-number">12</span> 		<span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">13</span> 		<span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">14</span> 		<span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">15</span>
<span class="hljs-number">16</span> 		<span class="hljs-type">int</span> (*online)(<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">17</span> 		<span class="hljs-type">int</span> (*offline)(<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">18</span> 		<span class="hljs-type">int</span> (*suspend)(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">pm_message_t</span> state);
<span class="hljs-number">19</span> 		<span class="hljs-type">int</span> (*resume)(<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">20</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> *<span class="hljs-title">pm</span>;</span>
<span class="hljs-number">21</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iommu_ops</span> *<span class="hljs-title">iommu_ops</span>;</span>
<span class="hljs-number">22</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> *<span class="hljs-title">p</span>;</span>
<span class="hljs-number">23</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span> <span class="hljs-title">lock_key</span>;</span>
<span class="hljs-number">24</span> &#125;;</code></pre></div>

<p>第 10 行，match 函数，此函数很重要，单词 match 的意思就是“匹配、相配”，因此此函数就是完成设备和驱动之间匹配的，总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。match 函数有两个参数：dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。</p>
<hr>
<p>platform 总线是 bus_type 的一个具体实例，定义在文件 drivers&#x2F;base&#x2F;platform.c，platform 总线定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">platform_bus_type</span> =</span> &#123;
<span class="hljs-number">2</span> 		.name = <span class="hljs-string">&quot;platform&quot;</span>,
<span class="hljs-number">3</span> 		.dev_groups = platform_dev_groups,
<span class="hljs-number">4</span> 		.match = platform_match,
<span class="hljs-number">5</span> 		.uevent = platform_uevent,
<span class="hljs-number">6</span> 		.pm = &amp;platform_dev_pm_ops,
<span class="hljs-number">7</span> &#125;;</code></pre></div>

<p>platform_bus_type 就是 platform 平台总线，其中 platform_match 就是匹配函数。我们来看一下驱动和设备是如何匹配的，platform_match 函数定义在文件drivers&#x2F;base&#x2F;platform.c 中，函数内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">platform_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span>
2 &#123;
<span class="hljs-number">3</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">pdev</span> =</span> to_platform_device(dev);
<span class="hljs-number">4</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> *<span class="hljs-title">pdrv</span> =</span> to_platform_driver(drv);
<span class="hljs-number">5</span>
<span class="hljs-number">6</span> 		<span class="hljs-comment">/*When driver_override is set,only bind to the matching driver*/</span>
<span class="hljs-number">7</span> 		<span class="hljs-keyword">if</span> (pdev-&gt;driver_override)
<span class="hljs-number">8</span> 			<span class="hljs-keyword">return</span> !<span class="hljs-built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);
<span class="hljs-number">9</span>
<span class="hljs-number">10</span> 		<span class="hljs-comment">/* Attempt an OF style match first */</span>
<span class="hljs-number">11</span> 		<span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))
<span class="hljs-number">12</span> 			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
<span class="hljs-number">13</span>
<span class="hljs-number">14</span> 		<span class="hljs-comment">/* Then try ACPI style match */</span>
<span class="hljs-number">15</span> 		<span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))
<span class="hljs-number">16</span> 			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
<span class="hljs-number">17</span>
<span class="hljs-number">18</span> 		<span class="hljs-comment">/* Then try to match against the id table */</span>
<span class="hljs-number">19</span> 		<span class="hljs-keyword">if</span> (pdrv-&gt;id_table)
<span class="hljs-number">20</span> 			<span class="hljs-keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="hljs-literal">NULL</span>;
<span class="hljs-number">21</span>
<span class="hljs-number">22</span> 		<span class="hljs-comment">/* fall-back to driver name match */</span>
<span class="hljs-number">23</span> 		<span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="hljs-number">0</span>);
<span class="hljs-number">24</span> &#125;</code></pre></div>

<p>驱动和设备的匹配有四种方法，我们依次来看一下：</p>
<p>第 11~12 行，第一种匹配方式， OF 类型的匹配，也就是设备树采用的匹配方式，of_driver_match_device 函数定义在文件 include&#x2F;linux&#x2F;of_device.h 中。device_driver 结构体(表示设备驱动)中有个名为of_match_table的成员变量，此成员变量保存着驱动的compatible匹配表，设备树中的每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较，查看是否有相同的条目，如果有的话就表示设备和此驱动匹配，设备和驱动匹配成功以后 probe 函数就会执行。</p>
<p>第 15~16 行，第二种匹配方式，ACPI 匹配方式。</p>
<p>第 19~20 行，第三种匹配方式，id_table 匹配，每个 platform_driver 结构体有一个 id_table成员变量，顾名思义，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱动类型。</p>
<p>第 23 行，第四种匹配方式，如果第三种匹配方式的 id_table 不存在的话就直接比较驱动和设备的 name 字段，看看是不是相等，如果相等的话就匹配成功。</p>
<p>对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了.</p>
<h3 id="2-platform驱动"><a href="#2-platform驱动" class="headerlink" title="2| platform驱动"></a>2| platform驱动</h3><p>platform_driver 结 构 体 表 示 platform 驱 动 ， 此 结 构 体 定 义 在 文 件include&#x2F;linux&#x2F;platform_device.h 中，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> &#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> platform_device *);
<span class="hljs-number">3</span> 		<span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> platform_device *);
<span class="hljs-number">4</span> 		<span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> platform_device *);
<span class="hljs-number">5</span> 		<span class="hljs-type">int</span> (*suspend)(<span class="hljs-keyword">struct</span> platform_device *, <span class="hljs-type">pm_message_t</span> state);
<span class="hljs-number">6</span> 		<span class="hljs-type">int</span> (*resume)(<span class="hljs-keyword">struct</span> platform_device *);
<span class="hljs-number">7</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span>
<span class="hljs-number">8</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> *<span class="hljs-title">id_table</span>;</span>
<span class="hljs-number">9</span> 		<span class="hljs-type">bool</span> prevent_deferred_probe;
<span class="hljs-number">10</span> &#125;;</code></pre></div>

<p>第 2 行，probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行，非常重要的函数！！一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。</p>
<p>第 7 行，driver 成员，为 device_driver 结构体变量，Linux 内核里面大量使用到了面向对象的思维，device_driver 相当于基类，提供了最基础的驱动框架。plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。</p>
<p>第 8 行，id_table 表，也就是我们上一小节讲解 platform 总线匹配驱动和设备的时候采用的第三种方法，id_table 是个表(也就是数组)，每个元素的类型为 platform_device_id，platform_device_id 结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> &#123;</span>
<span class="hljs-number">2</span> 	<span class="hljs-type">char</span> name[PLATFORM_NAME_SIZE];
<span class="hljs-number">3</span> 	<span class="hljs-type">kernel_ulong_t</span> driver_data;
<span class="hljs-number">4</span> &#125;;</code></pre></div>

<hr>
<p>device_driver 结构体定义在 include&#x2F;linux&#x2F;device.h，device_driver 结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> &#123;</span>
<span class="hljs-number">2</span> 	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;
<span class="hljs-number">3</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> *<span class="hljs-title">bus</span>;</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span>
<span class="hljs-number">6</span> 	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *mod_name; <span class="hljs-comment">/* used for built-in modules */</span>
<span class="hljs-number">7</span>
<span class="hljs-number">8</span> 	<span class="hljs-type">bool</span> suppress_bind_attrs; <span class="hljs-comment">/* disables bind/unbind via sysfs */</span>
<span class="hljs-number">9</span>
<span class="hljs-number">10</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">of_match_table</span>;</span>
<span class="hljs-number">11</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">acpi_device_id</span> *<span class="hljs-title">acpi_match_table</span>;</span>
<span class="hljs-number">12</span>
<span class="hljs-number">13</span> 	<span class="hljs-type">int</span> (*probe) (<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">14</span> 	<span class="hljs-type">int</span> (*remove) (<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">15</span> 	<span class="hljs-type">void</span> (*shutdown) (<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">16</span> 	<span class="hljs-type">int</span> (*suspend) (<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">pm_message_t</span> state);
<span class="hljs-number">17</span> 	<span class="hljs-type">int</span> (*resume) (<span class="hljs-keyword">struct</span> device *dev);
<span class="hljs-number">18</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span>
<span class="hljs-number">19</span>
<span class="hljs-number">20</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> *<span class="hljs-title">pm</span>;</span>
<span class="hljs-number">21</span>
<span class="hljs-number">22</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">driver_private</span> *<span class="hljs-title">p</span>;</span>
<span class="hljs-number">23</span> &#125;;</code></pre></div>

<p>第 10 行，of_match_table 就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型，此结构体定义在文件 include&#x2F;linux&#x2F;mod_devicetable.h 中，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> &#123;</span>
<span class="hljs-number">2</span> 	<span class="hljs-type">char</span> name[<span class="hljs-number">32</span>];
<span class="hljs-number">3</span> 	<span class="hljs-type">char</span> type[<span class="hljs-number">32</span>];
<span class="hljs-number">4</span> 	<span class="hljs-type">char</span> compatible[<span class="hljs-number">128</span>];
<span class="hljs-number">5</span> 	<span class="hljs-type">const</span> <span class="hljs-type">void</span> *data;
<span class="hljs-number">6</span> &#125;;</code></pre></div>

<p>第 4 行的 compatible 非常重要，因为对于设备树而言，就是通过设备节点的 compatible 属性值和 of_match_table 中每个项目的 compatible 成员变量进行比较，如果有相等的就表示设备和此驱动匹配成功。</p>
<p>在编写 platform 驱动的时候，首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量，重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等。当我们定义并初始化好 platform_driver 结构体变量以后，需要在驱动入口函数里面调用platform_driver_register 函数向 Linux 内核注册一个 platform 驱动，platform_driver_register 函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_driver_register</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *driver)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>driver</strong>：要注册的 platform 驱动。<br><strong>返回值</strong>：负数，失败；0，成功。</p>
<p>还需要在驱动卸载函数中通过 platform_driver_unregister 函数卸载 platform 驱动，platform_driver_unregister 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_driver_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *drv)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>drv</strong>：要卸载的 platform 驱动。<br><strong>返回值</strong>：无。</p>
<p>platform 驱动框架如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 设备结构体 */</span>
<span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span>&#123;</span>
<span class="hljs-number">2</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>
<span class="hljs-number">3</span> 		<span class="hljs-comment">/* 设备结构体其他具体内容 */</span>
<span class="hljs-number">4</span> &#125;;
<span class="hljs-number">5</span>
<span class="hljs-number">6</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> <span class="hljs-title">xxxdev</span>;</span> <span class="hljs-comment">/* 定义个设备结构体变量 */</span>
<span class="hljs-number">7</span>
<span class="hljs-number">8</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
9 &#123;
<span class="hljs-number">10</span> 		<span class="hljs-comment">/* 函数具体内容 */</span>
<span class="hljs-number">11</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">12</span> &#125;
<span class="hljs-number">13</span>
<span class="hljs-number">14</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">xxx_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
15 &#123;
<span class="hljs-number">16</span> 		<span class="hljs-comment">/* 函数具体内容 */</span>
<span class="hljs-number">17</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">18</span> &#125;
<span class="hljs-number">19</span>
<span class="hljs-number">20</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">21 * 字符设备驱动操作集</span>
<span class="hljs-comment">22 */</span>
<span class="hljs-number">23</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">xxx_fops</span> =</span> &#123;
<span class="hljs-number">24</span> 		.owner = THIS_MODULE,
<span class="hljs-number">25</span> 		.open = xxx_open,
<span class="hljs-number">26</span> 		.write = xxx_write,
<span class="hljs-number">27</span> &#125;;
<span class="hljs-number">28</span>
<span class="hljs-number">29</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">30 * platform 驱动的 probe 函数</span>
<span class="hljs-comment">31 * 驱动与设备匹配成功以后此函数就会执行</span>
<span class="hljs-comment">32 */</span>
<span class="hljs-number">33</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>
34 &#123;
<span class="hljs-number">35</span> 		......
<span class="hljs-number">36</span> 		cdev_init(&amp;xxxdev.cdev, &amp;xxx_fops); <span class="hljs-comment">/* 注册字符设备驱动 */</span>
<span class="hljs-number">37</span> 		<span class="hljs-comment">/* 函数具体内容 */</span>
<span class="hljs-number">38</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">39</span> &#125;
<span class="hljs-number">40</span>
<span class="hljs-number">41</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>
42 &#123;
<span class="hljs-number">43</span> 		......
<span class="hljs-number">44</span> 		cdev_del(&amp;xxxdev.cdev);<span class="hljs-comment">/* 删除 cdev */</span>
<span class="hljs-number">45</span> 		<span class="hljs-comment">/* 函数具体内容 */</span>
<span class="hljs-number">46</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-number">47</span> &#125;
<span class="hljs-number">48</span>
<span class="hljs-number">49</span> <span class="hljs-comment">/* 匹配列表 */</span>
<span class="hljs-number">50</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;
<span class="hljs-number">51</span> 		&#123; .compatible = <span class="hljs-string">&quot;xxx-gpio&quot;</span> &#125;,
<span class="hljs-number">52</span> 		&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;
<span class="hljs-number">53</span> &#125;;
<span class="hljs-number">54</span>
<span class="hljs-number">55</span> <span class="hljs-comment">/*</span>
<span class="hljs-comment">56 * platform 平台驱动结构体</span>
<span class="hljs-comment">57 */</span>
<span class="hljs-number">58</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">xxx_driver</span> =</span> &#123;
<span class="hljs-number">59</span> 		.driver = &#123;
<span class="hljs-number">60</span> 			.name = <span class="hljs-string">&quot;xxx&quot;</span>,
<span class="hljs-number">61</span> 			.of_match_table = xxx_of_match,
<span class="hljs-number">62</span> 		&#125;,
<span class="hljs-number">63</span> 		.probe = xxx_probe,
<span class="hljs-number">64</span> 		.remove = xxx_remove,
<span class="hljs-number">65</span> &#125;;
<span class="hljs-number">66</span>
<span class="hljs-number">67</span> <span class="hljs-comment">/* 驱动模块加载 */</span>
<span class="hljs-number">68</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxdriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
69 &#123;
<span class="hljs-number">70</span> 		<span class="hljs-keyword">return</span> platform_driver_register(&amp;xxx_driver);
<span class="hljs-number">71</span> &#125;
<span class="hljs-number">72</span>
<span class="hljs-number">73</span> <span class="hljs-comment">/* 驱动模块卸载 */</span>
<span class="hljs-number">74</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxxdriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
75 &#123;
<span class="hljs-number">76</span> 		platform_driver_unregister(&amp;xxx_driver);
<span class="hljs-number">77</span> &#125;
<span class="hljs-number">78</span>
<span class="hljs-number">79</span> module_init(xxxdriver_init);
<span class="hljs-number">80</span> module_exit(xxxdriver_exit);
<span class="hljs-number">81</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-number">82</span> MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>第 1~27 行，传统的字符设备驱动，所谓的 platform 驱动并不是独立于字符设备驱动、块设备驱动和网络设备驱动之外的其他种类的驱动。platform 只是为了驱动的分离与分层而提出来的一种框架，其驱动的具体实现还是需要字符设备驱动、块设备驱动或网络设备驱动。</p>
<p>第 33~39 行，xxx_probe 函数，当驱动和设备匹配成功以后此函数就会执行，以前在驱动入口 init 函数里面编写的字符设备驱动程序就全部放到此 probe 函数里面。比如注册字符设备<br>驱动、添加 cdev、创建类等等。</p>
<p>第 41~47 行，xxx_remove 函数，platform_driver 结构体中的 remove 成员变量，当关闭platform备驱动的时候此函数就会执行，以前在驱动卸载 exit 函数里面要做的事情就放到此函数中来。比如，使用 iounmap 释放内存、删除 cdev，注销设备号等等。</p>
<p>第 50~53 行，xxx_of_match 匹配表，如果使用设备树的话将通过此匹配表进行驱动和设备的匹配。第 51 行设置了一个匹配项，此匹配项的 compatible 值为“xxx-gpio”，因此当设备树中设备节点的 compatible 属性值为“xxx-gpio”的时候此设备就会与此驱动匹配。第 52 行是一个标记，of_device_id 表最后一个匹配项必须是空的。</p>
<p>第 58<del>65 行，定义一个 platform_driver 结构体变量 xxx_driver，表示 platform 驱动，第 59</del>62行设置 paltform_driver 中的 device_driver 成员变量的 name 和 of_match_table 这两个属性。其中name 属性用于传统的驱动与设备匹配，也就是检查驱动和设备的 name 字段是不是相同。of_match_table 属性就是用于设备树下的驱动与设备检查。对于一个完整的驱动程序，必须提供有设备树和无设备树两种匹配方法。最后 63 和 64 这两行设置 probe 和 remove 这两成员变量。</p>
<p>第68~71行，驱动入口函数，调用platform_driver_register函数向Linux内核注册一个platform驱动，也就是上面定义的 xxx_driver 结构体变量。</p>
<p>第 74~77 行，驱动出口函数，调用 platform_driver_unregister 函数卸载前面注册的 platform驱动。</p>
<p>总体来说，platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，只是套<br>上了一张“platform”的皮，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分<br>离与分层。</p>
<h3 id="3-platform设备"><a href="#3-platform设备" class="headerlink" title="3| platform设备"></a>3| platform设备</h3><p>platform 驱动已经准备好了，我们还需要 platform 设备，否则的话单单一个驱动也做不了什么。platform_device 这个结构体表示 platform 设备，这里我们要注意，如果内核支持设备树的话就不要再使用 platform_device 来描述设备了，因为改用设备树去描述了。当然了，你如果一定要用 platform_device 来描述设备信息的话也是可以的。platform_device 结构体定义在文件include&#x2F;linux&#x2F;platform_device.h 中，结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">22</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> &#123;</span>
<span class="hljs-number">23</span> 		<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;
<span class="hljs-number">24</span> 		<span class="hljs-type">int</span> id;
<span class="hljs-number">25</span> 		<span class="hljs-type">bool</span> id_auto;
<span class="hljs-number">26</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>
<span class="hljs-number">27</span> 		u32 num_resources;
<span class="hljs-number">28</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">resource</span>;</span>
<span class="hljs-number">29</span>
<span class="hljs-number">30</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> *<span class="hljs-title">id_entry</span>;</span>
<span class="hljs-number">31</span> 		<span class="hljs-type">char</span> *driver_override; <span class="hljs-comment">/* Driver name to force a match */</span>
<span class="hljs-number">32</span>
<span class="hljs-number">33</span> 		<span class="hljs-comment">/* MFD cell pointer */</span>
<span class="hljs-number">34</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mfd_cell</span> *<span class="hljs-title">mfd_cell</span>;</span>
<span class="hljs-number">35</span>
<span class="hljs-number">36</span> 		<span class="hljs-comment">/* arch specific additions */</span>
<span class="hljs-number">37</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pdev_archdata</span> <span class="hljs-title">archdata</span>;</span>
<span class="hljs-number">38</span> &#125;;</code></pre></div>

<p>第 23 行，name 表示设备名字，要和所使用的 platform 驱动的 name 字段相同，否则的话设备就无法匹配到对应的驱动。比如对应的 platform 驱动的 name 字段为“xxx-gpio”，那么此 name字段也要设置为“xxx-gpio”。</p>
<p>第 27 行，num_resources 表示资源数量，一般为第 28 行 resource 资源的大小。</p>
<p>第 28 行，resource 表示资源，也就是设备信息，比如外设寄存器等。Linux 内核使用resource结构体表示资源，resource 结构体内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">18</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> &#123;</span>
<span class="hljs-number">19</span> 		<span class="hljs-type">resource_size_t</span> start;
<span class="hljs-number">20</span> 		<span class="hljs-type">resource_size_t</span> end;
<span class="hljs-number">21</span> 		<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;
<span class="hljs-number">22</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;
<span class="hljs-number">23</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">parent</span>, *<span class="hljs-title">sibling</span>, *<span class="hljs-title">child</span>;</span>
<span class="hljs-number">24</span> &#125;;</code></pre></div>

<p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name 表示资源名字，flags 表示资源类型，可选的资源类型都定义在了文件include&#x2F;linux&#x2F;ioport.h 里面，如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">29</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BITS 			0x000000ff <span class="hljs-comment">/* Bus-specific bits */</span></span>
<span class="hljs-number">30</span>
<span class="hljs-number">31</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_TYPE_BITS  	0x00001f00 <span class="hljs-comment">/* Resource type */</span></span>
<span class="hljs-number">32</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IO 			0x00000100 <span class="hljs-comment">/* PCI/ISA I/O ports */</span></span>
<span class="hljs-number">33</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM 			0x00000200</span>
<span class="hljs-number">34</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_REG 			0x00000300 <span class="hljs-comment">/* Register offsets */</span></span>
<span class="hljs-number">35</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IRQ 			0x00000400</span>
<span class="hljs-number">36</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DMA 			0x00000800</span>
<span class="hljs-number">37</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUS 			0x00001000</span>
......
<span class="hljs-number">104</span> <span class="hljs-comment">/* PCI control bits. Shares IORESOURCE_BITS with above PCI ROM. */</span>
<span class="hljs-number">105</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_PCI_FIXED (1&lt;&lt;4) <span class="hljs-comment">/* Do not move resource */</span></span></code></pre></div>

<p>在以前不支持设备树的Linux版本中，用户需要编写platform_device变量来描述设备信息，然后使用 platform_device_register 函数将设备信息注册到 Linux 内核中，此函数原型如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_device_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>pdev</strong>：要注册的 platform 设备。<br><strong>返回值</strong>：负数，失败；0，成功。</p>
<p>如果不再使用 platform 的话可以通过 platform_device_unregister 函数注销掉相应的platform设备，platform_device_unregister 函数原型如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_device_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></code></pre></div>

<p>函数参数和返回值含义如下：<br><strong>pdev</strong>：要注销的 platform 设备。<br><strong>返回值</strong>：无。</p>
<p>platform 设备信息框架如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 寄存器地址定义*/</span>
<span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH1_REGISTER_BASE (0X20000000) <span class="hljs-comment">/* 外设 1 寄存器首地址 */</span></span>
<span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH2_REGISTER_BASE (0X020E0068) <span class="hljs-comment">/* 外设 2 寄存器首地址 */</span></span>
<span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_LENGTH 4</span>
<span class="hljs-number">5</span>
<span class="hljs-number">6</span> <span class="hljs-comment">/* 资源 */</span>
<span class="hljs-number">7</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> <span class="hljs-title">xxx_resources</span>[] =</span> &#123;
<span class="hljs-number">8</span> 		[<span class="hljs-number">0</span>] = &#123;
<span class="hljs-number">9</span> 			.start = PERIPH1_REGISTER_BASE,
<span class="hljs-number">10</span> 			.end = (PERIPH1_REGISTER_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),
<span class="hljs-number">11</span> 			.flags = IORESOURCE_MEM,
<span class="hljs-number">12</span> 		&#125;,
<span class="hljs-number">13</span> 		[<span class="hljs-number">1</span>] = &#123;
<span class="hljs-number">14</span> 			.start = PERIPH2_REGISTER_BASE,
<span class="hljs-number">15</span> 			.end = (PERIPH2_REGISTER_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),
<span class="hljs-number">16</span> 			.flags = IORESOURCE_MEM,
<span class="hljs-number">17</span> 		&#125;,
<span class="hljs-number">18</span> &#125;;
<span class="hljs-number">19</span>
<span class="hljs-number">20</span> <span class="hljs-comment">/* platform 设备结构体 */</span>
<span class="hljs-number">21</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">xxxdevice</span> =</span> &#123;
<span class="hljs-number">22</span> 		.name = <span class="hljs-string">&quot;xxx-gpio&quot;</span>,
<span class="hljs-number">23</span> 		.id = <span class="hljs-number">-1</span>,
<span class="hljs-number">24</span> 		.num_resources = ARRAY_SIZE(xxx_resources),
<span class="hljs-number">25</span> 		.resource = xxx_resources,
<span class="hljs-number">26</span> &#125;;
<span class="hljs-number">27</span>
<span class="hljs-number">28</span> <span class="hljs-comment">/* 设备模块加载 */</span>
<span class="hljs-number">29</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxdevice_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
30 &#123;
<span class="hljs-number">31</span> 		<span class="hljs-keyword">return</span> platform_device_register(&amp;xxxdevice);
<span class="hljs-number">32</span> &#125;
<span class="hljs-number">33</span>
<span class="hljs-number">34</span> <span class="hljs-comment">/* 设备模块注销 */</span>
<span class="hljs-number">35</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_resourcesdevice_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
36 &#123;
<span class="hljs-number">37</span> 		platform_device_unregister(&amp;xxxdevice);
<span class="hljs-number">38</span> &#125;
<span class="hljs-number">39</span>
<span class="hljs-number">40</span> module_init(xxxdevice_init);
<span class="hljs-number">41</span> module_exit(xxxdevice_exit);
<span class="hljs-number">42</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
<span class="hljs-number">43</span> MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>第 7~18 行，数组 xxx_resources 表示设备资源，一共有两个资源，分别为设备外设 1 和外设 2 的寄存器信息。因此 flags 都为 IORESOURCE_MEM，表示资源为内存类型的。</p>
<p>第 21~26 行，platform 设备结构体变量，注意 name 字段要和所使用的驱动中的 name 字段一致，否则驱动和设备无法匹配成功。num_resources 表示资源大小，其实就是数组 xxx_resources的元素数量，这里用 ARRAY_SIZE 来测量一个数组的元素个数。</p>
<p>第 29~32 行，设备模块加载函数，在此函数中调用 platform_device_register 向 Linux 内核注册 platform 设备。</p>
<p>第 35~38 行，设备模块卸载函数，在此函数中调用 platform_device_unregister 从 Linux 内核中卸载 platform 设备。</p>
<p>示例代码 主要是在不支持设备树的 Linux 版本中使用的，当 Linux 内核支持了设备树以后就不需要用户手动去注册 platform 设备了。因为设备信息都放到了设备树中去描述，Linux 内核启动的时候会从设备树中读取设备信息，然后将其组织成 platform_device 形式，至于设备树到 platform_device 的具体过程就不去详细的追究了，感兴趣的可以去看一下，网上也有很多博客详细的讲解了整个过程。</p>
<p>关于 platform 下的总线、驱动和设备就讲解到这里，我们接下来就使用 platform 驱动框架来编写一个 LED 灯驱动，本章我们不使用设备树来描述设备信息，我们采用自定义platform_device这种“古老”方式来编写LED的设备信息。下一章我们来编写设备树下的platform驱动，这样我们就掌握了无设备树和有设备树这两种 platform 驱动的开发方式。</p>
<h2 id="三、‘古老的’-platform驱动开发方式（无设备树）"><a href="#三、‘古老的’-platform驱动开发方式（无设备树）" class="headerlink" title="三、‘古老的’ platform驱动开发方式（无设备树）"></a>三、‘古老的’ platform驱动开发方式（无设备树）</h2><p>我们需要编写一个驱动模块和一个设备模块，其中驱动模块是 platform 驱动程序，设备模块是 platform 的设备信息。当这两个模块都加载成功以后就会匹配成功，然后 platform驱动模块中的 probe 函数就会执行，probe 函数中就是传统的字符设备驱动那一套。</p>
<h3 id="1-platform-设备与驱动程序编写"><a href="#1-platform-设备与驱动程序编写" class="headerlink" title="1| platform 设备与驱动程序编写"></a>1| platform 设备与驱动程序编写</h3><p>新建名为“17_platform”的文件夹，然后在 17_platform 文件夹里面创建 vscode 工程，工作<br>区命名为“platform”。新建名为 leddevice.c 和 leddriver.c 这两个文件，这两个文件分别为LED灯的 platform 设备文件和 LED 灯的 platform 的驱动文件。在 leddevice.c 中输入如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span>


<span class="hljs-comment">/* </span>
<span class="hljs-comment"> * 寄存器地址定义</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_CCGR1_BASE				(0X020C406C)	</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_MUX_GPIO1_IO03_BASE		(0X020E0068)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_PAD_GPIO1_IO03_BASE		(0X020E02F4)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_DR_BASE				(0X0209C000)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_GDIR_BASE				(0X0209C004)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_LENGTH				4</span>

<span class="hljs-comment">/* @description		: 释放flatform设备模块的时候此函数会执行	</span>
<span class="hljs-comment"> * @param - dev 	: 要释放的设备 </span>
<span class="hljs-comment"> * @return 			: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span>	<span class="hljs-title function_">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span>
&#123;
	printk(<span class="hljs-string">&quot;k:led device released!\r\n&quot;</span>);	
&#125;

<span class="hljs-comment">/*  </span>
<span class="hljs-comment"> * 设备资源信息，也就是LED0所使用的所有寄存器</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> <span class="hljs-title">led_resources</span>[] =</span> &#123;
	[<span class="hljs-number">0</span>] = &#123;
		.start 	= CCM_CCGR1_BASE,
		.end 	= (CCM_CCGR1_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),
		.flags 	= IORESOURCE_MEM,
	&#125;,	
	[<span class="hljs-number">1</span>] = &#123;
		.start	= SW_MUX_GPIO1_IO03_BASE,
		.end	= (SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),
		.flags	= IORESOURCE_MEM,
	&#125;,
	[<span class="hljs-number">2</span>] = &#123;
		.start	= SW_PAD_GPIO1_IO03_BASE,
		.end	= (SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),
		.flags	= IORESOURCE_MEM,
	&#125;,
	[<span class="hljs-number">3</span>] = &#123;
		.start	= GPIO1_DR_BASE,
		.end	= (GPIO1_DR_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),
		.flags	= IORESOURCE_MEM,
	&#125;,
	[<span class="hljs-number">4</span>] = &#123;
		.start	= GPIO1_GDIR_BASE,
		.end	= (GPIO1_GDIR_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),
		.flags	= IORESOURCE_MEM,
	&#125;,
&#125;;


<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * platform设备结构体 </span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">leddevice</span> =</span> &#123;
	.name = <span class="hljs-string">&quot;imx6ul-led&quot;</span>,
	.id = <span class="hljs-number">-1</span>,
	.dev = &#123;
		.release = &amp;led_release,
	&#125;,
	.num_resources = ARRAY_SIZE(led_resources),
	.resource = led_resources,
&#125;;
		
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 设备模块加载 </span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddevice_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-keyword">return</span> platform_device_register(&amp;leddevice);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 设备模块注销</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddevice_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	platform_device_unregister(&amp;leddevice);
&#125;

module_init(leddevice_init);
module_exit(leddevice_exit);
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>leddevice.c 文件内容就是按照示例代码  platform 设备模板编写的。</p>
<p>第 56~82 行，led_resources 数组，也就是设备资源，描述了 LED 所要使用到的寄存器信息，也就是 IORESOURCE_MEM 资源。</p>
<p>第 88~96，platform 设备结构体变量 leddevice，这里要注意 name 字段为“imx6ul-led”，所以稍后编写 platform 驱动中的 name 字段也要为“imx6ul-led”，否则设备和驱动匹配失败。</p>
<p>第 103~106 行，设备模块加载函数，在此函数里面通过 platform_device_register 向 Linux 内核注册 leddevice 这个 platform 设备。</p>
<p>第 113~116 行，设备模块卸载函数，在此函数里面通过 platform_device_unregister 从 Linux内核中删除掉 leddevice 这个 platform 设备。</p>
<p>leddevice.c 文件编写完成以后就编写 leddriver.c 这个 platform 驱动文件，在 leddriver.c 里<br>面输入如下内容:</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_CNT		1			<span class="hljs-comment">/* 设备号长度 	*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_NAME		<span class="hljs-string">&quot;platled&quot;</span>	<span class="hljs-comment">/* 设备名字 	*/</span></span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 			0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 			1</span>

<span class="hljs-comment">/* 寄存器名 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *IMX6U_CCM_CCGR1;
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_MUX_GPIO1_IO03;
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_PAD_GPIO1_IO03;
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_DR;
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_GDIR;

<span class="hljs-comment">/* leddev设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span>&#123;</span>
	<span class="hljs-type">dev_t</span> devid;			<span class="hljs-comment">/* 设备号	*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>		<span class="hljs-comment">/* cdev		*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>	<span class="hljs-comment">/* 类 		*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>	<span class="hljs-comment">/* 设备		*/</span>
	<span class="hljs-type">int</span> major;				<span class="hljs-comment">/* 主设备号	*/</span>		
&#125;;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span> <span class="hljs-title">leddev</span>;</span> 	<span class="hljs-comment">/* led设备 */</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: LED打开/关闭</span>
<span class="hljs-comment"> * @param - sta 	: LEDON(0) 打开LED，LEDOFF(1) 关闭LED</span>
<span class="hljs-comment"> * @return 			: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">led0_switch</span><span class="hljs-params">(u8 sta)</span>
&#123;
	u32 val = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(sta == LEDON)&#123;
		val = readl(GPIO1_DR);
		val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);	
		writel(val, GPIO1_DR);
	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sta == LEDOFF)&#123;
		val = readl(GPIO1_DR);
		val|= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);	
		writel(val, GPIO1_DR);
	&#125;	
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 打开设备</span>
<span class="hljs-comment"> * @param - inode 	: 传递给驱动的inode</span>
<span class="hljs-comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span>
<span class="hljs-comment"> * 					  一般在open的时候将private_data指向设备结构体。</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	filp-&gt;private_data = &amp;leddev; <span class="hljs-comment">/* 设置私有数据  */</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 向设备写数据 </span>
<span class="hljs-comment"> * @param - filp 	: 设备文件，表示打开的文件描述符</span>
<span class="hljs-comment"> * @param - buf 	: 要写给设备写入的数据</span>
<span class="hljs-comment"> * @param - cnt 	: 要写入的数据长度</span>
<span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span>
<span class="hljs-comment"> * @return 			: 写入的字节数，如果为负值，表示写入失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-type">int</span> retvalue;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">1</span>];
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;

	retvalue = copy_from_user(databuf, buf, cnt);
	<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">return</span> -EFAULT;
	&#125;

	ledstat = databuf[<span class="hljs-number">0</span>];		<span class="hljs-comment">/* 获取状态值 */</span>
	<span class="hljs-keyword">if</span>(ledstat == LEDON) &#123;
		led0_switch(LEDON);		<span class="hljs-comment">/* 打开LED灯 */</span>
	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ledstat == LEDOFF) &#123;
		led0_switch(LEDOFF);	<span class="hljs-comment">/* 关闭LED灯 */</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* 设备操作函数 */</span>
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.open = led_open,
	.write = led_write,
&#125;;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: flatform驱动的probe函数，当驱动与设备匹配以后此函数就会执行</span>
<span class="hljs-comment"> * @param - dev 	: platform设备</span>
<span class="hljs-comment"> * @return 			: 0，成功;其他负值,失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>
&#123;	
	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> ressize[<span class="hljs-number">5</span>];
	u32 val = <span class="hljs-number">0</span>;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">ledsource</span>[5];</span>

	printk(<span class="hljs-string">&quot;k:led driver and device has matched!\r\n&quot;</span>);
	<span class="hljs-comment">/* 1、获取资源 */</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
		ledsource[i] = platform_get_resource(dev, IORESOURCE_MEM, i); <span class="hljs-comment">/* 依次MEM类型资源 */</span>
		<span class="hljs-keyword">if</span> (!ledsource[i]) &#123;
			dev_err(&amp;dev-&gt;dev, <span class="hljs-string">&quot;No MEM resource for always on\n&quot;</span>);
			<span class="hljs-keyword">return</span> -ENXIO;
		&#125;
		ressize[i] = resource_size(ledsource[i]);	
	&#125;	

	<span class="hljs-comment">/* 2、初始化LED */</span>
	<span class="hljs-comment">/* 寄存器地址映射 */</span>
 	IMX6U_CCM_CCGR1 = ioremap(ledsource[<span class="hljs-number">0</span>]-&gt;start, ressize[<span class="hljs-number">0</span>]);
	SW_MUX_GPIO1_IO03 = ioremap(ledsource[<span class="hljs-number">1</span>]-&gt;start, ressize[<span class="hljs-number">1</span>]);
  	SW_PAD_GPIO1_IO03 = ioremap(ledsource[<span class="hljs-number">2</span>]-&gt;start, ressize[<span class="hljs-number">2</span>]);
	GPIO1_DR = ioremap(ledsource[<span class="hljs-number">3</span>]-&gt;start, ressize[<span class="hljs-number">3</span>]);
	GPIO1_GDIR = ioremap(ledsource[<span class="hljs-number">4</span>]-&gt;start, ressize[<span class="hljs-number">4</span>]);
	
	val = readl(IMX6U_CCM_CCGR1);
	val &amp;= ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);				<span class="hljs-comment">/* 清除以前的设置 */</span>
	val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);				<span class="hljs-comment">/* 设置新值 */</span>
	writel(val, IMX6U_CCM_CCGR1);

	<span class="hljs-comment">/* 设置GPIO1_IO03复用功能，将其复用为GPIO1_IO03 */</span>
	writel(<span class="hljs-number">5</span>, SW_MUX_GPIO1_IO03);
	writel(<span class="hljs-number">0x10B0</span>, SW_PAD_GPIO1_IO03);

	<span class="hljs-comment">/* 设置GPIO1_IO03为输出功能 */</span>
	val = readl(GPIO1_GDIR);
	val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);			<span class="hljs-comment">/* 清除以前的设置 */</span>
	val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);			<span class="hljs-comment">/* 设置为输出 */</span>
	writel(val, GPIO1_GDIR);

	<span class="hljs-comment">/* 默认关闭LED1 */</span>
	val = readl(GPIO1_DR);
	val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>) ;	
	writel(val, GPIO1_DR);
	
	<span class="hljs-comment">/* 注册字符设备驱动 */</span>
	<span class="hljs-comment">/*1、创建设备号 */</span>
	<span class="hljs-keyword">if</span> (leddev.major) &#123;		<span class="hljs-comment">/*  定义了设备号 */</span>
		leddev.devid = MKDEV(leddev.major, <span class="hljs-number">0</span>);
		register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);
	&#125; <span class="hljs-keyword">else</span> &#123;						<span class="hljs-comment">/* 没有定义设备号 */</span>
		alloc_chrdev_region(&amp;leddev.devid, <span class="hljs-number">0</span>, LEDDEV_CNT, LEDDEV_NAME);	<span class="hljs-comment">/* 申请设备号 */</span>
		leddev.major = MAJOR(leddev.devid);	<span class="hljs-comment">/* 获取分配号的主设备号 */</span>
	&#125;
	
	<span class="hljs-comment">/* 2、初始化cdev */</span>
	leddev.cdev.owner = THIS_MODULE;
	cdev_init(&amp;leddev.cdev, &amp;led_fops);
	
	<span class="hljs-comment">/* 3、添加一个cdev */</span>
	cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);

	<span class="hljs-comment">/* 4、创建类 */</span>
	leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);
	<span class="hljs-keyword">if</span> (IS_ERR(leddev.class)) &#123;
		<span class="hljs-keyword">return</span> PTR_ERR(leddev.class);
	&#125;

	<span class="hljs-comment">/* 5、创建设备 */</span>
	leddev.device = device_create(leddev.class, <span class="hljs-literal">NULL</span>, leddev.devid, <span class="hljs-literal">NULL</span>, LEDDEV_NAME);
	<span class="hljs-keyword">if</span> (IS_ERR(leddev.device)) &#123;
		<span class="hljs-keyword">return</span> PTR_ERR(leddev.device);
	&#125;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span>
<span class="hljs-comment"> * @param - dev 	: platform设备</span>
<span class="hljs-comment"> * @return 			: 0，成功;其他负值,失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>
&#123;
	iounmap(IMX6U_CCM_CCGR1);
	iounmap(SW_MUX_GPIO1_IO03);
	iounmap(SW_PAD_GPIO1_IO03);
	iounmap(GPIO1_DR);
	iounmap(GPIO1_GDIR);

	cdev_del(&amp;leddev.cdev);<span class="hljs-comment">/*  删除cdev */</span>
	unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="hljs-comment">/* 注销设备号 */</span>
	device_destroy(leddev.class, leddev.devid);
	class_destroy(leddev.class);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* platform驱动结构体 */</span>
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">led_driver</span> =</span> &#123;
	.driver		= &#123;
		.name	= <span class="hljs-string">&quot;imx6ul-led&quot;</span>,			<span class="hljs-comment">/* 驱动名字，用于和设备匹配 */</span>
	&#125;,
	.probe		= led_probe,
	.remove		= led_remove,
&#125;;
		
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动模块加载函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-keyword">return</span> platform_driver_register(&amp;led_driver);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动模块卸载函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	platform_driver_unregister(&amp;led_driver);
&#125;

module_init(leddriver_init);
module_exit(leddriver_exit);
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>leddriver.c 文件内容就是按照示例代码的 platform 驱动模板编写的。</p>
<p>probe 函数，当设备和驱动匹配以后此函数就会执行，当匹配成功以后会在终端上输出“led driver and device has matched!”这样语句。在 probe 函数里面初始化 LED、注册字符设备驱动。也就是将原来在驱动加载函数里面做的工作全部放到 probe 函数里面完成。</p>
<p>remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面释放内存、注销字符设备等。也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中完成。</p>
<p>platform_driver 驱动结构体，注意 name 字段为”imx6ul-led”，和我们在leddevice.c 文件里面设置的设备 name 字段一致。</p>
<p>驱动模块加载函数，在此函数里面通过 platform_driver_register 向 Linux 内核注册 led_driver 驱动。<br>驱动模块卸载函数，在此函数里面通过 platform_driver_unregister 从 Linux内核卸载 led_driver 驱动。</p>
<h3 id="2-测试-APP-编写"><a href="#2-测试-APP-编写" class="headerlink" title="2| 测试 APP  编写"></a>2| 测试 APP  编写</h3><p>测试 APP 的内容很简单，就是打开和关闭 LED 灯，新建 ledApp.c 这个文件，然后在里面输入如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 	0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 	1</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: main主程序</span>
<span class="hljs-comment"> * @param - argc 	: argv数组元素个数</span>
<span class="hljs-comment"> * @param - argv 	: 具体参数</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
&#123;
	<span class="hljs-type">int</span> fd, retvalue;
	<span class="hljs-type">char</span> *filename;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">2</span>];
	
	<span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)&#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;

	filename = argv[<span class="hljs-number">1</span>];

	<span class="hljs-comment">/* 打开led驱动 */</span>
	fd = open(filename, O_RDWR);
	<span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s open failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;
	
	databuf[<span class="hljs-number">0</span>] = atoi(argv[<span class="hljs-number">2</span>]);	<span class="hljs-comment">/* 要执行的操作：打开或关闭 */</span>
	retvalue = write(fd, databuf, <span class="hljs-keyword">sizeof</span>(databuf));
	<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LED Control Failed!\r\n&quot;</span>);
		close(fd);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;

	retvalue = close(fd); <span class="hljs-comment">/* 关闭文件 */</span>
	<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s close failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div>

<h3 id="3-运行测试"><a href="#3-运行测试" class="headerlink" title="3| 运行测试"></a>3| 运行测试</h3><p>编译驱动程序</p>
<p>编写 Makefile 文件，本章实验的 Makefile 文件和第四十章实验基本一样，只是将 obj-m 变<br>量的值改为“leddevice.o leddriver.o”，Makefile 内容如下所示：</p>
<div class="hljs code-wrapper"><pre><code class="hljs makefile">1 KERNELDIR := /home/zuozhongkai/linux/IMX6ULL/linux/temp/linux-imx-
rel_imx_4.1.15_2.1.0_ga_alientek
......
4 obj-m :=  leddevice.o leddriver.o</code></pre></div>



<p>将编译出来 leddevice.ko 、 leddriver.ko 和 ledApp 这两个文件拷贝到rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15 目录中，重启开发板，进入到目录 lib&#x2F;modules&#x2F;4.1.15 中，输入如下命令加载 leddevice.ko 设备模块和 leddriver.ko 这个驱动模块。</p>
<div class="hljs code-wrapper"><pre><code class="hljs sh">depmod //第一次加载驱动的时候需要运行此命令
modprobe leddevice.ko //加载设备模块
modprobe leddriver.ko //加载驱动模块</code></pre></div>

<p>根文件系统中&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;目录下保存着当前板子 platform 总线下的设备和驱动，其中devices 子目录为 platform 设备，drivers 子目录为 plartofm 驱动。查看&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices&#x2F; 目录，看看我们的设备是否存在，我们在 leddevice.c 中设置 leddevice(platform_device 类型)的name 字段为“imx6ul-led”，也就是设备名字为 imx6ul-led，因此肯定在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices&#x2F;目录下存在一个名字“imx6ul-led”的文件，否则说明我们的设备模块加载失败，结果如图所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828154257279.png" srcset="/img/loading.gif" lazyload alt="image-20200828154257279"></p>
<p>同理，查看&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录，看一下驱动是否存在，我们在 leddriver.c 中设置led_driver (platform_driver 类型)的 name 字段为“imx6ul-led”，因此会在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录下存在名为“imx6ul-led”这个文件，结果如图 所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828154439288.png" srcset="/img/loading.gif" lazyload alt="image-20200828154439288"></p>
<p>驱动模块和设备模块加载成功以后 platform 总线就会进行匹配，当驱动和设备匹配成功以<br>后就会输出如图 所示一行语句：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828154419442.png" srcset="/img/loading.gif" lazyload alt="image-20200828154419442"></p>
<p>驱动和设备匹配成功以后就可以测试 LED 灯驱动了，输入如下命令打开 LED 灯：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/ledApp /</span>dev<span class="hljs-regexp">/platled 1 /</span><span class="hljs-regexp">/打开 LED 灯</span></code></pre></div>

<p>在输入如下命令关闭 LED 灯：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/ledApp /</span>dev<span class="hljs-regexp">/platled 0 /</span><span class="hljs-regexp">/关闭 LED 灯</span></code></pre></div>

<p>观察一下 LED 灯能否打开和关闭，如果可以的话就说明驱动工作正常，如果要卸载驱动的话输入如下命令即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c">rmmod leddevice.ko
rmmod leddriver.ko</code></pre></div>



<h2 id="四、设备树下的-platform-驱动"><a href="#四、设备树下的-platform-驱动" class="headerlink" title="四、设备树下的 platform 驱动"></a>四、设备树下的 platform 驱动</h2><p>上一章我们详细的讲解了 Linux 下的驱动分离与分层，以及总线、设备和驱动这样的驱动框架。基于总线、设备和驱动这样的驱动框架，Linux 内核提出来 platform 这个虚拟总线，相应的也有 platform 设备和 platform 驱动。</p>
<p>上一章我们讲解了传统的、未采用设备树的 platform 设备和驱动编写方法。最新的 Linux 内核已经支持了设备树，因此在设备树下如何编写 platform驱动就显得尤为重要，本章我们就来学习一下如何在设备树下编写 platform 驱动。</p>
<h3 id="1-设备树下的-platform-驱动简介"><a href="#1-设备树下的-platform-驱动简介" class="headerlink" title="1| 设备树下的 platform  驱动简介"></a>1| 设备树下的 platform  驱动简介</h3><p>platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的platform 驱动的时候我们需要注意一下几点：</p>
<h4 id="1、在设备树中创建设备节点"><a href="#1、在设备树中创建设备节点" class="headerlink" title="1、在设备树中创建设备节点"></a>1、在设备树中创建设备节点</h4><p>毫无疑问，肯定要先在设备树中创建设备节点来描述设备信息，重点是要设置好 compatible属性的值，因为 platform 总线需要通过设备节点的 compatible 属性值来匹配驱动！这点要切记。比如，我们可以编写如下所示的设备节点来描述我们本章实验要用到的 LED 这个设备：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> gpioled &#123;
<span class="hljs-number">2</span> 		<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">3</span> 		<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>
<span class="hljs-number">4</span> 		compatible = <span class="hljs-string">&quot;atkalpha-gpioled&quot;</span>;
<span class="hljs-number">5</span> 		pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;
<span class="hljs-number">6</span> 		pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_led&gt;;
<span class="hljs-number">7</span> 		led-gpio = &lt;&amp;gpio1 <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;;
<span class="hljs-number">8</span> 		status = <span class="hljs-string">&quot;okay&quot;</span>;
<span class="hljs-number">9</span> &#125;;</code></pre></div>

<p>示例中的 gpioled 节点其实就是 之前中创建的 gpioled 设备节点，我们可以直接拿过来用。注意第 4 行的 compatible 属性值为“atkalpha-gpioled”，因此一会在编写 platform驱动的时候 of_match_table 属性表中要有“atkalpha-gpioled”。</p>
<h4 id="2-、编写-platform-驱动的时候要注意兼容属性"><a href="#2-、编写-platform-驱动的时候要注意兼容属性" class="headerlink" title="2 、编写 platform 驱动的时候要注意兼容属性"></a>2 、编写 platform 驱动的时候要注意兼容属性</h4><p>上一章已经详细的讲解过了，在使用设备树的时候 platform 驱动会通过 of_match_table 来保存兼容性值，也就是表明此驱动兼容哪些设备。所以，of_match_table 将会尤为重要，比如本例程的 platform 驱动中 platform_driver 就可以按照如下所示设置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">leds_of_match</span>[] =</span> &#123;
<span class="hljs-number">2</span> 		&#123; .compatible = <span class="hljs-string">&quot;atkalpha-gpioled&quot;</span> &#125;, <span class="hljs-comment">/*  兼容属性 */</span>
<span class="hljs-number">3</span> 		&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;
<span class="hljs-number">4</span> &#125;;
<span class="hljs-number">5</span>
<span class="hljs-number">6</span> MODULE_DEVICE_TABLE(of, leds_of_match);
<span class="hljs-number">7</span>
<span class="hljs-number">8</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">leds_platform_driver</span> =</span> &#123;
<span class="hljs-number">9</span> 		.driver = &#123;
<span class="hljs-number">10</span> 			.name = <span class="hljs-string">&quot;imx6ul-led&quot;</span>,
<span class="hljs-number">11</span> 			.of_match_table = leds_of_match,
<span class="hljs-number">12</span> 		&#125;,
<span class="hljs-number">13</span> 		.probe = leds_probe,
<span class="hljs-number">14</span> 		.remove = leds_remove,
<span class="hljs-number">15</span> &#125;;</code></pre></div>

<p>第 1~4 行，of_device_id 表，也就是驱动的兼容表，是一个数组，每个数组元素为of_device_id<br>类型。每个数组元素都是一个兼容属性，表示兼容的设备，一个驱动可以跟多个设备匹配。这里我们仅仅匹配了一个设备，那就是创建的 gpioled 这个设备。第 2 行的 compatible 值为“atkalpha-gpioled”，驱动中的 compatible 属性和设备中的 compatible 属性相匹配，因此驱动中对应的 probe 函数就会执行。注意第 3 行是一个空元素，在编写 of_device_id 的时候最后一个元素一定要为空！</p>
<p>第 6 行，通过 MODULE_DEVICE_TABLE 声明一下 leds_of_match 这个设备匹配表。</p>
<p>第 11 行，设置 platform_driver 中的 of_match_table 匹配表为上面创建的 leds_of_match，至此我们就设置好了 platform 驱动的匹配表了。</p>
<h4 id="3-、编写-platform-驱动"><a href="#3-、编写-platform-驱动" class="headerlink" title="3 、编写 platform 驱动"></a>3 、编写 platform 驱动</h4><p>基于设备树的 platform 驱动和上一章无设备树的 platform 驱动基本一样，都是当驱动和设备匹配成功以后就会执行 probe 函数。我们需要在 probe 函数里面执行字符设备驱动那一套，当注销驱动模块的时候 remove 函数就会执行，都是大同小异的。</p>
<h3 id="2-实验程序编写"><a href="#2-实验程序编写" class="headerlink" title="2| 实验程序编写"></a>2| 实验程序编写</h3><h4 id="1、修改设备树文件"><a href="#1、修改设备树文件" class="headerlink" title="1、修改设备树文件"></a>1、修改设备树文件</h4><p>首先修改设备树文件，加上我们需要的设备信息，本章我们就使用到一个 LED 灯，因此可以直接使用之前小节编写的 gpioled 子节点即可，不需要再重复添加。</p>
<h4 id="2、platform-驱动程序编写"><a href="#2、platform-驱动程序编写" class="headerlink" title="2、platform  驱动程序编写"></a>2、platform  驱动程序编写</h4><p>设备已经准备好了，接下来就要编写相应的 platform 驱动了，新建名为“18_dtsplatform”的文件夹，然后在 18_dtsplatform 文件夹里面创建 vscode 工程，工作区命名为“dtsplatform”。新建名为 leddriver.c 的驱动文件，在 leddriver.c 中输入如下所示内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_CNT		1				<span class="hljs-comment">/* 设备号长度 	*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_NAME		<span class="hljs-string">&quot;dtsplatled&quot;</span>	<span class="hljs-comment">/* 设备名字 	*/</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 			0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 			1</span>

<span class="hljs-comment">/* leddev设备结构体 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span>&#123;</span>
	<span class="hljs-type">dev_t</span> devid;				<span class="hljs-comment">/* 设备号	*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>			<span class="hljs-comment">/* cdev		*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>		<span class="hljs-comment">/* 类 		*/</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>		<span class="hljs-comment">/* 设备		*/</span>
	<span class="hljs-type">int</span> major;					<span class="hljs-comment">/* 主设备号	*/</span>	
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">node</span>;</span>	<span class="hljs-comment">/* LED设备节点 */</span>
	<span class="hljs-type">int</span> led0;					<span class="hljs-comment">/* LED灯GPIO标号 */</span>
&#125;;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span> <span class="hljs-title">leddev</span>;</span> 		<span class="hljs-comment">/* led设备 */</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: LED打开/关闭</span>
<span class="hljs-comment"> * @param - sta 	: LEDON(0) 打开LED，LEDOFF(1) 关闭LED</span>
<span class="hljs-comment"> * @return 			: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">led0_switch</span><span class="hljs-params">(u8 sta)</span>
&#123;
	<span class="hljs-keyword">if</span> (sta == LEDON )
		gpio_set_value(leddev.led0, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sta == LEDOFF)
		gpio_set_value(leddev.led0, <span class="hljs-number">1</span>);	
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 打开设备</span>
<span class="hljs-comment"> * @param - inode 	: 传递给驱动的inode</span>
<span class="hljs-comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span>
<span class="hljs-comment"> * 					  一般在open的时候将private_data指向设备结构体。</span>
<span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>
&#123;
	filp-&gt;private_data = &amp;leddev; <span class="hljs-comment">/* 设置私有数据  */</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: 向设备写数据 </span>
<span class="hljs-comment"> * @param - filp 	: 设备文件，表示打开的文件描述符</span>
<span class="hljs-comment"> * @param - buf 	: 要写给设备写入的数据</span>
<span class="hljs-comment"> * @param - cnt 	: 要写入的数据长度</span>
<span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span>
<span class="hljs-comment"> * @return 			: 写入的字节数，如果为负值，表示写入失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>
&#123;
	<span class="hljs-type">int</span> retvalue;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">2</span>];
	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;

	retvalue = copy_from_user(databuf, buf, cnt);
	<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;

		printk(<span class="hljs-string">&quot;kernel write failed!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> -EFAULT;
	&#125;
	
	ledstat = databuf[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">if</span> (ledstat == LEDON) &#123;
		led0_switch(LEDON);
	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ledstat == LEDOFF) &#123;
		led0_switch(LEDOFF);
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* 设备操作函数 */</span>
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;
	.owner = THIS_MODULE,
	.open = led_open,
	.write = led_write,
&#125;;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: flatform驱动的probe函数，当驱动与</span>
<span class="hljs-comment"> * 					  设备匹配以后此函数就会执行</span>
<span class="hljs-comment"> * @param - dev 	: platform设备</span>
<span class="hljs-comment"> * @return 			: 0，成功;其他负值,失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>
&#123;	
	printk(<span class="hljs-string">&quot;k:led driver and device was matched!\r\n&quot;</span>);
	<span class="hljs-comment">/* 1、设置设备号 */</span>
	<span class="hljs-keyword">if</span> (leddev.major) &#123;
		leddev.devid = MKDEV(leddev.major, <span class="hljs-number">0</span>);
		register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);
	&#125; <span class="hljs-keyword">else</span> &#123;
		alloc_chrdev_region(&amp;leddev.devid, <span class="hljs-number">0</span>, LEDDEV_CNT, LEDDEV_NAME);
		leddev.major = MAJOR(leddev.devid);
	&#125;

	<span class="hljs-comment">/* 2、注册设备      */</span>
	cdev_init(&amp;leddev.cdev, &amp;led_fops);
	cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);

	<span class="hljs-comment">/* 3、创建类      */</span>
	leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);
	<span class="hljs-keyword">if</span> (IS_ERR(leddev.class)) &#123;
		<span class="hljs-keyword">return</span> PTR_ERR(leddev.class);
	&#125;

	<span class="hljs-comment">/* 4、创建设备 */</span>
	leddev.device = device_create(leddev.class, <span class="hljs-literal">NULL</span>, leddev.devid, <span class="hljs-literal">NULL</span>, LEDDEV_NAME);
	<span class="hljs-keyword">if</span> (IS_ERR(leddev.device)) &#123;
		<span class="hljs-keyword">return</span> PTR_ERR(leddev.device);
	&#125;

	<span class="hljs-comment">/* 5、初始化IO */</span>	
	leddev.node = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);
	<span class="hljs-keyword">if</span> (leddev.node == <span class="hljs-literal">NULL</span>)&#123;
		printk(<span class="hljs-string">&quot;k:gpioled node nost find!\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> -EINVAL;
	&#125; 
	
	leddev.led0 = of_get_named_gpio(leddev.node, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span> (leddev.led0 &lt; <span class="hljs-number">0</span>) &#123;
		printk(<span class="hljs-string">&quot;k:can&#x27;t get led-gpio\r\n&quot;</span>);
		<span class="hljs-keyword">return</span> -EINVAL;
	&#125;

	gpio_request(leddev.led0, <span class="hljs-string">&quot;led0&quot;</span>);
	gpio_direction_output(leddev.led0, <span class="hljs-number">1</span>); <span class="hljs-comment">/* led0 IO设置为输出，默认高电平	*/</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description		: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span>
<span class="hljs-comment"> * @param - dev 	: platform设备</span>
<span class="hljs-comment"> * @return 			: 0，成功;其他负值,失败</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>
&#123;
	gpio_set_value(leddev.led0, <span class="hljs-number">1</span>); 	<span class="hljs-comment">/* 卸载驱动的时候关闭LED */</span>

	cdev_del(&amp;leddev.cdev);				<span class="hljs-comment">/*  删除cdev */</span>
	unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="hljs-comment">/* 注销设备号 */</span>
	device_destroy(leddev.class, leddev.devid);
	class_destroy(leddev.class);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* 匹配列表 */</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">led_of_match</span>[] =</span> &#123;
	&#123; .compatible = <span class="hljs-string">&quot;atkalpha-gpioled&quot;</span> &#125;,
	&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;
&#125;;

<span class="hljs-comment">/* platform驱动结构体 */</span>
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">led_driver</span> =</span> &#123;
	.driver		= &#123;
		.name	= <span class="hljs-string">&quot;imx6ul-led&quot;</span>,			<span class="hljs-comment">/* 驱动名字，用于和设备匹配 */</span>
		.of_match_table	= led_of_match, <span class="hljs-comment">/* 设备树匹配表 		 */</span>
	&#125;,
	.probe		= led_probe,
	.remove		= led_remove,
&#125;;
		
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动模块加载函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	<span class="hljs-keyword">return</span> platform_driver_register(&amp;led_driver);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * @description	: 驱动模块卸载函数</span>
<span class="hljs-comment"> * @param 		: 无</span>
<span class="hljs-comment"> * @return 		: 无</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
	platform_driver_unregister(&amp;led_driver);
&#125;

module_init(leddriver_init);
module_exit(leddriver_exit);
MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);
MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div>

<p>platform 驱动的 probe 函数，当设备树中的设备节点与驱动之间匹配成功以后此函数就会执行，原来在驱动加载函数里面做的工作现在全部放到 probe 函数里面完成。</p>
<p>remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面释放内存、注销字符设备等，也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中完成。</p>
<p>匹配表，描述了此驱动都和什么样的设备匹配，添加了一条值为”atkalpha-gpioled”的compatible 属性值，当设备树中某个设备节点的 compatible 属性值也为“atkalpha-gpioled”的时候就会与此驱动匹配。</p>
<p>platform_driver 驱动结构体，设置这个 platform 驱动的名字为“imx6ul-led”，因此，当驱动加载成功以后就会在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录下存在一个名为“imx6u-led”的文件。 设置 of_match_table 为上面的 led_of_match。</p>
<h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3| 编写测试 APP"></a>3| 编写测试 APP</h3><p>测试 APP 就直接使用上一小节编写的 ledApp.c 即可。</p>
<h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4| 运行测试"></a>4| 运行测试</h3><p>编译运行。</p>
<p>驱动模块加载完成以后到&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录下查看驱动是否存在，我们在leddriver.c 中设置 led_driver (platform_driver 类型)的 name 字段为“imx6ul-led”，因此会在<br>&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录下存在名为“imx6ul-led”这个文件，结果如图 所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828160111754.png" srcset="/img/loading.gif" lazyload alt="image-20200828160111754"></p>
<p>同理，在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices&#x2F;目录下也存在 led 的设备文件，也就是设备树中 gpioled 这个节点，如图 所示：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828160034597.png" srcset="/img/loading.gif" lazyload alt="image-20200828160034597"></p>
<p>驱动和模块都存在，当驱动和设备匹配成功以后就会输出如图 所示一行语句：</p>
<p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828160050525.png" srcset="/img/loading.gif" lazyload alt="image-20200828160050525"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">10| Linux阻塞非阻塞IO实验</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">8| Linux  内核定时器实验</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
