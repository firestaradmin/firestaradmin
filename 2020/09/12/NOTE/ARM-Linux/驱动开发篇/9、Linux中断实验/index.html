

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux 中断实验不管是裸机实验还是 Linux 下的驱动实验，中断都是频繁使用的功能，在裸机中使用中断我们需要做一大堆的工作，比如配置寄存器，使能 IRQ 等等。Linux 内核提供了完善的中断框架，我们只需要申请中断，然后注册中断处理函数即可，使用非常方便，不需要一系列复杂的寄存器配置。本章我们就来学习一下如何在 Linux 下使用中断。 一、 Linux 中断简介1|Linux  中断 A">
<meta property="og:type" content="article">
<meta property="og:title" content="9| Linux 中断实验">
<meta property="og:url" content="http://firestaradmin.top:888/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Linux 中断实验不管是裸机实验还是 Linux 下的驱动实验，中断都是频繁使用的功能，在裸机中使用中断我们需要做一大堆的工作，比如配置寄存器，使能 IRQ 等等。Linux 内核提供了完善的中断框架，我们只需要申请中断，然后注册中断处理函数即可，使用非常方便，不需要一系列复杂的寄存器配置。本章我们就来学习一下如何在 Linux 下使用中断。 一、 Linux 中断简介1|Linux  中断 A">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://firestaradmin.top:888/Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200824142754531.png">
<meta property="og:image" content="http://firestaradmin.top:888/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200825172109959.png">
<meta property="og:image" content="http://firestaradmin.top:888/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200826110945181.png">
<meta property="og:image" content="http://firestaradmin.top:888/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200826111221680.png">
<meta property="article:published_time" content="2020-09-11T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-11T16:00:00.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://firestaradmin.top:888/Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200824142754531.png">
  
  
  <title>9| Linux 中断实验 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"firestaradmin.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="9| Linux 中断实验">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-12 00:00" pubdate>
        September 12, 2020 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      24k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      196 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">9| Linux 中断实验</h1>
            
            <div class="markdown-body">
              <h1 id="Linux-中断实验"><a href="#Linux-中断实验" class="headerlink" title="Linux 中断实验"></a>Linux 中断实验</h1><p>不管是裸机实验还是 Linux 下的驱动实验，中断都是频繁使用的功能，在裸机中使用中断我们需要做一大堆的工作，比如配置寄存器，使能 IRQ 等等。Linux 内核提供了完善的中断框架，我们只需要申请中断，然后注册中断处理函数即可，使用非常方便，不需要一系列复杂的寄存器配置。本章我们就来学习一下如何在 Linux 下使用中断。</p>
<h2 id="一、-Linux-中断简介"><a href="#一、-Linux-中断简介" class="headerlink" title="一、 Linux 中断简介"></a>一、 Linux 中断简介</h2><h3 id="1-Linux-中断-API-函数"><a href="#1-Linux-中断-API-函数" class="headerlink" title="1|Linux  中断 API 函数"></a>1|Linux  中断 API 函数</h3><p>先来回顾一下裸机实验里面中断的处理方法：<br>①、使能中断，初始化相应的寄存器。<br>②、注册中断服务函数，也就是向 irqTable 数组的指定标号处写入中断服务函数<br>②、中断发生以后进入 IRQ 中断服务函数，在 IRQ 中断服务函数在数组 irqTable 里面查找具体的中断处理函数，找到以后执行相应的中断处理函数。</p>
<hr>
<p>在 Linux 内核中也提供了大量的中断相关的 API 函数，我们来看一下这些跟中断有关的API 函数：</p>
<h4 id="1-、中断号"><a href="#1-、中断号" class="headerlink" title="1 、中断号"></a><strong>1 、中断号</strong></h4><p>每个中断都有一个中断号，通过中断号即可区分不同的中断，有的资料也把中断号叫做中断线。在 Linux 内核中使用一个 int 变量表示中断号.</p>
<h4 id="2-、request-irq-函数"><a href="#2-、request-irq-函数" class="headerlink" title="2 、request_irq  函数"></a><strong>2 、request_irq  函数</strong></h4><p>在 Linux 内核中要想使用某个中断是需要申请的，request_irq 函数用于申请中断，request_irq函数可能会导致睡眠，因此不能在中断上下文或者其他禁止睡眠的代码段中使用 request_irq 函数。request_irq 函数会激活(使能)中断，所以不需要我们手动去使能中断，request_irq 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">request_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq,</span><br><span class="hljs-params">                <span class="hljs-type">irq_handler_t</span> handler,</span><br><span class="hljs-params">                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,</span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">                <span class="hljs-type">void</span> *dev)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：</p>
<ul>
<li><p><strong>irq</strong>：要申请中断的中断号。</p>
</li>
<li><p><strong>handler</strong>：中断处理函数，当中断发生以后就会执行此中断处理函数。</p>
</li>
<li><p><strong>flags</strong>：中断标志，可以在文件 include&#x2F;linux&#x2F;interrupt.h 里面查看所有的中断标志，这里我们介绍几个常用的中断标志，如表所示：</p>
<p><img src="/Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200824142754531.png" srcset="/img/loading.gif" lazyload alt="image-20200824142754531"></p>
<p>比如 I.MX6U-ALPHA 开发板上的 KEY0 使用 GPIO1_IO18，按下 KEY0 以后为低电平，因此可以设置为下降沿触发，也就是将 flags 设置为 IRQF_TRIGGER_FALLING。表 中的这些标志可以通过“|”来实现多种组合。</p>
</li>
<li><p><strong>name</strong>：中断名字，设置以后可以在&#x2F;proc&#x2F;interrupts 文件中看到对应的中断名字。</p>
</li>
<li><p><strong>dev</strong> ：如果将 flags 设置为 IRQF_SHARED 的话，dev 用来区分不同的中断，一般情况下将dev 设置为设备结构体，dev 会传递给中断处理函数 irq_handler_t 的第二个参数。</p>
</li>
<li><p><strong>返回值</strong>：0 中断申请成功，其他负值 中断申请失败，如果返回-EBUSY 的话表示中断已经被申请了。</p>
</li>
</ul>
<hr>
<h4 id="3-、free-irq-函数"><a href="#3-、free-irq-函数" class="headerlink" title="3 、free_irq  函数"></a><strong>3 、free_irq  函数</strong></h4><p>使用中断的时候需要通过 request_irq 函数申请，使用完成以后就要通过 free_irq 函数释放掉相应的中断。如果中断不是共享的，那么 free_irq 会删除中断处理函数并且禁止中断。free_irq函数原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq,</span><br><span class="hljs-params">                <span class="hljs-type">void</span> *dev)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>irq</strong> ：要释放的中断。<br><strong>dev</strong>：如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉。<br><strong>返回值</strong>：无。</p>
<hr>
<h4 id="4-、中断处理函数"><a href="#4-、中断处理函数" class="headerlink" title="4 、中断处理函数"></a><strong>4 、中断处理函数</strong></h4><p>使用 request_irq 函数申请中断的时候需要设置中断处理函数，中断处理函数格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">irqreturn_t</span> (*<span class="hljs-type">irq_handler_t</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *)<br></code></pre></td></tr></table></figure>

<ul>
<li>第一个参数是要中断处理函数要相应的中断号。</li>
<li>第二个参数是一个指向 void 的指针，也就是个通用指针，需要与 request_irq 函数的 dev 参数保持一致。用于区分共享中断的不同设备，dev 也可以指向设备数据结构。</li>
</ul>
<p>中断处理函数的返回值为 irqreturn_t 类型，irqreturn_t类型定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">10</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">irqreturn</span> &#123;</span><br><span class="hljs-number">11</span> 		IRQ_NONE = (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">0</span>),<br><span class="hljs-number">12</span> 		IRQ_HANDLED = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>),<br><span class="hljs-number">13</span> 		IRQ_WAKE_THREAD = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>),<br><span class="hljs-number">14</span> &#125;;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">irqreturn</span> <span class="hljs-title">irqreturn_t</span>;</span><br></code></pre></td></tr></table></figure>

<p>可以看出 irqreturn_t 是个枚举类型，一共有三种返回值。一般中断服务函数返回值使用如下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED)<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="5-、中断使能与禁止函数"><a href="#5-、中断使能与禁止函数" class="headerlink" title="5 、中断使能与禁止函数"></a><strong>5 、中断使能与禁止函数</strong></h4><p>常用的中断使用和禁止函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">enable_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">disable_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span><br></code></pre></td></tr></table></figure>

<p>enable_irq 和 disable_irq 用于使能和禁止指定的中断，irq 就是要禁止的中断号。disable_irq函数要等到当前正在执行的中断处理函数执行完才返回，因此使用者需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出。在这种情况下，可以使用另外一个中断禁止函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">disable_irq_nosync</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span><br></code></pre></td></tr></table></figure>

<p>disable_irq_nosync 函数调用以后立即返回，不会等待当前中断处理程序执行完毕。上面三个函数都是使能或者禁止某一个中断，有时候我们需要关闭当前处理器的整个中断系统，也就是在学习 STM32 的时候常说的关闭全局中断，这个时候可以使用如下两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">local_irq_enable()<br>local_irq_disable()<br></code></pre></td></tr></table></figure>

<p>local_irq_enable 用于使能当前处理器中断系统，local_irq_disable 用于禁止当前处理器中断系统。假如 A 任务调用 local_irq_disable 关闭全局中断 10S，当关闭了 2S 的时候 B 任务开始运行，B 任务也调用 local_irq_disable 关闭全局中断 3S，3 秒以后 B 任务调用local_irq_enable 函数将全局中断打开了。此时才过去 2+3&#x3D;5 秒的时间，然后全局中断就被打开了，此时 A 任务要关闭 10S 全局中断的愿望就破灭了，然后 A 任务就“生气了”，结果很严重，可能系统都要被A 任务整崩溃。为了解决这个问题，B 任务不能直接简单粗暴的通过 local_irq_enable 函数来打开全局中断，而是将中断状态恢复到以前的状态，要考虑到别的任务的感受，此时就要用到下面两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">local_irq_save(flags) <br>local_irq_restore(flags)<br></code></pre></td></tr></table></figure>

<p>这两个函数是一对，local_irq_save 函数用于禁止中断，并且将中断状态保存在 flags 中。local_irq_restore 用于恢复中断，将中断到 flags 状态。</p>
<h3 id="2-上半部与下半部"><a href="#2-上半部与下半部" class="headerlink" title="2|上半部与下半部"></a>2|上半部与下半部</h3><p>在有些资料中也将上半部和下半部称为顶半部和底半部，都是一个意思。我们在使用request_irq 申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。我们都知道中断处理函数一定要快点执行完毕，越短越好，但是现实往往是残酷的，有些中断处理过程就是比较费时间，我们必须要对其进行处理，缩小中断处理函数的执行时间。比如电容触摸屏通过中断通知 SOC 有触摸事件发生，SOC 响应中断，然后通过 IIC 接口读取触摸坐标值并将其上报给系统。但是我们都知道 IIC 的速度最高也只有400Kbit&#x2F;S，所以在中断中通过 IIC 读取数据就会浪费时间。我们可以将通过 IIC 读取触摸数据的操作暂后执行，中断处理函数仅仅相应中断，然后清除中断标志位即可。这个时候中断处理过程就分为了两部分：</p>
<ul>
<li>上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。</li>
<li>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。</li>
</ul>
<p>因此，Linux 内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，那些对时间敏感、执行速度快的操作可以放到中断处理函数中，也就是上半部。剩下的所有工作都可以放到下半部去执行，比如在上半部将数据拷贝到内存中，关于数据的具体处理就可以放到下半部去执行。至于哪些代码属于上半部，哪些代码属于下半部并没有明确的规定，一切根据实际使用情况去判断，这个就很考验驱动编写人员的功底了。这里有一些可以借鉴的参考点：</p>
<ul>
<li>①、如果要处理的内容不希望被其他中断打断，那么可以放到上半部。</li>
<li>②、如果要处理的任务对时间敏感，可以放到上半部。</li>
<li>③、如果要处理的任务与硬件有关，可以放到上半部</li>
<li>④、除了上述三点以外的其他任务，优先考虑放到下半部。</li>
</ul>
<p>上半部处理很简单，直接编写中断处理函数就行了，关键是下半部该怎么做呢？Linux 内核提供了多种下半部机制，接下来我们来学习一下这些下半部机制。</p>
<h4 id="1、软中断"><a href="#1、软中断" class="headerlink" title="1、软中断"></a>1、软中断</h4><p>一开始 Linux 内核提供了“bottom half”机制来实现下半部，简称“BH”。后面引入了软中断和 tasklet 来替代“BH”机制，完全可以使用软中断和 tasklet 来替代 BH，从 2.5 版本的 Linux内核开始 BH 已经被抛弃了。<strong>Linux 内核使用结构体 softirq_action 表示软中断</strong>，softirq_action结构体定义在文件 include&#x2F;linux&#x2F;interrupt.h 中，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">433</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span></span><br><span class="hljs-class">434 &#123;</span><br><span class="hljs-number">435</span> 	<span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action *);<br><span class="hljs-number">436</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>在 kernel&#x2F;softirq.c 文件中一共定义了 10 个软中断，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> <span class="hljs-title">softirq_vec</span>[<span class="hljs-title">NR_SOFTIRQS</span>];</span><br></code></pre></td></tr></table></figure>

<p>NR_SOFTIRQS 是枚举类型，定义在文件 include&#x2F;linux&#x2F;interrupt.h 中，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    HI_SOFTIRQ=<span class="hljs-number">0</span>, <span class="hljs-comment">/* 高优先级软中断 */</span><br>    TIMER_SOFTIRQ, <span class="hljs-comment">/* 定时器软中断 */</span><br>    NET_TX_SOFTIRQ, <span class="hljs-comment">/* 网络数据发送软中断 */</span><br>    NET_RX_SOFTIRQ, <span class="hljs-comment">/* 网络数据接收软中断 */</span><br>    BLOCK_SOFTIRQ,<br>    BLOCK_IOPOLL_SOFTIRQ,<br>    TASKLET_SOFTIRQ, <span class="hljs-comment">/* tasklet 软中断 */</span><br>    SCHED_SOFTIRQ, <span class="hljs-comment">/* 调度软中断 */</span><br>    HRTIMER_SOFTIRQ, <span class="hljs-comment">/* 高精度定时器软中断  */</span><br>    RCU_SOFTIRQ, <span class="hljs-comment">/* RCU 软中断  */</span><br>    NR_SOFTIRQS<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>可以看出，一共有 10 个软中断，因此 NR_SOFTIRQS 为 10，因此数组 softirq_vec 有 10 个元素。softirq_action 结构体中的 action 成员变量就是软中断的服务函数，数组 softirq_vec是个全局数组，因此所有的 CPU(对于 SMP 系统而言)都可以访问到，每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。要使用软中断，必须先使用open_softirq 函数注册对应的软中断处理函数，open_softirq 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">open_softirq</span><span class="hljs-params">(<span class="hljs-type">int</span> nr, <span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action *))</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：</p>
<ul>
<li>nr：要开启的软中断，在示例代码 51.1.2.3 中选择一个。</li>
<li>action：软中断对应的处理函数。</li>
<li>返回值：没有返回值。</li>
</ul>
<p>注册好软中断以后需要通过 raise_softirq 函数触发，raise_softirq 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">raise_softirq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：</p>
<ul>
<li>nr：要触发的软中断，在示例代码 51.1.2.3 中选择一个。</li>
<li>返回值：没有返回值。</li>
</ul>
<p>软中断必须在编译的时候静态注册！Linux 内核使用 softirq_init 函数初始化软中断.</p>
<h4 id="2、tasklet"><a href="#2、tasklet" class="headerlink" title="2、tasklet"></a>2、tasklet</h4><p>tasklet 是利用软中断来实现的另外一种下半部机制，在软中断和 tasklet 之间，建议大家使用 tasklet。Linux 内核使用结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">484</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span></span><br><span class="hljs-class">485 &#123;</span><br><span class="hljs-number">486</span> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">/* 下一个 tasklet */</span><br><span class="hljs-number">487</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> state; 		<span class="hljs-comment">/* tasklet 状态 */</span><br><span class="hljs-number">488</span> 	<span class="hljs-type">atomic_t</span> count; 			<span class="hljs-comment">/* 计数器，记录对 tasklet 的引用数 */</span><br><span class="hljs-number">489</span> 	<span class="hljs-type">void</span> (*func)(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>); <span class="hljs-comment">/* tasklet  执行的函数 */</span><br><span class="hljs-number">490</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data; 		<span class="hljs-comment">/* 函数 func 的参数 */</span><br><span class="hljs-number">491</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>第 489 行的 func 函数就是 tasklet 要执行的处理函数，用户定义函数内容，相当于中断处理函数。如果要使用 tasklet，必须先定义一个 tasklet，然后使用 tasklet_init 函数初始化tasklet，taskled_init 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tasklet_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tasklet_struct *t,</span><br><span class="hljs-params">                  <span class="hljs-type">void</span> (*func)(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>),</span><br><span class="hljs-params">				  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data)</span>;<br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：</p>
<ul>
<li>t：要初始化的 tasklet</li>
<li>func：tasklet 的处理函数。</li>
<li>data ：要传递给 func 函数的参数</li>
<li>返回值：没有返回值。</li>
</ul>
<p>也 可 以 使 用 宏 DECLARE_TASKLET 来 一 次 性 完 成 tasklet 的 定 义 和 初 始 化 ，DECLARE_TASKLET 定义在 include&#x2F;linux&#x2F;interrupt.h 文件中，定义如下:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">DECLARE_TASKLET(<span class="hljs-params">name</span>, <span class="hljs-params">func</span>, <span class="hljs-params">data</span>)</span><br></code></pre></td></tr></table></figure>

<p>其中 name 为要定义的 tasklet 名字，这个名字就是一个 tasklet_struct 类型的时候变量，func就是 tasklet 的处理函数，data 是传递给 func 函数的参数。</p>
<p>在上半部，也就是中断处理函数中调用 tasklet_schedule 函数就能使 tasklet 在合适的时间运<br>行，tasklet_schedule 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tasklet_schedule</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tasklet_struct *t)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：</p>
<ul>
<li>t：要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name。</li>
<li>返回值：没有返回值。</li>
</ul>
<p>关于 tasklet 的参考使用示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义 taselet */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> <span class="hljs-title">testtasklet</span>;</span><br><span class="hljs-comment">/* tasklet 处理函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">testtasklet_func</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data)</span><br>&#123;<br>    <span class="hljs-comment">/* tasklet 具体处理内容 */</span><br>&#125;<br><span class="hljs-comment">/* 中断处理函数 */</span><br><span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">test_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span><br>&#123;<br>    ......<br>    <span class="hljs-comment">/* 调度 tasklet */</span><br>    tasklet_schedule(&amp;testtasklet);<br>    ......<br>&#125;<br><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ......<br>    <span class="hljs-comment">/* 初始化 tasklet */</span><br>    tasklet_init(&amp;testtasklet, testtasklet_func, data);<br>    <span class="hljs-comment">/* 注册中断处理函数 */</span><br>    request_irq(xxx_irq, test_handler, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;xxx&quot;</span>, &amp;xxx_dev);<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3、工作队列"><a href="#3、工作队列" class="headerlink" title="3、工作队列"></a>3、工作队列</h4><p>工作队列是另外一种下半部执行方式，工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。因此如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet。</p>
<p>Linux 内核使用 work_struct 结构体表示一个工作，内容如下(省略掉条件编译)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> &#123;</span><br>    <span class="hljs-type">atomic_long_t</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span><br>    <span class="hljs-type">work_func_t</span> func; <span class="hljs-comment">/* 工作队列处理函数 */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这些工作组织成工作队列，工作队列使用 workqueue_struct 结构体表示，内容如下(省略掉条件编译)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pwqs</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span><br>    <span class="hljs-type">int</span> work_color;<br>    <span class="hljs-type">int</span> flush_color;<br>    <span class="hljs-type">atomic_t</span> nr_pwqs_to_flush;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wq_flusher</span> *<span class="hljs-title">first_flusher</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">flusher_queue</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">flusher_overflow</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">maydays</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> *<span class="hljs-title">rescuer</span>;</span><br>    <span class="hljs-type">int</span> nr_drainers;<br>    <span class="hljs-type">int</span> saved_max_active;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_attrs</span> *<span class="hljs-title">unbound_attrs</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> *<span class="hljs-title">dfl_pwq</span>;</span><br>    <span class="hljs-type">char</span> name[WQ_NAME_LEN];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags ____cacheline_aligned;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_pwqs</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">numa_pwq_tbl</span>[];</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Linux 内核使用工作者线程(worker thread)来处理工作队列中的各个工作，Linux 内核使用worker 结构体表示工作者线程，worker 结构体内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">hentry</span>;</span><br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> *<span class="hljs-title">current_work</span>;</span><br>    <span class="hljs-type">work_func_t</span> current_func;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> *<span class="hljs-title">current_pwq</span>;</span><br>    <span class="hljs-type">bool</span> desc_valid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">scheduled</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker_pool</span> *<span class="hljs-title">pool</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> last_active;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span> desc[WORKER_DESC_LEN];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_struct</span> *<span class="hljs-title">rescue_wq</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>从示例代码 可以看出，每个 worker 都有一个工作队列，工作者线程处理自己工作队列中的所有工作。在实际的驱动开发中，我们只需要定义工作(work_struct)即可，关于工作队列和工作者线程我们基本不用去管。简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作，INIT_WORK 宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_WORK(_work, _func) </span><br></code></pre></td></tr></table></figure>

<p>_work 表示要初始化的工作，_func 是工作对应的处理函数。</p>
<p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_WORK(n, f)</span><br></code></pre></td></tr></table></figure>

<p>n 表示定义的工作(work_struct)，f 表示工作对应的处理函数。<br>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work，函数原<br>型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">schedule_work</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：</p>
<ul>
<li>work ：要调度的工作。</li>
<li>返回值：0 成功，其他值 失败。</li>
</ul>
<p>关于工作队列的参考使用示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义工作(work) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">testwork</span>;</span><br><span class="hljs-comment">/* work 处理函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">testwork_func_t</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span>;<br>&#123;<br>    <span class="hljs-comment">/* work 具体处理内容 */</span><br>&#125;<br><span class="hljs-comment">/* 中断处理函数 */</span><br><span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">test_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span><br>&#123;<br>    ......<br>   	<span class="hljs-comment">/* 调度 work */</span><br>    schedule_work(&amp;testwork);<br>    ......<br>&#125;<br><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ......<br>    <span class="hljs-comment">/* 初始化 work */</span><br>    INIT_WORK(&amp;testwork, <span class="hljs-type">testwork_func_t</span>);<br>    <span class="hljs-comment">/* 注册中断处理函数 */</span><br>    request_irq(xxx_irq, test_handler, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;xxx&quot;</span>, &amp;xxx_dev);<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-设备树中断信息节点"><a href="#3-设备树中断信息节点" class="headerlink" title="3|设备树中断信息节点"></a>3|设备树中断信息节点</h3><p>如果使用设备树的话就需要在设备树中设置好中断属性信息，Linux 内核通过读取设备树中的中断属性信息来配置中断。对于中断控制器而言，设备树绑定信息参考文档Documentation&#x2F;devicetree&#x2F;bindings&#x2F;arm&#x2F;gic.txt。打开 imx6ull.dtsi 文件，其中的 <strong>intc 节点就是I.MX6ULL 的中断控制器节点</strong>，节点内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> intc: interrupt-controller@<span class="hljs-number">00</span>a01000 &#123;<br><span class="hljs-number">2</span> 		compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;<br><span class="hljs-number">3</span> 		<span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;3&gt;</span>;</span><br><span class="hljs-number">4</span> 		interrupt-controller;<br><span class="hljs-number">5</span> 		reg = &lt;<span class="hljs-number">0x00a01000</span> <span class="hljs-number">0x1000</span>&gt;,<br><span class="hljs-number">6</span> 			  &lt;<span class="hljs-number">0x00a02000</span> <span class="hljs-number">0x100</span>&gt;;<br><span class="hljs-number">7</span> &#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>第 2 行</strong>，<strong>compatible</strong> 属性值为“arm,cortex-a7-gic”在 Linux 内核源码中搜索“arm,cortex-a7-gic”即可找到 GIC 中断控制器驱动文件。</p>
</li>
<li><p><strong>第 3 行</strong>，**#interrupt-cells** 和#address-cells、#size-cells 一样。表示此中断控制器下设备的 cells大小，对于设备而言，会使用 interrupts 属性描述中断信息，#interrupt-cells 描述了interrupts 属性的 cells 大小，也就是一条信息有几个 cells。每个 cells 都是 32 位整形值，对于 ARM 处理的GIC 来说，一共有 3 个 cells，这三个 cells 的含义如下：</p>
<ul>
<li>第一个 cells：中断类型，0 表示 SPI 中断，1 表示 PPI 中断。</li>
<li>第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 0<del>987，对于 PPI 中断来说中断号的范围为 0</del>15。</li>
<li>第三个 cells：标志，bit[3:0]表示中断触发类型，为 1 的时候表示上升沿触发，为 2 的时候表示下降沿触发，为 4 的时候表示高电平触发，为 8 的时候表示低电平触发。bit[15:8]为 PPI中<br>断的 CPU 掩码。</li>
</ul>
</li>
<li><p><strong>第 4 行</strong>，<strong>interrupt-controller</strong> 节点为空，表示当前节点是中断控制器。对于 gpio 来说，gpio 节点也可以作为中断控制器，比如 imx6ull.dtsi 文件中的 gpio5 节点内容如下所示：</p>
</li>
<li><p>&#96;&#96;&#96;c<br>1 gpio5: gpio@020ac000 {<br>2         compatible &#x3D; “fsl,imx6ul-gpio”, “fsl,imx35-gpio”;<br>3         reg &#x3D; &lt;0x020ac000 0x4000&gt;;<br>4         interrupts &#x3D; &lt;GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH&gt;,<br>5                      &lt;GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH&gt;;<br>6         gpio-controller;<br>7         #gpio-cells &#x3D; &lt;2&gt;;<br>8         interrupt-controller;<br>9         #interrupt-cells &#x3D; &lt;2&gt;;<br>10 };</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tap"><br>- **第<span class="hljs-number"> 4 </span>行**，interrupts 描述中断源信息，对于 gpio5 来说一共有两条信息，中断类型都是 SPI，触发电平都是 IRQ_TYPE_LEVEL_HIGH。不同之处在于中断源，一个是 74，一个是 75，打开可以打开《IMX6ULL 参考手册》的“Chapter<span class="hljs-number"> 3 </span>Interrupts and DMA Events”章节，找到表 3-1，有如图所示的内容：<br><br>  ![image-20200825171323009](9、Linux中断实验/image-20200825171323009.png)<br><br>  从图 可以看出，GPIO5 一共用了<span class="hljs-number"> 2 </span>个中断号，一个是 74，一个是 75。其中<span class="hljs-number"> 74 </span>对应GPIO5_IO00~GPIO5_IO15 这低<span class="hljs-number"> 16 </span>个 IO，75 对应 GPIO5_IO16~GPIOI5_IO31 这高 16位 IO。<br><br>- 第<span class="hljs-number"> 8 </span>行，interrupt-controller 表明了 gpio5 节点也是个中断控制器，用于控制 gpio5 所有IO的中断。<br><br>- 第<span class="hljs-number"> 9 </span>行，将<span class="hljs-comment">#interrupt-cells 修改为 2。打开 imx6ull-lxg-emmc.dts 文件，找到如下所示内容：</span><br><br>  ```c<br> <span class="hljs-number"> 1 </span>fxls8471@1e &#123;<br> <span class="hljs-number"> 2 </span>	compatible = &quot;fsl,fxls8471&quot;;<br> <span class="hljs-number"> 3 </span>	reg = &lt;0x1e&gt;;<br> <span class="hljs-number"> 4 </span>	position = &lt;0&gt;;<br> <span class="hljs-number"> 5 </span>	interrupt-parent = &lt;&amp;gpio5&gt;;<br> <span class="hljs-number"> 6 </span>	interrupts = &lt;0 8&gt;;<br> <span class="hljs-number"> 7 </span>&#125;;<br></code></pre></td></tr></table></figure>

<p>fxls8471 是 NXP 官方的 6ULL 开发板上的一个磁力计芯片，fxls8471 有一个中断引脚链接到了 I.MX6ULL 的 SNVS_TAMPER0 因脚上，这个引脚可以复用为 GPIO5_IO00。第 5 行，interrupt-parent 属性设置中断控制器，这里使用 gpio5 作为中断控制器。第 6 行，interrupts 设置中断信息，0 表示 GPIO5_IO00，8 表示低电平触发。简单总结一下与中断有关的设备树属性信息：<br>①、#interrupt-cells，指定中断源的信息 cells 个数。<br>②、interrupt-controller，表示当前节点为中断控制器。<br>③、interrupts，指定中断号，触发方式等。<br>④、interrupt-parent，指定父中断，也就是中断控制器。</p>
</li>
</ul>
<h3 id="4-获取中断号-irq-of-parse-and-map"><a href="#4-获取中断号-irq-of-parse-and-map" class="headerlink" title="4|获取中断号 irq_of_parse_and_map"></a>4|获取中断号 irq_of_parse_and_map</h3><p>编写驱动的时候需要用到中断号，我们用到中断号，中断信息已经写到了设备树里面，因此可以通过 <strong>irq_of_parse_and_map</strong>函数从 interupts 属性中提取到对应的设备号，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">irq_of_parse_and_map</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev,</span><br><span class="hljs-params">                                  <span class="hljs-type">int</span> index)</span>	<br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>dev</strong> ：设备节点。<br><strong>index</strong>：索引号，interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息。<br><strong>返回值</strong>：中断号。</p>
<p>如果使用 GPIO 的话，可以使用 <strong>gpio_to_irq</strong> 函数来获取 gpio 对应的中断号，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_to_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gpio)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>gpio</strong> ：要获取的 GPIO 编号。<br><strong>返回值</strong>：GPIO 对应的中断号。</p>
<h2 id="二、硬件原理分析"><a href="#二、硬件原理分析" class="headerlink" title="二、硬件原理分析"></a>二、硬件原理分析</h2><p><img src="/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200825172109959.png" srcset="/img/loading.gif" lazyload alt="image-20200825172109959"></p>
<h2 id="三、实验程序编写"><a href="#三、实验程序编写" class="headerlink" title="三、实验程序编写"></a>三、实验程序编写</h2><p>本章实验我们驱动 I.MX6U-ALPHA 开发板上的 KEY0 按键，不过我们采用中断的方式，并且采用定时器来实现按键消抖，应用程序读取按键值并且通过终端打印出来。通过本章我们可以学习到 Linux 内核中断的使用方法，以及对 Linux 内核定时器的回顾。</p>
<h3 id="1-修改设备树文件"><a href="#1-修改设备树文件" class="headerlink" title="1|修改设备树文件"></a>1|修改设备树文件</h3><p>本章实验使用到了按键 KEY0，按键 KEY0 使用中断模式，因此需要在“key”节点下添加中断相关属性，添加完成以后的“key”节点内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> key &#123;<br><span class="hljs-number">2</span> 		<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">3</span> 		<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">4</span> 		compatible = <span class="hljs-string">&quot;atkalpha-key&quot;</span>;<br><span class="hljs-number">5</span> 		pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<br><span class="hljs-number">6</span> 		pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_key&gt;;<br><span class="hljs-number">7</span> 		key-gpio = &lt;&amp;gpio1 <span class="hljs-number">18</span> GPIO_ACTIVE_LOW&gt;; <span class="hljs-comment">/* KEY0 */</span><br><span class="hljs-number">8</span> 		interrupt-parent = &lt;&amp;gpio1&gt;;<br><span class="hljs-number">9</span> 		interrupts = &lt;<span class="hljs-number">18</span> IRQ_TYPE_EDGE_BOTH&gt;; <span class="hljs-comment">/* FALLING RISING */</span><br><span class="hljs-number">10</span> 		status = <span class="hljs-string">&quot;okay&quot;</span>;<br><span class="hljs-number">11</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>第 8 行，设置 interrupt-parent 属性值为“gpio1”，因为 KEY0 所使用的 GPIO 为GPIO1_IO18，也就是设置 KEY0 的 GPIO 中断控制器为 gpio1。</p>
<p>第 9 行，设置 interrupts 属性，也就是设置中断源，第一个 cells 的 18 表示 GPIO1 组的 18号 IO。</p>
<p>IRQ_TYPE_EDGE_BOTH 定义在文件 include&#x2F;linux&#x2F;irq.h 中，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">76</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br><span class="hljs-number">77</span> 		IRQ_TYPE_NONE = <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">78</span> 		IRQ_TYPE_EDGE_RISING = <span class="hljs-number">0x00000001</span>,<br><span class="hljs-number">79</span> 		IRQ_TYPE_EDGE_FALLING = <span class="hljs-number">0x00000002</span>,<br><span class="hljs-number">80</span> 		IRQ_TYPE_EDGE_BOTH = (IRQ_TYPE_EDGE_FALLING |<br>						 	  IRQ_TYPE_EDGE_RISING),<br><span class="hljs-number">81</span> 		IRQ_TYPE_LEVEL_HIGH = <span class="hljs-number">0x00000004</span>,<br><span class="hljs-number">82</span> 		IRQ_TYPE_LEVEL_LOW = <span class="hljs-number">0x00000008</span>,<br><span class="hljs-number">83</span> 		IRQ_TYPE_LEVEL_MASK = (IRQ_TYPE_LEVEL_LOW |<br>							   IRQ_TYPE_LEVEL_HIGH),<br>......<br><span class="hljs-number">100</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>从示例代码  中可以看出，IRQ_TYPE_EDGE_BOTH 表示上升沿和下降沿同时有效，相当于 KEY0 按下和释放都会触发中断。设备树编写完成以后使用“make dtbs”命令重新编译设备树，然后使用新编译出来的imx6ull-lxg-emmc.dtb 文件启动 Linux 系统。</p>
<h3 id="2-按键中断驱动程序编写"><a href="#2-按键中断驱动程序编写" class="headerlink" title="2|按键中断驱动程序编写"></a>2|按键中断驱动程序编写</h3><p>新建名为“13_irq”的文件夹，然后在 13_irq 文件夹里面创建 vscode 工程，工作区命名为“imx6uirq”。工程创建好以后新建 imx6uirq.c 文件，在 imx6uirq.c 里面输入如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CNT 	1			<span class="hljs-comment">/* 设备号个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_NAME <span class="hljs-string">&quot;imx6u-irq&quot;</span>	<span class="hljs-comment">/* 设备名 */</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE 	0X01 <span class="hljs-comment">/* KEY0 按键值 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY 	0XFF <span class="hljs-comment">/* 无效的按键值 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_CNT 	1 	 <span class="hljs-comment">/* 按键数量 */</span></span><br><br><br><span class="hljs-comment">/* 中断 IO 描述结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> &#123;</span><br>	<span class="hljs-type">int</span> gpio; 				<span class="hljs-comment">/* gpio */</span><br>	<span class="hljs-type">int</span> irqnum; 			<span class="hljs-comment">/* 中断号 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value; 	<span class="hljs-comment">/* 按键对应的键值  */</span><br>	<span class="hljs-type">char</span> name[<span class="hljs-number">10</span>]; 			<span class="hljs-comment">/* 名字 */</span><br>	<span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *); <span class="hljs-comment">/* 中断服务函数 */</span><br>&#125;;<br><br><br><br><br><span class="hljs-comment">/* imx6uirq设备结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> &#123;</span>	<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><br>	<span class="hljs-type">dev_t</span> devid;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><br>	<span class="hljs-type">int</span> major;<br>	<span class="hljs-type">int</span> minor;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span>		<span class="hljs-comment">/* 设备树节点 */</span><br>	<span class="hljs-type">atomic_t</span> keyvalue; 			<span class="hljs-comment">/* 有效的按键键值 */</span><br>	<span class="hljs-type">atomic_t</span> releasekey; 		<span class="hljs-comment">/* 标记是否完成一次完成的按键*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> 	<span class="hljs-comment">/* 定义一个定时器*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> <span class="hljs-title">irqkeydesc</span>[<span class="hljs-title">KEY_CNT</span>];</span> <span class="hljs-comment">/* 按键描述数组 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> curkeynum; 	<span class="hljs-comment">/* 当前的按键号 */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> <span class="hljs-title">imx6uirq</span>;</span><br><br><br><span class="hljs-comment">/* @description : 中断服务函数，开启定时器，延时 10ms，</span><br><span class="hljs-comment"> * 定时器用于按键消抖。</span><br><span class="hljs-comment"> * @param - irq : 中断号</span><br><span class="hljs-comment"> * @param - dev_id : 设备结构。</span><br><span class="hljs-comment"> * @return : 中断执行结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">key0_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)dev_id;<br><br>	dev-&gt;curkeynum = <span class="hljs-number">0</span>;<br>	dev-&gt;timer.data = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span>)dev_id;<br>	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="hljs-number">10</span>));<br>	<span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);<br>&#125;<br><br><span class="hljs-comment">/* @description : 定时器服务函数，用于按键消抖，定时器到了以后</span><br><span class="hljs-comment"> * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><br><span class="hljs-comment"> * @param – arg  : 设备结构变量</span><br><span class="hljs-comment"> * @return : 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> *<span class="hljs-title">keydesc</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)arg;<br><br>	num = dev-&gt;curkeynum;<br>	keydesc = &amp;dev-&gt;irqkeydesc[num];<br>	value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/* 读取 IO 值 */</span><br>	<span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span><br>		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);<br>	&#125;<br>	<span class="hljs-keyword">else</span>&#123; 			<span class="hljs-comment">/* 按键松开 */</span><br>		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="hljs-number">0x80</span> | keydesc-&gt;value);<br>		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 标记松开按键 */</span><br>	&#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description : 按键 IO 初始化</span><br><span class="hljs-comment"> * @param : 无</span><br><span class="hljs-comment"> * @return : 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>	imx6uirq.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);<br>	<span class="hljs-keyword">if</span> (imx6uirq.nd == <span class="hljs-literal">NULL</span>)<br>	&#123;<br>		printk(<span class="hljs-string">&quot;k:key node not find!\r\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> -EINVAL;<br>	&#125;<br><br>	<span class="hljs-comment">/* 提取 GPIO */</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)<br>	&#123;<br>		imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd,<br>														<span class="hljs-string">&quot;key-gpios&quot;</span>, i);<br>		<span class="hljs-keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="hljs-number">0</span>)<br>		&#123;<br>			printk(<span class="hljs-string">&quot;k:can&#x27;t get key%d\r\n&quot;</span>, i);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/* 初始化 key 所使用的 IO，并且设置成中断模式 */</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)<br>	&#123;<br>		<span class="hljs-built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-number">0</span>,<br>			   <span class="hljs-keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));<br>		<span class="hljs-built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-string">&quot;KEY%d&quot;</span>, i);<br>		gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);<br>		gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);<br>		imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(<br>			imx6uirq.nd, i);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(<br>imx6uirq.irqkeydesc[i].gpio);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		printk(<span class="hljs-string">&quot;k:key%d:gpio=%d, irqnum=%d\r\n&quot;</span>, i,<br>			   imx6uirq.irqkeydesc[i].gpio,<br>			   imx6uirq.irqkeydesc[i].irqnum);<br>	&#125;<br>	<span class="hljs-comment">/* 申请中断 */</span><br>	imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].handler = key0_handler;<br>	imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].value = KEY0VALUE;<br><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)<br>	&#123;<br>		ret = request_irq(imx6uirq.irqkeydesc[i].irqnum,<br>						  imx6uirq.irqkeydesc[i].handler,<br>						  IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,<br>						  imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);<br>		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>		&#123;<br>			printk(<span class="hljs-string">&quot;k:irq %d request failed!\r\n&quot;</span>,<br>				   imx6uirq.irqkeydesc[i].irqnum);<br>			<span class="hljs-keyword">return</span> -EFAULT;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/* 创建定时器 */</span><br>	init_timer(&amp;imx6uirq.timer);<br>	imx6uirq.timer.function = timer_function;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>	filp-&gt;private_data = &amp;imx6uirq; <span class="hljs-comment">/* 设置私有数据 */</span><br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description : 从设备读取数据</span><br><span class="hljs-comment"> * @param – filp : 要打开的设备文件(文件描述符)</span><br><span class="hljs-comment"> * @param – buf : 返回给用户空间的数据缓冲区</span><br><span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span><br><span class="hljs-comment"> * @param – offt : 相对于文件首地址的偏移</span><br><span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">imx6uirq_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf,</span><br><span class="hljs-params">							 <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br>	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> keyvalue = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> releasekey = <span class="hljs-number">0</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)<br>								   filp-&gt;private_data;<br><br>	keyvalue = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;keyvalue);<br>	releasekey = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey);<br><br>	<span class="hljs-keyword">if</span> (releasekey)<br>	&#123; <span class="hljs-comment">/* 有按键按下 */</span><br>		<span class="hljs-keyword">if</span> (keyvalue &amp; <span class="hljs-number">0x80</span>)<br>		&#123;<br>			keyvalue &amp;= ~<span class="hljs-number">0x80</span>;<br>			ret = copy_to_user(buf, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-keyword">goto</span> data_error;<br>		&#125;<br>		<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 按下标志清零 */</span><br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">goto</span> data_error;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>data_error:<br>	<span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">imx6uirq_fops</span> =</span> &#123;<br>	.owner = THIS_MODULE,<br>	.open = imx6uirq_open,<br>	.read = imx6uirq_read,<br><br>&#125;;<br><br><br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">imx6uirq_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br><br>	<span class="hljs-comment">/* 注册设备号 */</span><br>	imx6uirq.major = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(imx6uirq.major)&#123;<br>		imx6uirq.devid = MKDEV(imx6uirq.major, imx6uirq.minor);<br>		ret = register_chrdev_region(imx6uirq.devid, DEV_CNT, DEV_NAME);<br>	&#125;<br>	<span class="hljs-keyword">else</span>&#123;<br>		ret = alloc_chrdev_region(&amp;imx6uirq.devid, <span class="hljs-number">0</span>, DEV_CNT, DEV_NAME);<br>	&#125;<br>	imx6uirq.major = MAJOR(imx6uirq.devid);<br>	imx6uirq.minor = MINOR(imx6uirq.devid);<br>	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<br>		printk(<span class="hljs-string">&quot;k:register devid failed!\r\n&quot;</span>);<br>		result = -EINVAL;<br>		<span class="hljs-keyword">goto</span> fail_register_devid;<br>	&#125;<br>	printk(<span class="hljs-string">&quot;k:imx6uirq  MAJOR:%d  MINOR:%d\r\n&quot;</span>, imx6uirq.major, imx6uirq.minor);<br><br>	<span class="hljs-comment">/* 添加字符设备 */</span><br>	imx6uirq.cdev.owner = imx6uirq_fops.owner;<br>	cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);<br>	ret = cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, DEV_CNT);<br>	<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<br>		printk(<span class="hljs-string">&quot;k:register chrdev failed!\r\n&quot;</span>);<br>		result = -EINVAL;<br>		<span class="hljs-keyword">goto</span> fail_register_cdev;<br>	&#125;<br>	<span class="hljs-comment">/* 创建设备节点 */</span><br>	<span class="hljs-comment">/* 	1.创建类 */</span><br>	imx6uirq.class = class_create(THIS_MODULE, DEV_NAME);<br>	<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.class))&#123;<br>		printk(<span class="hljs-string">&quot;k:fail to create class!\r\n&quot;</span>);<br>		result = PTR_ERR(imx6uirq.class);<br>		<span class="hljs-keyword">goto</span> fail_class;<br>	&#125;<br>	<span class="hljs-comment">/*	2.创建设备*/</span><br>	imx6uirq.device = device_create(imx6uirq.class, <span class="hljs-literal">NULL</span>, imx6uirq.devid, <span class="hljs-literal">NULL</span>, DEV_NAME);<br>	<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.device))&#123;<br>		printk(<span class="hljs-string">&quot;k:fail to create device!\r\n&quot;</span>);<br>		result = PTR_ERR(imx6uirq.device);<br>		<span class="hljs-keyword">goto</span> fail_device;<br>	&#125;<br>		<br>	<span class="hljs-comment">/* 5、初始化按键 */</span><br>	<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);<br>	<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="hljs-number">0</span>);<br>	keyio_init();<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>fail_device:<br>	<span class="hljs-comment">/* 摧毁类 */</span><br>	class_destroy(imx6uirq.class);<br>fail_class:<br>	<span class="hljs-comment">/* 注销字符设备 */</span><br>	cdev_del(&amp;imx6uirq.cdev);<br>fail_register_cdev:<br>	<span class="hljs-comment">/* 注销设备号 */</span><br>	unregister_chrdev_region(imx6uirq.devid, DEV_CNT);<br>fail_register_devid:<br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">imx6uirq_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/* 删除定时器 */</span><br>	del_timer_sync(&amp;imx6uirq.timer);<br><br>	<span class="hljs-comment">/* 释放中断 */</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)<br>	&#123;<br>		free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);<br>	&#125;<br><br>	<span class="hljs-comment">/* 摧毁设备 */</span><br>	device_destroy(imx6uirq.class, imx6uirq.devid);<br>	<span class="hljs-comment">/* 摧毁类 */</span><br>	class_destroy(imx6uirq.class);<br>	<span class="hljs-comment">/* 注销字符设备 */</span><br>	cdev_del(&amp;imx6uirq.cdev);<br>	<span class="hljs-comment">/* 注销设备号 */</span><br>	unregister_chrdev_region(imx6uirq.devid, DEV_CNT);<br><br>&#125;<br><br><span class="hljs-comment">/* 驱动入口和出口 */</span><br>module_init(imx6uirq_init);<br>module_exit(imx6uirq_exit);<br><br><span class="hljs-comment">/* 许可 */</span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-comment">/* 作者信息 */</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>结构体 irq_keydesc 为<strong>按键的中断描述结构体</strong>，gpio 为按键 GPIO 编号，irqnum为按键 IO 对应的中断号，value 为按键对应的键值，name 为按键名字，handler 为按键中断服务函数。使用 irq_keydesc 结构体即可描述一个按键中断。</p>
</li>
<li><p>结构体 imx6uirq_dev 为本例程<strong>设备结构体</strong>， keyvalue 保存按键值， releasekey 表示按键是否被释放，如果按键被释放表示发生了一次完整的按键过程。timer 为按键消抖定时器。数组 irqkeydesc 为按键信息数组，数组元素个数就是开发板上的按键个数，I.MX6U-ALIPHA 开发板上只有一个按键，因此 irqkeydesc 数组只有一个元素。curkeynum 表示当前按键。</p>
</li>
<li><p>key0_handler 函数，<strong>按键 KEY0 中断处理函数</strong>，参数 dev_id 为设备结构体，也就是 imx6uirq。 curkeynum&#x3D;0，表示当前按键为 KEY0，使用mod_timer函数启动定时器，定时器周期为 10ms。</p>
</li>
<li><p>timer_function 函数，<strong>定时器定时处理函数</strong>，参数 arg 是设备结构体，也就是imx6uirq，在此函数中读取按键值。通过 gpio_get_value 函数读取按键值。如果为 0 的话就表示按键被按下去了，按下去的话就设置 imx6uirq 结构体的 keyvalue 成员变量为按键的键值，比如 KEY0 按键的话按键值就是 KEY0VALUE&#x3D;0。如果按键值为 1 的话表示按键被释放了，按键释放了的话就将 imx6uirq 结构体的 keyvalue 成员变量的最高位置 1，表示按键值有效，也就是将keyvalue 与 0x80 进行或运算，表示按键松开了，并且设置 imx6uirq 结构体的 releasekey成员变量为 1，表示按键释放，一次有效的按键过程发生。</p>
</li>
<li><p><strong>keyio_init 函数，按键 IO 初始化函数</strong>，在驱动入口函数里面会调用 keyio_init 来初始化按键 IO。轮流初始化所有的按键，包括申请 IO、设置 IO 为输入模式、从设备树中获取 IO 的中断号等等。通过 irq_of_parse_and_map 函数从设备树中获取按键 IO 对应的中断号。也可以使用 gpio_to_irq 函数将某个 IO 设置为中断状态，并且返回其中断号。然后设置 KEY0 按键对应的按键中断处理函数为 key0_handler、KEY0 的按键值为 KEY0VALUE。轮流调用request_irq 函数申请中断号，设置中断触发模式为IRQF_TRIGGER_FALLING 和 IRQF_TRIGGER_RISING，也就是上升沿和下降沿都可以触发中断。最后，初始化定时器，并且设置定时器的定时处理函数。</p>
</li>
<li><p><strong>imx6uirq_read 函数，对应应用程序的 read 函数</strong>。此函数向应用程序返回按键值。首先判断 imx6uirq 结构体的 releasekey 成员变量值是否为 1，如果为 1 的话表示有一次有效按键发生，否则的话就直接返回-EINVAL。当有按键事件发生的话就要向应用程序发送按键值，首先判断按键值的最高位是否为 1，如果为 1 的话就表示按键值有效。如果按键值有效的话就将最高位清除，得到真实的按键值，然后通过 copy_to_user 函数返回给应用程序。向应用程序发送按键值完成以后就将 imx6uirq 结构体的 releasekey 成员变量清零，准备下一次按键操作。</p>
</li>
<li><p>驱动入口函数，分别初始化 imx6uirq 结构体中的原子变量keyvalue 和 releasekey，调用 keyio_init 函数初始化按键所使用的 IO。</p>
</li>
<li><p>驱动出口函数，调用 del_timer_sync 函数删除定时器，轮流释放申请的所有按键中断。</p>
</li>
</ul>
<h3 id="3-编写测试APP"><a href="#3-编写测试APP" class="headerlink" title="3|编写测试APP"></a>3|编写测试APP</h3><p>测试 APP 要实现的内容很简单，通过不断的读取&#x2F;dev&#x2F;imx6uirq 文件来获取按键值，当按键按下以后就会将获取到的按键值输出在终端上，新建名为 imx6uirqApp.c 的文件，然后输入如下所示内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/ioctl.h&quot;</span></span><br><br><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @description : main 主程序</span><br><span class="hljs-comment">* @param - argc : argv 数组元素个数</span><br><span class="hljs-comment">* @param - argv : 具体参数</span><br><span class="hljs-comment">* @return : 0 成功;其他 失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, fd = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> *filename;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data;<br>    <br><br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    filename = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">/* 打开 key 驱动 */</span><br>    fd =  open(filename, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data));<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>        &#123; <span class="hljs-comment">/* 数据读取错误或者无效 */</span><br><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;             <span class="hljs-comment">/* 数据读取正确 */</span><br>            <span class="hljs-keyword">if</span> (data) <span class="hljs-comment">/* 读取到数据 */</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key value = %#X\r\n&quot;</span>, data);<br>        &#125;<br>    &#125;<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> while 循环用于不断的读取按键值，如果读取到有效的按键值就将其输出到终端上。</p>
<h2 id="四、运行测试"><a href="#四、运行测试" class="headerlink" title="四、运行测试"></a>四、运行测试</h2><p>编译运行。</p>
<p>驱动加载成功以后可以通过查看&#x2F;proc&#x2F;interrupts 文件来检查一下对应的中断有没有被注册上，输入如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /proc/interrupts<br></code></pre></td></tr></table></figure>

<p>结果如图 所示：</p>
<p><img src="/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200826110945181.png" srcset="/img/loading.gif" lazyload alt="image-20200826110945181"></p>
<p>按下按键 如图：</p>
<p><img src="/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200826111221680.png" srcset="/img/loading.gif" lazyload alt="image-20200826111221680"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/">NOTE</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/">ARM-Linux</a>
                    
                      <a class="hover-with-bg" href="/categories/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/">驱动开发篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM/">ARM</a>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">8| Linux  内核定时器实验</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/">
                        <span class="hidden-mobile">4| Linux  设备树</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
