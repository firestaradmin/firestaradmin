<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>树莓派部署个人博客(hexo)</title>
    <link href="/2022/03/02/NOTE/Web/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(hexo)/"/>
    <url>/2022/03/02/NOTE/Web/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(hexo)/</url>
    
    <content type="html"><![CDATA[<h1 id="树莓派部署个人博客-hexo"><a href="#树莓派部署个人博客-hexo" class="headerlink" title="树莓派部署个人博客(hexo)"></a>树莓派部署个人博客(hexo)</h1><blockquote><p>如何在黑夜里停止大脑在荒芜的草原上漂泊，抓紧时间学习。</p></blockquote><hr><p>最近搞到了公网IP，手头里还有一个域名，恰恰好好的手里还有一块吃灰的树莓派，嘿嘿。</p><p>所以呢我也没办法啊，只能部署一个博客了。OK FINE！</p><hr><p>大致步骤：</p><ol><li>在Win10 上生成hexo 代码</li><li>上传到树莓派上的Git 服务</li><li>在树莓派上部署Nginx 服务</li><li>在路由器上端口映射端口</li><li>外网访问</li></ol><p>让我们先来看第一步</p><h2 id="1-生成hexo-静态博客"><a href="#1-生成hexo-静态博客" class="headerlink" title="1. 生成hexo 静态博客"></a>1. 生成hexo 静态博客</h2><h3 id="1-1-安装环境"><a href="#1-1-安装环境" class="headerlink" title="1.1 安装环境"></a>1.1 安装环境</h3><p>电脑上需要安装 <code>Git</code> <code>NodeJs </code> </p><p>下载之后一路安装，安装完成后我们打开刚刚Git的命令行，右击桌面空白处打开GitBash，输入如下指令查看hexo和npm的版本：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">node -vnpm -v</code></pre></div><p>返回版本信息就说明安装OK</p><p><img src="/2022/03/02/NOTE/Web/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(hexo)/image-20220302222502195.png" alt="image-20220302222502195"></p><h3 id="1-2-安装Hexo"><a href="#1-2-安装Hexo" class="headerlink" title="1.2 安装Hexo"></a>1.2 安装Hexo</h3><p>使用nodejs的npm安装包管理工具安装hexo，指令如下</p><p>安装指令：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install -g hexo-cli</code></pre></div><p>查看是否安装成功：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">hexo -v</code></pre></div><p>出现版本信息说明安装成功</p><h3 id="1-3-Hexo-生成网页"><a href="#1-3-Hexo-生成网页" class="headerlink" title="1.3 Hexo 生成网页"></a>1.3 Hexo 生成网页</h3><p>新建一个文件夹，右键打开GitBash，然后输入初始化指令</p><div class="hljs code-wrapper"><pre><code class="hljs sh">hexo init</code></pre></div><p>输入后Git 会从远程拉取初始化代码下来，显示如下</p><p><img src="/2022/03/02/NOTE/Web/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(hexo)/image-20220302222937727.png" alt="image-20220302222937727"></p><p>然后文件夹内就有Hexo 源码了：</p><p><img src="/2022/03/02/NOTE/Web/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(hexo)/image-20220302223009726.png" alt="image-20220302223009726"></p><p>接下来输入下方指令</p><p>hexo生成网页指令：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">hexo g</code></pre></div><p>开启本地端口访问：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">hexo s</code></pre></div><p><img src="/2022/03/02/NOTE/Web/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(hexo)/image-20220302223205848.png" alt="image-20220302223205848"></p><p>在浏览器输入如下内容，就可以本地访问Hexo生成的网页代码了：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">localhost:4000</code></pre></div><p><img src="/2022/03/02/NOTE/Web/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(hexo)/image-20220302223235884.png" alt="image-20220302223235884"></p><hr><p>hexo 有很多主题，可以去hexo 官网寻找主题</p><h2 id="2-创建树莓派上的Git-仓库"><a href="#2-创建树莓派上的Git-仓库" class="headerlink" title="2. 创建树莓派上的Git 仓库"></a>2. 创建树莓派上的Git 仓库</h2><p>树莓派镜像安装啥的就不说了，网上很多教程，我用的是Ubuntu Server版本。</p><p>首先安装好镜像后，换源，然后update 源，然后安装Git 服务（一般系统自带Git）</p><h3 id="2-1-安装Git环境"><a href="#2-1-安装Git环境" class="headerlink" title="2.1 安装Git环境"></a>2.1 安装Git环境</h3><p>安装</p><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt install git</code></pre></div><p>查看版本</p><div class="hljs code-wrapper"><pre><code class="hljs shell">git --version</code></pre></div><h3 id="2-2-创建Git-仓库"><a href="#2-2-创建Git-仓库" class="headerlink" title="2.2 创建Git 仓库"></a>2.2 创建Git 仓库</h3><p>在树莓端安装Git 后，我们用Git 建立一个远程仓库，用来作为本地PC提交网页源码的中间站，这样更新网页，就可以直接git 上传代码即可（即使用指令<code>hexo d</code>），具体步骤如下：</p><p>创建一个文件夹存放Git 仓库</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> -p /home/xx/myRepo<span class="hljs-comment">#创建一个文件夹</span>sudo <span class="hljs-built_in">chown</span> -R <span class="hljs-variable">$USER</span>:<span class="hljs-variable">$USER</span> /home/xx/myRepo/<span class="hljs-comment">#给分到用户组</span>sudo <span class="hljs-built_in">chmod</span> -R 755 /home/xx/myRepo/<span class="hljs-comment">#改变文件夹权限</span></code></pre></div><ul><li>mkdir -p 选项 确保目录名称存在，不存在的就建一个。</li></ul><p>建立Git仓库</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /home/xx/myRepo/git init --bare myblog.git</code></pre></div><ul><li>–bare 选项代表生成的是一个裸仓库，是没有工作区的，只会记录git提交的历史信息，git log是可以看到各个版本信息的，但是没办法进行版本回退或者切换分支的操作，但是有一个好处是可以通过添加hooks钩子在其他目录下新建一个存放项目源码的文件夹，也就是说将git仓库与项目源码分离，这样推送的更新会马上显示到项目文件上</li></ul><hr><p>这里建立仓库后，需要再建一个文件夹给用于存放项目源码（也就是Web文件 | Nginx根目录）</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> -p /home/xx/www/hexo</code></pre></div><p>修改目录权限</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chown</span> -R <span class="hljs-variable">$USER</span>:<span class="hljs-variable">$USER</span> /home/xx/www/hexosudo <span class="hljs-built_in">chmod</span> -R 755 /home/xx/www/hexo</code></pre></div><p>然后在仓库 myblog下创建一个钩子，将上传的项目文件传送到Nginx 根目录下，即 <code>/home/xx/www/hexo</code> 下面。</p><p>创建钩子文件：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo vim /home/xx/myRepo/myblog.git/hooks/post-receive</code></pre></div><p>添加如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span>git --work-tree=/home/xx/www/hexo --git-dir=/home/xx/myRepo/myblog.git checkout -f</code></pre></div><p>保存后，添加可执行权限：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chmod</span> +x /home/xx/myRepo/myblog.git/hooks/post-receive</code></pre></div><p>这样添加脚本后，每次上传Git 后，仓库内容就会被推送到<code>/home/xx/www/hexo</code> 目录下了</p><h2 id="3-在树莓派上部署Nginx-服务"><a href="#3-在树莓派上部署Nginx-服务" class="headerlink" title="3. 在树莓派上部署Nginx 服务"></a>3. 在树莓派上部署Nginx 服务</h2><p>安装nginx</p><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt install nginx</code></pre></div><p>查看当前版本</p><div class="hljs code-wrapper"><pre><code class="hljs shell">nginx -v</code></pre></div><p>Nginx网页根目录设置<br>上一步我们已经创建好网页根目录，并且已经做好文件传送钩子，这一步我们配置Nginx的配置文件，开启Nginx并将根目录映射到我们创建的目录下</p><p>打开Nginx默认配置项</p><p>sudo vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</p><p>然后找到如下位置，修改root的值为我们设置的根目录文件夹</p><h2 id="4-上传Hexo-网页代码至树莓派Git"><a href="#4-上传Hexo-网页代码至树莓派Git" class="headerlink" title="4. 上传Hexo 网页代码至树莓派Git"></a>4. 上传Hexo 网页代码至树莓派Git</h2><h2 id="5-在路由器上端口映射端口"><a href="#5-在路由器上端口映射端口" class="headerlink" title="5. 在路由器上端口映射端口"></a>5. 在路由器上端口映射端口</h2><h2 id="6-外网访问"><a href="#6-外网访问" class="headerlink" title="6. 外网访问"></a>6. 外网访问</h2>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raspberry</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C&amp;C++ Function Pointer</title>
    <link href="/2022/02/22/NOTE/C&amp;C++/function%20pointer/"/>
    <url>/2022/02/22/NOTE/C&amp;C++/function%20pointer/</url>
    
    <content type="html"><![CDATA[<h1 id="Function-Pointer"><a href="#Function-Pointer" class="headerlink" title="Function Pointer"></a>Function Pointer</h1><blockquote><p>人生就是不断折磨自己！变得更强！                ——@firestaradmin</p></blockquote><p>See example：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> p; <span class="hljs-comment">//这是整数型变量p</span><span class="hljs-type">int</span> *p; <span class="hljs-comment">//这是整数型指针p</span><span class="hljs-type">int</span> *p[<span class="hljs-number">3</span>]; <span class="hljs-comment">//这是长度为3的整数型指针数组p，元素为整数型指针</span><span class="hljs-type">int</span> (*p)[<span class="hljs-number">3</span>]; <span class="hljs-comment">//这是一个数组指针，指向一个长度为3的整数型数组</span><span class="hljs-type">int</span> <span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>; <span class="hljs-comment">//这是函数声明，形参：整数型 ，返回值：整数型  等同于 int p(int x);</span><span class="hljs-type">int</span> *<span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>; <span class="hljs-comment">//这是函数声明，形参：整数型 ，返回值：整数型指针  等同于 int *p(int x);</span><span class="hljs-type">int</span> (*p)(<span class="hljs-type">int</span>); <span class="hljs-comment">//这是函数指针，指向有一个整数型形参和整数型返回值的函数</span><span class="hljs-type">int</span> (*p[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>);<span class="hljs-comment">//这是函数指针数组，每个元素指向有一个整数型形参和整数型返回值的函数</span><span class="hljs-type">int</span> *(*p(<span class="hljs-type">int</span>)); <span class="hljs-comment">//这是函数声明，形参：整数型 ，返回值：指向整数型指针的指针  等同于 int **p(int) ， int **p(int x) ， </span><span class="hljs-comment">//int *(*p(int x))</span><span class="hljs-type">int</span> *(*p(<span class="hljs-type">int</span>))[<span class="hljs-number">3</span>]; <span class="hljs-comment">//这是一个函数声明，形参：整数型，返回值：一个数组指针数组，此数组内的指针，指向一个长度为3的整数型指针数组。</span><span class="hljs-type">int</span> **<span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>[3];我知道这个很绕，简单说返回值就是这样： <span class="hljs-type">int</span> *i[x][<span class="hljs-number">3</span>]; <span class="hljs-comment">//x是任意数</span></code></pre></div><h3 id="定义一个-int-型变量"><a href="#定义一个-int-型变量" class="headerlink" title="定义一个 int 型变量"></a>定义一个 int 型变量</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> p;</code></pre></div><h3 id="定义一个-int-型指针-变量"><a href="#定义一个-int-型指针-变量" class="headerlink" title="定义一个 int 型指针 变量"></a>定义一个 int 型指针 变量</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> *p;</code></pre></div><h3 id="定义一个长度为3的-int-型指针数组"><a href="#定义一个长度为3的-int-型指针数组" class="headerlink" title="定义一个长度为3的 int 型指针数组"></a>定义一个长度为3的 int 型指针数组</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> *p[<span class="hljs-number">3</span>];</code></pre></div><h3 id="定义一个指向长度为3的-int-型数组的指针"><a href="#定义一个指向长度为3的-int-型数组的指针" class="headerlink" title="定义一个指向长度为3的 int 型数组的指针"></a>定义一个指向长度为3的 int 型数组的指针</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> (*p)[<span class="hljs-number">3</span>];</code></pre></div><h3 id="定义一个形参为-int-返回值为int-的函数"><a href="#定义一个形参为-int-返回值为int-的函数" class="headerlink" title="定义一个形参为 int 返回值为int 的函数"></a>定义一个形参为 int 返回值为int 的函数</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;</code></pre></div><h3 id="定义一个形参为int-返回值为int-型指针的函数（指针函数）"><a href="#定义一个形参为int-返回值为int-型指针的函数（指针函数）" class="headerlink" title="定义一个形参为int 返回值为int 型指针的函数（指针函数）"></a>定义一个形参为int 返回值为int 型指针的函数（指针函数）</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;</code></pre></div><h3 id="定义一个指向形参为-int-返回值为int-的函数指针"><a href="#定义一个指向形参为-int-返回值为int-的函数指针" class="headerlink" title="定义一个指向形参为 int 返回值为int 的函数指针"></a>定义一个指向形参为 int 返回值为int 的函数指针</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> (*p)(<span class="hljs-type">int</span>);</code></pre></div><h3 id="定义一个长度为3的-指向形参为-int-返回值为int-的函数指针数组"><a href="#定义一个长度为3的-指向形参为-int-返回值为int-的函数指针数组" class="headerlink" title="定义一个长度为3的 指向形参为 int 返回值为int 的函数指针数组"></a>定义一个长度为3的 指向形参为 int 返回值为int 的函数指针数组</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> (*p[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>);</code></pre></div><h3 id="定义一个指向-形参为-int-返回值为int-型指针的函数指针"><a href="#定义一个指向-形参为-int-返回值为int-型指针的函数指针" class="headerlink" title="定义一个指向 形参为 int 返回值为int 型指针的函数指针"></a>定义一个指向 形参为 int 返回值为int 型指针的函数指针</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> *(*p)(<span class="hljs-type">int</span>);</code></pre></div><h3 id="定义一个长度为3的-指向-形参为-int-返回值为int-型指针的函数指针数组"><a href="#定义一个长度为3的-指向-形参为-int-返回值为int-型指针的函数指针数组" class="headerlink" title="定义一个长度为3的 指向 形参为 int 返回值为int 型指针的函数指针数组"></a>定义一个长度为3的 指向 形参为 int 返回值为int 型指针的函数指针数组</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> *(*p[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>);</code></pre></div><h3 id="定义函数-形参为-int-返回值为int-型指针的指针的函数-（返回的是二维数组，子数组长度为3）"><a href="#定义函数-形参为-int-返回值为int-型指针的指针的函数-（返回的是二维数组，子数组长度为3）" class="headerlink" title="定义函数 形参为 int 返回值为int 型指针的指针的函数 （返回的是二维数组，子数组长度为3）"></a>定义函数 形参为 int 返回值为int 型指针的指针的函数 （返回的是二维数组，子数组长度为3）</h3><p>这个很绕，不要轻易去推敲，基本用不到</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> *(*p(<span class="hljs-type">int</span>))[<span class="hljs-number">3</span>];<span class="hljs-comment">// return int shuzu[x][3]</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>C&amp;C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
      <tag>C&amp;C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSA秘钥对以及SSH登陆</title>
    <link href="/2022/02/16/NOTE/Linux/RSA%E7%A7%98%E9%92%A5%E5%AF%B9%E5%92%8CSSH%E7%99%BB%E9%99%86/"/>
    <url>/2022/02/16/NOTE/Linux/RSA%E7%A7%98%E9%92%A5%E5%AF%B9%E5%92%8CSSH%E7%99%BB%E9%99%86/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA秘钥对以及SSH登陆"><a href="#RSA秘钥对以及SSH登陆" class="headerlink" title="RSA秘钥对以及SSH登陆"></a>RSA秘钥对以及SSH登陆</h1><blockquote><p>信息的加密很重要</p></blockquote><h2 id="RSA秘钥对简介"><a href="#RSA秘钥对简介" class="headerlink" title="RSA秘钥对简介"></a>RSA秘钥对简介</h2><p>RSA<a href="https://baike.baidu.com/item/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/11048976">公开密钥密码体制</a>是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p><p><strong>密钥对：</strong>在非对称加密技术中，有两种密钥，分为私钥和公钥，私钥是密钥对所有者持有，不可公布，公钥是密钥对持有者公布给他人的。<br><strong>公钥：</strong>公钥用来给数据加密，用公钥加密的数据只能使用私钥解密<br><strong>私钥：</strong>如上，用来解密公钥加密的数据。<br><strong>摘要：</strong>对需要传输的文本，做一个HASH计算，一般采用SHA1，SHA2来获得<br><strong>签名：</strong>使用私钥对需要传输的文本的摘要进行加密，得到的密文即被称为该次传输过程的签名。（看最下面的一部分就明白了）<br><strong>签名验证</strong>：数据接收端，拿到传输文本，但是需要确认该文本是否就是发送发出的内容，中途是否曾经被篡改。因此拿自己持有的公钥对签名进行解密（密钥对中的一种密钥加密的数据必定能使用另一种密钥解密。），得到了文本的摘要，然后使用与发送方同样的HASH算法计算摘要值，再与解密得到的摘要做对比，发现二者完全一致，则说明文本没有被篡改过。<br><strong>加密：</strong>是将数据资料加密，使得非法用户即使取得加密过的资料，也无法获取正确的资料内容，所以数据加密可以保护数据，防止监听攻击。其重点在于数据的安全性。</p><h2 id="公开密钥过程"><a href="#公开密钥过程" class="headerlink" title="公开密钥过程"></a>公开密钥<strong>过程</strong></h2><p>比如有两个用户Alice和Bob，Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下：</p><ol><li><strong>Bob将他的公开密钥传送给Alice</strong>。</li><li><strong>Alice用Bob的公开密钥加密她的消息，然后传送给Bob</strong>。</li><li><strong>Bob用他的私人密钥解密Alice的消息</strong>。</li></ol><h2 id="SSH秘钥认证登陆"><a href="#SSH秘钥认证登陆" class="headerlink" title="SSH秘钥认证登陆"></a>SSH秘钥认证登陆</h2><p>一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</p><h3 id="1-制作密钥对"><a href="#1-制作密钥对" class="headerlink" title="1. 制作密钥对"></a>1. 制作密钥对</h3><p>首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">[root@host ~]$ ssh-keygen  &lt;== 建立密钥对Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/root/</span>.ssh/id_rsa): &lt;== 按 EnterCreated directory <span class="hljs-string">&#x27;/root/.ssh&#x27;</span>.Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): &lt;== 输入密钥锁码，或直接按 Enter 留空Enter same passphrase again: &lt;== 再输入一遍密钥锁码Your identification has been saved in <span class="hljs-regexp">/root/</span>.ssh/id_rsa. &lt;== 私钥Your <span class="hljs-keyword">public</span> key has been saved in <span class="hljs-regexp">/root/</span>.ssh/id_rsa.pub. &lt;== 公钥The key fingerprint is:<span class="hljs-number">0</span>f:d3:e7:<span class="hljs-number">1</span>a:<span class="hljs-number">1</span>c:bd:<span class="hljs-number">5</span>c:<span class="hljs-number">03</span>:f1:<span class="hljs-number">19</span>:f1:<span class="hljs-number">22</span>:df:<span class="hljs-number">9</span>b:cc:<span class="hljs-number">08</span> root@host</code></pre></div><p>密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。</p><p>现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。</p><h3 id="2-在服务器上安装公钥"><a href="#2-在服务器上安装公钥" class="headerlink" title="2. 在服务器上安装公钥"></a>2. 在服务器上安装公钥</h3><p>键入以下命令，在服务器上安装公钥：</p><div class="hljs code-wrapper"><pre><code class="hljs crystal">[root<span class="hljs-variable">@host</span> ~]<span class="hljs-variable">$ </span>cd .ssh[root<span class="hljs-variable">@host</span> .ssh]<span class="hljs-variable">$ </span>cat id_rsa.pub &gt;&gt; authorized_keys</code></pre></div><p>如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</p><div class="hljs code-wrapper"><pre><code class="hljs crystal">[root<span class="hljs-variable">@host</span> .ssh]<span class="hljs-variable">$ </span>chmod <span class="hljs-number">600</span> authorized_keys[root<span class="hljs-variable">@host</span> .ssh]<span class="hljs-variable">$ </span>chmod <span class="hljs-number">700</span> ~<span class="hljs-regexp">/.ssh</span></code></pre></div><h3 id="3-设置-SSH，打开密钥登录功能"><a href="#3-设置-SSH，打开密钥登录功能" class="headerlink" title="3. 设置 SSH，打开密钥登录功能"></a>3. 设置 SSH，打开密钥登录功能</h3><p>编辑 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 文件，进行如下设置：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">RSAAuthentication</span> <span class="hljs-literal">yes</span>PubkeyAuthentication <span class="hljs-literal">yes</span></code></pre></div><p>另外，请留意 root 用户能否通过 SSH 登录：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">PermitRootLogin</span> <span class="hljs-literal">yes</span></code></pre></div><p>当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录（可选）：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">PasswordAuthentication</span> <span class="hljs-literal">no</span></code></pre></div><p>最后，重启 SSH 服务：</p><div class="hljs code-wrapper"><pre><code class="hljs crystal">[root<span class="hljs-variable">@host</span> .ssh]<span class="hljs-variable">$ </span>service sshd restart</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 常用</title>
    <link href="/2022/01/07/NOTE/Linux/Ubuntu%E5%B8%B8%E7%94%A8/"/>
    <url>/2022/01/07/NOTE/Linux/Ubuntu%E5%B8%B8%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-常用"><a href="#Ubuntu-常用" class="headerlink" title="Ubuntu 常用"></a>Ubuntu 常用</h1><h2 id="1-开机自动运行"><a href="#1-开机自动运行" class="headerlink" title="1. 开机自动运行"></a>1. 开机自动运行</h2><h3 id="way-1-rc-local"><a href="#way-1-rc-local" class="headerlink" title="way 1. rc.local"></a>way 1. rc.local</h3><p>在 &#x2F;etc&#x2F;rc.local 下添加 要运行的命令，即可开机自动执行这些命令。</p><p>如：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh -e</span><span class="hljs-comment"># rc.local</span><span class="hljs-comment"># This script is executed at the end of each multiuser runlevel.</span><span class="hljs-comment"># Make sure that the script will &quot;exit 0&quot; on success or any other</span><span class="hljs-comment"># value on error.</span><span class="hljs-comment"># In order to enable or disable this script just change the execution</span><span class="hljs-comment"># bits.</span><span class="hljs-comment"># By default this script does nothing.</span><span class="hljs-built_in">cd</span>  /soft/nat123    --本地实际安装目录mono  nat123linux.sh  service  &amp;      ---自动读取上次成功登录帐号并以后台服务启动<span class="hljs-built_in">exit</span> 0</code></pre></div><hr><p>例外情况，可能会etc下没有 <code>rc.local</code> 文件，则需要按以下步骤启动 rc.local 服务</p><p><strong>1、设置rc-local.service</strong></p><p>创建并编辑 <code>sudo vim /etc/systemd/system/rc-local.service</code> </p><p>将以下内容复制进去</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span> <span class="hljs-attr">Description</span>=/etc/rc.local Compatibility <span class="hljs-attr">ConditionPathExists</span>=/etc/rc.local<span class="hljs-section">[Service]</span> <span class="hljs-attr">Type</span>=forking <span class="hljs-attr">ExecStart</span>=/etc/rc.local start <span class="hljs-attr">TimeoutSec</span>=<span class="hljs-number">0</span> <span class="hljs-attr">StandardOutput</span>=tty <span class="hljs-attr">RemainAfterExit</span>=<span class="hljs-literal">yes</span> <span class="hljs-attr">SysVStartPriority</span>=<span class="hljs-number">99</span><span class="hljs-section">[Install]</span> <span class="hljs-attr">WantedBy</span>=multi-user.target</code></pre></div><p><strong>2、激活rc-local.service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">sudo systemctl <span class="hljs-keyword">enable</span> rc-<span class="hljs-keyword">local</span>.service</code></pre></div><p><strong>3、添加启动服务</strong></p><p>手工创建或者拷贝已有的&#x2F;etc&#x2F;rc.local，并赋予执行权限</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh -e</span><span class="hljs-comment"># </span><span class="hljs-comment"># rc.local</span><span class="hljs-comment">#</span><span class="hljs-comment"># This script is executed at the end of each multiuser runlevel.</span><span class="hljs-comment"># Make sure that the script will &quot;exit 0&quot; on success or any other</span><span class="hljs-comment"># value on error.</span><span class="hljs-comment">#</span><span class="hljs-comment"># In order to enable or disable this script just change the execution</span><span class="hljs-comment"># bits.</span><span class="hljs-comment">#</span><span class="hljs-comment"># By default this script does nothing.</span><span class="hljs-comment"># 下面这条是要开机启动的命令</span>/home/selfcs/anaconda3/bin/Python /home/selfcs/t.py &gt; /home/selfcs/auto.log <span class="hljs-built_in">exit</span> 0</code></pre></div><p><strong>4、给予脚本执行权限</strong></p><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo chmod +x <span class="hljs-regexp">/etc/</span>rc.local</code></pre></div><h2 id="2-用户登录自动运行"><a href="#2-用户登录自动运行" class="headerlink" title="2. 用户登录自动运行"></a>2. 用户登录自动运行</h2><h3 id="1-在-x2F-etc-x2F-profile-里编辑"><a href="#1-在-x2F-etc-x2F-profile-里编辑" class="headerlink" title="1. 在 &#x2F;etc&#x2F;profile 里编辑"></a>1. 在 &#x2F;etc&#x2F;profile 里编辑</h3><h3 id="2-在-x2F-etc-x2F-profile-d-x2F-下-添加-sh-脚本"><a href="#2-在-x2F-etc-x2F-profile-d-x2F-下-添加-sh-脚本" class="headerlink" title="2. 在 &#x2F;etc&#x2F;profile.d&#x2F;下 添加 sh 脚本"></a>2. 在 &#x2F;etc&#x2F;profile.d&#x2F;下 添加 sh 脚本</h3><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> nat<span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> xxxkill -<span class="hljs-number">9</span>kill -<span class="hljs-number">15</span>xxx/xxx.<span class="hljs-keyword">sh</span> &amp;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt Note</title>
    <link href="/2021/12/23/NOTE/QT/PyQt/"/>
    <url>/2021/12/23/NOTE/QT/PyQt/</url>
    
    <content type="html"><![CDATA[<h1 id="PyQt-notes"><a href="#PyQt-notes" class="headerlink" title="PyQt notes"></a>PyQt notes</h1><h2 id="1-PyQt5-QML-界面"><a href="#1-PyQt5-QML-界面" class="headerlink" title="1. PyQt5 QML 界面"></a>1. PyQt5 QML 界面</h2><h3 id="py"><a href="#py" class="headerlink" title=".py"></a>.py</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt5.QtGui <span class="hljs-keyword">import</span> QGuiApplication<span class="hljs-keyword">from</span> PyQt5 <span class="hljs-keyword">import</span> QtQml<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    path = <span class="hljs-string">&#x27;QtQuick/test/qml/main.qml&#x27;</span>    app = QGuiApplication([])    engine = QtQml.QQmlApplicationEngine()    engine.load(path)    app.exec_()</code></pre></div><h3 id="main-qml"><a href="#main-qml" class="headerlink" title="main.qml"></a>main.qml</h3><div class="hljs code-wrapper"><pre><code class="hljs dts">import QtQuick <span class="hljs-number">2.12</span>import QtQuick.Controls <span class="hljs-number">2.12</span><span class="hljs-title class_">ApplicationWindow</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    id:</span> test<span class="hljs-symbol">    visible:</span> true<span class="hljs-symbol">    width:</span> <span class="hljs-number">400</span><span class="hljs-punctuation">;</span> height: <span class="hljs-number">700</span><span class="hljs-symbol">    color:</span> <span class="hljs-string">&quot;#ffffff&quot;</span>    <span class="hljs-title class_">Text</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        text:</span> <span class="hljs-string">&quot;hello world!&quot;</span><span class="hljs-punctuation">;</span>    <span class="hljs-punctuation">&#125;</span>        Button<span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        id:</span> btn        property alias cellColor1: btnColorRect.color<span class="hljs-comment">//cunstom var/property</span><span class="hljs-symbol"></span><span class="hljs-symbol">        text:</span> <span class="hljs-string">&quot;你好hello&quot;</span><span class="hljs-punctuation">;</span>        font.family: <span class="hljs-string">&quot;Alibaba puhuiti&quot;</span><span class="hljs-punctuation">;</span>         font.pointSize: <span class="hljs-number">13</span><span class="hljs-punctuation">;</span>         <span class="hljs-comment">// background.color: &quot;#aacccc&quot;</span><span class="hljs-symbol">        background:</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">            id:</span> btnColorRect            anchors.fill: parent<span class="hljs-symbol">            color:</span> <span class="hljs-string">&quot;#8000ff&quot;</span>        <span class="hljs-punctuation">&#125;</span>        anchors.centerIn: parent        MouseArea<span class="hljs-punctuation">&#123;</span>            anchors.fill: parent<span class="hljs-symbol">            hoverEnabled:</span> true<span class="hljs-symbol">            onEntered:</span><span class="hljs-punctuation">&#123;</span>                 btnColorRect.<span class="hljs-attr">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;#0000ff&quot;</span>                <span class="hljs-punctuation">&#125;</span><span class="hljs-symbol">            onExited:</span> <span class="hljs-punctuation">&#123;</span>                btnColorRect.<span class="hljs-attr">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;#8000ff&quot;</span>                <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">&#125;</span>    <span class="hljs-title class_">Grid</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        id:</span> colorGrid        <span class="hljs-comment">// x: 4; </span>        anchors<span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">            horizontalCenter:</span> parent.horizontalCenter<span class="hljs-symbol">            bottom:</span> parent.bottom<span class="hljs-symbol">            bottomMargin:</span> <span class="hljs-number">4</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-symbol">        rows:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">;</span> columns: <span class="hljs-number">3</span><span class="hljs-punctuation">;</span> spacing: <span class="hljs-number">3</span>        <span class="hljs-title class_">MyColorPicLabel</span> <span class="hljs-punctuation">&#123;</span> cellColor: <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">;</span> onClicked: btnColorRect.<span class="hljs-attr">color</span> <span class="hljs-operator">=</span> cellColor <span class="hljs-punctuation">&#125;</span>        <span class="hljs-title class_">MyColorPicLabel</span> <span class="hljs-punctuation">&#123;</span> cellColor: <span class="hljs-string">&quot;green&quot;</span><span class="hljs-punctuation">;</span> onClicked: btnColorRect.<span class="hljs-attr">color</span> <span class="hljs-operator">=</span> cellColor <span class="hljs-punctuation">&#125;</span>        <span class="hljs-title class_">MyColorPicLabel</span> <span class="hljs-punctuation">&#123;</span> cellColor: <span class="hljs-string">&quot;blue&quot;</span><span class="hljs-punctuation">;</span> onClicked: btnColorRect.<span class="hljs-attr">color</span> <span class="hljs-operator">=</span> cellColor <span class="hljs-punctuation">&#125;</span>        <span class="hljs-title class_">MyColorPicLabel</span> <span class="hljs-punctuation">&#123;</span> cellColor: <span class="hljs-string">&quot;yellow&quot;</span><span class="hljs-punctuation">;</span> onClicked: btnColorRect.<span class="hljs-attr">color</span> <span class="hljs-operator">=</span> cellColor <span class="hljs-punctuation">&#125;</span>        <span class="hljs-title class_">MyColorPicLabel</span> <span class="hljs-punctuation">&#123;</span> cellColor: <span class="hljs-string">&quot;steelblue&quot;</span><span class="hljs-punctuation">;</span> onClicked: btnColorRect.<span class="hljs-attr">color</span> <span class="hljs-operator">=</span> cellColor <span class="hljs-punctuation">&#125;</span>        <span class="hljs-title class_">MyColorPicLabel</span> <span class="hljs-punctuation">&#123;</span> cellColor: <span class="hljs-string">&quot;#ff0080&quot;</span><span class="hljs-punctuation">;</span> onClicked: btnColorRect.<span class="hljs-attr">color</span> <span class="hljs-operator">=</span> cellColor <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">&#125;</span></code></pre></div><h3 id="MyColorPicLabel-qml"><a href="#MyColorPicLabel-qml" class="headerlink" title="MyColorPicLabel.qml"></a>MyColorPicLabel.qml</h3><div class="hljs code-wrapper"><pre><code class="hljs maxima">import QtQuick <span class="hljs-number">2.4</span>Item &#123;    id: container    property <span class="hljs-built_in">alias</span> cellColor: <span class="hljs-built_in">rectangle</span>.<span class="hljs-built_in">color</span>//cunstom <span class="hljs-built_in">var</span>/property    signal clicked(<span class="hljs-built_in">color</span> cellColor)//singal    <span class="hljs-built_in">width</span>: <span class="hljs-number">70</span>; <span class="hljs-built_in">height</span>: <span class="hljs-number">40</span>    Rectangle &#123;        id: <span class="hljs-built_in">rectangle</span>        <span class="hljs-built_in">border</span>.<span class="hljs-built_in">color</span>: <span class="hljs-string">&quot;#380071&quot;</span>        <span class="hljs-built_in">border</span>.<span class="hljs-built_in">width</span>: <span class="hljs-number">2</span>        anchors.fill: parent    &#125;    MouseArea &#123;        anchors.fill: parent        hoverEnabled: <span class="hljs-literal">true</span>        onClicked: container.clicked(container.cellColor)//触发信号        onEntered:&#123;            // console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;hello&quot;</span>);            <span class="hljs-built_in">rectangle</span>.<span class="hljs-built_in">border</span>.<span class="hljs-built_in">width</span> = <span class="hljs-number">4</span>        &#125;        onExited:&#123;            // console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;no hello&quot;</span>);            <span class="hljs-built_in">rectangle</span>.<span class="hljs-built_in">border</span>.<span class="hljs-built_in">width</span> = <span class="hljs-number">2</span>        &#125;    &#125;&#125;</code></pre></div><h2 id="2-QML-与-Python-Class-互通"><a href="#2-QML-与-Python-Class-互通" class="headerlink" title="2. QML 与 Python Class 互通"></a>2. QML 与 Python Class 互通</h2><h3 id="python-class-定义要点"><a href="#python-class-定义要点" class="headerlink" title="python class 定义要点"></a>python class 定义要点</h3><ul><li>需要继承 QObject 类</li><li><code>__init__()</code> 函数需要调用父类的 构造函数</li><li>QML 里调用的函数必须是槽函数，用 @pyqtSlot(…) 修饰</li></ul><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyScreen</span>(<span class="hljs-title class_ inherited__">QObject</span>):    screens = QGuiApplication.screens()    screenCount = <span class="hljs-number">0</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 调用父类的__init__() 这样才能加载该类至 QML 里</span>        self.screens = QGuiApplication.screens()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.screens:            self.screenCount += <span class="hljs-number">1</span><span class="hljs-meta">    @pyqtSlot(<span class="hljs-params"><span class="hljs-built_in">int</span>, result=QRect</span>)</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getScreenSize</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span></span>):        <span class="hljs-string">&quot;&quot;&quot;[getScreenSize]</span><span class="hljs-string"></span><span class="hljs-string">        Args:</span><span class="hljs-string">            id ([int]): [id of screen]</span><span class="hljs-string"></span><span class="hljs-string">        Returns:</span><span class="hljs-string">            [QRect]: [screen&#x27;s size]</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">id</span> &gt;= self.screenCount <span class="hljs-keyword">or</span> <span class="hljs-built_in">id</span> &lt; <span class="hljs-number">0</span>):            <span class="hljs-keyword">return</span> QRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> self.screens[<span class="hljs-built_in">id</span>].geometry()<span class="hljs-meta">    @pyqtSlot(<span class="hljs-params">result=<span class="hljs-built_in">str</span></span>) </span><span class="hljs-comment"># 使用pyqtSlot() 修饰该函数，这样 QML 里才能知道函数的参数与返回值</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是python槽函数传递的字符串&quot;</span><span class="hljs-meta">    @pyqtSlot(<span class="hljs-params"><span class="hljs-built_in">str</span></span>)</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printlog</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span></span>):        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)</code></pre></div><h3 id="将python-class-加载进-QML"><a href="#将python-class-加载进-QML" class="headerlink" title="将python class 加载进 QML"></a>将python class 加载进 QML</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># create screen obejct</span>scr = MyScreen()<span class="hljs-comment"># 注册 Python 类至 QML 根节点</span>engine.rootContext().setContextProperty(<span class="hljs-string">&quot;scr&quot;</span>, scr)</code></pre></div><p>这样QML 里可以使用 scr 对象了。</p><h3 id="QML-信号定义和触发"><a href="#QML-信号定义和触发" class="headerlink" title="QML 信号定义和触发"></a>QML 信号定义和触发</h3><p>定义信号</p><div class="hljs code-wrapper"><pre><code class="hljs qml"><span class="hljs-title">ApplicationWindow</span> &#123;    <span class="hljs-attribute">id:</span><span class="hljs-string"> mainWin</span>    <span class="hljs-comment">// signal</span>    <span class="hljs-keyword">signal</span><span class="hljs-string"> myLogSignal</span>(<span class="hljs-built_in">string</span> log)    ....&#125;</code></pre></div><p>触发信号</p><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-tag">Button</span>&#123;    text: <span class="hljs-string">&quot;点我输出log&quot;</span>;    <span class="hljs-attribute">font</span><span class="hljs-selector-class">.family</span>: <span class="hljs-string">&quot;Alibaba puhuiti&quot;</span>;     <span class="hljs-attribute">font</span><span class="hljs-selector-class">.pointSize</span>: <span class="hljs-number">13</span>;         anchors<span class="hljs-selector-class">.horizontalCenter</span>: parent.horizontalCenter    anchors.bottom: btn1.top     anchors.bottomMargin: <span class="hljs-number">10</span>    MouseArea&#123;        anchors<span class="hljs-selector-class">.fill</span>: parent        onClicked:&#123;            mainWin<span class="hljs-selector-class">.myLogSignal</span>(&quot;我是QML 里信号发来的字符串&quot;)        &#125;    &#125;&#125;</code></pre></div><h3 id="QML-信号绑定-Python-槽函数"><a href="#QML-信号绑定-Python-槽函数" class="headerlink" title="QML 信号绑定 Python 槽函数"></a>QML 信号绑定 Python 槽函数</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># QML 信号连接 Python 槽函数</span>my_obj = engine.rootObjects()[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 获取根节点</span>my_obj.myLogSignal.connect(scr.printlog)    <span class="hljs-comment"># 绑定信号和槽</span></code></pre></div><h3 id="Python-调用QML-函数"><a href="#Python-调用QML-函数" class="headerlink" title="Python 调用QML 函数"></a>Python 调用QML 函数</h3><p>定义函数</p><div class="hljs code-wrapper"><pre><code class="hljs arcade">ApplicationWindow &#123;...  <span class="hljs-keyword">function</span> <span class="hljs-title function_">qmlLog</span>(<span class="hljs-params">str</span>)&#123;        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(str);    &#125;    ....&#125;</code></pre></div><p>python 调用</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># QML 信号连接 Python 槽函数</span>my_obj = engine.rootObjects()[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 获取根节点</span><span class="hljs-comment"># 调用QML 函数</span>my_obj.qmlLog(<span class="hljs-string">&quot;我是qml 函数输出的字符串&quot;</span>)</code></pre></div><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>main.py</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt5.QtCore <span class="hljs-keyword">import</span> QObject, QRect, pyqtSlot<span class="hljs-keyword">from</span> PyQt5 <span class="hljs-keyword">import</span> QtQml<span class="hljs-keyword">from</span> PyQt5.QtGui <span class="hljs-keyword">import</span> QGuiApplication<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyScreen</span>(<span class="hljs-title class_ inherited__">QObject</span>):    screens = QGuiApplication.screens()    screenCount = <span class="hljs-number">0</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 调用父类的__init__() 这样才能加载该类至 QML 里</span>        self.screens = QGuiApplication.screens()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.screens:            self.screenCount += <span class="hljs-number">1</span><span class="hljs-meta">    @pyqtSlot(<span class="hljs-params"><span class="hljs-built_in">int</span>, result=QRect</span>)</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getScreenSize</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span></span>):        <span class="hljs-string">&quot;&quot;&quot;[getScreenSize]</span><span class="hljs-string"></span><span class="hljs-string">        Args:</span><span class="hljs-string">            id ([int]): [id of screen]</span><span class="hljs-string"></span><span class="hljs-string">        Returns:</span><span class="hljs-string">            [QRect]: [screen&#x27;s size]</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">id</span> &gt;= self.screenCount <span class="hljs-keyword">or</span> <span class="hljs-built_in">id</span> &lt; <span class="hljs-number">0</span>):            <span class="hljs-keyword">return</span> QRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> self.screens[<span class="hljs-built_in">id</span>].geometry()<span class="hljs-meta">    @pyqtSlot(<span class="hljs-params">result=<span class="hljs-built_in">str</span></span>) </span><span class="hljs-comment"># 使用pyqtSlot() 修饰该函数，这样 QML 里才能知道函数的参数与返回值</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是python槽函数传递的字符串&quot;</span><span class="hljs-meta">    @pyqtSlot(<span class="hljs-params"><span class="hljs-built_in">str</span></span>)</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printlog</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span></span>):        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    path = <span class="hljs-string">&#x27;QtQuick/grabImage/qml/main.qml&#x27;</span>    app = QGuiApplication([])    engine = QtQml.QQmlApplicationEngine()    <span class="hljs-comment"># create screen obejct</span>    scr = MyScreen()    <span class="hljs-comment"># 注册 Python 类至 QML 根节点</span>    engine.rootContext().setContextProperty(<span class="hljs-string">&quot;scr&quot;</span>, scr)    engine.load(path)    <span class="hljs-comment"># QML 信号连接 Python 槽函数</span>    my_obj = engine.rootObjects()[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 获取根节点</span>    my_obj.myLogSignal.connect(scr.printlog)    <span class="hljs-comment"># 绑定信号和槽</span>    <span class="hljs-comment"># 调用QML 函数</span>    my_obj.qmlLog(<span class="hljs-string">&quot;我是qml 函数输出的字符串&quot;</span>)        app.exec_()</code></pre></div><p>main.qml</p><div class="hljs code-wrapper"><pre><code class="hljs qml"><span class="hljs-keyword">import</span> QtQuick <span class="hljs-number">2.12</span><span class="hljs-keyword">import</span> QtQuick.Controls <span class="hljs-number">2.12</span><span class="hljs-title">ApplicationWindow</span> &#123;    <span class="hljs-attribute">id:</span><span class="hljs-string"> mainWin</span>    <span class="hljs-attribute">visible</span>: <span class="hljs-literal">true</span>    <span class="hljs-attribute">width</span>: <span class="hljs-number">400</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">700</span>    <span class="hljs-attribute">color</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>    <span class="hljs-comment">// signal</span>    <span class="hljs-keyword">signal</span><span class="hljs-string"> myLogSignal</span>(<span class="hljs-built_in">string</span> log)    <span class="hljs-title">Text</span> &#123;        <span class="hljs-attribute">text</span>: <span class="hljs-string">&quot;hello world!&quot;</span>;    &#125;    <span class="hljs-title">Button</span>&#123;        <span class="hljs-attribute">id:</span><span class="hljs-string"> btn</span>        <span class="hljs-keyword">property</span><span class="hljs-string"> alias cellColor1</span>: btnColorRect.color<span class="hljs-comment">//cunstom var/property</span>        <span class="hljs-attribute">text</span>: <span class="hljs-string">&quot;你好hello&quot;</span>;        <span class="hljs-attribute">font.family</span>: <span class="hljs-string">&quot;Alibaba puhuiti&quot;</span>;         <span class="hljs-attribute">font.pointSize</span>: <span class="hljs-number">13</span>;         <span class="hljs-comment">// background.color: &quot;#aacccc&quot;</span>        <span class="hljs-attribute">background</span>: <span class="hljs-title">Rectangle</span> &#123;            <span class="hljs-attribute">id:</span><span class="hljs-string"> btnColorRect</span>            <span class="hljs-attribute">anchors.fill</span>: <span class="hljs-built_in">parent</span>            <span class="hljs-attribute">color</span>: <span class="hljs-string">&quot;#8000ff&quot;</span>        &#125;        <span class="hljs-attribute">anchors.centerIn</span>: <span class="hljs-built_in">parent</span>        <span class="hljs-title">MouseArea</span>&#123;            <span class="hljs-attribute">anchors.fill</span>: <span class="hljs-built_in">parent</span>            <span class="hljs-attribute">hoverEnabled</span>: <span class="hljs-literal">true</span>            <span class="hljs-attribute">onEntered</span>:&#123;                 btnColorRect.color = <span class="hljs-string">&quot;#0000ff&quot;</span>                &#125;            <span class="hljs-attribute">onExited</span>: &#123;                btnColorRect.color = <span class="hljs-string">&quot;#8000ff&quot;</span>                &#125;            <span class="hljs-attribute">onPressed</span>: &#123;                btnColorRect.color = <span class="hljs-string">&quot;#800008&quot;</span>            &#125;            <span class="hljs-attribute">onClicked</span>:&#123;                <span class="hljs-comment">// grabWin.setFlags(Qt::FramelessWindowHint)</span>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello world&quot;</span>);            &#125;        &#125;    &#125;    <span class="hljs-title">Button</span>&#123;        <span class="hljs-attribute">id:</span><span class="hljs-string"> btn1</span>        <span class="hljs-attribute">font.family</span>: <span class="hljs-string">&quot;Alibaba puhuiti&quot;</span>;         <span class="hljs-attribute">font.pointSize</span>: <span class="hljs-number">13</span>;         <span class="hljs-attribute">text</span>: <span class="hljs-string">&quot;点我输出屏幕2分辨率&quot;</span>;        <span class="hljs-keyword">property</span><span class="hljs-string"> rect sereen_size</span>: scr.getScreenSize(<span class="hljs-number">1</span>) <span class="hljs-comment">// get size of screen 2</span>                <span class="hljs-attribute">anchors.horizontalCenter</span>: <span class="hljs-built_in">parent</span>.horizontalCenter        <span class="hljs-attribute">anchors.bottom</span>: btn.top         <span class="hljs-attribute">anchors.bottomMargin</span>: <span class="hljs-number">10</span>        <span class="hljs-title">MouseArea</span>&#123;            <span class="hljs-attribute">anchors.fill</span>: <span class="hljs-built_in">parent</span>            <span class="hljs-attribute">onClicked</span>:&#123;                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;x =&quot;</span>, <span class="hljs-built_in">parent</span>.sereen_size.x)                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;y =&quot;</span>, <span class="hljs-built_in">parent</span>.sereen_size.y)                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;width =&quot;</span>, <span class="hljs-built_in">parent</span>.sereen_size.width)                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;height =&quot;</span>, <span class="hljs-built_in">parent</span>.sereen_size.height)            &#125;        &#125;    &#125;    <span class="hljs-title">Button</span>&#123;        <span class="hljs-attribute">text</span>: <span class="hljs-string">&quot;点我输出log&quot;</span>;        <span class="hljs-attribute">font.family</span>: <span class="hljs-string">&quot;Alibaba puhuiti&quot;</span>;         <span class="hljs-attribute">font.pointSize</span>: <span class="hljs-number">13</span>;                 <span class="hljs-attribute">anchors.horizontalCenter</span>: <span class="hljs-built_in">parent</span>.horizontalCenter        <span class="hljs-attribute">anchors.bottom</span>: btn1.top         <span class="hljs-attribute">anchors.bottomMargin</span>: <span class="hljs-number">10</span>        <span class="hljs-title">MouseArea</span>&#123;            <span class="hljs-attribute">anchors.fill</span>: <span class="hljs-built_in">parent</span>            <span class="hljs-attribute">onClicked</span>:&#123;                mainWin.myLogSignal(<span class="hljs-string">&quot;我是QML 里信号发来的字符串&quot;</span>)            &#125;        &#125;    &#125;    <span class="hljs-title">Grid</span> &#123;        <span class="hljs-attribute">id:</span><span class="hljs-string"> colorGrid</span>        <span class="hljs-comment">// x: 4; </span>        <span class="hljs-title">anchors</span>&#123;            <span class="hljs-attribute">horizontalCenter</span>: <span class="hljs-built_in">parent</span>.horizontalCenter            <span class="hljs-attribute">bottom</span>: <span class="hljs-built_in">parent</span>.bottom            <span class="hljs-attribute">bottomMargin</span>: <span class="hljs-number">4</span>        &#125;        <span class="hljs-attribute">rows</span>: <span class="hljs-number">2</span>; <span class="hljs-attribute">columns</span>: <span class="hljs-number">3</span>; <span class="hljs-attribute">spacing</span>: <span class="hljs-number">3</span>        <span class="hljs-title">MyColorPicLabel</span> &#123; <span class="hljs-attribute">cellColor</span>: <span class="hljs-string">&quot;red&quot;</span>; <span class="hljs-attribute">onClicked</span>: btnColorRect.color = cellColor &#125;        <span class="hljs-title">MyColorPicLabel</span> &#123; <span class="hljs-attribute">cellColor</span>: <span class="hljs-string">&quot;green&quot;</span>; <span class="hljs-attribute">onClicked</span>: btnColorRect.color = cellColor &#125;        <span class="hljs-title">MyColorPicLabel</span> &#123; <span class="hljs-attribute">cellColor</span>: <span class="hljs-string">&quot;blue&quot;</span>; <span class="hljs-attribute">onClicked</span>: btnColorRect.color = cellColor &#125;        <span class="hljs-title">MyColorPicLabel</span> &#123; <span class="hljs-attribute">cellColor</span>: <span class="hljs-string">&quot;yellow&quot;</span>; <span class="hljs-attribute">onClicked</span>: btnColorRect.color = cellColor &#125;        <span class="hljs-title">MyColorPicLabel</span> &#123; <span class="hljs-attribute">cellColor</span>: <span class="hljs-string">&quot;steelblue&quot;</span>; <span class="hljs-attribute">onClicked</span>: btnColorRect.color = cellColor &#125;        <span class="hljs-title">MyColorPicLabel</span> &#123; <span class="hljs-attribute">cellColor</span>: <span class="hljs-string">&quot;#ff0080&quot;</span>; <span class="hljs-attribute">onClicked</span>: btnColorRect.color = cellColor &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qmlLog</span>(<span class="hljs-params">str</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(str);    &#125;    &#125;</code></pre></div><p>MycolorPicLabel.qml</p><div class="hljs code-wrapper"><pre><code class="hljs maxima">import QtQuick <span class="hljs-number">2.4</span>Item &#123;    id: container    property <span class="hljs-built_in">alias</span> cellColor: <span class="hljs-built_in">rectangle</span>.<span class="hljs-built_in">color</span>//cunstom <span class="hljs-built_in">var</span>/property    signal clicked(<span class="hljs-built_in">color</span> cellColor)//singal    <span class="hljs-built_in">width</span>: <span class="hljs-number">70</span>; <span class="hljs-built_in">height</span>: <span class="hljs-number">40</span>    Rectangle &#123;        id: <span class="hljs-built_in">rectangle</span>        <span class="hljs-built_in">border</span>.<span class="hljs-built_in">color</span>: <span class="hljs-string">&quot;#380071&quot;</span>        <span class="hljs-built_in">border</span>.<span class="hljs-built_in">width</span>: <span class="hljs-number">2</span>        anchors.fill: parent    &#125;    MouseArea &#123;        anchors.fill: parent        hoverEnabled: <span class="hljs-literal">true</span>        onClicked: container.clicked(container.cellColor)//触发信号        onEntered:&#123;            // console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;hello&quot;</span>);            <span class="hljs-built_in">rectangle</span>.<span class="hljs-built_in">border</span>.<span class="hljs-built_in">width</span> = <span class="hljs-number">4</span>        &#125;        onExited:&#123;            // console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;no hello&quot;</span>);            <span class="hljs-built_in">rectangle</span>.<span class="hljs-built_in">border</span>.<span class="hljs-built_in">width</span> = <span class="hljs-number">2</span>        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>QT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Common License Manual</title>
    <link href="/2021/11/22/NOTE/Note/License%20manual/"/>
    <url>/2021/11/22/NOTE/Note/License%20manual/</url>
    
    <content type="html"><![CDATA[<h1 id="License-Manual"><a href="#License-Manual" class="headerlink" title="License Manual"></a>License Manual</h1><blockquote><p>坚持会将你指引到正确的道路上 —— firestaradmin</p></blockquote><p>如果开源的内容对你没有太大的利弊影响并且不想做太多限制，可以选择普遍且宽松的 MIT 许可证。</p><h2 id="MIT-License"><a href="#MIT-License" class="headerlink" title="MIT License"></a>MIT License</h2><p>限制及要求相对自由。</p><div class="hljs code-wrapper"><pre><code class="hljs">允许用于商业目的允许发行允许修改允许私人使用许可证和版权声明的副本必须随软件一起提供不承担一定的责任不提供任何保证</code></pre></div><h2 id="GNU-GPLv3-License-GNU-General-Public-License-v3-0"><a href="#GNU-GPLv3-License-GNU-General-Public-License-v3-0" class="headerlink" title="GNU GPLv3 License (GNU General Public License v3.0)"></a>GNU GPLv3 License (GNU General Public License v3.0)</h2><p>限制及要求相对较严格。</p><div class="hljs code-wrapper"><pre><code class="hljs">允许商业用途允许发行允许修改明确授予专利权允许私人使用必须公开源代码许可证和版权声明的副本必须随软件一起提供分发软件时必须以相同的许可证发布修改（在某些情况下可以使用类似或相关的许可证）对源代码的修改必须有文件记录不承担一定的责任不提供任何保证</code></pre></div><h2 id="Apache-License-2-0"><a href="#Apache-License-2-0" class="headerlink" title="Apache License 2.0"></a>Apache License 2.0</h2><p>限制及要求相对中性。</p><div class="hljs code-wrapper"><pre><code class="hljs">允许商业用途允许发行允许修改明确授予专利权允许私人使用许可证和版权声明的副本必须随软件一起提供对源代码的修改必须有文件记录不承担一定的责任不授予商标权不提供任何保证</code></pre></div><h2 id="BSD-2-Clause-“Simplified”-License"><a href="#BSD-2-Clause-“Simplified”-License" class="headerlink" title="BSD 2-Clause “Simplified” License"></a>BSD 2-Clause “Simplified” License</h2><p>限制及要求和 MIT 许可证相似。</p><div class="hljs code-wrapper"><pre><code class="hljs">允许用于商业目的允许发行允许修改允许私人使用许可证和版权声明的副本必须随软件一起提供不承担一定的责任不提供任何保证</code></pre></div><h2 id="BSD-3-Clause-“New”-or-“Revised”-License"><a href="#BSD-3-Clause-“New”-or-“Revised”-License" class="headerlink" title="BSD 3-Clause “New” or “Revised” License"></a>BSD 3-Clause “New” or “Revised” License</h2><p>限制及要求和 MIT 许可证相似。</p><div class="hljs code-wrapper"><pre><code class="hljs">允许用于商业目的允许发行允许修改允许私人使用许可证和版权声明的副本必须随软件一起提供不承担一定的责任不提供任何保证</code></pre></div><h2 id="Eclipse-Public-License-2-0"><a href="#Eclipse-Public-License-2-0" class="headerlink" title="Eclipse Public License 2.0"></a>Eclipse Public License 2.0</h2><div class="hljs code-wrapper"><pre><code class="hljs">允许商业用途允许发行允许修改明确授予专利权允许私人使用必须公开源代码许可证和版权声明的副本必须随软件一起提供分发软件时必须以相同的许可证发布修改（在某些情况下可以使用类似或相关的许可证）不承担一定的责任不提供任何保证</code></pre></div><h2 id="GNU-AGPLv3-GNU-Affero-General-Public-License-v3-0"><a href="#GNU-AGPLv3-GNU-Affero-General-Public-License-v3-0" class="headerlink" title="GNU AGPLv3 (GNU Affero General Public License v3.0)"></a>GNU AGPLv3 (GNU Affero General Public License v3.0)</h2><p>限制及要求更严格。</p><div class="hljs code-wrapper"><pre><code class="hljs">允许商业用途允许发行允许修改明确授予专利权允许私人使用必须公开源代码许可证和版权声明的副本必须随软件一起提供通过网络与软件进行交互的用户有权获得源代码的副本分发软件时必须以相同的许可证发布修改（在某些情况下可以使用类似或相关的许可证）对源代码的修改必须有文件记录不承担一定的责任不提供任何保证</code></pre></div><h2 id="GNU-GPLv2-GNU-General-Public-License-v2-0"><a href="#GNU-GPLv2-GNU-General-Public-License-v2-0" class="headerlink" title="GNU GPLv2 (GNU General Public License v2.0)"></a>GNU GPLv2 (GNU General Public License v2.0)</h2><p>相比于 GNU GPLv3 许可证，少了一条明确授予专利权。</p><div class="hljs code-wrapper"><pre><code class="hljs">允许商业用途允许发行允许修改允许私人使用必须公开源代码许可证和版权声明的副本必须随软件一起提供分发软件时必须以相同的许可证发布修改（在某些情况下可以使用类似或相关的许可证）对源代码的修改必须有文件记录不承担一定的责任不提供任何保证</code></pre></div><h2 id="GNU-LGPLv2-1-GNU-Lesser-General-Public-License-v2-1"><a href="#GNU-LGPLv2-1-GNU-Lesser-General-Public-License-v2-1" class="headerlink" title="GNU LGPLv2.1 (GNU Lesser General Public License v2.1)"></a>GNU LGPLv2.1 (GNU Lesser General Public License v2.1)</h2><p>相比于 GNU GPLv2 许可证，区别在相同许可证的限制。</p><div class="hljs code-wrapper"><pre><code class="hljs">允许商业用途允许发行允许修改允许私人使用必须公开源代码许可证和版权声明的副本必须随软件一起提供分发软件时必须以相同的许可证发布修改（在某些情况下可以使用类似或相关的许可证，或者这个条件可能不适用于将本软件作为库使用的作品）对源代码的修改必须有文件记录不承担一定的责任不提供任何保证</code></pre></div><h2 id="GNU-LGPLv3-0-GNU-Lesser-General-Public-License-v3-0"><a href="#GNU-LGPLv3-0-GNU-Lesser-General-Public-License-v3-0" class="headerlink" title="GNU LGPLv3.0 (GNU Lesser General Public License v3.0)"></a>GNU LGPLv3.0 (GNU Lesser General Public License v3.0)</h2><p>相比于 GNU GPLv3 许可证，区别在相同许可证的限制。</p><div class="hljs code-wrapper"><pre><code class="hljs">允许商业用途允许发行允许修改明确授予专利权允许私人使用必须公开源代码许可证和版权声明的副本必须随软件一起提供分发软件时必须以相同的许可证发布修改（在某些情况下可以使用类似或相关的许可证，或者这个条件可能不适用于将本软件作为库使用的作品）对源代码的修改必须有文件记录不承担一定的责任不提供任何保证</code></pre></div><h2 id="Mozilla-Public-License-2-0"><a href="#Mozilla-Public-License-2-0" class="headerlink" title="Mozilla Public License 2.0"></a>Mozilla Public License 2.0</h2><div class="hljs code-wrapper"><pre><code class="hljs">允许商业用途允许发行允许修改明确授予专利权允许私人使用必须公开源代码许可证和版权声明的副本必须随软件一起提供分发软件时必须以相同的许可证发布对现有文件的修改（在某些情况下可以使用类似或相关的许可证）不承担一定的责任不授予商标权不提供任何保证</code></pre></div><h2 id="The-Unlicense"><a href="#The-Unlicense" class="headerlink" title="The Unlicense"></a>The Unlicense</h2><div class="hljs code-wrapper"><pre><code class="hljs">允许商业用途允许发行允许修改允许私人使用不承担一定的责任不提供任何保证</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
      <tag>License</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git commit specification(Commit 规范)</title>
    <link href="/2021/11/19/NOTE/Note/Git%20commit%20specification/"/>
    <url>/2021/11/19/NOTE/Note/Git%20commit%20specification/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-commit-specification"><a href="#Git-commit-specification" class="headerlink" title="Git commit specification"></a>Git commit specification</h1><blockquote><p>裤裆里撒盐，闲。。 @firestaradmin</p></blockquote><p>When you commit a branch , you’d better to obey its specification.</p><p>![img](Git commit specification&#x2F;328599-20190123104458539-2041029483.png)</p><p>Sample:</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 新增一条 Commit 记录</span>git commit -m <span class="hljs-string">&#x27;chore(package.json): 新增 AngularJS 规范，Commit 时会自动调用钩子（GitHook）来判断 Message 是否有效&#x27;</span><span class="hljs-comment"># 搜索跟 package.json 文件相关的历史记录</span>git <span class="hljs-built_in">log</span> HEAD --grep chore(package.json)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用命令</title>
    <link href="/2021/11/19/NOTE/Note/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/11/19/NOTE/Note/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><p>@firestaradmin </p><blockquote><p>人生好像很没意思，但总有很多人在享受着生活，我也不例外</p></blockquote><hr><p>[TOC]</p><hr><h2 id="Base-cmd："><a href="#Base-cmd：" class="headerlink" title="Base cmd："></a>Base cmd：</h2><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git init</code></td><td>初始化仓库</td></tr><tr><td><code>git clone </code></td><td>拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><hr><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git add</code></td><td>添加文件到仓库</td></tr><tr><td><code>git status </code></td><td>查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td><code>git diff </code></td><td>比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td><code>git commit </code></td><td>提交暂存区到本地仓库。</td></tr><tr><td><code>git reset </code></td><td>回退版本。</td></tr><tr><td><code>git rm </code></td><td>删除工作区文件。</td></tr><tr><td><code>git mv </code></td><td>移动或重命名工作区文件。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git log</code></td><td>查看历史提交记录</td></tr><tr><td><code>git blame &lt;file&gt;        </code></td><td>以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git remote</code></td><td>远程仓库操作</td></tr><tr><td><code>git fetch </code></td><td>从远程获取代码库</td></tr><tr><td><code>git pull    </code></td><td>下载远程代码并合并</td></tr><tr><td><code>git push        </code></td><td>上传远程代码并合并</td></tr></tbody></table><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h3 id="Set-global-user-config"><a href="#Set-global-user-config" class="headerlink" title="Set global user config"></a>Set global user config</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;firestaradmin&quot;</span>git config --global user.email <span class="hljs-string">&quot;firestaradmin@xxx.com&quot;</span></code></pre></div><h3 id="List-config"><a href="#List-config" class="headerlink" title="List config"></a>List config</h3><p>List all global config:</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git config --global -l</code></pre></div><p>List all local config:</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git config --<span class="hljs-built_in">local</span> -l</code></pre></div><h3 id="Core-config"><a href="#Core-config" class="headerlink" title="Core config"></a>Core config</h3><p>Core config is set to process file before you push it.</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">core.autocrlf</span>=<span class="hljs-literal">false</span><span class="hljs-attr">core.ignorecase</span>=<span class="hljs-literal">false</span></code></pre></div><ul><li>autocrlf: whether the CRLF will be automatically converted.</li><li>ignorecase: whether case file name sensitve.</li></ul><h2 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h2><h3 id="Add-remote"><a href="#Add-remote" class="headerlink" title="Add remote"></a>Add remote</h3><div class="hljs code-wrapper"><pre><code class="hljs sh">git remote add origin http:xxxxxxxxxxx/xxxx/xx</code></pre></div><p>you can add multiple remotes, as follows:</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git remote add origin1 http:xxxxxxxxxxx/xxxx/xxgit remote add origin2 http:xxxxxxxxxxx/xxxx/xxgit remote add gitee http:xxxxxxxxxxx/xxxx/xx</code></pre></div><p>And then, you can push branch use the following command:</p><div class="hljs code-wrapper"><pre><code class="hljs sh">push originX localBranchX:remoteBranchX</code></pre></div><ul><li>originx: the remote repository name</li><li>localBranchX: the branch locally</li><li>remoteBranchX: the branch of the remote will be uploaded.</li></ul><h3 id="Rename-remote"><a href="#Rename-remote" class="headerlink" title="Rename remote"></a>Rename remote</h3><div class="hljs code-wrapper"><pre><code class="hljs sh">git remote rename origin old-origin</code></pre></div><h3 id="Check-remote-address"><a href="#Check-remote-address" class="headerlink" title="Check remote address"></a>Check remote address</h3><div class="hljs code-wrapper"><pre><code class="hljs sh">git remote -v</code></pre></div><h2 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h2><p>branch 是分支管理命令。</p><h3 id="Querrying-all-branches"><a href="#Querrying-all-branches" class="headerlink" title="Querrying all branches"></a>Querrying all branches</h3><div class="hljs code-wrapper"><pre><code class="hljs sh">git branch -avv</code></pre></div><h3 id="create-a-new-branch"><a href="#create-a-new-branch" class="headerlink" title="create a new branch"></a>create a new branch</h3><div class="hljs code-wrapper"><pre><code class="hljs sh">git branch (branchname)</code></pre></div><p>or</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git checkout -b local-branchname remote_name/remote_branchname</code></pre></div><p>  就可以新建本地 local-branchname 分支，并将远程分支映射到该分支，且设置追踪。</p><h3 id="change-current-branch"><a href="#change-current-branch" class="headerlink" title="change current branch"></a>change current branch</h3><div class="hljs code-wrapper"><pre><code class="hljs sh">git checkout (branchname)</code></pre></div><p>or</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git checkout -b (branchname)</code></pre></div><p>if you add <code>-b</code> , will auto create a new branch if the repository does not have it.</p><h3 id="delete-branch"><a href="#delete-branch" class="headerlink" title="delete branch"></a>delete branch</h3><p>delete local branch:</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git branch -d (branchname)</code></pre></div><p>delete remote branch:</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git push origin --delete master</code></pre></div><p>or</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git push origin :master</code></pre></div><h3 id="Merge-branch"><a href="#Merge-branch" class="headerlink" title="Merge branch"></a>Merge branch</h3><p>合并前要先切回要并入的分支<br>以下表示要把issue1234分支合并入master分支</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git checkout mastergit merge issue1234</code></pre></div><hr><h2 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h2><p>Normall, need use <code>git fetch</code> before pull a branch form remote.</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git fetch</code></pre></div><p>将远程分支test_remote拉取下来到本地test分支, 如果本地没有该分支，自动创建</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git checkout -b <span class="hljs-built_in">test</span> origin/test_remote</code></pre></div><p>从远程分支test 中checkout下来的本地分支test成为跟踪分支，使用git pull或者git push就会操作到对应的远程分支test</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git pull <span class="hljs-built_in">test</span></code></pre></div><hr><h2 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h2><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。 </p><p>命令格式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></pre></div><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</code></pre></div><hr><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p><p>**一般用于删除远程commit，比如错误的上传了commit4，不想要了，可以回退到commit3，然后重新push，加上 **</p><p><strong>–force 就会吧commit3之后的commit 全部删除，谨慎使用！</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">git push --force origin master</code></pre></div><blockquote><p>智能人性化提示：在操作过程中，可能会需要使用 Clean 指令，删除Untracked file。</p></blockquote><hr><p>删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git push origin --delete master</code></pre></div><hr><p>当你每次输入 git push origin master:master，是不是很麻烦</p><p>使用 <code>-u</code> 选项，输入一次命令，就可以直接跟踪本地分支和远程分支，以后在本分支下就直接输入 git push 即可</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git push -u origin master:master</code></pre></div><h2 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h2><h3 id="Submit-a-commit"><a href="#Submit-a-commit" class="headerlink" title="Submit a commit"></a>Submit a commit</h3><div class="hljs code-wrapper"><pre><code class="hljs sh">git commit -m <span class="hljs-string">&quot;这里是提交的说明信息&quot;</span></code></pre></div><h3 id="Undo-a-commit"><a href="#Undo-a-commit" class="headerlink" title="Undo a commit"></a>Undo a commit</h3><p>commit 之后想撤回咋办?</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git reset --soft HEAD^</code></pre></div><p>这样就成功的撤销了你的commit</p><p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><h3 id="Change-commit"><a href="#Change-commit" class="headerlink" title="Change commit"></a>Change commit</h3><p>commit 后发现写错了 信息，可以重写</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git commit --amend</code></pre></div><p> 此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p><h2 id="Clean-删除-untracked-files"><a href="#Clean-删除-untracked-files" class="headerlink" title="Clean (删除 untracked files)"></a>Clean (删除 untracked files)</h2><p>删除 untracked files</p><p><code>git clean -f</code></p><hr><p>连 untracked 的目录也一起删掉</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git clean -fd</code></pre></div><hr><p>连 gitignore 的untrack 文件&#x2F;目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git clean -xfd</code></pre></div><p><strong>在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">git clean -nxfdgit clean -nfgit clean -nfd</code></pre></div><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><h3 id="git查询本地所有tag"><a href="#git查询本地所有tag" class="headerlink" title="git查询本地所有tag"></a>git查询本地所有tag</h3><div class="hljs code-wrapper"><pre><code class="hljs sh">git tag</code></pre></div><h3 id="本地新增无备注的tag"><a href="#本地新增无备注的tag" class="headerlink" title="本地新增无备注的tag"></a>本地新增无备注的tag</h3><p>（默认在当前分支最后一个commit上添加tag）</p><p><code>git tag 标签名</code></p><div class="hljs code-wrapper"><pre><code class="hljs sh">git tag v1.1.0</code></pre></div><h3 id="本地新增有备注的tag"><a href="#本地新增有备注的tag" class="headerlink" title="本地新增有备注的tag"></a>本地新增有备注的tag</h3><p>（默认在当前分支最后一个commit上添加tag）</p><p><code>git tag -a 标签名 -m “备注内容”</code></p><div class="hljs code-wrapper"><pre><code class="hljs sh">git tag -a v1.1.1 -m <span class="hljs-string">&quot;测试&quot;</span></code></pre></div><h3 id="在指定commit上新增tag"><a href="#在指定commit上新增tag" class="headerlink" title="在指定commit上新增tag"></a>在指定commit上新增tag</h3><p><code>git tag 标签名 commit</code>（前几位也可以，尝试过最低3位报错，最好5位以上）</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git tag v1.1.0  105851905c8a0f9cc040cf845b35c1ced1963fcc</code></pre></div><h3 id="将tag推送到远程分支"><a href="#将tag推送到远程分支" class="headerlink" title="将tag推送到远程分支"></a>将tag推送到远程分支</h3><p><code>git push origin 标签名</code></p><div class="hljs code-wrapper"><pre><code class="hljs sh">git push origin v1.1.0</code></pre></div><h3 id="删除本地分支标签"><a href="#删除本地分支标签" class="headerlink" title="删除本地分支标签"></a>删除本地分支标签</h3><p><code>git tag -d 标签名</code></p><div class="hljs code-wrapper"><pre><code class="hljs sh">git tag -d v1.1.0</code></pre></div><h3 id="删除远程分支标签"><a href="#删除远程分支标签" class="headerlink" title="删除远程分支标签"></a>删除远程分支标签</h3><p><code>git push origin :refs/tags/标签名</code></p><div class="hljs code-wrapper"><pre><code class="hljs sh">git push origin :refs/tags/v1.1.0</code></pre></div><p> or</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> push origin :v1.<span class="hljs-number">1</span>.<span class="hljs-number">0</span></code></pre></div><p>or</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git push origin --delete <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">1.0</span></code></pre></div><h3 id="Show-tag-info"><a href="#Show-tag-info" class="headerlink" title="Show tag info"></a>Show tag info</h3><div class="hljs code-wrapper"><pre><code class="hljs sh">git show tagXX</code></pre></div><ul><li>tagXX: tag name</li></ul><h2 id="rm-x2F-Reset-undo"><a href="#rm-x2F-Reset-undo" class="headerlink" title="rm&#x2F;Reset (undo)"></a>rm&#x2F;Reset (undo)</h2><h3 id="仅仅删除暂存区里的文件"><a href="#仅仅删除暂存区里的文件" class="headerlink" title="仅仅删除暂存区里的文件"></a>仅仅删除暂存区里的文件</h3><p>此时你想撤销错误添加到暂存区里的文件，可以输入以下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs ada">git rm <span class="hljs-comment">--cache 文件名</span></code></pre></div><h3 id="删除暂存区和工作区的文件"><a href="#删除暂存区和工作区的文件" class="headerlink" title="删除暂存区和工作区的文件"></a>删除暂存区和工作区的文件</h3><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 文件名</code></pre></div><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>有时，不仅添加到了暂存区，而且commit到了版本库，这个时候就不能使用git rm了，需要使用git reset命令。</p><p><strong>错误提交到了版本库，此时无论工作区、暂存区，还是版本库，这三者的内容都是一样的</strong>，所以在这种情况下，只是删除了工作区和暂存区的文件，下一次用该版本库回滚那个误添加的文件还会重新生成。</p><p>这个时候，我们必须撤销版本库的修改才能解决问题！</p><p>一般指令为:</p><div class="hljs code-wrapper"><pre><code class="hljs sh">git reset HEAD^</code></pre></div><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><p>可以加一些选项，如在commit后使用一下指令：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft HEAD^</span></code></pre></div><p>这样就成功的撤销了你的commit</p><p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p><p>选项：</p><ul><li><p>–mixed </p><p>  意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作</p><p>  这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p></li><li><p>–soft  </p><p>  不删除工作空间改动代码，撤销commit，不撤销git add . </p></li><li><p>–hard</p><p>  删除工作空间改动代码，撤销commit，撤销git add . </p><p>  注意完成这个操作后，就恢复到了上一次的commit状态。</p></li></ul><h2 id="git-submodule-子模块"><a href="#git-submodule-子模块" class="headerlink" title="git submodule 子模块"></a>git submodule 子模块</h2><p>Git一个项目中引用其他Git仓库</p><div class="hljs code-wrapper"><pre><code class="hljs sh">// git submodule add [git地址] [目录位置]$ git submodule add https://xxx/gittest.git src/gittest</code></pre></div><p>使用submodule后 在当前git目录下会生成一个 .gitmodules 文件</p><p>如果但当前目录已经存在了一个 .gitmodules，命令需要更改为</p><div class="hljs code-wrapper"><pre><code class="hljs sh">$ git submodule add -f https://xxx/gittest.git src/gittest</code></pre></div><p>目录存放位置如果设置，会将clone下来的仓库存放在指定位置, 默认在当前目录下</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p><code>.gitignore</code>  file is a very useable file in git system.</p><p>it can help you to ignore some files you do not want upload to repository.</p><p>Format:</p><div class="hljs code-wrapper"><pre><code class="hljs swift">mtk<span class="hljs-operator">/</span> 过滤整个文件夹<span class="hljs-operator">*</span>.zip 过滤所有.zip文件mtk<span class="hljs-operator">/</span><span class="hljs-keyword">do</span>.c 过滤某个具体文件</code></pre></div><p>以上规则意思是：被过滤掉的文件就不会出现在你的GitHub库中了，当然本地库中还有，只是push的时候不会上传。</p><p>除了以上规则，它还可以指定要将哪些文件添加到版本管理中。</p><p>如 <code>project</code> 文件夹除了 <code>stm32.proj</code> 文件其他都忽略，示例：</p><div class="hljs code-wrapper"><pre><code class="hljs swift">project<span class="hljs-comment">/*</span><span class="hljs-comment">!project/stm32.proj</span></code></pre></div><p>当你需要不过滤一个特定文件时，该文件夹一定不能直接屏蔽，即 <code>project/</code> ， 这样就算底下设置了 <code>!peoject/xxx.xx</code> 也不会上传该文件。 一定要使用 <code>project/*</code>  这样子来过滤所有文件。</p><p>当有多级目录时，需要加入某个特定文件时：</p><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">//错误写法</span>**<span class="hljs-regexp">/node_modules/</span>*<span class="hljs-comment">//忽略文件夹node_modules</span>!**<span class="hljs-regexp">/node_modules/</span>vue-html5-editor/dist/  <span class="hljs-comment">//这样写是不生效的</span><span class="hljs-comment">//正确写法</span>**<span class="hljs-regexp">/node_modules/</span>*!**<span class="hljs-regexp">/node_modules/</span>vue-html5-editor/**<span class="hljs-regexp">/node_modules/</span>vue-html5-editor<span class="hljs-comment">/*</span><span class="hljs-comment">!**/</span>node_modules/vue-html5-editor/dist</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏定义log输出</title>
    <link href="/2021/11/10/NOTE/C&amp;C++/%E5%AE%8F%E5%AE%9A%E4%B9%89log%E8%BE%93%E5%87%BA/"/>
    <url>/2021/11/10/NOTE/C&amp;C++/%E5%AE%8F%E5%AE%9A%E4%B9%89log%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="log输出宏定义"><a href="#log输出宏定义" class="headerlink" title="log输出宏定义"></a>log输出宏定义</h1><blockquote><p>丈夫非无泪，不洒离别间。</p></blockquote><p>首先看几个编译器预定义的变量</p><p>C&amp;C++预处理器定义了几个对于程序调试很有用的名字：</p><ul><li><code>__func__</code>存放函数的名字</li><li><code>__FILE__</code>存放文件名的字符串字面值</li><li><code>__LINE__</code>存放当前行号的整型字面值</li><li><code>__TIME__</code>存放文件编译时间的字符串字面值</li><li><code>__DATE__</code>存放文件编译日期的字符串字面值</li></ul><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s hello&quot;</span>, __func__);&#125;</code></pre></div><p>则会输出：</p><blockquote><p>main hello</p></blockquote><p>调试的时候非常方便看是哪里输出的：</p><p><img src="/2021/11/10/NOTE/C&C++/%E5%AE%8F%E5%AE%9A%E4%B9%89log%E8%BE%93%E5%87%BA/image-20211110151723335.png" alt="image-20211110151723335"></p><p>看到这里懂了吧。那么想不想拥有它呢，接着看吧。</p><h2 id="一、使用C-类特性的宏定义"><a href="#一、使用C-类特性的宏定义" class="headerlink" title="一、使用C++ 类特性的宏定义"></a>一、使用C++ 类特性的宏定义</h2><p>这里我们需要定义一个类如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-string">&quot;.h&quot;</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> AHINFO\</span><span class="hljs-meta">    AH_LOG::getinstance().printTitle(__func__, <span class="hljs-string">&quot;Info&quot;</span>).printS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AHWARNING\</span><span class="hljs-meta">    AH_LOG::getinstance().printTitle(__func__, <span class="hljs-string">&quot;Warning&quot;</span>).printS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AHERROR\</span><span class="hljs-meta">    AH_LOG::getinstance().printTitle(__func__, <span class="hljs-string">&quot;Error&quot;</span>).printS</span>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">AH_LOG</span>&#123;    <span class="hljs-built_in">AH_LOG</span>();    ~<span class="hljs-built_in">AH_LOG</span>();  <span class="hljs-keyword">public</span>:    <span class="hljs-function">AH_LOG &amp;<span class="hljs-title">printS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span></span>;    <span class="hljs-function">AH_LOG &amp;<span class="hljs-title">printTitle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *funcName, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span></span>;    <span class="hljs-function"><span class="hljs-type">static</span> AH_LOG &amp;<span class="hljs-title">getinstance</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 返回自己</span>  <span class="hljs-keyword">private</span>:    <span class="hljs-type">static</span> AH_LOG* singleInstance;  <span class="hljs-comment">// 声明一个静态类</span>&#125;;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-string">&quot;.cpp&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AH_log.hpp&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>    AH_LOG* AH_LOG::singleInstance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AH_LOG</span>();<span class="hljs-function">AH_LOG &amp;<span class="hljs-title">AH_LOG::printS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span></span>&#123;    <span class="hljs-type">char</span> log[<span class="hljs-number">500</span>] = &#123;<span class="hljs-number">0</span>&#125;;    va_list args;    <span class="hljs-built_in">va_start</span>(args, fmt);    <span class="hljs-built_in">vsnprintf</span>(log, <span class="hljs-built_in">sizeof</span>(log) - <span class="hljs-number">1</span>, fmt, args);    <span class="hljs-built_in">va_end</span>(args);    std::cout &lt;&lt; log;    <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)        std::cout &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-function">AH_LOG &amp;<span class="hljs-title">AH_LOG::printTitle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *funcName, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span></span><span class="hljs-function"></span>&#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;] @&quot;</span> &lt;&lt; funcName &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-function">AH_LOG &amp;<span class="hljs-title">AH_LOG::getinstance</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> *singleInstance;&#125;</code></pre></div><p>总的来说就是定义一个返回自己的打印 log 头信息的函数，返回自己后再调用其自定义的PrintS 函数。 大家可以发挥创意，根据需要自己设计自己的LOG 输出函数。</p><p>后面会有完整例程。</p><h2 id="二、使用宏定义-VA-ARGS-输出log"><a href="#二、使用宏定义-VA-ARGS-输出log" class="headerlink" title="二、使用宏定义(__VA_ARGS__)输出log"></a>二、使用宏定义(<code>__VA_ARGS__</code>)输出log</h2><p>这个特性是可以C 和 C++ 通用的。 如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(...)    printf(__VA_ARGS__)</span></code></pre></div><p>这样子 我们使用 <code>LOG(&quot;hello&quot;);</code> 就相当于 <code>printf(&quot;hello&quot;);</code> 了</p><p>示例如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;.h&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UGPRINT(...)    printS(__VA_ARGS__)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UGINFO(...)     printLogS(__func__, <span class="hljs-string">&quot; info&quot;</span>, __VA_ARGS__)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UGDEBUG(...)    printLogS(__func__, <span class="hljs-string">&quot;debug&quot;</span>, __VA_ARGS__)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UGERROR(...)    printLogS(__func__, <span class="hljs-string">&quot;error&quot;</span>, __VA_ARGS__)</span><span class="hljs-type">void</span> <span class="hljs-title function_">printS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">printLogS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* funcname,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">ug_log_hal_print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span>;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* C libs */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-comment">/* my libs */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_log.h&quot;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">printS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span>&#123;    <span class="hljs-type">char</span> <span class="hljs-built_in">log</span>[<span class="hljs-number">300</span>] = &#123;<span class="hljs-number">0</span>&#125;;    va_list args;    va_start(args, fmt);    vsnprintf(<span class="hljs-built_in">log</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">log</span>) - <span class="hljs-number">1</span>, fmt, args);    va_end(args);    ug_log_hal_print(<span class="hljs-built_in">log</span>);    <span class="hljs-comment">// if(log[strlen(log)] != &#x27;\n&#x27;)</span>    <span class="hljs-comment">//     ug_log_hal_print(&quot;\n&quot;);</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">printLogS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* funcname,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span>&#123;    <span class="hljs-type">char</span> <span class="hljs-built_in">log</span>[<span class="hljs-number">300</span>] = &#123;<span class="hljs-number">0</span>&#125;;    va_list args;    va_start(args, fmt);    vsnprintf(<span class="hljs-built_in">log</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">log</span>) - <span class="hljs-number">1</span>, fmt, args);    va_end(args);    ug_log_hal_print(<span class="hljs-string">&quot;[&quot;</span>);    ug_log_hal_print(type);    ug_log_hal_print(<span class="hljs-string">&quot;] @&quot;</span>);    ug_log_hal_print(funcname);    ug_log_hal_print(<span class="hljs-string">&quot; &quot;</span>);    ug_log_hal_print(<span class="hljs-built_in">log</span>);    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>[<span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">log</span>)] != <span class="hljs-string">&#x27;\n&#x27;</span>)        ug_log_hal_print(<span class="hljs-string">&quot;\n&quot;</span>);&#125;__attribute__((weak)) <span class="hljs-type">void</span> <span class="hljs-title function_">ug_log_hal_print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span>&#123;    <span class="hljs-comment">/* HAL Lib sample */</span>    <span class="hljs-comment">// uint32_t cnt = 0;</span>    <span class="hljs-comment">// while (str[cnt++] != &#x27;\0&#x27;);</span>    <span class="hljs-comment">// HAL_UART_Transmit(&amp;UART1_Handler, str, cnt-1, 500);</span>    <span class="hljs-comment">/* STD Lib sample */</span>    <span class="hljs-comment">// UartSendStr(USART1, str);</span>&#125;</code></pre></div><h2 id="三、完整示例"><a href="#三、完整示例" class="headerlink" title="三、完整示例"></a>三、完整示例</h2><h4 id="1-C-类特性示例代码"><a href="#1-C-类特性示例代码" class="headerlink" title="1. C++ 类特性示例代码"></a>1. C++ 类特性示例代码</h4><h5 id="hpp"><a href="#hpp" class="headerlink" title=".hpp"></a>.hpp</h5><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*! @file AH_log.hpp</span><span class="hljs-comment"> *  @version 0.0.1</span><span class="hljs-comment"> *  @date April 07 2021</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  @brief</span><span class="hljs-comment"> *  Print and out log info.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __AH_LOG_HPP_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __AH_LOG_HPP_</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-comment">// store log file local</span><span class="hljs-comment">// #define LOG_LOCALL_STORE</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(LOG_LOCALL_STORE)</span><span class="hljs-keyword">extern</span> std::ofstream g_logFile;  <span class="hljs-comment">// log file handle</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-keyword">namespace</span> AH&#123;<span class="hljs-meta">#<span class="hljs-keyword">define</span> AHINFO\</span><span class="hljs-meta">    AH_LOG::getinstance().printTitle(__func__, <span class="hljs-string">&quot;Info&quot;</span>).printS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AHWARNING\</span><span class="hljs-meta">    AH_LOG::getinstance().printTitle(__func__, <span class="hljs-string">&quot;Warning&quot;</span>).printS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AHERROR\</span><span class="hljs-meta">    AH_LOG::getinstance().printTitle(__func__, <span class="hljs-string">&quot;Error&quot;</span>).printS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AHTIPS\</span><span class="hljs-meta">    AH_LOG::getinstance().printTitle(__func__, <span class="hljs-string">&quot;Tips&quot;</span>).printS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AHACTION\</span><span class="hljs-meta">    AH_LOG::getinstance().printTitle(__func__, <span class="hljs-string">&quot;Action&quot;</span>).printS</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">AH_Log_Mode</span> &#123;    LOG_MODE_DEFAULT = <span class="hljs-number">0</span>,    LOG_MODE_SIMPLE,    LOG_MODE_COMPLEX,    LOG_MODE_STORE_LOCALLY&#125; AH_Log_Mode;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">AH_Log_Type</span> &#123;    LOG_TYPE_INFO = <span class="hljs-number">0</span>,    LOG_TYPE_WARNING,    LOG_TYPE_ACTION,    LOG_TYPE_TIPS,    LOG_TYPE_ERROR&#125; AH_Log_Type;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AH_LOG</span>&#123;    <span class="hljs-built_in">AH_LOG</span>();    ~<span class="hljs-built_in">AH_LOG</span>();  <span class="hljs-keyword">public</span>:    <span class="hljs-function">AH_LOG &amp;<span class="hljs-title">printS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span></span>;    <span class="hljs-function">AH_LOG &amp;<span class="hljs-title">printTitle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *funcName, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span></span>;    <span class="hljs-function"><span class="hljs-type">static</span> AH_LOG &amp;<span class="hljs-title">getinstance</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 返回自己</span>  <span class="hljs-keyword">private</span>:    <span class="hljs-function">tm *<span class="hljs-title">getSystemTime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;    <span class="hljs-type">static</span> AH_LOG* singleInstance;  <span class="hljs-comment">// 声明一个静态类</span>    <span class="hljs-type">bool</span> storeLocall = <span class="hljs-literal">false</span>;        <span class="hljs-type">time_t</span> tt;  <span class="hljs-comment">// time for log output.</span>    <span class="hljs-type">char</span> fileName[<span class="hljs-number">255</span>];&#125;;&#125;;     <span class="hljs-comment">// namespace AH</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// !__AH_LOG_HPP_</span></span></code></pre></div><h5 id="cpp"><a href="#cpp" class="headerlink" title=".cpp"></a>.cpp</h5><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*! @file AH_log.cpp</span><span class="hljs-comment"> *  @version 0.0.1</span><span class="hljs-comment"> *  @date April 07 2021</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  @brief</span><span class="hljs-comment"> *  Print and out log info.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AH_log.hpp&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(LOG_LOCALL_STORE)</span>std::ofstream g_logFile;  <span class="hljs-comment">// log file handle</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><span class="hljs-keyword">namespace</span> AH&#123;AH_LOG* AH_LOG::singleInstance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AH_LOG</span>();AH_LOG::<span class="hljs-built_in">AH_LOG</span>()&#123;        <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(LOG_LOCALL_STORE)</span>    tm *time = <span class="hljs-built_in">getSystemTime</span>();    <span class="hljs-comment">// AHINFO(&quot;Current system time: %d-%02d-%02d %02d:%02d:%02d&quot;,    </span>    <span class="hljs-comment">//         time-&gt;tm_year + 1900,</span>    <span class="hljs-comment">//         time-&gt;tm_mon + 1,</span>    <span class="hljs-comment">//         time-&gt;tm_mday,</span>    <span class="hljs-comment">//         time-&gt;tm_hour,</span>    <span class="hljs-comment">//         time-&gt;tm_min,</span>    <span class="hljs-comment">//         time-&gt;tm_sec);</span>    <span class="hljs-comment">// AHINFO(&quot;Create Log File.&quot;);</span>    <span class="hljs-built_in">sprintf</span>(fileName, <span class="hljs-string">&quot;/home/dji/osdkDemo/Log--%d-%02d-%02d--%02d:%02d.txt&quot;</span>,            time-&gt;tm_year + <span class="hljs-number">1900</span>,            time-&gt;tm_mon + <span class="hljs-number">1</span>,            time-&gt;tm_mday,            time-&gt;tm_hour,            time-&gt;tm_min);    g_logFile.<span class="hljs-built_in">open</span>(fileName , std::ios::app);          <span class="hljs-keyword">if</span> (g_logFile.<span class="hljs-built_in">is_open</span>())    &#123;        <span class="hljs-comment">// AHINFO(&quot;open file success&quot;);</span>                <span class="hljs-comment">// logFile &lt;&lt; &quot;This is a line.\n&quot;;</span>        <span class="hljs-comment">// logFile &lt;&lt; &quot;This is another line.\n&quot;; </span>        <span class="hljs-comment">// g_logFile.close();</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;AH_LOG::~<span class="hljs-built_in">AH_LOG</span>()&#123;    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(LOG_LOCALL_STORE)</span>    g_logFile.<span class="hljs-built_in">close</span>();    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">format for tm*</span><span class="hljs-comment">    AHINFO(&quot;current Time:%d-%02d-%02d %02d:%02d:%02d&quot;,    </span><span class="hljs-comment">            time-&gt;tm_year + 1900,</span><span class="hljs-comment">            time-&gt;tm_mon + 1,</span><span class="hljs-comment">            time-&gt;tm_mday,</span><span class="hljs-comment">            time-&gt;tm_hour,</span><span class="hljs-comment">            time-&gt;tm_min,</span><span class="hljs-comment">            time-&gt;tm_sec);</span><span class="hljs-comment">*/</span><span class="hljs-function">tm* <span class="hljs-title">AH_LOG::getSystemTime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">time</span>( &amp;tt );    tt = tt + <span class="hljs-number">8</span>*<span class="hljs-number">3600</span>;  <span class="hljs-comment">// transform the time zone</span>    tm* t= <span class="hljs-built_in">gmtime</span>( &amp;tt );    <span class="hljs-keyword">return</span> t;&#125;<span class="hljs-function">AH_LOG &amp;<span class="hljs-title">AH_LOG::printS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span></span>&#123;    <span class="hljs-type">char</span> log[<span class="hljs-number">500</span>] = &#123;<span class="hljs-number">0</span>&#125;;    va_list args;    <span class="hljs-built_in">va_start</span>(args, fmt);    <span class="hljs-built_in">vsnprintf</span>(log, <span class="hljs-built_in">sizeof</span>(log) - <span class="hljs-number">1</span>, fmt, args);    <span class="hljs-built_in">va_end</span>(args);    std::cout &lt;&lt; log;    <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)        std::cout &lt;&lt; std::endl;    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(LOG_LOCALL_STORE)</span>    g_logFile &lt;&lt; log &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    g_logFile.<span class="hljs-built_in">flush</span>();    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-function">AH_LOG &amp;<span class="hljs-title">AH_LOG::printTitle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *funcName, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span></span>&#123;    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(LOG_LOCALL_STORE)</span>    <span class="hljs-type">char</span> timeStamp[<span class="hljs-number">255</span>] = <span class="hljs-string">&quot;hello&quot;</span>;    tm *time = <span class="hljs-built_in">getSystemTime</span>();    <span class="hljs-built_in">sprintf</span>(timeStamp, <span class="hljs-string">&quot;%02d:%02d:%02d || &quot;</span>,            time-&gt;tm_hour,            time-&gt;tm_min,            time-&gt;tm_sec);    <span class="hljs-comment">// g_logFile.open(fileName , std::ios::app);        </span>    g_logFile &lt;&lt; timeStamp &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;] @&quot;</span> &lt;&lt; funcName &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-comment">// g_logFile.close();</span>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    std::cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;] @&quot;</span> &lt;&lt; funcName &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-function">AH_LOG &amp;<span class="hljs-title">AH_LOG::getinstance</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> *singleInstance;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *funcName, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *log, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type, AH_Log_Mode mode)</span></span>&#123;    std::string log_type;    log_type = type;    <span class="hljs-keyword">switch</span> (mode)    &#123;    <span class="hljs-keyword">case</span> LOG_MODE_DEFAULT:        std::cout &lt;&lt; <span class="hljs-string">&quot;@&quot;</span> &lt;&lt; funcName &lt;&lt; <span class="hljs-string">&quot; [&quot;</span> + log_type + <span class="hljs-string">&quot;] &quot;</span> + log;        <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)            std::cout &lt;&lt; std::endl;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> LOG_MODE_SIMPLE:        std::cout &lt;&lt; <span class="hljs-string">&quot;@&quot;</span> &lt;&lt; funcName &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> + log_type + <span class="hljs-string">&quot;] =&gt;|| &quot;</span> + log ;        <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)            std::cout &lt;&lt; std::endl;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> LOG_MODE_STORE_LOCALLY:        std::cout &lt;&lt; <span class="hljs-string">&quot;@&quot;</span> &lt;&lt; funcName &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> + log_type + <span class="hljs-string">&quot;] =&gt;|| &quot;</span> + log;        <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)            std::cout &lt;&lt; std::endl;        <span class="hljs-comment">//TODO Store log locally.</span>        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> LOG_MODE_COMPLEX:        std::cout &lt;&lt; <span class="hljs-string">&quot;============ &quot;</span> &lt;&lt; <span class="hljs-string">&quot;@&quot;</span> &lt;&lt; funcName &lt;&lt;  <span class="hljs-string">&quot;  [&quot;</span> + log_type + <span class="hljs-string">&quot;]  ============ \n&quot;</span>;        std::cout &lt;&lt; log;        <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)            std::cout &lt;&lt; std::endl;        std::cout &lt;&lt; <span class="hljs-string">&quot;====================================== \n&quot;</span>;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">break</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *log, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type, AH_Log_Mode mode)</span></span>&#123;    std::string log_type;    log_type = type;    <span class="hljs-keyword">switch</span> (mode)    &#123;    <span class="hljs-keyword">case</span> LOG_MODE_DEFAULT:        std::cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> + log_type + <span class="hljs-string">&quot;] &quot;</span> + log;        <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)            std::cout &lt;&lt; std::endl;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> LOG_MODE_SIMPLE:        std::cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> + log_type + <span class="hljs-string">&quot;] =&gt;|| &quot;</span> + log ;        <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)            std::cout &lt;&lt; std::endl;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> LOG_MODE_STORE_LOCALLY:        std::cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> + log_type + <span class="hljs-string">&quot;] =&gt;|| &quot;</span> + log;        <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)            std::cout &lt;&lt; std::endl;        <span class="hljs-comment">//TODO Store log locally.</span>        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> LOG_MODE_COMPLEX:        std::cout &lt;&lt; <span class="hljs-string">&quot;==============  [&quot;</span> + log_type + <span class="hljs-string">&quot;]  ============== \n&quot;</span>;        std::cout &lt;&lt; log;        <span class="hljs-keyword">if</span>(log[<span class="hljs-built_in">strlen</span>(log)] != <span class="hljs-string">&#x27;\n&#x27;</span>)            std::cout &lt;&lt; std::endl;        std::cout &lt;&lt; <span class="hljs-string">&quot;====================================== \n&quot;</span>;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">break</span>;    &#125;&#125;&#125;; <span class="hljs-comment">// namespace AH</span></code></pre></div><h4 id="2-VA-ARGS-特性示例代码"><a href="#2-VA-ARGS-特性示例代码" class="headerlink" title="2. __VA_ARGS__特性示例代码"></a>2. <code>__VA_ARGS__</code>特性示例代码</h4><h5 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h5><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*! @file ug_log.h</span><span class="hljs-comment"> *  @version 0.0.1</span><span class="hljs-comment"> *  @date May 12 2021</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  @brief</span><span class="hljs-comment"> *  Print and out log info.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UG_LOG_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __UG_LOG_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UGPRINT(...)    printS(__VA_ARGS__)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UGINFO(...)     printLogS(__func__, <span class="hljs-string">&quot; info&quot;</span>, __VA_ARGS__)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UGDEBUG(...)    printLogS(__func__, <span class="hljs-string">&quot;debug&quot;</span>, __VA_ARGS__)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UGERROR(...)    printLogS(__func__, <span class="hljs-string">&quot;error&quot;</span>, __VA_ARGS__)</span><span class="hljs-type">void</span> <span class="hljs-title function_">printS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">printLogS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* funcname,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">ug_log_hal_print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// !__UG_LOG_H</span></span></code></pre></div><h5 id="c"><a href="#c" class="headerlink" title=".c"></a>.c</h5><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*! @file ug_log.c</span><span class="hljs-comment"> *  @version 0.0.1</span><span class="hljs-comment"> *  @date May 12 2021</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  @brief</span><span class="hljs-comment"> *  Print and out log info.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-comment">/* C libs */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-comment">/* my libs */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_log.h&quot;</span></span><span class="hljs-comment">// #include &quot;usart.h&quot;</span><span class="hljs-type">void</span> <span class="hljs-title function_">printS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span>&#123;    <span class="hljs-type">char</span> <span class="hljs-built_in">log</span>[<span class="hljs-number">300</span>] = &#123;<span class="hljs-number">0</span>&#125;;    va_list args;    va_start(args, fmt);    vsnprintf(<span class="hljs-built_in">log</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">log</span>) - <span class="hljs-number">1</span>, fmt, args);    va_end(args);    ug_log_hal_print(<span class="hljs-built_in">log</span>);    <span class="hljs-comment">// if(log[strlen(log)] != &#x27;\n&#x27;)</span>    <span class="hljs-comment">//     ug_log_hal_print(&quot;\n&quot;);</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">printLogS</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* funcname,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span>&#123;    <span class="hljs-type">char</span> <span class="hljs-built_in">log</span>[<span class="hljs-number">300</span>] = &#123;<span class="hljs-number">0</span>&#125;;    va_list args;    va_start(args, fmt);    vsnprintf(<span class="hljs-built_in">log</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">log</span>) - <span class="hljs-number">1</span>, fmt, args);    va_end(args);    ug_log_hal_print(<span class="hljs-string">&quot;[&quot;</span>);    ug_log_hal_print(type);    ug_log_hal_print(<span class="hljs-string">&quot;] @&quot;</span>);    ug_log_hal_print(funcname);    ug_log_hal_print(<span class="hljs-string">&quot; &quot;</span>);    ug_log_hal_print(<span class="hljs-built_in">log</span>);    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>[<span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">log</span>)] != <span class="hljs-string">&#x27;\n&#x27;</span>)        ug_log_hal_print(<span class="hljs-string">&quot;\n&quot;</span>);&#125;__attribute__((weak)) <span class="hljs-type">void</span> <span class="hljs-title function_">ug_log_hal_print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span>&#123;    <span class="hljs-comment">/* HAL Lib sample */</span>    <span class="hljs-comment">// uint32_t cnt = 0;</span>    <span class="hljs-comment">// while (str[cnt++] != &#x27;\0&#x27;);</span>    <span class="hljs-comment">// HAL_UART_Transmit(&amp;UART1_Handler, str, cnt-1, 500);</span>    <span class="hljs-comment">/* STD Lib sample */</span>    <span class="hljs-comment">// UartSendStr(USART1, str);</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>C&amp;C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>note</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QML Note</title>
    <link href="/2021/10/29/NOTE/QT/QML%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/29/NOTE/QT/QML%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="QML-Notes"><a href="#QML-Notes" class="headerlink" title="QML Notes"></a>QML Notes</h1><h2 id="1-自定义控件"><a href="#1-自定义控件" class="headerlink" title="1. 自定义控件"></a>1. 自定义控件</h2><p>新建MyItem.qml 文件，自定义 如下（文件名就是控件名，第一个字母大写）</p><div class="hljs code-wrapper"><pre><code class="hljs qml"><span class="hljs-keyword">import</span> QtQuick <span class="hljs-number">2.4</span><span class="hljs-title">Item</span> &#123;    <span class="hljs-attribute">id:</span><span class="hljs-string"> container</span>    <span class="hljs-keyword">property</span><span class="hljs-string"> alias cellColor</span>: rectangle.color<span class="hljs-comment">//cunstom var/property</span>    <span class="hljs-keyword">signal</span><span class="hljs-string"> clicked</span>(<span class="hljs-built_in">color</span> cellColor)<span class="hljs-comment">//singal</span>    <span class="hljs-attribute">width</span>: <span class="hljs-number">40</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">25</span>    <span class="hljs-title">Rectangle</span> &#123;        <span class="hljs-attribute">id:</span><span class="hljs-string"> rectangle</span>        <span class="hljs-attribute">border.color</span>: <span class="hljs-string">&quot;white&quot;</span>        <span class="hljs-attribute">anchors.fill</span>: <span class="hljs-built_in">parent</span>    &#125;    <span class="hljs-title">MouseArea</span> &#123;        <span class="hljs-attribute">anchors.fill</span>: <span class="hljs-built_in">parent</span>        <span class="hljs-attribute">onClicked</span>: container.clicked(container.cellColor)<span class="hljs-comment">//触发信号</span>    &#125;&#125;</code></pre></div><p>使用：</p><div class="hljs code-wrapper"><pre><code class="hljs qml"><span class="hljs-keyword">import</span> QtQuick <span class="hljs-number">2.9</span><span class="hljs-keyword">import</span> QtQuick.Controls <span class="hljs-number">2.2</span><span class="hljs-title">ApplicationWindow</span> &#123;    <span class="hljs-attribute">visible</span>: <span class="hljs-literal">true</span>    <span class="hljs-attribute">width</span>: <span class="hljs-number">640</span>    <span class="hljs-attribute">height</span>: <span class="hljs-number">480</span>    <span class="hljs-attribute">color</span>: <span class="hljs-string">&quot;#e9e9e9&quot;</span>    <span class="hljs-attribute">title</span>: qsTr(<span class="hljs-string">&quot;TestWin&quot;</span>)    <span class="hljs-keyword">property</span><span class="hljs-string"> string ar</span>: <span class="hljs-string">&quot;value&quot;</span>    <span class="hljs-keyword">property</span><span class="hljs-string"> string strvalue</span>: <span class="hljs-string">&quot;helloworld&quot;</span>    <span class="hljs-title">Text</span> &#123;        <span class="hljs-attribute">id:</span><span class="hljs-string"> text1</span>        <span class="hljs-attribute">text</span>: strvalue        <span class="hljs-attribute">y</span>: <span class="hljs-number">30</span>        <span class="hljs-attribute">anchors.horizontalCenter</span>: <span class="hljs-built_in">parent</span>.horizontalCenter        <span class="hljs-attribute">font.pointSize</span>: <span class="hljs-number">24</span>; <span class="hljs-attribute">font.bold</span>: <span class="hljs-literal">true</span>    &#125;    <span class="hljs-title">MyItem</span> &#123;        <span class="hljs-attribute">id:</span><span class="hljs-string"> cell</span>        <span class="hljs-attribute">x</span>: <span class="hljs-number">47</span>        <span class="hljs-attribute">y</span>: <span class="hljs-number">240</span>        <span class="hljs-attribute">width</span>: <span class="hljs-number">55</span>        <span class="hljs-attribute">height</span>: <span class="hljs-number">40</span>        <span class="hljs-attribute">cellColor</span>: <span class="hljs-string">&quot;red&quot;</span>        <span class="hljs-attribute">onClicked</span>: text1.color = cellColor    &#125;&#125;</code></pre></div><h2 id="2-Grid-组件"><a href="#2-Grid-组件" class="headerlink" title="2. Grid 组件"></a>2. Grid 组件</h2><p>配合 上面的自定义控件使用如下：</p><div class="hljs code-wrapper"><pre><code class="hljs css">import QtQuick <span class="hljs-number">2.9</span>import QtQuick<span class="hljs-selector-class">.Controls</span> <span class="hljs-number">2.2</span>ApplicationWindow &#123;    visible: true    width: <span class="hljs-number">640</span>    height: <span class="hljs-number">480</span>    color: <span class="hljs-string">&quot;#e9e9e9&quot;</span>    title: <span class="hljs-built_in">qsTr</span>(<span class="hljs-string">&quot;TestWin&quot;</span>)    Text &#123;        id: text1        text: strvalue        y: <span class="hljs-number">30</span>        anchors.horizontalCenter: parent.horizontalCenter        font.pointSize: <span class="hljs-number">24</span>; <span class="hljs-attribute">font</span><span class="hljs-selector-class">.bold</span>: true    &#125;    <span class="hljs-attribute">Grid</span> &#123;        id: colorPicker        x: <span class="hljs-number">4</span>; anchors<span class="hljs-selector-class">.bottom</span>: parent.bottom; anchors<span class="hljs-selector-class">.bottomMargin</span>: <span class="hljs-number">4</span>        rows: <span class="hljs-number">2</span>; <span class="hljs-attribute">columns</span>: <span class="hljs-number">3</span>; spacing: <span class="hljs-number">3</span>        MyItem &#123; cellColor: <span class="hljs-string">&quot;red&quot;</span>; onClicked: text1.color = cellColor &#125;        MyItem &#123; cellColor: <span class="hljs-string">&quot;green&quot;</span>; onClicked: text1.color = cellColor &#125;        MyItem &#123; cellColor: <span class="hljs-string">&quot;blue&quot;</span>; onClicked: text1.color = cellColor &#125;        MyItem &#123; cellColor: <span class="hljs-string">&quot;yellow&quot;</span>; onClicked: text1.color = cellColor &#125;        MyItem &#123; cellColor: <span class="hljs-string">&quot;steelblue&quot;</span>; onClicked: text1.color = cellColor &#125;        MyItem &#123; cellColor: <span class="hljs-string">&quot;black&quot;</span>; onClicked: text1.color = cellColor &#125;    &#125;&#125;</code></pre></div><h2 id="3-QML-与-C-Class-互通"><a href="#3-QML-与-C-Class-互通" class="headerlink" title="3. QML 与 C++ Class 互通"></a>3. QML 与 C++ Class 互通</h2><p>新建 tempClass 类：</p><p>这里定义两个槽函数：</p><ul><li>QString getStr();    &#x2F;&#x2F; 返回字符串</li><li>void setqml();     &#x2F;&#x2F;C++ 直接修改qml 控件属性</li></ul><p>“tempClass.h”</p><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> GETARRAYDATA_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GETARRAYDATA_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QObject&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QByteArray&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QDebug&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TempClass</span> : <span class="hljs-keyword">public</span> QObject&#123;    Q_OBJECT<span class="hljs-keyword">public</span>:<span class="hljs-keyword">public</span> slots:    <span class="hljs-function">QString <span class="hljs-title">getStr</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setqml</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// GETARRAYDATA_H</span></span></code></pre></div><p>“tempClass.cpp”</p><p>这里 <code>extern QObject *qmlObj;</code> 全局变量，在main.cpp 里声明</p><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tempClass.h&quot;</span></span><span class="hljs-keyword">extern</span> QObject *qmlObj;<span class="hljs-function">QString <span class="hljs-title">TempClass::getStr</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am cool boy&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TempClass::setqml</span><span class="hljs-params">()</span></span>&#123;    qmlObj-&gt;<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">&quot;strvalue&quot;</span>,<span class="hljs-string">&quot;setqml hello&quot;</span>);    <span class="hljs-comment">// 要访问其子对象 使用 qmlObj-&gt;findChild();</span><span class="hljs-comment">//     QObject *obj = qmlObj-&gt;findChild&lt;QObject*&gt;(&quot;qmlText&quot;);</span><span class="hljs-comment">//     obj-&gt;setProperty(&quot;text&quot;,&quot;setqml hello&quot;);</span><span class="hljs-comment">//     qDebug() &lt;&lt; obj-&gt;property(&quot;text&quot;);</span>&#125;</code></pre></div><p>“main.cpp”</p><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QGuiApplication&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QQmlApplicationEngine&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QQmlContext&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tempClass.h&quot;</span></span>QObject *qmlObj;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    QCoreApplication::<span class="hljs-built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling);    <span class="hljs-function">QGuiApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;    QQmlApplicationEngine engine;    engine.<span class="hljs-built_in">rootContext</span>()-&gt;<span class="hljs-built_in">setContextProperty</span>(<span class="hljs-string">&quot;tempClass&quot;</span>, <span class="hljs-keyword">new</span> TempClass);    engine.<span class="hljs-built_in">load</span>(<span class="hljs-built_in">QUrl</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;qrc:/main.qml&quot;</span>)));    <span class="hljs-keyword">if</span> (engine.<span class="hljs-built_in">rootObjects</span>().<span class="hljs-built_in">isEmpty</span>())        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    qmlObj=engine.<span class="hljs-built_in">rootObjects</span> ().<span class="hljs-built_in">at</span> (<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();&#125;</code></pre></div><p>“main.qml”</p><div class="hljs code-wrapper"><pre><code class="hljs xml">import QtQuick 2.9import QtQuick.Controls 2.2ApplicationWindow &#123;    visible: true    width: 640    height: 480    color: &quot;#e9e9e9&quot;    title: qsTr(&quot;TestWin&quot;)    property string vTextValue: &quot;value&quot;    property string strvalue: &quot;helloworld&quot;    Text &#123;        objectName: &quot;qmlText&quot; //用于cpp查找对象        id: text1        text: strvalue        y: 30        anchors.horizontalCenter: parent.horizontalCenter        font.pointSize: 24; font.bold: true    &#125;    Text&#123;        id: vtext        anchors.horizontalCenter: parent.horizontalCenter        y: 200        text: vTextValue        font: &#123;family:&quot;arial&quot;&#125;    &#125;    Button&#123;        id: btn        anchors.horizontalCenter: parent.horizontalCenter        y:100        text: &quot;点我&quot;        onClicked: &#123;vTextValue = tempClass.getStr(); tempClass.setqml()&#125;    &#125;&#125;</code></pre></div><h3 id="1-qml-使用-C-类"><a href="#1-qml-使用-C-类" class="headerlink" title="1. qml 使用 C++ 类"></a>1. qml 使用 C++ 类</h3><p> <code>engine.rootContext()-&gt;setContextProperty(&quot;tempClass&quot;, new TempClass);</code> 给qml 根对象 添加类。</p><h3 id="2-C-直接调用qml-对象"><a href="#2-C-直接调用qml-对象" class="headerlink" title="2. C++ 直接调用qml 对象"></a>2. C++ 直接调用qml 对象</h3><div class="hljs code-wrapper"><pre><code class="hljs c++">QObject *qmlObj;<span class="hljs-comment">//定义QObject指针</span>qmlObj=engine.<span class="hljs-built_in">rootObjects</span> ().<span class="hljs-built_in">at</span> (<span class="hljs-number">0</span>);<span class="hljs-comment">// 取其根 对象</span></code></pre></div><p>找到对应的Object 调用</p><div class="hljs code-wrapper"><pre><code class="hljs c++">qmlObj-&gt;<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">&quot;strvalue&quot;</span>,<span class="hljs-string">&quot;setqml hello&quot;</span>);<span class="hljs-comment">// 要访问其子对象 使用 qmlObj-&gt;findChild();</span><span class="hljs-comment">//     QObject *obj = qmlObj-&gt;findChild&lt;QObject*&gt;(&quot;qmlText&quot;);</span><span class="hljs-comment">//     obj-&gt;setProperty(&quot;text&quot;,&quot;setqml hello&quot;);</span><span class="hljs-comment">//     qDebug() &lt;&lt; obj-&gt;property(&quot;text&quot;);</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>QT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QT</tag>
      
      <tag>QML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QT ini配置文件</title>
    <link href="/2021/10/27/NOTE/QT/QT%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6ini%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/10/27/NOTE/QT/QT%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6ini%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="QT-配置文件"><a href="#QT-配置文件" class="headerlink" title="QT 配置文件"></a>QT 配置文件</h1><h2 id="一、QSettings-类-ini-文件"><a href="#一、QSettings-类-ini-文件" class="headerlink" title="一、QSettings 类 ini 文件"></a>一、QSettings 类 ini 文件</h2><h3 id="1-创建ini-文件"><a href="#1-创建ini-文件" class="headerlink" title="1. 创建ini 文件"></a>1. 创建ini 文件</h3><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//创建ini配置文件</span>QSettings *iniFile = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QSettings</span>(<span class="hljs-string">&quot;sysConfig.ini&quot;</span>, QSettings::IniFormat);</code></pre></div><ul><li>arg1：文件路径</li><li>arg2：文件格式</li></ul><p>当没有文件会创建文件，有文件会打开文件。</p><h3 id="2-设置键值对"><a href="#2-设置键值对" class="headerlink" title="2. 设置键值对"></a>2. 设置键值对</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//索引进入组 这个时候根目录在 flashSetting 下</span>iniFile-&gt;beginGroup(<span class="hljs-string">&quot;flashSetting&quot;</span>);<span class="hljs-comment">//设置键值对</span>iniFile-&gt;setValue(<span class="hljs-string">&quot;offset&quot;</span>, <span class="hljs-number">0x08000000</span>);iniFile-&gt;setValue(<span class="hljs-string">&quot;dataPackSize&quot;</span>, <span class="hljs-number">1000</span>);</code></pre></div><p>结果如下：</p><p><img src="/2021/10/27/NOTE/QT/QT%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6ini%E4%BD%BF%E7%94%A8/image-20211027105619894.png" alt="image-20211027105619894"></p><ul><li><p>beginGroup </p><p>  使当前索引进入 组下。 当<code>iniFile-&gt;beginGroup(&quot;flashSetting&quot;);</code> 执行后，相当于当前根目录在 flashSetting 下了，所以后面的Value在当前组下</p></li><li><p>endGroup </p><p>  回到上一目录级（组）</p></li><li><p>setValue</p><p>  顾名思义 设置键值对</p></li></ul><h3 id="3-判断键值对是否存在"><a href="#3-判断键值对是否存在" class="headerlink" title="3. 判断键值对是否存在"></a>3. 判断键值对是否存在</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//索引进入组 这个时候根目录在 flashSetting 下</span>iniFile-&gt;beginGroup(<span class="hljs-string">&quot;flashSetting&quot;</span>);<span class="hljs-comment">//判断键是否存在</span>key = iniFile-&gt;contains(<span class="hljs-string">&quot;offset&quot;</span>);qDebug() &lt;&lt; <span class="hljs-string">&quot;falshSetting/offset &quot;</span> &lt;&lt; key;</code></pre></div><h3 id="3-读取键值对"><a href="#3-读取键值对" class="headerlink" title="3. 读取键值对"></a>3. 读取键值对</h3><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//索引进入组 这个时候根目录在 flashSetting 下</span>iniFile-&gt;<span class="hljs-built_in">beginGroup</span>(<span class="hljs-string">&quot;flashSetting&quot;</span>);<span class="hljs-comment">//读取键值对</span><span class="hljs-type">int</span> dataPackSize = iniFile-&gt;<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;dataPackSize&quot;</span>).<span class="hljs-built_in">toInt</span>();QString name = iniFile-&gt;<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;name&quot;</span>).<span class="hljs-built_in">toString</span>();</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>QT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QT</tag>
      
      <tag>ini</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode编译调试STM32的环境搭建</title>
    <link href="/2021/05/13/NOTE/ARM/STM32/Keil%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/"/>
    <url>/2021/05/13/NOTE/ARM/STM32/Keil%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Keil-Compile-Option"><a href="#Keil-Compile-Option" class="headerlink" title="Keil Compile Option"></a>Keil Compile Option</h1><h3 id="1-One-ELF-Section-per-Function"><a href="#1-One-ELF-Section-per-Function" class="headerlink" title="1. One ELF Section per Function"></a>1. One ELF Section per Function</h3><p><img src="/2021/05/13/NOTE/ARM/STM32/Keil%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/image-20211203145225371.png" alt="image-20211203145225371"></p><p>选项<strong>One ELF Section per Function</strong> 的主要功能是对冗余函数的优化。通过这个选项，可以在最后生成的二进制文件中将冗余函数排除掉(虽然其所在的文件已经参与了编译链接),以便最大程度地优化最后生成的二进制代码。</p><p>而该选项实现的机制是将每一个函数作为一个优化的单元，而并非整个文件作为参与优化的单元。</p><p>该选项勾选后，表现为在 Compiler Option里 为 <code>--split_sections</code></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode编译调试STM32的环境搭建</title>
    <link href="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="VSCode编译调试STM32的环境搭建"><a href="#VSCode编译调试STM32的环境搭建" class="headerlink" title="VSCode编译调试STM32的环境搭建"></a>VSCode编译调试STM32的环境搭建</h1><blockquote><p>深夜了，我很饿，我只是想起床吃个泡面。</p></blockquote><p>@firestaradmin 2021年5月13日00:49:02</p><h2 id="一、软件环境安装"><a href="#一、软件环境安装" class="headerlink" title="一、软件环境安装"></a>一、软件环境安装</h2><ul><li><p><a href="https://link.zhihu.com/?target=https://code.visualstudio.com/">VSCode</a>：</p><p> 主角不用多说。</p></li><li><p><a href="https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html">STM32CubeMX</a>：</p><p>  用于生成带Makefile的HAL库工程。（本文章后面会介绍如何替换为STD标准库）</p></li><li><p><a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNU Arm Embedded Toolchain</a>：</p><p>  arm用的GNU工具链，记得把bin文件夹添加到系统Path环境变量。</p></li><li><p><a href="https://link.zhihu.com/?target=https://gnutoolchains.com/arm-eabi/openocd/">OpenOCD </a>：</p><p> 开源的片上调试器(Open On-Chip Debugger)，记得把bin文件夹添加到系统Path环境变量。</p><p> linux可以直接 <code>apt install openocd</code>。</p></li><li><p><a href="https://link.zhihu.com/?target=https://git-scm.com/">Git</a>：</p><p> git版本管理，我们这里要使用的是下载git附带的git bash。这个bash是基于mingw的，非常轻量了，甚至于make都没有。但是问题不大，相信你们电脑里肯定都装有MinGW，或者QT，进入他们的目录，搜索<code>mingw32-make.exe</code>，复制一份重命名为<code>make.exe</code>，然后将存放的目录添加到系统环境变量即可。（如果是Linux则无视这条）</p></li></ul><p>我的环境变量如下：</p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513011459480.png" alt="image-20210513011459480" style="zoom:80%;"><p>环境变量修改完毕后，可能需要<strong>重启电脑</strong>才能生效。然后打开cmd，输入：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-none-eabi-gcc --version</code></pre></div><p>and</p><div class="hljs code-wrapper"><pre><code class="hljs sh">openocd --version</code></pre></div><p>能看到版本号，说明ok。</p><h2 id="二、工程创建"><a href="#二、工程创建" class="headerlink" title="二、工程创建"></a>二、工程创建</h2><h3 id="1-用STM32CubeMX创建工程"><a href="#1-用STM32CubeMX创建工程" class="headerlink" title="1. 用STM32CubeMX创建工程"></a>1. 用STM32CubeMX创建工程</h3><p>新建工程，如下：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513182206951.png" alt="image-20210513182206951"></p><p>选择工程后配置，这里就不详细介绍配置了。主要配置一下时钟和调试接口，SWD就选Serial Wire调试模式。</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513182653731.png" alt="image-20210513182653731"></p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513182709266.png" alt="image-20210513182709266"></p><p>之后到Project Manager页面 ，选择Toolchain 为 MakeFile，如图：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513182902639.png" alt="image-20210513182902639"></p><p>紧接着，选择拷贝所有的库到工程目录，这样HAL库就全部在工程目录了。当然到时候你可以自己替换为标准库。</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513183115734.png" alt="image-20210513183115734"></p><p>最后点击 GENERATE CODE 按钮，生成工程：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513183206234.png" alt="image-20210513183206234"></p><p>于是乎，生成了如下的文件：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513183322131.png" alt="image-20210513183322131"></p><h3 id="2-配置VSCode"><a href="#2-配置VSCode" class="headerlink" title="2. 配置VSCode"></a>2. 配置VSCode</h3><p>可以直接用VSCode 打开当前目录，或者重新复制一份：</p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513183526491.png" alt="image-20210513183526491"><p>这里有些文件，是后面生成的，亲们目录里没有不要着急哦。</p><p>这里 .ioc 文件和 .mxproject 文件是STM32Cube的工程文件，Drivers文件夹里是STM32和ARM CMSIS的库。Core文件夹里的Inc和Src是用户源码和头文件。</p><hr><p>接下来装一些插件啦</p><ul><li>**C&#x2F;C++**：提供代码补全、智能感知和debug功能；</li><li><strong>C&#x2F;C++ Snippets</strong>：C&#x2F;C++ 代码模板片段，自动生成代码段；</li><li><strong>ARM</strong>：提供ARM汇编语言的代码高亮；</li><li><strong>Cortex-Debug</strong>：结合ARM工具链和OpenOCD等工具可以进行图形化调试操作，这样就不用了敲命令来GDB调试了。</li></ul><p>以下为可选插件：</p><ul><li><p>**Chinese (Simplified)**：中文支持;</p></li><li><p><strong>file-icons</strong>：文件图标；</p></li><li><p><strong>LinkerScript</strong>：ld链接脚本语法高亮。</p></li><li><p>其他的插件，你们自己想装就装咯。</p></li></ul><hr><p>下一步(Linux 无视之)，Ctrl + Shift + P 快捷键，搜索 <code>settings json</code>，会出现下图，选中打开设置（JSON）</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513212324549.png" alt="image-20210513212324549"></p><p>之后在文件末尾添加如下两行设置，用来设置VSCode默认终端为我们上面下载的Git自带的Bash。</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;terminal.integrated.shell.windows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:\\Program Files\\Git\\bin\\bash.exe&quot;</span><span class="hljs-punctuation">,</span></code></pre></div><p>Ctrl + S 保存，Ctrl + ~(Tab按键上面那个键) 打开终端。</p><p>或者如果你只想在当前工程目录下使用bash开发，可以只在当前目录下新建一个.vscode文件夹，然后新建一个单独的settings.json，在里面写上：</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;terminal.integrated.shell.windows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\Program Files\\Git\\bin\\bash.exe&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>这里如果你是另存为工作区了，可能新建settings.json 文件设置不了终端，需要下图的设置打上勾</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210608171112190.png" alt="image-20210608171112190"></p><p>然后点击你的工作区文件，进行设置，如下图：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210608171147563.png" alt="image-20210608171147563"></p><hr><p>现在其实已经可以打开终端，make 了。但是VSCode 会提示很多波浪线，让人头大，而且会发现也没有语法提示，这怎么能受得了呢。</p><p>以前用Keil 开发的时候，我们会在Project Options里设置全局宏定义，如：</p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513213420906.png" alt="image-20210513213420906"><p>而我们用CubeMX生成的Makefile项目中，这两个宏是通过gcc的-D参数在编译时添加的：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513213535863.png" alt="image-20210513213535863"></p><p>但是，<strong>VS Code只是一个编辑器</strong>，它检查代码的时候并不会去读Makefile，而是只看.h和.c文件，于是在STM32的头文件（如stm32f1xx.h）中就检测不到那个宏，从而认为这个宏没有被定义。</p><p>因此我们需要在当前目录的.vscode文件夹下创建<code>c_cpp_properties.json</code>配置文件，用来告诉VS Code我们定义了这些宏。</p><p>Ctrl + Shift + P 打开搜索 <code>c/c++</code>，选择编辑配置，如图：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513213747665.png" alt="image-20210513213747665"></p><p>这里是设置好的（我会解释每个设置的作用）：</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Win32&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;D:/Program Files/gcc-arm-none-eabi-10-2020-q4-major/**&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>                <span class="hljs-comment">// &quot;$&#123;workspaceFolder&#125;/Drivers/CMSIS&quot;,</span>                <span class="hljs-comment">// &quot;$&#123;workspaceFolder&#125;/Core/Inc&quot;,</span>                <span class="hljs-comment">// &quot;$&#123;workspaceFolder&#125;/Drivers/STM32F1xx_HAL_Driver/Inc&quot;,</span>                <span class="hljs-comment">// &quot;$&#123;workspaceFolder&#125;/Drivers/CMSIS/Device/ST/STM32F1xx/Include&quot;</span>                            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;USE_HAL_DRIVER&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;STM32F103xE&quot;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:\\Program Files\\gcc-arm-none-eabi-10-2020-q4-major\\bin\\arm-none-eabi-gcc.exe&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c11&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++17&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc-x64&quot;</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">&#125;</span></code></pre></div><ul><li><p><strong>name</strong>：用于标记当前平台，如win32、Linux或Mac。也就是说，这个json里“configuration“下可以写三组配置，只要每组配置前面写上不同的平台，即可在不同的操作系统上使用就会自动适配不同的配置。</p></li><li><p><strong>includePath</strong>：VSCode会从这些目录寻找头文件。</p><p>  第一个目录是ARM交叉编译工具链的目录，&#x2F;** 代表递归寻找目下的文件，可能会降低识别的速度，当文件夹下文件夹很多的时候，尽量用详细点的路径比较好。 目录可以参考Makefile， “${workspaceFolder}”&#96;表示项目文件夹。</p></li><li><p><strong>defines</strong>：全局宏定义，告诉VSCode这些宏都被定义了，只是没写在源码中而已。上述多加的两个宏是Makefile里的。</p></li><li><p><strong>compilerPath</strong>：指定编译器的路径。因为有些宏是编译器自带的，连Makefile里也没有，例如<code>__GNUC__</code>。有些教程里会让你在defines里面加上<code>__GNUC__</code>，但是这是没必要的。只要你指定了编译器路径，所有的编译器自带的宏都会导入VS Code。</p></li><li><p><strong>intelliSenseMode</strong>：gcc选gcc-x64。</p></li><li><p><strong>cStandard</strong>: 使用的c标准（一般不影响）</p></li><li><p><strong>cppStandard</strong>: 使用的c++标准（一般不影响）</p></li></ul><p>配置好后，Ctrl + S 保存， 神情气爽，没有红色波浪线了，如果有，请慢慢找问题，一般是头文件路径的问题。</p><hr><p>这个时候make编译，提示没有make的，去MinGW，或者QT，进入他们的目录，搜索<code>mingw32-make.exe</code>，复制一份重命名为<code>make.exe</code>，然后将存放的目录添加到系统环境变量即可。</p><hr><p>（可以无视这里，命令不多的情况下，我喜欢用手敲指令，这里只是介绍一下）为了方便操作，我们在.vscode目录下创建 <strong>tasks.json</strong> 文件，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>            <span class="hljs-punctuation">&#123;</span>                <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;make&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                    <span class="hljs-string">&quot;-j&quot;</span>                <span class="hljs-punctuation">]</span>             <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>            <span class="hljs-punctuation">&#123;</span>                <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;clean&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;make&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                    <span class="hljs-string">&quot;clean&quot;</span>                <span class="hljs-punctuation">]</span>             <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>这个文件创建了两个任务，分别叫做<strong>build</strong>和<strong>clean</strong>，<strong>build</strong>任务就是在bash里执行了make -j，clean任务就是在bash里执行了make clean。</p><p>VS Code是可以给任务绑定快捷键的，有兴趣可以自己搜索。</p><p>不使用快捷键而执行task的方法：按Ctrl + P，然后输入”task[空格]“，就会出现可用的任务列表。</p><h2 id="三、编译调试"><a href="#三、编译调试" class="headerlink" title="三、编译调试"></a>三、编译调试</h2><h3 id="1、Openocd-设置"><a href="#1、Openocd-设置" class="headerlink" title="1、Openocd 设置"></a>1、Openocd 设置</h3><p>直接在项目文件夹下新建一个openocd.cfg文件，内容如下</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 选择调试器</span><span class="hljs-comment">#source [find interface/jlink.cfg]</span><span class="hljs-built_in">source</span> [find interface/cmsis-dap.cfg]<span class="hljs-comment"># 选择接口为SWD</span>transport select swd<span class="hljs-comment"># 选择目标芯片</span><span class="hljs-built_in">source</span> [find target/stm32f1x.cfg]<span class="hljs-comment">#source [find target/stm32f4x.cfg]</span></code></pre></div><p>openocd启动时，会自动在当前目录下寻找名为openocd.cfg的文件作为配置文件。</p><p>本配置文件中引用到的配置文件，都在openocd安装目录下的share&#x2F;openocd&#x2F;scripts目录下。其中interface目录下都是接口相关配置文件、target目录下都是芯片相关的配置文件。</p><hr><h3 id="2、下载svd文件（可选）"><a href="#2、下载svd文件（可选）" class="headerlink" title="2、下载svd文件（可选）"></a>2、下载svd文件（可选）</h3><p>在<a href="https://github.com/posborne/cmsis-svd">&lt;我是链接&gt;</a>寻找对应STM32的svd文件。</p><p>CMSIS-SVD是CMSIS的一个组件，它包含完整微控制器系统（包括外设）的程序员视图的系统视图描述 XML 文件。<strong>VS Code可以通过它来知道外设寄存器的地址分布，从而把寄存器内容展示到窗口中</strong>。将下载好的STM32FXXX.svd文件放在项目文件夹根目录即可。</p><h3 id="3-配置VS-Code的调试功能"><a href="#3-配置VS-Code的调试功能" class="headerlink" title="3. 配置VS Code的调试功能"></a>3. 配置VS Code的调试功能</h3><p>在.vscode文件夹中新建一个launch.json，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Cortex Debug&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;executable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;/build/$&#123;workspaceFolderBasename&#125;.elf&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cortex-debug&quot;</span><span class="hljs-punctuation">,</span>                        <span class="hljs-attr">&quot;device&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;STM32F103ZE&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">//使用J-link GDB Server时必须；其他GBD Server时可选（有可能帮助自动选择SVD文件）。支持的设备见 https://www.segger.com/downloads/supported-devices.php</span>            <span class="hljs-comment">//&quot;svdFile&quot;: &quot;./STM32F407.svd&quot;,  //svd文件，有这个文件才能查看寄存器的值，每个单片机都不同。可以在以下地址找到 https://github.com/posborne/cmsis-svd</span>            <span class="hljs-attr">&quot;servertype&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;openocd&quot;</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">//使用的GDB Server</span>            <span class="hljs-attr">&quot;configFiles&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                                  <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;/openocd.cfg&quot;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-comment">//&quot;preLaunchTask&quot;: &quot;build&quot;,</span>            <span class="hljs-comment">//&quot;armToolchainPath&quot;: &quot;C:/Program Files (x86)/GNU Arm Embedded Toolchain/9 2020-q2-update/bin/&quot;</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>解释几个重要选项：</p><ul><li><strong>executable</strong>：编译出的文件，也就是最终烧录到单片机中的，这里是elf文件。根据芯片的不同，可能产生不同的后缀。</li><li><strong>request</strong>：可以选launch或attach。launch是指启动调试时同时开始执行程序；attcah是指程序已经在运行了，然后开始调试。</li><li><strong>type</strong>：调试的类型，选cortex-debug，这是我们装的插件。默认是cppdbg之类的，但是那样我们得自己配置gdb，配置起来听说很非常麻烦。</li><li><strong>device</strong>：使用J-link GDB Server时必须；其他GBD Server时可选（有可能帮助自动选择SVD文件）。支持的设备见 <a href="https://www.segger.com/downloads/supported-devices.php">https://www.segger.com/downloads/supported-devices.php</a></li><li><strong>svdFile：svd</strong>文件的路径。</li><li><strong>servertype</strong>：要选择的gdb server。我们用openocd。</li><li><strong>configFiles：gdb</strong> server的配置文件路径。其实openocd会自动读当前目录下的openocd.cfg文件，这个选项不填也行。但是如果你想把openocd.cfg放在别处，就可以用这个选项指定配置文件的路径。</li><li><strong>preLaunchTask</strong>：在启动调试前，预先执行的任务。在这里如果配置成前面可选的build任务。这样每次调试前都会先自动编译好。</li><li><strong>armToolchainPath</strong>：工具链的路径。配置了全局环境变量的情况下好像不设置也行</li></ul><p>（PS：我注释掉某些的意思就是，大家可以多变通，不必跟着教程一步一步来，按照自己的想法来（当然我自己就是上面那么配置的）。）</p><hr><h3 id="4、编译调试"><a href="#4、编译调试" class="headerlink" title="4、编译调试"></a>4、编译调试</h3><p>配置完后，如下图：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513220116017.png" alt="image-20210513220116017"></p><p>接下来，按F5 或者点击 左侧：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513220242332.png" alt="image-20210513220242332"></p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513220301119.png" alt="image-20210513220301119"></p><p>就开始调试、设置断点、单步执行和暂停了。</p><p>左边可以看到<strong>变量窗口、调用堆栈、断点、外设寄存器、CPU寄存器。</strong></p><p>配置已经全部完成，你的show time 到了。</p><h2 id="四、替换为标准库"><a href="#四、替换为标准库" class="headerlink" title="四、替换为标准库"></a>四、替换为标准库</h2><p>0、删掉之前的HAL库文件，如图红框中的文件：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513231131457.png" alt="image-20210513231131457"></p><p>1、下载对应芯片的标准库，解压后：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513230423786.png" alt="image-20210513230423786"></p><hr><p>2、进入Library 文件夹，复制目录下的两个文件夹，到我们工程目录下的Drivers。</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513230757976.png" alt="image-20210513230757976"></p><hr><p>3、进入解压标准库下的STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Examples\USART\Printf文件夹，也就是随便找个例程</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513231217656.png" alt="image-20210513231217656"></p><p>然后全部复制到我们工程目录下的Core文件夹（readme.txt 可以不复制），文件夹的命名当然随意了，如图：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513231325816.png" alt="image-20210513231325816"></p><hr><p>4、打开VSCode，目录结构如下：</p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513231650999.png" alt="image-20210513231650999"><hr><p>5、修改之前的<code>c_cpp_properties.json</code>文件，包含头文件，修改后如下：</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Win32&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;D:/Program Files/gcc-arm-none-eabi-10-2020-q4-major/**&quot;</span>                            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;USE_STDPERIPH_DRIVER&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;STM32F10X_HD&quot;</span>               <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:\\Program Files\\gcc-arm-none-eabi-10-2020-q4-major\\bin\\arm-none-eabi-gcc.exe&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c11&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++17&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc-x64&quot;</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>这里主要修改了define 里的定义，因为之前是HAL库，现在是STD库。</p><hr><p>6、打开根目录下的MakeFile文件，修改</p><p>首先是 C_SOURCES 变量：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513232951903.png" alt="image-20210513232951903"></p><div class="hljs code-wrapper"><pre><code class="hljs makefile">C_SOURCES =  \Core/main.c \Core/stm32f10x_it.c \Drivers/CMSIS/CM3/CoreSupport/core_cm3.c \Drivers/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c \<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> Drivers/STM32F10x_StdPeriph_Driver/src/*.c)</span></code></pre></div><p>也就是将用到的.c 添加进 C_SOURCES 变量。$(wildcard Drivers&#x2F;STM32F10x_StdPeriph_Driver&#x2F;src&#x2F;*.c) ，会读取目录下所有.c文件，你也可以不全部添加，一个一个输入。下图中有两个<code>system_stm32f10x.c</code>文件，随便包含一个即可，这是因为刚刚复制的printf demo里有，重复了，可以删掉一个。</p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513232706311.png" alt="image-20210513232706311"><hr><p>下一步，修改ASM_SOURCES 变量：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513233104725.png" alt="image-20210513233104725"></p><p>这里为什么要选择TrueSTUDIO 下的启动文件呢，因为在其中，arm是MDK-kei使用的、gcc_ride7是RIDE7 toolchain使用的，iar是IAR使用的，TrueSTUDIO是Atollic toolchain使用的。我们使用TrueSTUDIO文件夹里面的汇编启动文件即可。</p><hr><p>修改C_DEFS 变量：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513233240976.png" alt="image-20210513233240976"></p><div class="hljs code-wrapper"><pre><code class="hljs makefile">C_DEFS =  \-DUSE_STDPERIPH_DRIVER \-DSTM32F10X_HD              </code></pre></div><p>因为替换为了STD标准库，定义当然不一样了。</p><hr><p>修改 C_INCLUDES 变量：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513233456617.png" alt="image-20210513233456617"></p><div class="hljs code-wrapper"><pre><code class="hljs makefile">C_INCLUDES =  \-ICore \-IDrivers/CMSIS/CM3/CoreSupport/ \-IDrivers/CMSIS/CM3/DeviceSupport/ST/STM32F10x \-IDrivers/STM32F10x_StdPeriph_Driver/inc </code></pre></div><p>也就是包含用到的头文件。</p><hr><p>接下来make 编译试试，发现报错：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513233622854.png" alt="image-20210513233622854"></p><p>说main.c 里找不到 stm32_eval.h 因为我们没有复制该文件，我们简单的修改main.c 文件如下：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513233901498.png" alt="image-20210513233901498"></p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;&#125;&#125;</code></pre></div><hr><p>然后再次make编译，发现还有错误：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513233955273.png" alt="image-20210513233955273"></p><p>提示我们，core_cm3.c 文件有问题，后来我百度发现，需要修改该文件内容。</p><p>将其中原来的这两个函数注释掉，然后替换为以下两个函数。</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> __STREXB(<span class="hljs-type">uint8_t</span> value, <span class="hljs-type">uint8_t</span> *addr)&#123;   <span class="hljs-type">uint32_t</span> result=<span class="hljs-number">0</span>;   __ASM <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;strexb %0, %2, [%1]&quot;</span> : <span class="hljs-string">&quot;=&amp;r&quot;</span> (result) : <span class="hljs-string">&quot;r&quot;</span> (addr), <span class="hljs-string">&quot;r&quot;</span> (value) )</span>;   <span class="hljs-keyword">return</span>(result);&#125;<span class="hljs-type">uint32_t</span> __STREXH(<span class="hljs-type">uint16_t</span> value, <span class="hljs-type">uint16_t</span> *addr)&#123;   <span class="hljs-type">uint32_t</span> result=<span class="hljs-number">0</span>;   __ASM <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;strexh %0, %2, [%1]&quot;</span> : <span class="hljs-string">&quot;=&amp;r&quot;</span> (result) : <span class="hljs-string">&quot;r&quot;</span> (addr), <span class="hljs-string">&quot;r&quot;</span> (value) )</span>;   <span class="hljs-keyword">return</span>(result);&#125;</code></pre></div><p>函数分别位于core_cm3.c 中的732、749行：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513234244284.png" alt="image-20210513234244284"></p><p>替换后如下：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513234326508.png" alt="image-20210513234326508"></p><hr><p>这个时候我们再次make编译：</p><p><img src="/2021/05/13/NOTE/ARM/STM32/VSCode_STM32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210513234405225.png" alt="image-20210513234405225"></p><p>成功，神清气爽！</p><p>你的show time 又到了。</p><h2 id="五、使用CMAKE生成"><a href="#五、使用CMAKE生成" class="headerlink" title="五、使用CMAKE生成"></a>五、使用CMAKE生成</h2><p><strong>重点就是在CMakeLists.txt 文件首行添加 <code>set(CMAKE_SYSTEM_NAME Generic)</code> 。</strong></p><p>这里有一份我写好的F103 的CMAKE文件，STD库的。修改头文件路径和源文件就好了。如果是F4的或者其他的，照着修改就好了，主要就是编译参数什么的，可以去默认的Makefile文件里找，慢慢测试，不要心急。</p><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_SYSTEM_NAME Generic)<span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<span class="hljs-keyword">project</span>(mydemo C CXX ASM)<span class="hljs-comment"># specify the cross compiler</span><span class="hljs-keyword">set</span>(CMAKE_C_COMPILER arm-none-eabi-gcc)<span class="hljs-keyword">set</span>(CMAKE_CXX_COMPILER arm-none-eabi-g++)<span class="hljs-keyword">set</span>(CMAKE_ASM_COMPILER arm-none-eabi-gcc)<span class="hljs-keyword">set</span>(CMAKE_OBJCOPY arm-none-eabi-objcopy)<span class="hljs-keyword">set</span>(CMAKE_OBJDUMP arm-none-eabi-objdump)<span class="hljs-keyword">set</span>(CMAKE_SIZE arm-none-eabi-size)<span class="hljs-comment">## add project components</span><span class="hljs-keyword">set</span>(ELF_TARGET <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>.elf)<span class="hljs-comment"># set the build type</span><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Debug)<span class="hljs-comment"># generate flags from user variables</span><span class="hljs-keyword">if</span>(CMAKE_BUILD_TYPE <span class="hljs-keyword">MATCHES</span> Debug)<span class="hljs-keyword">set</span>(DBG_FLAGS <span class="hljs-string">&quot;-O0 -g2 -ggdb&quot;</span>)<span class="hljs-keyword">elseif</span>(CMAKE_BUILD_TYPE <span class="hljs-keyword">MATCHES</span> Release)<span class="hljs-keyword">set</span>(DBG_FLAGS <span class="hljs-string">&quot;-O3&quot;</span>)<span class="hljs-keyword">endif</span>()<span class="hljs-comment"># print build type.</span><span class="hljs-keyword">if</span>(CMAKE_BUILD_TYPE <span class="hljs-keyword">MATCHES</span> Debug)  <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build type: Debug&quot;</span>)<span class="hljs-keyword">elseif</span>(CMAKE_BUILD_TYPE <span class="hljs-keyword">MATCHES</span> Release)  <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build type: Release&quot;</span>)<span class="hljs-keyword">endif</span>()<span class="hljs-comment">#######################################</span><span class="hljs-comment"># MCU_FLAGS</span><span class="hljs-comment">#######################################</span><span class="hljs-comment"># cpu</span><span class="hljs-keyword">set</span>(CPU <span class="hljs-string">&quot;-mcpu=cortex-m3&quot;</span>)<span class="hljs-comment"># fpu</span><span class="hljs-comment"># NONE for Cortex-M0/M0+/M3</span><span class="hljs-keyword">set</span>(FPU <span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment"># float-abi</span><span class="hljs-keyword">set</span>(FLOAT_ABI <span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">## auto-set variables from user input</span><span class="hljs-keyword">set</span>(MCU_FLAGS <span class="hljs-string">&quot;$&#123;CPU&#125; -mthumb $&#123;FPU&#125; $&#123;FLOAT_ABI&#125;&quot;</span>)<span class="hljs-comment">#######################################</span><span class="hljs-comment"># LDFLAGS</span><span class="hljs-comment">#######################################</span><span class="hljs-comment"># link script</span><span class="hljs-keyword">set</span>(LDSCRIPT <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/STM32F103ZETx_FLASH.ld)<span class="hljs-comment"># libraries</span><span class="hljs-keyword">set</span>(LIBS <span class="hljs-string">&quot;-lc -lm -lnosys&quot;</span>)<span class="hljs-keyword">set</span>(LIBDIR <span class="hljs-string">&quot;&quot;</span>)<span class="hljs-keyword">set</span>(LDFLAGS <span class="hljs-string">&quot;$&#123;MCU&#125; -specs=nano.specs -T$&#123;LDSCRIPT&#125; $&#123;LIBDIR&#125; $&#123;LIBS&#125; -Wl,-Map=$&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.map,--cref -Wl,--gc-sections&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="hljs-string">&quot;$&#123;LDFLAGS&#125;&quot;</span>)<span class="hljs-comment"># compiler: language specific flags</span><span class="hljs-keyword">set</span>(CMAKE_C_FLAGS <span class="hljs-string">&quot;$&#123;MCU_FLAGS&#125; -Wall -fdata-sections -ffunction-sections $&#123;DBG_FLAGS&#125; &quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;MCU_FLAGS&#125; -fno-rtti -fno-exceptions -fno-builtin -Wall -fdata-sections -ffunction-sections $&#123;DBG_FLAGS&#125; &quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ASM_FLAGS <span class="hljs-string">&quot;$&#123;MCU_FLAGS&#125; -x assembler-with-cpp $&#123;DBG_FLAGS&#125; &quot;</span>)<span class="hljs-comment"># global define.</span><span class="hljs-keyword">add_definitions</span>(-DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD              )<span class="hljs-comment"># include path.</span><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Core <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Drivers/CMSIS/CM3/CoreSupport <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Drivers/CMSIS/CM3/DeviceSupport/ST/STM32F10x <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Drivers/STM32F10x_StdPeriph_Driver/inc )<span class="hljs-comment"># C source files</span><span class="hljs-keyword">set</span>(C_SOURCES    <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Core/main.c    <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Core/stm32f10x_it.c    <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Drivers/CMSIS/CM3/CoreSupport/core_cm3.c    <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Drivers/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c    )<span class="hljs-comment"># 添加文件夹里所有的源文件到 C_SOURCES_2</span><span class="hljs-keyword">aux_source_directory</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Drivers/STM32F10x_StdPeriph_Driver/src/ C_SOURCES_2)<span class="hljs-comment"># ASM sources</span><span class="hljs-keyword">set</span>(ASM_SOURCES<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Drivers/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_hd.s)<span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;ELF_TARGET&#125;</span> <span class="hljs-variable">$&#123;C_SOURCES&#125;</span> <span class="hljs-variable">$&#123;C_SOURCES_2&#125;</span> <span class="hljs-variable">$&#123;ASM_SOURCES&#125;</span>)<span class="hljs-comment"># # name of targets</span><span class="hljs-keyword">set</span>(ELF_FILE <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>.elf)<span class="hljs-keyword">set</span>(HEX_FILE <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>.hex)<span class="hljs-keyword">set</span>(BIN_FILE <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>.bin)<span class="hljs-comment"># # create binary &amp; hex files and show size of resulting firmware image</span><span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> <span class="hljs-string">&quot;$&#123;PROJECT_NAME&#125;.elf&quot;</span> POST_BUILD    <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_OBJCOPY&#125;</span> -Obinary <span class="hljs-variable">$&#123;ELF_FILE&#125;</span> <span class="hljs-variable">$&#123;BIN_FILE&#125;</span>    <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_OBJCOPY&#125;</span> -Oihex  <span class="hljs-variable">$&#123;ELF_FILE&#125;</span> <span class="hljs-variable">$&#123;HEX_FILE&#125;</span>    COMMENT <span class="hljs-string">&quot;Building $&#123;PROJECT_NAME&#125;.bin and $&#123;PROJECT_NAME&#125;.hex&quot;</span>    <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy <span class="hljs-variable">$&#123;HEX_FILE&#125;</span> <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.hex&quot;</span>    <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy <span class="hljs-variable">$&#123;BIN_FILE&#125;</span> <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.bin&quot;</span>    <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_SIZE&#125;</span> --format=berkeley <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>.hex    COMMENT <span class="hljs-string">&quot;Invoking: Cross ARM GNU Print Size&quot;</span>)</code></pre></div><h3 id="1、编译生成"><a href="#1、编译生成" class="headerlink" title="1、编译生成"></a>1、编译生成</h3><ol><li><p>CTRL+` 键打开终端， 输入 <code>mkdir build &amp; cd build</code> 新建文件夹并进入</p></li><li><p>输入 <code>cmake .. -G &quot;MinGW Makefiles&quot;</code> 生成makefile 文件。</p></li><li><p><code>make -j</code> 编译</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMAKE简明教程</title>
    <link href="/2020/12/18/NOTE/C&amp;C++/CMAKE%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <url>/2020/12/18/NOTE/C&amp;C++/CMAKE%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>@firestaradmin 2020年12月18日</p><blockquote><p>客路青山外，行舟绿水前。</p><p>潮平两岸阔，风正一帆悬。</p><p>海日生残夜，江春入旧年。</p><p>乡书何处达？归雁洛阳边。</p><p>​                                                        ————《次北固山下》作者：王湾</p></blockquote><hr><h1 id="CMAKE简明教程"><a href="#CMAKE简明教程" class="headerlink" title="CMAKE简明教程"></a>CMAKE简明教程</h1><h2 id="一、CMake-构建"><a href="#一、CMake-构建" class="headerlink" title="一、CMake 构建"></a>一、CMake 构建</h2><h3 id="例程目录介绍"><a href="#例程目录介绍" class="headerlink" title="例程目录介绍"></a>例程目录介绍</h3><p>这是一个 CMake 的多目录，多子工程（应用），库模式链接和不使用库模式链接的例子。</p><p>工程目录如下图：</p><p><img src="/2020/12/18/NOTE/C&C++/CMAKE%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20201218114413028.png" alt="image-20201218114413028"></p><ul><li><strong>app</strong>：该目录下有两个demo （应用程序or子工程）文件夹</li><li><strong>app&#x2F;demo1</strong>：该目录为demo1 应用程序的目录，会调用外部的驱动文件，和LIB库文件</li><li><strong>app&#x2F;demo2</strong>：同上</li><li><strong>bin</strong>：可执行程序输出目录。（可在CMakeLists文件中修改）</li><li><strong>build</strong>：CMake 输出文件夹</li><li><strong>driver</strong>：驱动文件（本例程，该驱动就是实现一个<code>myadd()</code> 函数）</li><li><strong>lib</strong>：lib库文件（实现了一个<code>mysub()</code> 函数）</li></ul><hr><blockquote><p>其实driver 文件夹和lib 文件夹都是给APP 提供函数功能的，区别在于driver中的文件我们不编译为lib库，所以driver 文件夹中不需要CMakeLists 文件。</p></blockquote><hr><h3 id="顶层CMake-文件"><a href="#顶层CMake-文件" class="headerlink" title="顶层CMake 文件"></a>顶层CMake 文件</h3><p>该文件位于 <code>./CMakeLists.txt</code> 内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置最低需求版本</span><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.19</span>)<span class="hljs-comment"># 设置工程名称</span><span class="hljs-keyword">project</span> (CMAKE_DEMO) <span class="hljs-comment"># include dir</span><span class="hljs-comment"># 添加头文件搜索路径，会继承到子目标</span><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/driver/<span class="hljs-keyword">include</span>)   <span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib)            <span class="hljs-comment"># 添加子目录下的CMakeLists.txt</span><span class="hljs-keyword">add_subdirectory</span>(app/demo1)<span class="hljs-keyword">add_subdirectory</span>(app/demo2)<span class="hljs-keyword">add_subdirectory</span>(lib)<span class="hljs-comment"># 这里在子cmake中 链接，所以这里注释了</span><span class="hljs-comment"># 添加链接库</span><span class="hljs-comment"># target_link_libraries(demo1 myMathLib)</span><span class="hljs-comment"># 添加链接库</span><span class="hljs-comment"># target_link_libraries(demo2 myMathLib)</span></code></pre></div><h3 id="APP-下的子工程-CMake-文件"><a href="#APP-下的子工程-CMake-文件" class="headerlink" title="APP 下的子工程 CMake 文件"></a>APP 下的子工程 CMake 文件</h3><p><strong>.&#x2F;app&#x2F;demo1&#x2F;CMakeLists.txt ：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.19</span>)<span class="hljs-keyword">project</span> (demo1) <span class="hljs-comment"># 添加头文件搜索路径</span><span class="hljs-keyword">include_directories</span>(.)<span class="hljs-comment"># aux_source_directory 会搜索目录下所有源文件</span><span class="hljs-keyword">aux_source_directory</span>(./ SOURCE_FILE)<span class="hljs-comment"># CMAKE_CURRENT_SOURCE_DIR 指向当前目录</span><span class="hljs-keyword">aux_source_directory</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/../../driver/src/ SOURCE_FILE2)<span class="hljs-comment"># CMAKE_SOURCE_DIR 指向总工程的根目录，设置 EXECUTABLE_OUTPUT_PATH 变量，将可执行文件存放到该目录</span><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<span class="hljs-comment"># 输出可执行文件</span><span class="hljs-keyword">add_executable</span>(demo1 <span class="hljs-variable">$&#123;SOURCE_FILE&#125;</span> <span class="hljs-variable">$&#123;SOURCE_FILE2&#125;</span>)<span class="hljs-comment"># 添加链接库</span><span class="hljs-keyword">target_link_libraries</span>(demo1 myMathLib)</code></pre></div><p><strong>.&#x2F;app&#x2F;demo2&#x2F;CMakeLists.txt ：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.19</span>)<span class="hljs-keyword">project</span> (demo2) <span class="hljs-comment"># 添加头文件搜索路径</span><span class="hljs-keyword">include_directories</span>(.)<span class="hljs-comment"># aux_source_directory 会搜索目录下所有源文件</span><span class="hljs-comment"># aux_source_directory(./ SOURCE_FILE)</span><span class="hljs-comment"># CMAKE_CURRENT_SOURCE_DIR 指向当前目录</span><span class="hljs-comment"># aux_source_directory($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../driver/src/ SOURCE_FILE2)</span><span class="hljs-comment"># 有时候可能不需要目录下的所有源文件，可以使用SET 来指定源文件. CMAKE_SOURCE_DIR 指向总工程的根目录</span><span class="hljs-keyword">set</span>(SRC_LIST     main.c    <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/driver/src/mymath.c    )<span class="hljs-comment"># CMAKE_SOURCE_DIR 指向总工程的根目录，设置 EXECUTABLE_OUTPUT_PATH 变量，将可执行文件存放到该目录</span><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<span class="hljs-comment"># 输出可执行文件</span><span class="hljs-keyword">add_executable</span>(demo2 <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<span class="hljs-comment"># 添加链接库</span><span class="hljs-keyword">target_link_libraries</span>(demo2 myMathLib)</code></pre></div><h3 id="LIB-下的CMake-文件"><a href="#LIB-下的CMake-文件" class="headerlink" title="LIB 下的CMake 文件"></a>LIB 下的CMake 文件</h3><p><strong>.&#x2F;lib&#x2F;CMakeLists.txt：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.19</span>)<span class="hljs-comment"># 查找当前目录下的所有源文件</span><span class="hljs-comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span><span class="hljs-keyword">aux_source_directory</span>(. DIR_LIB_SRCS)<span class="hljs-comment"># 生成链接库</span><span class="hljs-comment"># add_library(&lt;name&gt; [STATIC | SHARED | MODULE]</span><span class="hljs-comment">#                    [EXCLUDE_FROM_ALL]</span><span class="hljs-comment">#                    [&lt;source&gt;...])</span><span class="hljs-comment"># 默认 不填写是静态库 也就是 STATIC</span><span class="hljs-comment"># STATIC：静态创建库，此模式该库会集成到应用程序中。</span><span class="hljs-comment"># SHARED：动态创建库，会生成.dll .so .a 等lib文件，需要将文件和程序放在同一目录，才可运行程序。</span><span class="hljs-comment"># MODULE：在使用 dyld 的系统有效,如果不支持 dyld,则被当作 SHARED 对待。</span><span class="hljs-comment"># EXCLUDE_FROM_ALL：这个库不会被默认构建，除非有其他的组件依赖或者手工构建。</span><span class="hljs-keyword">add_library</span> (myMathLib <span class="hljs-variable">$&#123;DIR_LIB_SRCS&#125;</span>)<span class="hljs-comment"># add_library (myMathLib STATIC $&#123;DIR_LIB_SRCS&#125;)</span></code></pre></div><h2 id="二、编译输出"><a href="#二、编译输出" class="headerlink" title="二、编译输出"></a>二、编译输出</h2><p><strong>1、在根目录创建 build 目录，进入后输入如下命令：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">cmake ..或者cmake .. -G &quot;MingW Makefiles&quot;</code></pre></div><p><code>-G </code> 指定编译器，控制台输入 <code>cmake --help</code> 即可查询编译器名称</p><p><strong>2、cmake 后使用make 进行编译链接</strong></p><p><strong>win10 下：</strong></p><p>在build&#x2F; 目录下 输入以下命令（以MinGW 为例）：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">mingw32-makemingw32-make demo1mingw32-make clean</code></pre></div><ul><li>mingw32-make：默认编译全部 target</li><li>mingw32-make demo1：只编译 demo1 </li><li>mingw32-make clean：删除所有编译</li></ul><p><strong>Linux 下：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs gauss">mingw32-<span class="hljs-built_in">make</span><span class="hljs-built_in">make</span> demo1<span class="hljs-built_in">make</span> clean</code></pre></div><ul><li>make：默认编译全部 target</li><li>make demo1：只编译 demo1 </li><li>make clean：删除所有编译</li></ul><h2 id="三、文件内容"><a href="#三、文件内容" class="headerlink" title="三、文件内容"></a>三、文件内容</h2><p><strong>1、demo</strong></p><p><strong>.&#x2F;app&#x2F;demo1&#x2F;main.c</strong></p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;main.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mymath.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mymath2.h&quot;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> add_temp, sub_temp;    add_temp = myadd(NUM1, <span class="hljs-number">10</span>);    sub_temp = mysub(NUM1, <span class="hljs-number">10</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;======= demo1: ========\r\n&quot;</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add result= %d\r\n&quot;</span>, add_temp);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sub result= %d\r\n&quot;</span>, sub_temp);    <span class="hljs-type">char</span> c;    c = getchar();&#125;</code></pre></div><p><strong>.&#x2F;app&#x2F;demo1&#x2F;main.h</strong></p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MAIN_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAIN_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM1 100</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// !__MAIN_H_</span></span></code></pre></div><p><strong>2、driver</strong></p><p><strong>.&#x2F;driver&#x2F;include&#x2F;mymath.h</strong></p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MYMATH_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MYMATH_H_</span><span class="hljs-type">int</span> <span class="hljs-title function_">myadd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// !__MYMATH_H_</span></span></code></pre></div><p><strong>.&#x2F;driver&#x2F;include&#x2F;mymath.c</strong></p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mymath.h&quot;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">myadd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;    <span class="hljs-keyword">return</span> a+b;&#125;</code></pre></div><p><strong>3、lib</strong></p><p><strong>.&#x2F;lib&#x2F;mymath2.h</strong></p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MYMATH2_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MYMATH2_H_</span><span class="hljs-type">int</span> <span class="hljs-title function_">mysub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// !__MYMATH2_H_</span></span></code></pre></div><p><strong>.&#x2F;lib&#x2F;mymath2.c</strong></p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mymath2.h&quot;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">mysub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;    <span class="hljs-keyword">return</span> a-b;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>C&amp;C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AD宝典</title>
    <link href="/2020/12/18/NOTE/Note/AD%E5%AE%9D%E5%85%B8/"/>
    <url>/2020/12/18/NOTE/Note/AD%E5%AE%9D%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<p>@firestaradmin </p><blockquote><p>Creation is the most precious thing of my life.</p></blockquote><h1 id="AD宝典"><a href="#AD宝典" class="headerlink" title="AD宝典"></a>AD宝典</h1><p>菜单项快捷键设置：CTRL + 鼠标左键点击菜单项</p><hr><h2 id="画面操作"><a href="#画面操作" class="headerlink" title="画面操作"></a>画面操作</h2><p><strong>平移</strong>：鼠标右键拖动 </p><p><strong>缩放</strong>：鼠标中键拖动 | CTRL + 鼠标右键拖动</p><p><strong>旋转</strong>：SHIFT+ 鼠标右键拖动 </p><hr><h2 id="SCH"><a href="#SCH" class="headerlink" title="SCH"></a>SCH</h2><p><strong>走线</strong>：CTRL + W </p><p><strong>对齐到栅格</strong>：CTRL + SHIFT + D </p><p><strong>器件翻转</strong>：选中该器件，拖动，鼠标呈十字状，X 键水平左右翻转；Y 键为垂直上下翻转。</p><p><strong>批量标注</strong>：点击工具 -&gt; 标注 -&gt; 原理图标注</p><hr><h4 id="设置Net-作用范围："><a href="#设置Net-作用范围：" class="headerlink" title="设置Net 作用范围："></a>设置Net 作用范围：</h4><p><strong>Projct（工程） -&gt; Project Option（工程参数） -&gt; Options标签，在Net Identifier Scope(网络标示符范围)中选择。</strong></p><p><strong>Net Label 的四种作用范围：</strong></p><ul><li><strong>“Automatic”</strong>是缺省选项，表示系统会检测项目图纸内容，从而自动调整网络标识的范围。检测及自动调整的过程如下：<ul><li>如果原理图里有Sheet Entry标识，则网络标识的范围调整为Hierarchical。如果原理图里没有Sheet  Entry标识。但是有Port标识，则网络标识的范围调整为Flat。如果原理图里既没有Sheet Entry标识，又没有Port标识，则Net  Label的范围调整为Global。</li></ul></li><li><strong>“Flat”</strong>代表扁平式图纸结构，这种情况下，Net Label的作用范围仍是单张图纸以内。而Port的作用范围扩大到所有图纸，各图纸只要有相同的Port名，就可以发生信号传递。</li><li><strong>“Hierarchical”</strong>代表层次式结构，这种情况下，Net Label，Port的作用范围是单张图纸以内。当然，Port可以与上层的Sheet Entry连接，以纵向方式在图纸之间传递信号。</li><li><strong>“Global”</strong>是最开放的连接方式，这种情况下，Net Label、Port的作用范围都扩大到所有图纸。各图纸只要有相同的Port或相同的Net Label，就可以发生信号传递。</li></ul><hr><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p><strong>切换单位</strong>：Q</p><p><strong>层 视图选项</strong>：L  </p><p><strong>网络高亮</strong>：CTRL + 鼠标单击需要高亮的网络</p><p><strong>层显示模式</strong> [单层、多层、其它层灰色模式]：SHIFT+ S</p><p><strong>更改走线模式</strong>：SHIFT+ 空格</p><p><strong>翻转选中的元件</strong>：M + I</p><p><strong>翻转电路板</strong>：CTRL + F       </p><p><strong>切换布线层</strong>：NUM* | L</p><p><strong>布线时切换层并放置过孔</strong>：CTRL + SHIFT+ 滚轮</p><p><strong>布线过程中放置过孔</strong>：NUM* | 2(大键盘上的数字2)</p><p><strong>哪里要测点哪里</strong>：CTRL + M</p><p><strong>测量边距</strong>：R + P</p><p><strong>选中整条线</strong>：CTRL + H</p><p><strong>切换线宽</strong>：SHIFT+ w | 3</p><p><strong>切换栅格大小：</strong>G</p><p><strong>忽略栅格捕捉</strong>：按住CTRL</p><p><strong>快速布局选中的元器件</strong>：选中元件后 T + O + L 左键拖拽</p><p><strong>固定间距的等间距走线</strong>：T + T + M</p><p><strong>可更改间距的等间距走线</strong>：P + M</p><p><strong>走线时显示走线长度</strong>：SHIFT+ G</p><p><strong>显示或关闭坐标显示信息</strong>：SHIFT+ H</p><p><strong>显示或关闭放大镜</strong>：SHIFT+ M</p><p><strong>局部自动走线</strong>：SHIFT+ A</p><p><strong>复位错误标志</strong>：T + M</p><hr><p> <strong>PCB 设计时的技巧：</strong></p><ul><li>PCB设计时，交叉选择是个好东西</li><li>PCB设计时，可为网络建立Net Class 分组，来设计规则，和显示隐藏飞线</li><li>PCB设计时，分组的网络显示和隐藏，在右下角panels 里的PCB框设置</li><li>PCB设计时，设置好规则 记得复位错误标志 快捷键 T + M</li></ul>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
      <tag>Altium Design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 脚本基础模块</title>
    <link href="/2020/12/15/NOTE/Python/%E9%80%9A%E7%94%A8%E8%84%9A%E6%9C%AC%E6%A8%A1%E5%9D%97API/"/>
    <url>/2020/12/15/NOTE/Python/%E9%80%9A%E7%94%A8%E8%84%9A%E6%9C%AC%E6%A8%A1%E5%9D%97API/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-脚本基础模块"><a href="#Python-脚本基础模块" class="headerlink" title="Python 脚本基础模块"></a>Python 脚本基础模块</h1><p>@firestaradmin 2020年12月15日15:14:34</p><blockquote><p>如果死亡会带来平静，和安息。死去吧。</p></blockquote><h2 id="一、键盘鼠标操作模拟"><a href="#一、键盘鼠标操作模拟" class="headerlink" title="一、键盘鼠标操作模拟"></a>一、键盘鼠标操作模拟</h2><h3 id="autopy-模块"><a href="#autopy-模块" class="headerlink" title="autopy 模块"></a>autopy 模块</h3><p>安装：<code>pip3 install autopy</code></p><p>主要用来模拟鼠标和键盘的点击操作。</p><h4 id="1-键盘"><a href="#1-键盘" class="headerlink" title="1. 键盘"></a>1. 键盘</h4><blockquote><p>这个模块包含控制键盘的函数.</p></blockquote><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>按下键或者释放键</p><div class="hljs code-wrapper"><pre><code class="hljs python">autopy.key.toggle(autopy.key.Code.UP_ARROW, <span class="hljs-literal">True</span>, [])  <span class="hljs-comment">#按下方向键</span>autopy.key.toggle(autopy.key.Code.UP_ARROW, <span class="hljs-literal">False</span>, [])  <span class="hljs-comment">#释放方向键</span></code></pre></div><p><strong>autopy.key.toggle(autopy.key.Code.UP_ARROW, True, [autopy.key.Modifier.CONTROL], 0)</strong>  </p><p>#参数1  键盘代码(看下表)或键名</p><p>#参数2  True表示按下,False松开</p><p>#参数3  同时按下的修饰键</p><p>#参数4 延迟n秒后再往下执行</p><p>#注意释放，要不然会电脑会一直按着那个键，直到你终止程序</p><hr><p><strong>autopy.key.tap(autopy.key.Code.CONTROL, [], 2)</strong>  </p><p>#对autopy.key.toggle进行的封装,方便使用,按下并自动释放.</p><hr><p><strong>autopy.key.type_string(‘Hello123’, 0)</strong></p><p>#输入相应的字符串</p><p>#参数2  每分钟的字符个数，0表示最快</p><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p><strong>class autopy.key.Code</strong></p><table><thead><tr><th>type</th><th>code</th></tr></thead><tbody><tr><td>Code</td><td>F1</td></tr><tr><td>Code</td><td>F2</td></tr><tr><td>Code</td><td>F3</td></tr><tr><td>Code</td><td>F4</td></tr><tr><td>Code</td><td>F5</td></tr><tr><td>Code</td><td>F6</td></tr><tr><td>Code</td><td>F7</td></tr><tr><td>Code</td><td>F8</td></tr><tr><td>Code</td><td>F9</td></tr><tr><td>Code</td><td>F10</td></tr><tr><td>Code</td><td>F11</td></tr><tr><td>Code</td><td>F12</td></tr><tr><td>Code</td><td>ALT</td></tr><tr><td>Code</td><td>BACKSPACE</td></tr><tr><td>Code</td><td>CAPS_LOCK</td></tr><tr><td>Code</td><td>CONTROL</td></tr><tr><td>Code</td><td>DELETE</td></tr><tr><td>Code</td><td>DOWN_ARROW</td></tr><tr><td>Code</td><td>END</td></tr><tr><td>Code</td><td>ESCAPE</td></tr><tr><td>Code</td><td>HOME</td></tr><tr><td>Code</td><td>LEFT_ARROW</td></tr><tr><td>Code</td><td>PAGE_DOWN</td></tr><tr><td>Code</td><td>PAGE_UP</td></tr><tr><td>Code</td><td>RETURN</td></tr><tr><td>Code</td><td>RIGHT_ARROW</td></tr><tr><td>Code</td><td>SHIFT</td></tr><tr><td>Code</td><td>SHIFT</td></tr><tr><td>Code</td><td>SPACE</td></tr><tr><td>Code</td><td>UP_ARROW</td></tr></tbody></table><p><strong>class autopy.key.Modifier</strong></p><table><thead><tr><th>type</th><th>code</th></tr></thead><tbody><tr><td>Modifier</td><td>META</td></tr><tr><td>Modifier</td><td>ALT</td></tr><tr><td>Modifier</td><td>CONTROL</td></tr><tr><td>Modifier</td><td>SHIFT</td></tr></tbody></table><h4 id="2-鼠标"><a href="#2-鼠标" class="headerlink" title="2. 鼠标"></a>2. 鼠标</h4><p><strong>有些窗口可能需要管理员运行，才能移动鼠标！！！</strong></p><blockquote><p>这个模块包含获取发鼠标状态和控制鼠标光标的函数.非特殊情况下,都使用屏幕坐标系,原点在左上角.</p></blockquote><h5 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h5><p><strong>#移动鼠标到指定点–相对于屏幕，没有移动过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python">autopy.mouse.move(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</code></pre></div><hr><p><strong>#移动鼠标到指定点–相对于屏幕，有直线移动过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python">autopy.mouse.smooth_move(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>)</code></pre></div><hr><p><strong>#返回鼠标的当前位置–相对于屏幕</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python">i = autopy.mouse.location()<span class="hljs-comment">#i =&gt; (500.0, 500.0)</span></code></pre></div><hr><p> <strong>#按下指定鼠标键</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python">autopy.mouse.toggle(autopy.mouse.Button.LEFT, <span class="hljs-literal">True</span>)<span class="hljs-comment">#autopy.mouse.Button.LEFT   鼠标左键</span><span class="hljs-comment">#autopy.mouse.Button.RIGHT  鼠标右键</span><span class="hljs-comment">#autopy.mouse.Button.MIDDLE  鼠标中键</span><span class="hljs-comment">#None   默认左键</span></code></pre></div><hr><p><strong>#释放指定鼠标键</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python">autopy.mouse.toggle(autopy.mouse.Button.LEFT, <span class="hljs-literal">False</span>)  <span class="hljs-comment">#注意释放，要不然会电脑会一直按着那个键，直到你终止程序</span></code></pre></div><hr><div class="hljs code-wrapper"><pre><code class="hljs python">autopy.mouse.click(<span class="hljs-literal">None</span>)   <span class="hljs-comment"># 点左键一下,然后松开</span>autopy.mouse.click(autopy.mouse.Button.RIGHT)  <span class="hljs-comment"># 点右键一下,然后松开</span>autopy.mouse.click(autopy.mouse.Button.LEFT, <span class="hljs-number">3</span>)   <span class="hljs-comment"># 按住左键保持3秒,然后松开</span></code></pre></div><hr><p><strong>autopy.mouse.Button:Code</strong></p><table><thead><tr><th>type</th><th>code</th></tr></thead><tbody><tr><td>Button</td><td>LEFT</td></tr><tr><td>Button</td><td>RIGHT</td></tr><tr><td>Button</td><td>MIDDLE</td></tr></tbody></table><hr><h4 id="3-控制屏幕的模块screen"><a href="#3-控制屏幕的模块screen" class="headerlink" title="3.控制屏幕的模块screen"></a>3.控制屏幕的模块screen</h4><blockquote><p>这个模块包含控制屏幕的函数</p></blockquote><h5 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h5><ol><li><strong>autopy.screen,scale()-&gt;float</strong><br>  获得屏幕的<strong>scale</strong>值,多少像素代表一个点.</li><li><strong>autopy.screen.size()-&gt;(float,float)</strong><br>  返回<strong>tuple(width,height)</strong>,代表屏幕宽高有多少个像素点.</li><li><strong>autopy.screen.is_point_visible(x:float,y:float)-&gt;bool</strong><br>  如果这个点在屏幕的范围内,返回<strong>True</strong></li><li><strong>autopy.screen.get_color(x:float,y:float)-&gt;(int,int,int)</strong><br>  返回屏幕上对应点的颜色值.异常:如果点不在屏幕上,抛出ValueError.</li></ol><hr><p>autopy 也有图像识别，但是是位图识别，它的处理图像不适合脚本编写，我们会使用其他的模块，更加适合。</p><h2 id="二、屏幕截图"><a href="#二、屏幕截图" class="headerlink" title="二、屏幕截图"></a>二、屏幕截图</h2><h3 id="Pillow"><a href="#Pillow" class="headerlink" title="Pillow"></a>Pillow</h3><p>Pillow是PIL的一个派生分支，但如今已经发展成为比PIL本身更具活力的图像处理库。pillow可以说已经取代了PIL，将其封装成python的库（pip即可安装），且支持python2和python3，目前最新版本是3.0.0。</p><p><strong>安装：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs cmake">pip3 <span class="hljs-keyword">install</span> pillow</code></pre></div><p><strong>屏幕截图：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageGrab im = ImageGrab.grab((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">800</span>,<span class="hljs-number">200</span>)) <span class="hljs-comment">#截取屏幕指定区域的图像 </span>im = ImageGrab.grab() <span class="hljs-comment">#不带参数表示全屏幕截图</span>im.save(<span class="hljs-string">&quot;D:\\test.jpg&quot;</span>);<span class="hljs-comment">#储存为.jpg</span></code></pre></div><p>其他图像处理功能，如缩放、颜色等操作，百度。</p><h2 id="三、窗口控制"><a href="#三、窗口控制" class="headerlink" title="三、窗口控制"></a>三、窗口控制</h2><h3 id="pywin32"><a href="#pywin32" class="headerlink" title="pywin32"></a>pywin32</h3><p>一般系统自带，如果没有，安装可能是<code>pip install pywin32</code></p><hr><p>使用 <code>win32gui</code> <code>win32api</code> <code>win32con</code> 等模块进行窗体控制。</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> win32gui, win32api, win32con<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">global</span> game_hwnd, window_size    game_hwnd = win32gui.FindWindow(game_class, game_title)  <span class="hljs-comment">#获得句柄 &lt;hwnd: int&gt;</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;窗口句柄：&quot;</span>,game_hwnd)    win32gui.SetForegroundWindow(game_hwnd)              <span class="hljs-comment">#窗口浮现</span>    window_size = win32gui.GetWindowRect(game_hwnd)      <span class="hljs-comment">#pos: (x1, y1, x2, y2) &lt;pos: tuple&gt;</span></code></pre></div><h4 id="1、获取窗口句柄"><a href="#1、获取窗口句柄" class="headerlink" title="1、获取窗口句柄"></a>1、获取窗口句柄</h4><div class="hljs code-wrapper"><pre><code class="hljs python">win32gui.FindWindow(game_class, game_title)  <span class="hljs-comment">#获得句柄 &lt;hwnd: int&gt;</span></code></pre></div><p>关键在于 <strong>窗口类名</strong> 和 <strong>窗口标题 ** 的获取， 可以使用</strong>spy**++ 软件 来抓取窗口信息。</p><h4 id="2、窗口移到最前"><a href="#2、窗口移到最前" class="headerlink" title="2、窗口移到最前"></a>2、窗口移到最前</h4><div class="hljs code-wrapper"><pre><code class="hljs python">win32gui.SetForegroundWindow(game_hwnd)     <span class="hljs-comment">#窗口浮现</span></code></pre></div><p>把窗口移到前方，但窗口最小化后会有错误，待解决。</p><h4 id="3、获取窗口坐标位置"><a href="#3、获取窗口坐标位置" class="headerlink" title="3、获取窗口坐标位置"></a>3、获取窗口坐标位置</h4><div class="hljs code-wrapper"><pre><code class="hljs python">window_size = win32gui.GetWindowRect(game_hwnd)      <span class="hljs-comment">#pos: (x1, y1, x2, y2) &lt;pos: tuple&gt;</span></code></pre></div><p>获取窗口的位置，可以通过点坐标计算窗口大小，获取的位置数据类型为 元组 (X1, Y1, X2, Y2) 对应窗体左上角和右下角的坐标。</p><h4 id="4、更好的获取句柄的方式"><a href="#4、更好的获取句柄的方式" class="headerlink" title="4、更好的获取句柄的方式"></a>4、更好的获取句柄的方式</h4><p>因为有时候应用程序会更新，标题可能会更改，所以可以通过 窗口的标题进行关键字匹配，从而找到窗体句柄。</p><h2 id="四、图像识别"><a href="#四、图像识别" class="headerlink" title="四、图像识别"></a>四、图像识别</h2><h3 id="CV2-opencv-python"><a href="#CV2-opencv-python" class="headerlink" title="CV2 [ opencv-python ]"></a>CV2 [ opencv-python ]</h3><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a><strong>安装：</strong></h4><div class="hljs code-wrapper"><pre><code class="hljs python">pip3 install opencv-python</code></pre></div><p>会自动安装依赖的 numpy 模块。</p><p><strong>可能的import 错误：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs elm">&gt;&gt;&gt;<span class="hljs-keyword">import</span> cv2 <span class="hljs-type">ImportError</span>: numpy.core.multiarray failed to <span class="hljs-keyword">import</span></code></pre></div><p>原因是因为 numpy 模块的版本太新，将版本降低即可。</p><div class="hljs code-wrapper"><pre><code class="hljs python">pip3 install -U numpy==<span class="hljs-number">1.14</span><span class="hljs-number">.5</span></code></pre></div><p>具体版本和 opencv 的 版本有关。可以直接降低到 1.12.0。 如果版本太低，会有提示：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">opencv</span>-python <span class="hljs-number">4.4.0.46</span> has requirement numpy&gt;=<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">5</span>, but you&#x27;ll have numpy <span class="hljs-number">1</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span> which is incompatible.</code></pre></div><h4 id="基本库函数"><a href="#基本库函数" class="headerlink" title="基本库函数"></a>基本库函数</h4><h5 id="1、读入一张图像"><a href="#1、读入一张图像" class="headerlink" title="1、读入一张图像"></a>1、读入一张图像</h5><p><strong>cv2.imread(filepath, flags)</strong>   #读入一张图像</p><ul><li>filepath：要读入图片的完整路径</li><li>flags：读入图片的模式   <ul><li>cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道</li><li>cv2.IMREAD_GRAYSCALE：读入灰度图片</li><li>cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道</li></ul></li></ul><h5 id="2、显示图像"><a href="#2、显示图像" class="headerlink" title="2、显示图像"></a>2、显示图像</h5><p><strong>cv2.imshow(wname,img)</strong>   #显示图像</p><ul><li>第一个参数是显示图像的窗口的名字</li><li>第二个参数是要显示的图像（imread读入的图像），窗口大小自动调整为图片大小</li></ul><div class="hljs code-wrapper"><pre><code class="hljs python">cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>,img)cv2.waitKey(<span class="hljs-number">0</span>)   <span class="hljs-comment">#等待键盘输入，单位为毫秒，即等待指定的毫秒数看是否有键盘输入，若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行。</span><span class="hljs-comment">#若没有按下任何键，超时后返回-1。参数为0表示无限等待。不调用waitKey的话，窗口会一闪而逝，看不到显示的图片。</span>cv2.destroyAllWindow()     <span class="hljs-comment">#销毁所有窗口</span>cv2.destroyWindow(wname)   <span class="hljs-comment">#销毁指定窗口</span></code></pre></div><h5 id="3、保存图像"><a href="#3、保存图像" class="headerlink" title="3、保存图像"></a>3、保存图像</h5><p><strong>cv2.imwrite(file，img，num)</strong>  #保存一张图像</p><ul><li>第一个参数是要保存的文件名</li><li>第二个参数是要保存的图像。可选的第三个参数，它针对特定的格式：对于JPEG，其表示的是图像的质量，用0 - 100的整数表示，默认95。</li><li>第三个参数表示的是压缩级别。默认为3.</li></ul><h5 id="4、其他部分函数"><a href="#4、其他部分函数" class="headerlink" title="4、其他部分函数"></a>4、其他部分函数</h5><div class="hljs code-wrapper"><pre><code class="hljs python">img.copy()  <span class="hljs-comment">#图像复制</span>cv2.resize(image, image2,dsize)   <span class="hljs-comment">#图像缩放：(输入原始图像，输出新图像，图像的大小)</span>cv2.flip(img,flipcode)            <span class="hljs-comment">#图像翻转，flipcode控制翻转效果。</span><span class="hljs-comment">#flipcode = 0：沿x轴翻转；flipcode &gt; 0：沿y轴翻转；flipcode &lt; 0：x,y轴同时翻转</span></code></pre></div><h4 id="实现屏幕上找到特定图像"><a href="#实现屏幕上找到特定图像" class="headerlink" title="实现屏幕上找到特定图像"></a>实现屏幕上找到特定图像</h4><p><strong>cv2.matchTemplate(image, templ, method, result&#x3D;None, mask&#x3D;None)</strong></p><p> image：待搜索图像<br> templ：模板图像<br> result：匹配结果<br> method：匹配模式参数 </p><p><strong>method：</strong></p><ul><li>CV_TM_SQDIFF 平方差匹配法：该方法采用平方差来进行匹配；最好的匹配值为0；匹配越差，匹配值越大。</li><li>CV_TM_CCORR 相关匹配法：该方法采用乘法操作；数值越大表明匹配程度越好。</li><li>CV_TM_CCOEFF 相关系数匹配法：1表示完美的匹配；-1表示最差的匹配。</li><li>CV_TM_SQDIFF_NORMED 归一化平方差匹配法</li><li>CV_TM_CCORR_NORMED 归一化相关匹配法</li><li>CV_TM_CCOEFF_NORMED 归一化相关系数匹配法</li></ul><blockquote><p>模板匹配具有自身的局限性，主要表现在它只能进行平行移动，若原图像中的匹配目标发生旋转或大小变化，该算法无效。</p><p>一般，寻找的目标和容器，尺寸必须相同</p></blockquote><p> <strong>实例代码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">* @brief 在容器图片里寻找样例. 使用OPONCV TM_CCOEFF_NORMED 模式识别</span><span class="hljs-string">* @param template the target will find in container ex. &quot;D:\\a.jpg&quot;</span><span class="hljs-string">* @param container the pic where to find ex. &quot;D:\\b.jpg&quot;</span><span class="hljs-string">* @param thres the threshold of finding simlike, default 0.8, range(0, 1)</span><span class="hljs-string">* @retval 0 means not found, &gt; 0 means level of similarity range(0 ,1)</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">match_sim_img</span>(<span class="hljs-params">template, container, thres = <span class="hljs-number">0.80</span></span>):    template = cv2.imread(template,<span class="hljs-number">0</span>)    container = cv2.imread(container,<span class="hljs-number">0</span>)    res = cv2.matchTemplate(container, template, cv2.TM_CCOEFF_NORMED)    <span class="hljs-keyword">if</span> res.<span class="hljs-built_in">max</span>() &gt;= thres:        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">max</span>()    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre></div><p>返回值 res 为列表变量，所以取res.max() 判断是否大于阈值，大于就说明可能找到了该图。</p><hr><p>但我们的目的大部分的在屏幕上查找坐标，然后进行鼠标点击操作。那么如何获得图片相对于屏幕的坐标呢？</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<span class="hljs-keyword">import</span> cv2<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">* @brief 在容器图片里寻找样例并返回坐标值. 使用OPONCV TM_CCOEFF_NORMED 模式识别</span><span class="hljs-string">* @param template_path the target will find in container ex. &quot;D:\\a.jpg&quot;</span><span class="hljs-string">* @param container_path the pic where to find ex. &quot;D:\\b.jpg&quot;</span><span class="hljs-string">* @param thres the threshold of finding simlike, default 0.8, range(0, 1)</span><span class="hljs-string">* @retval tuple[X, Y], if return (0, 0) means not found.</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_img_pos</span>(<span class="hljs-params">template_path, container_path, thres = <span class="hljs-number">0.80</span></span>):    template = cv2.imread(template_path,<span class="hljs-number">0</span>)    container = cv2.imread(container_path,<span class="hljs-number">0</span>)    res = cv2.matchTemplate(container, template, cv2.TM_CCOEFF_NORMED)        <span class="hljs-keyword">if</span> res.<span class="hljs-built_in">max</span>() &lt; thres:        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)    container_size = Image.<span class="hljs-built_in">open</span>(template_path).size        loc = numpy.where(res==res.<span class="hljs-built_in">max</span>())    X = <span class="hljs-built_in">int</span>(loc[<span class="hljs-number">1</span>]+container_size[<span class="hljs-number">0</span>]/<span class="hljs-number">2</span>)    Y = <span class="hljs-built_in">int</span>(loc[<span class="hljs-number">0</span>]+container_size[<span class="hljs-number">1</span>]/<span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> (X,Y)</code></pre></div><h2 id="五、配置文件"><a href="#五、配置文件" class="headerlink" title="五、配置文件"></a>五、配置文件</h2><h3 id="configparser"><a href="#configparser" class="headerlink" title="configparser"></a>configparser</h3><p>python使用自带的<strong>configparser</strong>模块用来读取配置文件，配置文件的形式类似windows中的ini文件，在使用前需要先安装该模块，使用pip安装即可</p><div class="hljs code-wrapper"><pre><code class="hljs shell">pip install configparser</code></pre></div><hr><p><strong>实例：</strong></p><p>可以新建一个.ini文件 输入以下内容进行测试：</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[user-info]</span><span class="hljs-attr">name</span> = ZhangSan<span class="hljs-attr">passwd</span> = <span class="hljs-number">123456</span><span class="hljs-attr">level</span> = <span class="hljs-number">12</span><span class="hljs-section">[email]</span><span class="hljs-attr">address</span> = <span class="hljs-number">123455678</span>@qq.com<span class="hljs-attr">passwd</span> = <span class="hljs-number">123123</span></code></pre></div><p><strong>python code：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> configparser <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    cf = configparser.ConfigParser()    cf.read(<span class="hljs-string">&quot;C://temp/config.ini&quot;</span>)  <span class="hljs-comment"># 读取配置文件，如果写文件的绝对路径，就可以不用os模块</span>    secs = cf.sections()    <span class="hljs-comment"># 获取文件中所有的section, 一个配置文件中可以有多个配置  </span>    <span class="hljs-built_in">print</span>(secs)    sec_userinfo = cf.options(<span class="hljs-string">&quot;user-info&quot;</span>)  <span class="hljs-comment"># 获取sec名为user-info 所有的键</span>    <span class="hljs-built_in">print</span>(sec_userinfo)    items_userinfo = cf.items(<span class="hljs-string">&quot;user-info&quot;</span>)  <span class="hljs-comment"># 获取sec名为user-info 所有的键值对</span>    <span class="hljs-built_in">print</span>(items_userinfo)    username = cf.get(<span class="hljs-string">&quot;user-info&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>)  <span class="hljs-comment"># 获取[user-info]name 对应的值</span>    <span class="hljs-built_in">print</span>(username)        level = cf.getint(<span class="hljs-string">&quot;user-info&quot;</span>, <span class="hljs-string">&quot;level&quot;</span>)    <span class="hljs-built_in">print</span>(level + <span class="hljs-number">2</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    main()</code></pre></div><p>执行结果如下：</p><div class="hljs code-wrapper"><pre><code class="hljs css">&gt;&gt;&gt;<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;user-info&#x27;</span>, <span class="hljs-string">&#x27;email&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;passwd&#x27;</span>]</span><span class="hljs-selector-attr">[(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;ZhangSan&#x27;</span>), (<span class="hljs-string">&#x27;passwd&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)]</span>ZhangSan<span class="hljs-number">14</span></code></pre></div><hr><p><strong>实例2</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> configparser<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">config.ini 内容：</span><span class="hljs-string"></span><span class="hljs-string">[game-info]</span><span class="hljs-string">title = NBA2KOL2 0.3.230.675</span><span class="hljs-string">classname = &quot;NBAWindowClass&quot;</span><span class="hljs-string"></span><span class="hljs-string">[debug-config]</span><span class="hljs-string">debug_enable = False</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    cf = configparser.ConfigParser()  cf.read(<span class="hljs-string">&quot;F:\MarsCloud\MyFortune\Program\mycode\python\code\gameAssistant_2kol2\config.ini&quot;</span>)          title = cf.get(<span class="hljs-string">&quot;game-info&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>)    <span class="hljs-built_in">print</span>(title)    classname = cf.get(<span class="hljs-string">&quot;game-info&quot;</span>, <span class="hljs-string">&quot;classname&quot;</span>)    <span class="hljs-built_in">print</span>(name)    val_bool = cf.getboolean(<span class="hljs-string">&quot;debug-config&quot;</span>, <span class="hljs-string">&quot;debug_enable&quot;</span>)    <span class="hljs-built_in">print</span>(val_bool)</code></pre></div><p>结果：</p><div class="hljs code-wrapper"><pre><code class="hljs ada">&gt;&gt;&gt;NBA2KOL2 <span class="hljs-number">0.3</span>.<span class="hljs-number">230.675</span><span class="hljs-string">&quot;NBAWindowClass&quot;</span><span class="hljs-literal">False</span></code></pre></div><h2 id="六、其他知识"><a href="#六、其他知识" class="headerlink" title="六、其他知识"></a>六、其他知识</h2><h3 id="1、判断是否以管理员模式运行"><a href="#1、判断是否以管理员模式运行" class="headerlink" title="1、判断是否以管理员模式运行"></a>1、判断是否以管理员模式运行</h3><p><strong>使用 pywin32 模块</strong></p><p><strong>代码如下：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> win32com.shell <span class="hljs-keyword">import</span> shell<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-keyword">if</span> shell.IsUserAnAdmin():        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;now is admin mode.&quot;</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;just a poor man.&quot;</span>)</code></pre></div><hr><h3 id="2、获取程序当前绝对路径"><a href="#2、获取程序当前绝对路径" class="headerlink" title="2、获取程序当前绝对路径"></a>2、获取程序当前绝对路径</h3><p><strong>使用 os 模块</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-built_in">print</span>(os.getcwd())</code></pre></div><h2 id="七、NBA2kOL2-挂机实例"><a href="#七、NBA2kOL2-挂机实例" class="headerlink" title="七、NBA2kOL2 挂机实例"></a>七、NBA2kOL2 挂机实例</h2><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string"> @brief This is for NBA2KOL2 game.</span><span class="hljs-string"> @author firestaradmin 2020年12月16日</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image,ImageGrab<span class="hljs-keyword">from</span> cv2 <span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> autopy<span class="hljs-keyword">import</span> win32gui<span class="hljs-keyword">from</span> win32com.shell <span class="hljs-keyword">import</span> shell<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> configparser<span class="hljs-comment"># Configuartion</span>debug_enable = <span class="hljs-literal">True</span> <span class="hljs-comment"># config if print debug</span><span class="hljs-comment"># &#x27;GLOBAL VARIABLE&#x27;</span>game_title = <span class="hljs-string">&quot;NBA2KOL2 0.3.230.675&quot;</span>game_class = <span class="hljs-string">&quot;NBAWindowClass&quot;</span>game_hwnd = <span class="hljs-number">0</span>window_size = (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)game_completed_cnt = <span class="hljs-number">0</span>game_win_cnt = <span class="hljs-number">0</span>game_fail_cnt = <span class="hljs-number">0</span>game_one_game_timeS = <span class="hljs-number">0</span>cwd_path = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">* @brief 在容器图片里寻找样例并返回坐标值. 使用OPONCV TM_CCOEFF_NORMED 模式识别</span><span class="hljs-string">* @param template   the path of target will find in container. ex- &quot;D:\\a.jpg&quot;</span><span class="hljs-string">* @param container  the path of pic where to find. ex- &quot;D:\\b.jpg&quot;</span><span class="hljs-string">* @param img_mode   the img open mode. </span><span class="hljs-string">    - cv2.IMREAD_COLOR：    默认参数，读入一副彩色图片，忽略alpha通道</span><span class="hljs-string">    - cv2.IMREAD_GRAYSCALE：读入灰度图片</span><span class="hljs-string">    - cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道</span><span class="hljs-string">* @param thres      the threshold of finding simlike level. default 0.7, range(0, 1)</span><span class="hljs-string">* @retval (X, Y), find_falg, matching_value</span><span class="hljs-string">    (X, Y): The relative center coordinate of matched template.</span><span class="hljs-string">    find_flag: if have found return True </span><span class="hljs-string">    matching_value: return finding max value</span><span class="hljs-string"></span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_img_pos</span>(<span class="hljs-params">template_path, container_path, img_mode = cv2.IMREAD_GRAYSCALE, thres = <span class="hljs-number">0.7</span></span>):    template = cv2.imread(template_path, img_mode)    container = cv2.imread(container_path, img_mode)    res = cv2.matchTemplate(container, template, cv2.TM_CCOEFF_NORMED)        <span class="hljs-keyword">if</span> res.<span class="hljs-built_in">max</span>() &lt; thres:        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-literal">False</span>, res.<span class="hljs-built_in">max</span>()    container_size = Image.<span class="hljs-built_in">open</span>(template_path).size        loc = numpy.where(res==res.<span class="hljs-built_in">max</span>())    X = <span class="hljs-built_in">int</span>(loc[<span class="hljs-number">1</span>]+container_size[<span class="hljs-number">0</span>]/<span class="hljs-number">2</span>)    Y = <span class="hljs-built_in">int</span>(loc[<span class="hljs-number">0</span>]+container_size[<span class="hljs-number">1</span>]/<span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> (X,Y), <span class="hljs-literal">True</span>, res.<span class="hljs-built_in">max</span>()    <span class="hljs-comment"># @brief capture window and save it.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">grab_window</span>():    <span class="hljs-keyword">global</span> game_hwnd, window_size, cwd_path    win32gui.SetForegroundWindow(game_hwnd) <span class="hljs-comment">#窗口浮现</span>    mydelay(<span class="hljs-number">0.3</span>)    im = ImageGrab.grab(window_size)     <span class="hljs-comment">#截取屏幕指定区域的图像 </span>    im.save(cwd_path + <span class="hljs-string">&quot;/resource/window.jpg&quot;</span>);<span class="hljs-comment">#储存为.jpg</span>    mydelay(<span class="hljs-number">0.2</span>)<span class="hljs-comment"># @brief find a template and click it.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">finding_in_window_and_click_it</span>(<span class="hljs-params">template_path, click_delay = <span class="hljs-number">0.5</span>, img_mode = cv2.IMREAD_GRAYSCALE, thres = <span class="hljs-number">0.7</span></span>):    <span class="hljs-keyword">global</span> cwd_path    grab_window()   <span class="hljs-comment">#截取窗口</span>    err_code = <span class="hljs-number">0</span>    relative_pos, flag, value = get_img_pos(template_path, cwd_path + <span class="hljs-string">&quot;/resource/window.jpg&quot;</span>, img_mode, thres)    mydebug(<span class="hljs-string">&quot;匹配度:&quot;</span>+ <span class="hljs-built_in">str</span>(value)+ <span class="hljs-string">&quot;of&quot;</span>+ template_path)    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> flag):        err_code = <span class="hljs-number">1</span>    <span class="hljs-comment">#have not found template.</span>        <span class="hljs-keyword">return</span>    abs_pos = (relative_pos[<span class="hljs-number">0</span>] + window_size[<span class="hljs-number">0</span>], relative_pos[<span class="hljs-number">1</span>] + window_size[<span class="hljs-number">1</span>])    autopy.mouse.move(abs_pos[<span class="hljs-number">0</span>], abs_pos[<span class="hljs-number">1</span>])    mydelay(<span class="hljs-number">0.5</span>)    autopy.mouse.click(autopy.mouse.Button.LEFT, click_delay)    <span class="hljs-keyword">return</span> err_code<span class="hljs-comment"># @brief detect a page, until timeOut.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">detect_page_apper</span>(<span class="hljs-params">detect_img_path, timeOut_S, detect_period_S = <span class="hljs-number">5</span>, img_mode = cv2.IMREAD_GRAYSCALE, thres = <span class="hljs-number">0.7</span></span>):    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始侦测 &quot;</span>, detect_img_path, <span class="hljs-string">&quot;=============================&quot;</span>)    <span class="hljs-keyword">global</span> cwd_path    timeOut = timeOut_S    <span class="hljs-keyword">while</span>(timeOut &gt; <span class="hljs-number">0</span>):        grab_window()   <span class="hljs-comment">#截取窗口</span>        pos, flag, value = get_img_pos(detect_img_path, cwd_path + <span class="hljs-string">&quot;/resource/window.jpg&quot;</span>, img_mode, thres)                mydebug(detect_img_path + <span class="hljs-string">&quot; 匹配度= &quot;</span>+ <span class="hljs-built_in">str</span>(value))  <span class="hljs-comment">#for debug</span>        <span class="hljs-keyword">if</span>(flag):            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        mydelay(detect_period_S - <span class="hljs-number">0.5</span>)   <span class="hljs-comment">#why need sub 0.5s, because grab_window() will delay 0.5s.</span>        timeOut -= detect_period_S        mydebug(<span class="hljs-string">&quot;Time_elapsed: &quot;</span>+ <span class="hljs-built_in">str</span>(timeOut_S - timeOut)+ <span class="hljs-string">&quot;S&quot;</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>           <span class="hljs-comment"># only used in detect game over.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">detect_game_over</span>(<span class="hljs-params">timeOut_S, detect_period_S = <span class="hljs-number">5</span>, img_mode = cv2.IMREAD_GRAYSCALE, thres = <span class="hljs-number">0.7</span></span>):    <span class="hljs-keyword">global</span> game_win_cnt, game_fail_cnt, cwd_path    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始侦测, 等待比赛结束 =============================&quot;</span>)    timeOut = timeOut_S    <span class="hljs-keyword">while</span>(timeOut &gt; <span class="hljs-number">0</span>):        grab_window()   <span class="hljs-comment">#截取窗口</span>        pos, flag, value = get_img_pos(cwd_path + <span class="hljs-string">&quot;/resource/fail_label.jpg&quot;</span>, cwd_path + <span class="hljs-string">&quot;/resource/window.jpg&quot;</span>, img_mode, thres)        mydebug(<span class="hljs-string">&quot;失败标志匹配度= &quot;</span>+ <span class="hljs-built_in">str</span>(value))  <span class="hljs-comment">#for debug</span>        <span class="hljs-keyword">if</span>(flag):            game_fail_cnt += <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        pos, flag, value = get_img_pos(cwd_path + <span class="hljs-string">&quot;/resource/win_label.jpg&quot;</span>, cwd_path + <span class="hljs-string">&quot;/resource/window.jpg&quot;</span>, img_mode, thres)        mydebug(<span class="hljs-string">&quot;胜利标志匹配度= &quot;</span>+ <span class="hljs-built_in">str</span>(value))  <span class="hljs-comment">#for debug</span>        <span class="hljs-keyword">if</span>(flag):            game_win_cnt += <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        mydelay(detect_period_S - <span class="hljs-number">0.5</span>)   <span class="hljs-comment">#why need sub 0.5s, because grab_window() will delay 0.5s.</span>        timeOut -= detect_period_S        mydebug(<span class="hljs-string">&quot;Time_elapsed: &quot;</span> + <span class="hljs-built_in">str</span>(timeOut_S - timeOut) + <span class="hljs-string">&quot;S&quot;</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">mydebug</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):    <span class="hljs-keyword">global</span> debug_enable    <span class="hljs-keyword">if</span>(debug_enable):        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[debug] &quot;</span>, <span class="hljs-built_in">str</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mydelay</span>(<span class="hljs-params">timeS</span>):    <span class="hljs-keyword">global</span> game_one_game_timeS    time.sleep(timeS)    game_one_game_timeS += timeS<span class="hljs-keyword">def</span> <span class="hljs-title function_">if_admin_runing</span>():    <span class="hljs-keyword">if</span> shell.IsUserAnAdmin():        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">myinit</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======== 使用前注意把游戏调至窗口模式 分辨率 1440x900 !! =====I,me,justice AG====&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======== 使用前注意把游戏调至窗口模式 分辨率 1440x900 !! =====  is the most  ====&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======== 注意游戏版本号，因为标题会随着版本号改变        ===most cool perfect====&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======== 标题改变要修改 根目录下的 config.ini 文件 配置 =====cool superman!======&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>)    time.sleep(<span class="hljs-number">0.5</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;初始化中......&quot;</span>)    time.sleep(<span class="hljs-number">0.5</span>)    <span class="hljs-comment"># 初始化变量</span>    <span class="hljs-keyword">global</span> game_hwnd, window_size, debug_enable, cwd_path    cwd_path = os.getcwd().replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)    cwd_temp = cwd_path+<span class="hljs-string">&quot;/config.ini&quot;</span>    <span class="hljs-comment"># 读取Config文件</span>    cf = configparser.ConfigParser()    cf.read(cwd_temp)    game_title = cf.get(<span class="hljs-string">&quot;game-info&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>)    game_class = cf.get(<span class="hljs-string">&quot;game-info&quot;</span>, <span class="hljs-string">&quot;classname&quot;</span>)    debug_enable = cf.getboolean(<span class="hljs-string">&quot;debug-config&quot;</span>, <span class="hljs-string">&quot;debug_print_enable&quot;</span>)    <span class="hljs-comment"># 获取窗口句柄</span>    game_hwnd = win32gui.FindWindow(game_class, game_title)  <span class="hljs-comment">#获得句柄</span>    <span class="hljs-keyword">if</span>(game_hwnd == <span class="hljs-number">0</span>):        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未检测到游戏窗口，有以下几种原因可能：&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1.游戏未运行。。真的呆哦&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2.游戏更新了，版本号有变动，请到脚本根目录下的config.ini文件进行修改标题名称&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;3.可能你不配吧，嘻嘻&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请打开游戏正确配置后再运行脚本，谢谢合作。&quot;</span>)        os.system(<span class="hljs-string">&#x27;pause&#x27;</span>)        exit()    time.sleep(<span class="hljs-number">0.5</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;游戏窗口句柄为：&quot;</span>,game_hwnd)    time.sleep(<span class="hljs-number">0.5</span>)    win32gui.SetForegroundWindow(game_hwnd)              <span class="hljs-comment">#窗口浮现</span>    window_size = win32gui.GetWindowRect(game_hwnd)      <span class="hljs-comment">#pos: x1, y1, x2, y2</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">myexit</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== 异常错误！请重新运行脚本 ==&quot;</span>)    <span class="hljs-keyword">global</span> game_completed_cnt, game_win_cnt, game_fail_cnt    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已完成&quot;</span>, game_completed_cnt, <span class="hljs-string">&quot; 场比赛。&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;胜利&quot;</span>, game_win_cnt, <span class="hljs-string">&quot; 场比赛。&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;失败&quot;</span>, game_fail_cnt, <span class="hljs-string">&quot; 场比赛。&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;===============================&quot;</span>)    os.system(<span class="hljs-string">&quot;pause&quot;</span>)    exit()<span class="hljs-comment"># =================================== main ======================================</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    <span class="hljs-comment"># 检查是否以管理员模式运行</span>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> if_admin_runing()):        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请以管理员模式 重新运行本脚本！&quot;</span>)        os.system(<span class="hljs-string">&#x27;pause&#x27;</span>)        exit()    <span class="hljs-comment"># 初始化</span>    <span class="hljs-keyword">global</span> game_completed_cnt, game_win_cnt, game_fail_cnt, game_one_game_timeS    myinit()    <span class="hljs-comment">#开始循环进行比赛</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始比赛循环&quot;</span>)    time.sleep(<span class="hljs-number">0.5</span>)    <span class="hljs-keyword">while</span> (<span class="hljs-literal">True</span>):        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始新一局比赛============&quot;</span>)        mydelay(<span class="hljs-number">1</span>)        err = finding_in_window_and_click_it(cwd_path + <span class="hljs-string">&quot;/resource/main_page_start.jpg&quot;</span>, <span class="hljs-number">1</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.58</span>)        <span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[开始比赛] 点击成功&quot;</span>)        <span class="hljs-keyword">else</span>:               <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[开始比赛] 点击失败&quot;</span>)            myexit()        mydelay(<span class="hljs-number">1</span>)        err = finding_in_window_and_click_it(cwd_path + <span class="hljs-string">&quot;/resource/start_page_paiwei.jpg&quot;</span>, <span class="hljs-number">1</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.6</span>)        <span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[排位] 点击成功&quot;</span>)        <span class="hljs-keyword">else</span>:               <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[排位] 点击失败&quot;</span>)            myexit()        mydelay(<span class="hljs-number">1</span>)        err = finding_in_window_and_click_it(cwd_path + <span class="hljs-string">&quot;/resource/start_paiwei_page_jingli.jpg&quot;</span>, <span class="hljs-number">1</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.6</span>)        <span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[经理模式] 点击成功&quot;</span>)        <span class="hljs-keyword">else</span>:               <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[经理模式] 点击失败&quot;</span>)            myexit()        mydelay(<span class="hljs-number">1</span>)        err = finding_in_window_and_click_it(cwd_path + <span class="hljs-string">&quot;/resource/start_paiwei_jingli_page_enter.jpg&quot;</span>, <span class="hljs-number">1</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.6</span>)        <span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[进入] 点击成功&quot;</span>)        <span class="hljs-keyword">else</span>:               <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[进入] 点击失败&quot;</span>)            myexit()    <span class="hljs-comment">#********等待匹配， 准备*********</span>        ret = detect_page_apper(cwd_path + <span class="hljs-string">&quot;/resource/zhunbei_page_judge.jpg&quot;</span>, <span class="hljs-number">60</span>*<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.7</span>)        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> ret):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备阶段错误！&quot;</span>)            myexit()        mydelay(<span class="hljs-number">2</span>)        err = finding_in_window_and_click_it(cwd_path + <span class="hljs-string">&quot;/resource/zhunbei_page_ready.jpg&quot;</span>, <span class="hljs-number">1</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.6</span>)        <span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[准备] 点击成功&quot;</span>)        <span class="hljs-keyword">else</span>:               <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[准备] 点击失败&quot;</span>)            myexit()    <span class="hljs-comment">#********等待比赛完毕， 结算*********</span>        <span class="hljs-comment"># ret = detect_page_apper(cwd_path + &quot;/resource/end_page_judge.jpg&quot;, 60*40, 5, cv2.IMREAD_GRAYSCALE, 0.58)</span>        ret = detect_game_over(<span class="hljs-number">60</span>*<span class="hljs-number">40</span>, <span class="hljs-number">5</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.7</span>)        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> ret):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;err:未匹配到比赛完毕界面！&quot;</span>)            myexit()        mydelay(<span class="hljs-number">3</span>)        err = finding_in_window_and_click_it(cwd_path + <span class="hljs-string">&quot;/resource/end_page_confirm.jpg&quot;</span>, <span class="hljs-number">1</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.7</span>)        <span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[确定比赛结果] 点击成功&quot;</span>)        <span class="hljs-keyword">else</span>:               <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[确定比赛结果] 点击失败&quot;</span>)            myexit()        mydelay(<span class="hljs-number">3</span>)        err = finding_in_window_and_click_it(cwd_path + <span class="hljs-string">&quot;/resource/end_jiesuan_page_next.jpg&quot;</span>, <span class="hljs-number">1</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.7</span>)        <span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[下一页] 点击成功&quot;</span>)        <span class="hljs-keyword">else</span>:               <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[下一页] 点击失败&quot;</span>)            myexit()        mydelay(<span class="hljs-number">1</span>)        err = finding_in_window_and_click_it(cwd_path + <span class="hljs-string">&quot;/resource/end_jiesuan2_page_next.jpg&quot;</span>, <span class="hljs-number">1</span>, cv2.IMREAD_GRAYSCALE, <span class="hljs-number">0.7</span>)        <span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[下一页] 点击成功&quot;</span>)        <span class="hljs-keyword">else</span>:               <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[下一页] 点击失败&quot;</span>)            myexit()    <span class="hljs-comment">#********结算完毕， 开始下一局*********</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成功完成一局比赛！ 花费&quot;</span>, game_one_game_timeS, <span class="hljs-string">&quot;秒&quot;</span>)        game_one_game_timeS = <span class="hljs-number">0</span>        game_completed_cnt += <span class="hljs-number">1</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已完成&quot;</span>, game_completed_cnt, <span class="hljs-string">&quot; 场比赛。&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;胜利&quot;</span>, game_win_cnt, <span class="hljs-string">&quot; 场比赛。&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;失败&quot;</span>, game_fail_cnt, <span class="hljs-string">&quot; 场比赛。&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;10秒后开始下一局比赛=============&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;===============================&quot;</span>)        mydelay(<span class="hljs-number">10</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    main()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIN10右键菜单</title>
    <link href="/2020/12/11/NOTE/Windows/WIN10%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
    <url>/2020/12/11/NOTE/Windows/WIN10%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>@firestaradmin 2020年12月11日15:34:07</p><h1 id="WIN10右键菜单"><a href="#WIN10右键菜单" class="headerlink" title="WIN10右键菜单"></a>WIN10右键菜单</h1><h2 id="一、新建文本文档的快捷键设置"><a href="#一、新建文本文档的快捷键设置" class="headerlink" title="一、新建文本文档的快捷键设置"></a>一、新建文本文档的快捷键设置</h2><p><strong>1、WIN + R 输入 <code>regedit</code> 打开注册表编辑器</strong></p><p><strong>2、定位到 <code>HKEY_CLASSES_ROOT\Local Settings\MuiCache\63\AAF68885 </code></strong>    (这个路径的 63  不同电脑是不同的，以自己的为准)    之后找到右侧@C:\Windows\system32\notepad.exe,-469，将 <code>文本文档</code> 改为 <code>文本文档(&amp;T)</code>，这里的 <code>文本文档(&amp;T)</code> T 就是快捷键。之后就可以右键后按WT 就可以直接新建一个文本文档啦。</p><p>其他的快捷键以此类推。</p><h2 id="二、添加右键新建菜单"><a href="#二、添加右键新建菜单" class="headerlink" title="二、添加右键新建菜单"></a>二、添加右键新建菜单</h2><p><strong>比如说右键添加新建.md （Typora）文档。</strong></p><p>1、一样 WIN + R 打开 regedit 注册表编辑器。</p><p>2、在<code>计算机&gt;HKEY_CLASSES_ROOT</code>右键查找，输入<code>Typora</code>，勾选项，取消勾选值和数据</p><p><img src="/2020/12/11/NOTE/Windows/WIN10%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/image-20201211153827891.png" alt="image-20201211153827891"></p><p>确认运行的程序名字，我的电脑如图所示，运行文件是<code>Typora.exe</code></p><p><img src="/2020/12/11/NOTE/Windows/WIN10%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/image-20201211153851340.png" alt="image-20201211153851340"></p><p>如果使用的是其他编辑器，同理查找即可。</p><p>3、新建一个txt文件，并在里面输入以下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs reg">Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\.md]@=&quot;Typora.exe&quot;[HKEY_CLASSES_ROOT\.md\ShellNew]&quot;NullFile&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Typora.exe]@=&quot;Markdown&quot;</code></pre></div><ul><li><code>@=&quot;Typora.exe&quot;</code>代表的是指定.md文件的运行程序 , 也就是我们刚刚查找到的名字。</li><li><code>@=&quot;Markdown&quot;</code> 代表的是右键时默认的文件名字，这样写新建为<code>新建Markdown.md</code>文件，而且右键菜单中显示MarkDown。那有个问题来啦，在第一个教程里，我们是不是可以加快捷键，这里如果直接把<code>@=&quot;Markdown&quot;</code> 这个 改成 <code>@=&quot;Markdown(&amp;D)&quot;</code> 这样就有快捷键啦。</li></ul><hr><p>其它的以此类推。</p><h2 id="三、-右键VSCode-打开"><a href="#三、-右键VSCode-打开" class="headerlink" title="三、 右键VSCode 打开"></a>三、 右键VSCode 打开</h2><p>新建reg 文件运行，记得修改VSCode 路径</p><div class="hljs code-wrapper"><pre><code class="hljs reg">Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;C:\\Users\\ACGkaka\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe&quot;[HKEY_CLASSES_ROOT\*\shell\VSCode\command]@=&quot;\&quot;C:\\Users\\ACGkaka\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\&quot; \&quot;%1\&quot;&quot;    Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;C:\\Users\\ACGkaka\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe&quot;[HKEY_CLASSES_ROOT\Directory\shell\VSCode\command]@=&quot;\&quot;C:\\Users\\ACGkaka\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot;Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;C:\\Users\\ACGkaka\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe&quot;[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode\command]@=&quot;\&quot;C:\\Users\\ACGkaka\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>WIN10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件共享</title>
    <link href="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    <url>/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux文件共享"><a href="#Linux文件共享" class="headerlink" title="Linux文件共享"></a>Linux文件共享</h1><p>@firestaradmin 2020年12月10日</p><h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2><h3 id="NFS-服务端"><a href="#NFS-服务端" class="headerlink" title="NFS 服务端"></a>NFS 服务端</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install nfs-kernel-server rpcbind</code></pre></div><p>安装完成后创建一个nfs文件夹，以后需要通过网络用的文件都放这里.<code>xxxx/nfs</code></p><p>之后配置文件&#x2F;etc&#x2F;exports：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vi /etc/exports</code></pre></div><p>在文件末尾添加如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">xxxx/nfs *(rw,<span class="hljs-built_in">sync</span>,no_root_squash)</code></pre></div><p>重启 NFS 服务</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo /etc/init.d/nfs-kernel-server restart</code></pre></div><h3 id="NFS客户端"><a href="#NFS客户端" class="headerlink" title="NFS客户端"></a>NFS客户端</h3><p>安装客户端应用：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">apt-get install -y nfs-common</code></pre></div><p>用mkdir命令创建一个文件夹xxx&#x2F;nfs-mount。</p><p>将NFS服务器的xxx&#x2F;nfs 目录挂载到NFS客户端的xxx&#x2F;nfs-mount 目录，执行以下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">mount 192.168.119.128:xxx/nfs  xxx/nfs-mount</code></pre></div><h3 id="连接失败情况解决："><a href="#连接失败情况解决：" class="headerlink" title="连接失败情况解决："></a>连接失败情况解决：</h3><p>如果出现以下情况</p><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/image-20200820013608568.png" alt="image-20200820013608568"></p><p>ARM-Linux NFS挂载不上，是由于高版本的NFS服务，默认不支持nfs v2的连接，而uboot中nfs服务是 V2版本的，所以需要修改<code>/etc/default/nfs-kernel-server </code>文件以支持v2 nfs。</p><p>修改完内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># Number of servers to start up</span><span class="hljs-comment">#RPCNFSDCOUNT=8</span>RPCNFSDCOUNT=<span class="hljs-string">&#x27;-V 2 8&#x27;</span><span class="hljs-comment"># Runtime priority of server (see nice(1))</span>RPCNFSDPRIORITY=0<span class="hljs-comment"># Options for rpc.mountd.</span><span class="hljs-comment"># If you have a port-based firewall, you might want to set up</span><span class="hljs-comment"># a fixed port here using the --port option. For more information, </span><span class="hljs-comment"># see rpc.mountd(8) or http://wiki.debian.org/SecuringNFS</span><span class="hljs-comment"># To disable NFSv4 on the server, specify &#x27;--no-nfs-version 4&#x27; here</span><span class="hljs-comment">#RPCMOUNTDOPTS=&quot;--manage-gids&quot;</span>RPCMOUNTDOPTS=<span class="hljs-string">&quot;-V 2 --manage-gids&quot;</span><span class="hljs-comment"># Do you want to start the svcgssd daemon? It is only required for Kerberos</span><span class="hljs-comment"># exports. Valid alternatives are &quot;yes&quot; and &quot;no&quot;; the default is &quot;no&quot;.</span>NEED_SVCGSSD=<span class="hljs-string">&quot;&quot;</span><span class="hljs-comment"># Options for rpc.svcgssd.</span>RPCSVCGSSDOPTS=<span class="hljs-string">&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span></code></pre></div><h2 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h2><h3 id="1、在Ubuntu上安装Samba"><a href="#1、在Ubuntu上安装Samba" class="headerlink" title="1、在Ubuntu上安装Samba"></a>1、在Ubuntu上安装Samba</h3><p><strong>更新apt包索引：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt update</code></pre></div><p><strong>安装Samba软件包：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo apt install samba</code></pre></div><p><strong>安装完成后，Samba服务将自动启动。 要检查Samba服务器是否正在运行，请键入：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo systemctl status nmbd//或service smbd status</code></pre></div><p><strong>输出应如下所示，表示Samba服务处于活动状态并正在运行：</strong></p><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/image-20201210172357197.png" alt="image-20201210172357197"></p><h3 id="2、创建共享的文件位置和创建用户"><a href="#2、创建共享的文件位置和创建用户" class="headerlink" title="2、创建共享的文件位置和创建用户"></a>2、创建共享的文件位置和创建用户</h3><p><strong>1、创建要共享的文件位置：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> xxx/samba_share</code></pre></div><p><strong>2、设置共享文件的权限</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">chomd -R 777 xxx/samba_share</code></pre></div><p><strong>3、创建Samba用户</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo smbpasswd -a Samba用户名</code></pre></div><p><strong>然后输入密码</strong></p><h3 id="3、配置Samba"><a href="#3、配置Samba" class="headerlink" title="3、配置Samba"></a>3、配置Samba</h3><p><strong>1、在更改Samba配置文件之前，请创建备份以供将来参考或还原：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo cp <span class="hljs-regexp">/etc/</span>samba<span class="hljs-regexp">/smb.conf /</span>etc<span class="hljs-regexp">/samba/</span>smb.conf.bak</code></pre></div><p><strong>2、修改配置文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>samba/smb.conf</code></pre></div><p><strong>在最后增加以下内容：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">[share]<span class="hljs-comment"># 连接的时候的名字</span>   comment = share folder<span class="hljs-comment"># 描述，说明共享信息</span>   path = xxx/samba_share<span class="hljs-comment"># 要共享的文件位置</span>   create mask = 0777<span class="hljs-comment"># 创建文件的权限</span>   directory mask = 0777    <span class="hljs-comment"># 创建目录的权限</span>   valid <span class="hljs-built_in">users</span> = wzh<span class="hljs-comment"># 允许使用服务的用户列表</span>   force user = nobody<span class="hljs-comment"># 前置把共享的文件属主</span>   force group = nogroup<span class="hljs-comment"># 可以访问的用户组</span>   public = <span class="hljs-built_in">yes</span><span class="hljs-comment"># 允许guest用户访问，与guest ok=yes完全相同</span>   available = <span class="hljs-built_in">yes</span><span class="hljs-comment"># 该指定共享资源可使用</span>   writable = <span class="hljs-built_in">yes</span>       <span class="hljs-comment"># 是否可写</span>   browseable = <span class="hljs-built_in">yes</span><span class="hljs-comment"># 是否可见，no为隐藏共享</span>   <span class="hljs-built_in">read</span> only = no     <span class="hljs-comment"># 是否为只读</span></code></pre></div><p>其他设置：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">samba安全级别       share   <span class="hljs-comment">##匿名共享，不需要用户名密码</span>       user    <span class="hljs-comment">#需要用户名密码，默认由samba服务器检查  </span>       server    <span class="hljs-comment">#由指定的服务器认证</span>       domain     <span class="hljs-comment">#由域控制器验证</span></code></pre></div><p><strong>3、重启Samba</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo systemctl restart nmbd// 或者service smbd restart</code></pre></div><p><strong>4、验证配置的正确性</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">smbclient -L //localhost/share</code></pre></div><p><strong>输入账号和密码，正确则会出现以下内容：</strong></p><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/image-20201210172732864.png" alt="image-20201210172732864"></p><hr><h3 id="4、WIN10连接Samba"><a href="#4、WIN10连接Samba" class="headerlink" title="4、WIN10连接Samba"></a>4、WIN10连接Samba</h3><p><strong>0、确保windows配置正确</strong></p><ul><li>确保windows能访问到Ubuntu的地址</li><li>确保windows共享服务已开启</li></ul><h4 id="1、法一："><a href="#1、法一：" class="headerlink" title="1、法一："></a><strong>1、法一：</strong></h4><p>win键 + R 打开运行,，并输入：<code>\\192.168.12.200\share</code></p><p><strong>注意！！</strong>此处的<code>\\192.168.12.200\share</code> 里的 <code>share</code> 和之前我们添加配置的 中括号中的内容一致，而不是你的共享目录的路径。</p><h4 id="2、法二："><a href="#2、法二：" class="headerlink" title="2、法二："></a><strong>2、法二：</strong></h4><p>此电脑&#x3D;&#x3D;》映射网络驱动器&#x3D;&#x3D;》映射网络驱动器</p><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/image-20201210173039083.png" alt="image-20201210173039083"></p><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/image-20201210173043771.png" alt="image-20201210173043771"></p><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/image-20201210173056813.png" alt="image-20201210173056813"></p><h3 id="5、可能遇到的问题"><a href="#5、可能遇到的问题" class="headerlink" title="5、可能遇到的问题"></a>5、可能遇到的问题</h3><h4 id="防火墙问题"><a href="#防火墙问题" class="headerlink" title="防火墙问题"></a><strong>防火墙问题</strong></h4><p>有时候会因为防火墙的原因导致window访问Ubuntu中的共享文件失败。</p><p><strong>（1）法一：</strong></p><p>关闭防火墙：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo ufw <span class="hljs-built_in">disable</span></code></pre></div><p>注：开启防火墙：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo ufw <span class="hljs-built_in">enable</span></code></pre></div><p><strong>（2）允许Samba使用端口</strong></p><p>查看Samba服务所使用的端口：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">netstat -anop | grep smbd（Samba）</code></pre></div><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/20201204162510322.png" alt="img"></p><div class="hljs code-wrapper"><pre><code class="hljs sh">netstat -anop | grep nmbd</code></pre></div><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/20201204162510288.png" alt="img"></p><p>nmbd是属于smb服务的一个进程。</p><p>我们看到使用了tcp的139和445端口，udp的137和138端口。在防火墙中允许通行，如允许139端口被访问：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo ufw alow 139\\ 或者sudo allow Sambd</code></pre></div><p><strong>（3）查看ufw状态</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo ufw status</code></pre></div><h4 id="windows10上面的配置问题"><a href="#windows10上面的配置问题" class="headerlink" title="windows10上面的配置问题"></a>windows10上面的配置问题</h4><p><strong>（1）开启共享服务</strong></p><p>​    控制面板&#x3D;&#x3D;》卸载程序&#x3D;&#x3D;》启动或关闭windows功能&#x3D;&#x3D;》勾选SMB1.0&#x2F;CIFS文件共享支持&#x3D;&#x3D;》重启电脑</p><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/20201204162510253.png" alt="img"></p><p><strong>（2）本地组策略编辑</strong></p><p>注意win10家庭版一开始是打不开本地组策略的</p><p><strong>（a）新建文档，内容入下：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs cmd">@<span class="hljs-built_in">echo</span> off<span class="hljs-built_in">pushd</span> &quot;%~dp0&quot;<span class="hljs-built_in">dir</span> /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~<span class="hljs-number">3</span>*.mum &gt;List.txt<span class="hljs-built_in">dir</span> /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~<span class="hljs-number">3</span>*.mum &gt;&gt;List.txt<span class="hljs-keyword">for</span> /f <span class="hljs-variable">%%i</span> <span class="hljs-keyword">in</span> (&#x27;<span class="hljs-built_in">findstr</span> /i . List.txt <span class="hljs-number">2</span>^&gt;<span class="hljs-built_in">nul</span>&#x27;) <span class="hljs-keyword">do</span> dism /online /norestart /add-package:&quot;C:\Windows\servicing\Packages\<span class="hljs-variable">%%i</span>&quot;<span class="hljs-built_in">pause</span></code></pre></div><p><strong>（b）修改扩展名并运行</strong></p><p>​    将文本文档的扩展名由txt修改成cmd，出现扩展名修改提示按确定按钮</p><p>​    鼠标右键单击新建文本文档.cmd这个文件，选择以管理员身份运行</p><p><strong>（c）重启电脑，在运行中输入gpedit.msc启动组策略</strong></p><p><strong>（d）修改本地组策略</strong></p><p>​    计算机配置&#x3D;&#x3D;》管理模板&#x3D;&#x3D;》网络&#x3D;&#x3D;》Lanman工作站</p><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/20201204162510311.png" alt="img"></p><p>​    启用不安全的来宾登录：</p><p><img src="/2020/12/10/NOTE/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/20201204162510297.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Share</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Keil_C++环境移植第三方库出现类型错误问题解决</title>
    <link href="/2020/12/08/NOTE/ARM/STM32/Keil_Cpp%E7%8E%AF%E5%A2%83%E7%A7%BB%E6%A4%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF/"/>
    <url>/2020/12/08/NOTE/ARM/STM32/Keil_Cpp%E7%8E%AF%E5%A2%83%E7%A7%BB%E6%A4%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Keil-C-环境移植第三方库出现类型错误问题解决"><a href="#Keil-C-环境移植第三方库出现类型错误问题解决" class="headerlink" title="Keil_C++环境移植第三方库出现类型错误问题解决"></a>Keil_C++环境移植第三方库出现类型错误问题解决</h1><p>@firestaradmin 2020年12月8日16:28:18    </p><blockquote><p><strong>死亡如风，常伴吾身。</strong></p></blockquote><hr><p>Keil里实现C++环境编程，在C&#x2F;C++ 选项卡中 添加Misc 功能，添加<code>--cpp11</code> 即可支持C++。</p><p>可是在移植一些第三方库的时候会出现问题，比如说FreeRTOS、USB库等等。</p><p>如以下编译错误：</p><div class="hljs code-wrapper"><pre><code class="hljs llvm">..\OS\FreeRTOS\tasks.<span class="hljs-keyword">c</span>(<span class="hljs-number">2896</span>): error:  <span class="hljs-variable">#513</span>: a value of <span class="hljs-keyword">type</span> <span class="hljs-string">&quot;void *&quot;</span> cannot be assigned <span class="hljs-keyword">to</span> an entity of <span class="hljs-keyword">type</span> <span class="hljs-string">&quot;TCB_t *&quot;</span>..\OS\FreeRTOS\portable\MemMang\heap_<span class="hljs-number">4</span>.<span class="hljs-keyword">c</span>(<span class="hljs-number">350</span>): error:  <span class="hljs-variable">#513</span>: a value of <span class="hljs-keyword">type</span> <span class="hljs-string">&quot;void *&quot;</span> cannot be assigned <span class="hljs-keyword">to</span> an entity of <span class="hljs-keyword">type</span> <span class="hljs-string">&quot;A_BLOCK_LINK *&quot;</span></code></pre></div><p><img src="/2020/12/08/NOTE/ARM/STM32/Keil_Cpp%E7%8E%AF%E5%A2%83%E7%A7%BB%E6%A4%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF/image-20201208162907276.png" alt="image-20201208162907276"></p><p>是不是看的头都大了，我曾在网上寻找许久，找的天昏地暗，觉得解决这问题真的是天方夜谭，可能有些人遇不到问题，我去FreeRTOS 官网也找了，各种国外论坛都找不倒解决方案，但是现在我知道问题所在了，那么问题怎么解决呢！！！！！</p><p><strong>PACK包！！！！</strong></p><p><strong>PACK包！！！！</strong></p><p><strong>PACK包！！！！</strong></p><h2 id="没错问题就是PACK-包的版本问题！！！"><a href="#没错问题就是PACK-包的版本问题！！！" class="headerlink" title="没错问题就是PACK 包的版本问题！！！"></a>没错问题就是PACK 包的版本问题！！！</h2><p><img src="/2020/12/08/NOTE/ARM/STM32/Keil_Cpp%E7%8E%AF%E5%A2%83%E7%A7%BB%E6%A4%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF/image-20201208163132682.png" alt="image-20201208163132682"></p><p>如果你是F4的 板子，那么如果你用的是2.14.0 或者 2.15.0 那么恭喜你，你必定遇到这错误，我在官网找到了一条版本更新警告！如下：</p><p><img src="/2020/12/08/NOTE/ARM/STM32/Keil_Cpp%E7%8E%AF%E5%A2%83%E7%A7%BB%E6%A4%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF/image-20201208163354071.png" alt="image-20201208163354071"></p><p>可以看到，自从2.14.0 后 不在强制使用C99 MODE。 但是我在每个c文件的单独的MISC 选项中单独添加</p><p><code>--C99</code>还是会有一些莫名其妙的问题所在，所以直接使用2.13.0 版本的PACK包即可。</p><hr><p>点击这个</p><p><img src="/2020/12/08/NOTE/ARM/STM32/Keil_Cpp%E7%8E%AF%E5%A2%83%E7%A7%BB%E6%A4%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF/image-20201208163656071.png" alt="image-20201208163656071"></p><p>按照下图设置即可完美解决一些疑难杂症</p><p><img src="/2020/12/08/NOTE/ARM/STM32/Keil_Cpp%E7%8E%AF%E5%A2%83%E7%A7%BB%E6%A4%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF/image-20201208163801096.png" alt="image-20201208163801096"></p><p>这样就可以啦！！</p><hr><p>其他系列的单片机我没试过，不知道，其他版本我也不知道。但是F4 使用2.13.0 版本的PACK包 绝壁可以。</p><p>如果有帮到你，也不用谢我，我只是一个活雷锋！！！ 谢谢！</p><hr><p><img src="/2020/12/08/NOTE/ARM/STM32/Keil_Cpp%E7%8E%AF%E5%A2%83%E7%A7%BB%E6%A4%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF/image-20201208163922938.png" alt="image-20201208163922938"></p><p>点击编译！神清气爽！ 爽！</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVGUI屏幕刷新原理</title>
    <link href="/2020/12/07/NOTE/ARM/UVGUI/UVGUI%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2020/12/07/NOTE/ARM/UVGUI/UVGUI%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="UVGUI屏幕刷新原理"><a href="#UVGUI屏幕刷新原理" class="headerlink" title="UVGUI屏幕刷新原理"></a>UVGUI屏幕刷新原理</h1><p>@firestaradmin 2020年12月9日17:39:32</p><p><strong>我还在寻找回家的路。长路漫漫，唯剑作伴。        ——亚索</strong></p><h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><p>核心结构体为 <code>ug_disp_t</code>，UVGUI 支持同时驱动多个屏幕，每个屏幕对应一个disp 结构体，disp 定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Display structure.</span><span class="hljs-comment"> * @note `ug_disp_drv_t` should be the first member of the structure.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">disp_t</span> &#123;</span>        <span class="hljs-comment">/**&lt; Driver to the display*/</span>    <span class="hljs-type">ug_disp_drv_t</span> driver;        <span class="hljs-comment">/**&lt; A task which periodically checks the dirty areas and refreshes them*/</span>    <span class="hljs-type">ug_task_t</span> * refr_task;        <span class="hljs-comment">/** Screens of the display*/</span>    <span class="hljs-type">ug_ll_t</span> scr_ll;    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ug_obj_t</span> * <span class="hljs-title">act_scr</span>;</span>   <span class="hljs-comment">/**&lt; Currently active screen on this display */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ug_obj_t</span> * <span class="hljs-title">prev_scr</span>;</span>  <span class="hljs-comment">/**&lt; Previous screen. Used during screen animations */</span>    <span class="hljs-type">ug_color_t</span> bg_color;          <span class="hljs-comment">/**&lt; Default display color when screens are transparent*/</span>    <span class="hljs-type">const</span> <span class="hljs-type">void</span> * bg_img;       <span class="hljs-comment">/**&lt; An image source to display as wallpaper*/</span>    <span class="hljs-type">ug_area_t</span> inv_areas[UG_INV_BUF_SIZE];    <span class="hljs-type">uint8_t</span> inv_area_joined[UG_INV_BUF_SIZE];    <span class="hljs-type">uint32_t</span> inv_p : <span class="hljs-number">10</span>;    <span class="hljs-comment">/* invalid parts */</span>    <span class="hljs-comment">/*Miscellaneous data*/</span>    <span class="hljs-type">uint8_t</span> disp_index;     <span class="hljs-comment">/* Used to select/change which physical screen to display. */</span>&#125; <span class="hljs-type">ug_disp_t</span>;</code></pre></div><p>其中刷屏算法核心关键成员为：</p><ul><li>scr_ll：屏幕列表，一个物理屏幕可以有多个屏幕列表去绘制，也可理解为窗口或者页面。</li><li>inv_areas[]：不合法区域数组，储存着需要重新绘制的区域。</li><li>inv_area_joined[]：不合法区域的合并标志，为0 则表示该区域未合并。</li><li>inc_p：不合法区域的个数。</li></ul><p>宏<code>UG_INV_BUF_SIZE</code>  定义了最大的不合法区域数，如果超过限制，则会重新绘制整个屏幕。</p><hr><p>每创建一个对象，就会根据对象的区域大小，将其储存到<code>inv_areas</code>数组中，并且inv_p 数加一。</p><hr><h2 id="二、核心算法"><a href="#二、核心算法" class="headerlink" title="二、核心算法"></a>二、核心算法</h2><p>算法流程：</p><div class="hljs code-wrapper"><pre><code class="hljs c">_ug_disp_refr_task()<span class="hljs-comment">/* 屏幕刷新任务 */</span>    -&gt; ug_refr_join_area();<span class="hljs-comment">/* 合并非法区域 */</span>    -&gt; ug_refr_areas();<span class="hljs-comment">/* 刷新区域 */</span>-&gt; ug_refr_area();-&gt;ug_refr_area_part();-&gt;ug_refr_obj_and_children();-&gt;ug_refr_obj();-&gt;ug_refr_vdb_flush();<span class="hljs-comment">/* 在非真实像素显存大小模式，每次刷新都要刷屏 */</span></code></pre></div><hr><h3 id="ug-refr-join-area"><a href="#ug-refr-join-area" class="headerlink" title="ug_refr_join_area()"></a>ug_refr_join_area()</h3><p>此函数功能为 合并有相同部分的区域。 函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Join the areas which has got common parts</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ug_refr_join_area</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">uint32_t</span> join_from;    <span class="hljs-type">uint32_t</span> join_in;    <span class="hljs-type">ug_area_t</span> joined_area;    <span class="hljs-keyword">for</span>(join_in = <span class="hljs-number">0</span>; join_in &lt; disp_refr-&gt;inv_p; join_in++) &#123;          <span class="hljs-comment">/* if the area is already been joined , skip. */</span>        <span class="hljs-keyword">if</span>(disp_refr-&gt;inv_area_joined[join_in] != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">/*Check all areas to join them in &#x27;join_in&#x27;*/</span>        <span class="hljs-keyword">for</span>(join_from = <span class="hljs-number">0</span>; join_from &lt; disp_refr-&gt;inv_p; join_from++) &#123;                <span class="hljs-comment">/*Handle only unjoined areas and ignore itself*/</span>            <span class="hljs-keyword">if</span>(disp_refr-&gt;inv_area_joined[join_from] != <span class="hljs-number">0</span> || join_in == join_from) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">/*Check if the areas are on each other*/</span>            <span class="hljs-keyword">if</span>(_ug_area_is_on(&amp;disp_refr-&gt;inv_areas[join_in], &amp;disp_refr-&gt;inv_areas[join_from]) == <span class="hljs-literal">false</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            _ug_area_join(&amp;joined_area, &amp;disp_refr-&gt;inv_areas[join_in], &amp;disp_refr-&gt;inv_areas[join_from]);            <span class="hljs-comment">/*Join two area only if the joined area size is smaller*/</span>            <span class="hljs-keyword">if</span>(ug_area_get_size(&amp;joined_area) &lt; (ug_area_get_size(&amp;disp_refr-&gt;inv_areas[join_in]) +                                                 ug_area_get_size(&amp;disp_refr-&gt;inv_areas[join_from]))) &#123;                ug_area_copy(&amp;disp_refr-&gt;inv_areas[join_in], &amp;joined_area);                <span class="hljs-comment">/*Mark &#x27;join_form&#x27; is joined into &#x27;join_in&#x27;*/</span>                disp_refr-&gt;inv_area_joined[join_from] = <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>参数说明：</p><ul><li>join_in：要合并进去的区域编号，即其他区域符合要求会合并到这个区域。</li><li>join_from：要被合并的区域编号，即这个区域会被合并到join_in 这个区域。</li><li>joined_area：合并后的区域。</li></ul><p>函数有循环嵌套。</p><p>第一个大循环会遍历每个<strong>inv</strong> 区域，如果该区域已被合并则跳过该区域，然后进入第二个循环，再次遍历非合法区域，如果区域是自己，或者已经被合并了则跳过。</p><p>然后判断，两个区域是否有相同部分，即是否有接壤，如果有 则将两个区域合并的区域储存至<strong>joined_area</strong>，然后再判断合并后的区域大小是否比之前两个区域的大小加在一起更小，如果更小则会将合并后的区域储存到 <strong>inv_area[join_in]</strong> 里，并且将<strong>inv_area_joined[join_form]</strong> 置1，来指示该区域已被合并。</p><hr><h3 id="ug-refr-areas"><a href="#ug-refr-areas" class="headerlink" title="ug_refr_areas()"></a>ug_refr_areas()</h3><p>此函数刷新所有非合法区域，即刷新 <code>inv_area_joined[]</code> 标志未被置 1 (即未被合并) 的 <code>inv_areas[]</code> 储存的区域。代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Refresh the joined areas</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ug_refr_areas</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    px_num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(disp_refr-&gt;inv_p == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">/*Find the last area which will be drawn*/</span>    <span class="hljs-type">int32_t</span> i;    <span class="hljs-type">int32_t</span> last_i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i = disp_refr-&gt;inv_p - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">if</span>(disp_refr-&gt;inv_area_joined[i] == <span class="hljs-number">0</span>) &#123;            last_i = i;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    disp_refr-&gt;driver.buffer-&gt;last_area = <span class="hljs-number">0</span>;    disp_refr-&gt;driver.buffer-&gt;last_part = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; disp_refr-&gt;inv_p; i++) &#123;        <span class="hljs-comment">/*Refresh the unjoined areas*/</span>        <span class="hljs-keyword">if</span>(disp_refr-&gt;inv_area_joined[i] == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(i == last_i) disp_refr-&gt;driver.buffer-&gt;last_area = <span class="hljs-number">1</span>;            disp_refr-&gt;driver.buffer-&gt;last_part = <span class="hljs-number">0</span>;            ug_refr_area(&amp;disp_refr-&gt;inv_areas[i]);            <span class="hljs-comment">//if(disp_refr-&gt;driver.monitor_cb) px_num += ug_area_get_size(&amp;disp_refr-&gt;inv_areas[i]);</span>        &#125;    &#125;&#125;</code></pre></div><p>此函数会找到符合条件的区域并调用子函数 <code>ug_refr_area()</code> 来刷新。</p><hr><h3 id="ug-refr-area"><a href="#ug-refr-area" class="headerlink" title="ug_refr_area()"></a>ug_refr_area()</h3><p>此函数代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Refresh an area if there is Virtual Display Buffer</span><span class="hljs-comment"> * @param area_p  pointer to an area to refresh</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ug_refr_area</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">ug_area_t</span> * area_p)</span>&#123;    <span class="hljs-comment">/*True double buffering: there are two screen sized buffers. Just redraw directly into a * buffer */</span>    <span class="hljs-keyword">if</span>(ug_disp_is_true_double_buf(disp_refr)) &#123;        <span class="hljs-type">ug_disp_buf_t</span> * vdb = ug_disp_get_buf(disp_refr);        vdb-&gt;area.x1        = <span class="hljs-number">0</span>;        vdb-&gt;area.x2        = ug_disp_get_hor_res(disp_refr) - <span class="hljs-number">1</span>;        vdb-&gt;area.y1        = <span class="hljs-number">0</span>;        vdb-&gt;area.y2        = ug_disp_get_ver_res(disp_refr) - <span class="hljs-number">1</span>;        disp_refr-&gt;driver.buffer-&gt;last_part = <span class="hljs-number">1</span>;        ug_refr_area_part(area_p);    &#125;    <span class="hljs-comment">/*The buffer is smaller: refresh the area in parts*/</span>    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">ug_disp_buf_t</span> * vdb = ug_disp_get_buf(disp_refr);        <span class="hljs-comment">/* Calculate the max row value */</span>        <span class="hljs-type">ug_coord_t</span> w = ug_area_get_width(area_p);        <span class="hljs-type">ug_coord_t</span> h = ug_area_get_height(area_p);        <span class="hljs-type">ug_coord_t</span> y2 = area_p-&gt;y2 &gt;= ug_disp_get_ver_res(disp_refr) ? ug_disp_get_ver_res(disp_refr) - <span class="hljs-number">1</span> : area_p-&gt;y2;        <span class="hljs-type">int32_t</span> max_row = (<span class="hljs-type">uint32_t</span>)vdb-&gt;size / w;        <span class="hljs-keyword">if</span>(max_row &gt; h) max_row = h;        <span class="hljs-comment">/*Always use the full row*/</span>        <span class="hljs-type">ug_coord_t</span> row;        <span class="hljs-type">ug_coord_t</span> row_last = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(row = area_p-&gt;y1; row + max_row - <span class="hljs-number">1</span> &lt;= y2; row += max_row) &#123;            <span class="hljs-comment">/*Calc. the next y coordinates of VDB*/</span>            vdb-&gt;area.x1 = area_p-&gt;x1;            vdb-&gt;area.x2 = area_p-&gt;x2;            vdb-&gt;area.y1 = row;            vdb-&gt;area.y2 = row + max_row - <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(vdb-&gt;area.y2 &gt; y2) vdb-&gt;area.y2 = y2;            row_last = vdb-&gt;area.y2;            <span class="hljs-keyword">if</span>(y2 == row_last) disp_refr-&gt;driver.buffer-&gt;last_part = <span class="hljs-number">1</span>;            ug_refr_area_part(area_p);        &#125;        <span class="hljs-comment">/*If the last y coordinates are not handled yet ...*/</span>        <span class="hljs-keyword">if</span>(y2 != row_last) &#123;            <span class="hljs-comment">/*Calc. the next y coordinates of VDB*/</span>            vdb-&gt;area.x1 = area_p-&gt;x1;            vdb-&gt;area.x2 = area_p-&gt;x2;            vdb-&gt;area.y1 = row;            vdb-&gt;area.y2 = y2;            disp_refr-&gt;driver.buffer-&gt;last_part = <span class="hljs-number">1</span>;            ug_refr_area_part(area_p);        &#125;    &#125;&#125;</code></pre></div><p>此函数会根据你设置的显存大小和刷新的区域大小进行判断，如果你的显存大小是真实屏幕的像素大小，就一次刷新完，如果显存比屏幕小，就会一部分一部分刷新，直至刷新完毕。计算好虚拟显存的区域后，会调用<code>ug_refr_area_part()</code>  函数来刷新。</p><hr><h3 id="ug-refr-area-part"><a href="#ug-refr-area-part" class="headerlink" title="ug_refr_area_part()"></a>ug_refr_area_part()</h3><p>此函数会刷新在当前虚拟显存上的一块区域。代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Refresh a part of an area which is on the actual Virtual Display Buffer</span><span class="hljs-comment"> * @param area_p pointer to an area to refresh</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ug_refr_area_part</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">ug_area_t</span> * area_p)</span>&#123;    <span class="hljs-type">ug_disp_buf_t</span> * vdb = ug_disp_get_buf(disp_refr);    <span class="hljs-comment">/*In non double buffered mode, before rendering the next part wait until the previous image is</span><span class="hljs-comment">     * flushed*/</span>    <span class="hljs-keyword">if</span>(ug_disp_is_double_buf(disp_refr) == <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">while</span>(vdb-&gt;flushing) &#123;            <span class="hljs-keyword">if</span>(disp_refr-&gt;driver.wait_cb) disp_refr-&gt;driver.wait_cb(&amp;disp_refr-&gt;driver);        &#125;    &#125;    <span class="hljs-type">ug_obj_t</span> * top_act_scr = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">ug_obj_t</span> * top_prev_scr = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/*Get the new mask from the original area and the act. VDB</span><span class="hljs-comment">     It will be a part of &#x27;area_p&#x27;*/</span>    <span class="hljs-type">ug_area_t</span> start_mask;    _ug_area_intersect(&amp;start_mask, area_p, &amp;vdb-&gt;area);    <span class="hljs-comment">/*Get the most top object which is not covered by others*/</span>    top_act_scr = ug_refr_get_top_obj(&amp;start_mask, ug_disp_get_actscr(disp_refr));    <span class="hljs-keyword">if</span>(disp_refr-&gt;prev_scr) &#123;        top_prev_scr = ug_refr_get_top_obj(&amp;start_mask, disp_refr-&gt;prev_scr);    &#125;    <span class="hljs-comment">/*Draw a display background if there is no top object*/</span>    <span class="hljs-keyword">if</span>(top_act_scr == <span class="hljs-literal">NULL</span> &amp;&amp; top_prev_scr == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-keyword">if</span>(disp_refr-&gt;bg_img) &#123;            <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> ug_draw_img(&amp;a, &amp;start_mask, disp_refr-&gt;bg_img, &amp;dsc);</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-type">ug_draw_rect_dsc_t</span> dsc;            ug_draw_rect_dsc_init(&amp;dsc);            dsc.bg_color = disp_refr-&gt;bg_color;            ug_draw_rect(&amp;start_mask, &amp;start_mask, &amp;dsc);        &#125;    &#125;    <span class="hljs-comment">/*Refresh the previous screen if any*/</span>    <span class="hljs-keyword">if</span>(disp_refr-&gt;prev_scr) &#123;        <span class="hljs-comment">/*Get the most top object which is not covered by others*/</span>        <span class="hljs-keyword">if</span>(top_prev_scr == <span class="hljs-literal">NULL</span>) &#123;            top_prev_scr = disp_refr-&gt;prev_scr;        &#125;        <span class="hljs-comment">/*Do the refreshing from the top object*/</span>        ug_refr_obj_and_children(top_prev_scr, &amp;start_mask);    &#125;    <span class="hljs-keyword">if</span>(top_act_scr == <span class="hljs-literal">NULL</span>) &#123;         top_act_scr = disp_refr-&gt;act_scr;     &#125;    <span class="hljs-comment">/*Do the refreshing from the top object*/</span>    ug_refr_obj_and_children(top_act_scr, &amp;start_mask);    <span class="hljs-comment">/* In true double buffered mode flush only once when all areas were rendered.</span><span class="hljs-comment">     * In normal mode flush after every area */</span>    <span class="hljs-keyword">if</span>(ug_disp_is_true_double_buf(disp_refr) == <span class="hljs-literal">false</span>) &#123;        ug_refr_vdb_flush();    &#125;&#125;</code></pre></div><p>在只有一块显存的模式下，如果正在刷屏传输中，则会等待传输完成。</p><p>然后会获取当前区域的最TOP 的对象，从它开始刷新。</p><blockquote><p>何谓最TOP的对象呢？就是这个区域内最底层的对象，它会从屏幕这个obj 开始寻找 子obj ，找到一个完全覆盖区域的子对象。 </p><p>也就是说，当屏幕中有两个正方体 A 和 B，B 是 A的儿子。A比B小并在B里面，寻找的时候就会返回B。如果A和B一样大，那么B就会遮挡住A，所以返回的时候就是返回A的儿子B。</p></blockquote><p>最后会调用<code>ug_refr_obj_and_children()</code> 来刷新。</p><h3 id="ug-refr-obj-and-children"><a href="#ug-refr-obj-and-children" class="headerlink" title="ug_refr_obj_and_children()"></a>ug_refr_obj_and_children()</h3><p>函数代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Make the refreshing from an object. Draw all its children and the youngers too.</span><span class="hljs-comment"> * @param top_p pointer to an objects. Start the drawing from it.</span><span class="hljs-comment"> * @param mask_p pointer to an area, the objects will be drawn only here</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ug_refr_obj_and_children</span><span class="hljs-params">(<span class="hljs-type">ug_obj_t</span> * top_p, <span class="hljs-type">const</span> <span class="hljs-type">ug_area_t</span> * mask_p)</span>&#123;    <span class="hljs-comment">/* Normally always will be a top_obj (at least the screen)</span><span class="hljs-comment">     * but in special cases (e.g. if the screen has alpha) it won&#x27;t.</span><span class="hljs-comment">     * In this case use the screen directly */</span>    <span class="hljs-keyword">if</span>(top_p == <span class="hljs-literal">NULL</span>) top_p = ug_disp_get_actscr(disp_refr);    <span class="hljs-keyword">if</span>(top_p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">/*Shouldn&#x27;t happen*/</span>    <span class="hljs-comment">/*Refresh the top object and its children*/</span>    ug_refr_obj(top_p, mask_p);    <span class="hljs-comment">/*Draw the &#x27;younger&#x27; sibling objects because they can be on top_obj */</span>    <span class="hljs-type">ug_obj_t</span> * par;    <span class="hljs-type">ug_obj_t</span> * border_p = top_p;    par = ug_obj_get_parent(top_p);    <span class="hljs-comment">/*Do until not reach the screen*/</span>    <span class="hljs-keyword">while</span>(par != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-comment">/*object before border_p has to be redrawn*/</span>        <span class="hljs-type">ug_obj_t</span> * i = _ug_ll_get_prev(&amp;(par-&gt;child_ll), border_p);        <span class="hljs-keyword">while</span>(i != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-comment">/*Refresh the objects*/</span>            ug_refr_obj(i, mask_p);            i = _ug_ll_get_prev(&amp;(par-&gt;child_ll), i);        &#125;        <span class="hljs-comment">/*Call the post draw design function of the parents of the to object*/</span>        <span class="hljs-keyword">if</span>(par-&gt;design_cb) par-&gt;design_cb(par, mask_p, UG_DESIGN_DRAW_POST);        <span class="hljs-comment">/*The new border will be there last parents,</span><span class="hljs-comment">         *so the &#x27;younger&#x27; brothers of parent will be refreshed*/</span>        border_p = par;        <span class="hljs-comment">/*Go a level deeper*/</span>        par = ug_obj_get_parent(par);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Refresh an object and all of its children. (Called recursively)</span><span class="hljs-comment"> * @param obj pointer to an object to refresh</span><span class="hljs-comment"> * @param mask_ori_p pointer to an area, the objects will be drawn only here</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ug_refr_obj</span><span class="hljs-params">(<span class="hljs-type">ug_obj_t</span> * obj, <span class="hljs-type">const</span> <span class="hljs-type">ug_area_t</span> * mask_ori_p)</span>&#123;    <span class="hljs-comment">/*Do not refresh hidden objects*/</span>    <span class="hljs-keyword">if</span>(obj-&gt;hidden != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-type">bool</span> union_ok; <span class="hljs-comment">/* Store the return value of area_union */</span>    <span class="hljs-comment">/* Truncate the original mask to the coordinates of the parent</span><span class="hljs-comment">     * because the parent and its children are visible only here */</span>    <span class="hljs-type">ug_area_t</span> obj_mask;    <span class="hljs-type">ug_area_t</span> obj_ext_mask;    <span class="hljs-type">ug_area_t</span> obj_area;    <span class="hljs-type">ug_coord_t</span> ext_size = obj-&gt;ext_draw_pad;    ug_obj_get_coords(obj, &amp;obj_area);    obj_area.x1 -= ext_size;    obj_area.y1 -= ext_size;    obj_area.x2 += ext_size;    obj_area.y2 += ext_size;    union_ok = _ug_area_intersect(&amp;obj_ext_mask, mask_ori_p, &amp;obj_area);    <span class="hljs-comment">/*Draw the parent and its children only if they ore on &#x27;mask_parent&#x27;*/</span>    <span class="hljs-keyword">if</span>(union_ok != <span class="hljs-literal">false</span>) &#123;        <span class="hljs-comment">/* Redraw the object */</span>        <span class="hljs-keyword">if</span>(obj-&gt;design_cb) obj-&gt;design_cb(obj, &amp;obj_ext_mask, UG_DESIGN_DRAW_MAIN);        <span class="hljs-comment">/*Create a new &#x27;obj_mask&#x27; without &#x27;ext_size&#x27; because the children can&#x27;t be visible there*/</span>        ug_obj_get_coords(obj, &amp;obj_area);        union_ok = _ug_area_intersect(&amp;obj_mask, mask_ori_p, &amp;obj_area);        <span class="hljs-keyword">if</span>(union_ok != <span class="hljs-literal">false</span>) &#123;            <span class="hljs-type">ug_area_t</span> mask_child; <span class="hljs-comment">/*Mask from obj and its child*/</span>            <span class="hljs-type">ug_obj_t</span> * child_p;            <span class="hljs-type">ug_area_t</span> child_area;            _UG_LL_READ_BACK(obj-&gt;child_ll, child_p) &#123;                ug_obj_get_coords(child_p, &amp;child_area);                ext_size = child_p-&gt;ext_draw_pad;                child_area.x1 -= ext_size;                child_area.y1 -= ext_size;                child_area.x2 += ext_size;                child_area.y2 += ext_size;                <span class="hljs-comment">/* Get the union (common parts) of original mask (from obj)</span><span class="hljs-comment">                 * and its child */</span>                union_ok = _ug_area_intersect(&amp;mask_child, &amp;obj_mask, &amp;child_area);                <span class="hljs-comment">/*If the parent and the child has common area then refresh the child */</span>                <span class="hljs-keyword">if</span>(union_ok) &#123;                    <span class="hljs-comment">/*Refresh the next children*/</span>                    ug_refr_obj(child_p, &amp;mask_child);                &#125;            &#125;        &#125;        <span class="hljs-comment">/* If all the children are redrawn make &#x27;post draw&#x27; design */</span>        <span class="hljs-keyword">if</span>(obj-&gt;design_cb) obj-&gt;design_cb(obj, &amp;obj_ext_mask, UG_DESIGN_DRAW_POST);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>UVGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UVGUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVGUI抗锯齿字模符号显示原理</title>
    <link href="/2020/12/07/NOTE/ARM/UVGUI/UVGUI%E6%8A%97%E9%94%AF%E9%BD%BF%E5%AD%97%E6%A8%A1%E7%AC%A6%E5%8F%B7%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/"/>
    <url>/2020/12/07/NOTE/ARM/UVGUI/UVGUI%E6%8A%97%E9%94%AF%E9%BD%BF%E5%AD%97%E6%A8%A1%E7%AC%A6%E5%8F%B7%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="UVGUI抗锯齿字模符号显示原理"><a href="#UVGUI抗锯齿字模符号显示原理" class="headerlink" title="UVGUI抗锯齿字模符号显示原理"></a>UVGUI抗锯齿字模符号显示原理</h1><p>@firestaradmin 2020年12月7日14:24:50</p><h2 id="一、浅析LVGL-Label显示原理"><a href="#一、浅析LVGL-Label显示原理" class="headerlink" title="一、浅析LVGL Label显示原理"></a>一、浅析LVGL Label显示原理</h2><p>绘制 label 过程：</p><p><code>lv_draw_label</code> -》 <code>lv_draw_letter</code> -》<code>draw_letter_normal</code></p><h3 id="lv-draw-label"><a href="#lv-draw-label" class="headerlink" title="lv_draw_label"></a>lv_draw_label</h3><p>函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Write a text</span><span class="hljs-comment"> * @param coords coordinates of the label</span><span class="hljs-comment"> * @param mask the label will be drawn only in this area</span><span class="hljs-comment"> * @param dsc pointer to draw descriptor</span><span class="hljs-comment"> * @param txt `\0` terminated text to write</span><span class="hljs-comment"> * @param hint pointer to a `lv_draw_label_hint_t` variable.</span><span class="hljs-comment"> * It is managed by the drawer to speed up the drawing of very long texts (thousands of lines).</span><span class="hljs-comment"> */</span>LV_ATTRIBUTE_FAST_MEM <span class="hljs-type">void</span> <span class="hljs-title function_">lv_draw_label</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">lv_area_t</span> * coords, <span class="hljs-type">const</span> <span class="hljs-type">lv_area_t</span> * mask, <span class="hljs-type">lv_draw_label_dsc_t</span> * dsc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * txt, <span class="hljs-type">lv_draw_label_hint_t</span> * hint)</span>&#123;    ...&#125;</code></pre></div><ul><li>coords：label 的坐标区域位置</li><li>mask：label 的遮罩， 表示要在哪个区域显示</li><li>dsc：绘制主题相关</li><li>txt：要显示的文字字符串指针</li><li>hint：方便计算第一个字符位置的结构体信息</li></ul><p>此函数主要收集并判断字符串显示的行数、位置等信息，再去循环调用<code>lv_draw_letter</code>  来显示每一个字符。</p><hr><h3 id="lv-draw-letter"><a href="#lv-draw-letter" class="headerlink" title="lv_draw_letter"></a>lv_draw_letter</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Draw a letter in the Virtual Display Buffer</span><span class="hljs-comment"> * @param pos_p left-top coordinate of the latter</span><span class="hljs-comment"> * @param clip_area the letter will be drawn only on this area  (truncated to VDB area)</span><span class="hljs-comment"> * @param font_p pointer to font</span><span class="hljs-comment"> * @param letter a letter to draw</span><span class="hljs-comment"> * @param color color of letter</span><span class="hljs-comment"> * @param opa opacity of letter (0..255)</span><span class="hljs-comment"> */</span>LV_ATTRIBUTE_FAST_MEM <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lv_draw_letter</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">lv_point_t</span> * pos_p, <span class="hljs-type">const</span> <span class="hljs-type">lv_area_t</span> * clip_area, <span class="hljs-type">const</span> <span class="hljs-type">lv_font_t</span> * font_p, <span class="hljs-type">uint32_t</span> letter, <span class="hljs-type">lv_color_t</span> color, <span class="hljs-type">lv_opa_t</span> opa, <span class="hljs-type">lv_blend_mode_t</span> blend_mode)</span></code></pre></div><ul><li>pos_p：字符左上角坐标</li><li>clip_area：在此区域的字符部分才会被显示</li><li>font_p：字体结构体指针</li><li>letter：要绘制的字符</li><li>color：字符颜色</li><li>opa：字符不透明度（或者是灰度？）</li><li>blend_mode：混合模式</li></ul><p>此函数主要获取字符的描述信息结构体（字体样式，字模的宽、高），并获取字符的字型数据，再调用<code>draw_letter_normal</code> 来显示字符。</p><hr><h3 id="draw-letter-normal"><a href="#draw-letter-normal" class="headerlink" title="draw_letter_normal"></a>draw_letter_normal</h3><div class="hljs code-wrapper"><pre><code class="hljs c">LV_ATTRIBUTE_FAST_MEM <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">draw_letter_normal</span><span class="hljs-params">(<span class="hljs-type">lv_coord_t</span> pos_x, <span class="hljs-type">lv_coord_t</span> pos_y, <span class="hljs-type">lv_font_glyph_dsc_t</span> * g, <span class="hljs-type">const</span> <span class="hljs-type">lv_area_t</span> * clip_area, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> * map_p, <span class="hljs-type">lv_color_t</span> color, <span class="hljs-type">lv_opa_t</span> opa, <span class="hljs-type">lv_blend_mode_t</span> blend_mode)</span></code></pre></div><ul><li>pos_x：字符左上角坐标 x 值</li><li>pos_y：字符左上角坐标 y 值</li><li>g：字符描述信息结构体指针</li><li>clip_area：只在此区域显示字符</li><li>map_p：字模数据指针</li><li>color：颜色</li><li>…</li></ul><p>此函数是核心函数，根据字符信息，判断抗锯齿，并且将字模数据按照对应的抗锯齿解析，并绘制到显存中。</p><hr><h2 id="二、LVGL-字体-数据结构"><a href="#二、LVGL-字体-数据结构" class="headerlink" title="二、LVGL 字体 数据结构"></a>二、LVGL 字体 数据结构</h2><p>LVGL 的字体统一通过以下数据结构管理：</p><h3 id="lv-font-glyph-dsc-t"><a href="#lv-font-glyph-dsc-t" class="headerlink" title="lv_font_glyph_dsc_t"></a>lv_font_glyph_dsc_t</h3><p>字形描述结构体：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/** Describes the properties of a glyph. */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-type">uint16_t</span> adv_w; <span class="hljs-comment">/**&lt; The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional */</span>    <span class="hljs-type">uint16_t</span> box_w;  <span class="hljs-comment">/**&lt; Width of the glyph&#x27;s bounding box*/</span>    <span class="hljs-type">uint16_t</span> box_h;  <span class="hljs-comment">/**&lt; Height of the glyph&#x27;s bounding box*/</span>    <span class="hljs-type">int16_t</span> ofs_x;   <span class="hljs-comment">/**&lt; x offset of the bounding box*/</span>    <span class="hljs-type">int16_t</span> ofs_y;  <span class="hljs-comment">/**&lt; y offset of the bounding box*/</span>    <span class="hljs-type">uint8_t</span> bpp;   <span class="hljs-comment">/**&lt; Bit-per-pixel: 1, 2, 4, 8*/</span>&#125; <span class="hljs-type">lv_font_glyph_dsc_t</span>;</code></pre></div><ul><li>adv_w : 字形的绝对宽度，下一个字形在这么多间距后绘制。</li><li>box_w：字模边框宽度</li><li>box_h：字模边框高度</li><li>ofs_x：边框x 坐标偏移</li><li>ofs_y：边框y 坐标偏移</li><li>bpp：抗锯齿</li></ul><hr><h3 id="lv-font-t"><a href="#lv-font-t" class="headerlink" title="lv_font_t"></a>lv_font_t</h3><p>字体结构体</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/** Describe the properties of a font*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">lv_font_struct</span> &#123;</span>    <span class="hljs-comment">/** Get a glyph&#x27;s  descriptor from a font*/</span>    <span class="hljs-type">bool</span> (*get_glyph_dsc)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> _lv_font_struct *, <span class="hljs-type">lv_font_glyph_dsc_t</span> *, <span class="hljs-type">uint32_t</span> letter, <span class="hljs-type">uint32_t</span> letter_next);    <span class="hljs-comment">/** Get a glyph&#x27;s bitmap from a font*/</span>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> * (*get_glyph_bitmap)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> _lv_font_struct *, <span class="hljs-type">uint32_t</span>);    <span class="hljs-comment">/*Pointer to the font in a font pack (must have the same line height)*/</span>    <span class="hljs-type">lv_coord_t</span> line_height;         <span class="hljs-comment">/**&lt; The real line height where any text fits*/</span>    <span class="hljs-type">lv_coord_t</span> base_line;           <span class="hljs-comment">/**&lt; Base line measured from the top of the line_height*/</span>    <span class="hljs-type">uint8_t</span> subpx  : <span class="hljs-number">2</span>;             <span class="hljs-comment">/**&lt; An element of `lv_font_subpx_t`*/</span>    <span class="hljs-type">void</span> * dsc;                     <span class="hljs-comment">/**&lt; Store implementation specific or run_time data or caching here*/</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> LV_USE_USER_DATA</span>    <span class="hljs-type">lv_font_user_data_t</span> user_data;  <span class="hljs-comment">/**&lt; Custom user data for font. */</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125; <span class="hljs-type">lv_font_t</span>;</code></pre></div><ul><li>get_glyph_dsc：获取字形描述信息的函数指针</li><li>get_glyph_bitmap：获取字形数据的函数指针</li><li>line_height：真实的行高度</li><li>base_line：基线 从行高度的上方开始测量</li><li>dsc：储存细节实现或者运行数据或者缓存</li><li>user_data：自定义数据</li></ul><hr><h3 id="take-a-chestnut☺："><a href="#take-a-chestnut☺：" class="headerlink" title="take a chestnut☺："></a>take a chestnut☺：</h3>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>UVGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UVGUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32移植FreeRTOS</title>
    <link href="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/"/>
    <url>/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/</url>
    
    <content type="html"><![CDATA[<p>@firestaradmin 2020年12月2日15:47:03</p><h1 id="STM32移植FreeRTOS操作记录"><a href="#STM32移植FreeRTOS操作记录" class="headerlink" title="STM32移植FreeRTOS操作记录"></a>STM32移植FreeRTOS操作记录</h1><h2 id="一、获取源码"><a href="#一、获取源码" class="headerlink" title="一、获取源码"></a>一、获取源码</h2><ul><li>获取STM32 官方STD 库</li><li>获取FreeRTOS V10.0.1 (版本不同，大致步骤相似，见招拆招即可)</li></ul><h2 id="二、移植步骤"><a href="#二、移植步骤" class="headerlink" title="二、移植步骤"></a>二、移植步骤</h2><h3 id="1-添加FreeRTOS-库"><a href="#1-添加FreeRTOS-库" class="headerlink" title="1| 添加FreeRTOS 库"></a>1| 添加FreeRTOS 库</h3><p>解压缩后，在工程目录创建OS\FreeRTOS 文件夹，将 FreeRTOSv10.0.1\FreeRTOS\Source 内的文件复制到工程目录</p><p>并在FreeRTOSv10.0.1\FreeRTOS\Demo 目录下寻找自己开发板的文件，这里以STM32F4 为例，打开目录 FreeRTOSv10.0.1\FreeRTOS\Demo\CORTEX_M4F_STM32F407ZG-SK ，并将 目录中的 FreeRTOSConfig.h 文件复制到 工程User目录下。</p><p>添加完毕后如图所示：</p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202160233250.png" alt="image-20201202160233250"></p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202175426792.png" alt="image-20201202175426792"></p><h3 id="2-配置STM32-工程"><a href="#2-配置STM32-工程" class="headerlink" title="2| 配置STM32 工程"></a>2| 配置STM32 工程</h3><p>创建如下目录，并添加相应文件</p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202160915739.png" alt="image-20201202160915739"></p><p>FreeRTOS&#x2F;port 目录下需要添加 OS\FreeRTOS\portable\目录中的 MemMang 内存操作文件（heap_4.c） 和 对于平台的 port.c 文件(对于STM32F4 使用\OS\FreeRTOS\portable\RVDS\ARM_CM4F目录中的port.c)</p><p>添加文件完毕后，配置头文件路径。配置完毕，如图所示：</p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202161501611.png" alt="image-20201202161501611"></p><hr><p>编译报错如图：</p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202162234504.png" alt="image-20201202162234504"></p><p>原因是因为stm32f4xx_fmc.c 是针对于stm32f429 等芯片的，我们直接删除改文件即可。</p><hr><p>再次编译报错：</p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202162333690.png" alt="image-20201202162333690"></p><p>打开FreeRTOSConfig.h 文件 将<code>#ifdef __ICCARM__ </code> 修改为<br><code>#if defined(__ICCARM__)||defined(__CC_ARM)||defined(__GNU__)</code>  如图：</p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202162553823.png" alt="image-20201202162553823"></p><p>此处注意<code>SystemCoreClock</code> 的值要与你系统时钟移植，查看一下已确定。</p><hr><p>再次编译显示</p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202162816847.png" alt="image-20201202162816847"></p><p>参考第三步配置FreeRTOS 时钟心跳。</p><h3 id="3-配置FreeRTOS-时钟心跳"><a href="#3-配置FreeRTOS-时钟心跳" class="headerlink" title="3| 配置FreeRTOS 时钟心跳"></a>3| 配置FreeRTOS 时钟心跳</h3><p>将stm32f4xx_it.c 中的 <code>SVC_Handler(void)  PendSV_Handler(void)  SysTick_Handler(void)</code>三个中断函数注释。</p><p>将FreeRTOSConfig.h 文件中 <code>#define xPortSysTickHandler SysTick_Handler</code>注释，如图</p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202175620531.png" alt="image-20201202175620531"></p><hr><p>在delay.c 中添加<code>sysTick</code>中断 和 <code>sysTick Init</code> 如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">FreeRTOS</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span>  fac_us=<span class="hljs-number">0</span>;<span class="hljs-comment">//us延时倍乘数, 1us 需要的 systick 计数次数   </span><span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> fac_ms=<span class="hljs-number">0</span>;<span class="hljs-comment">//ms延时倍乘数,在os下,代表每个节拍的ms数</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  This function handles SysTick Handler.</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-comment">//systick  中断服务函数</span><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1 )</span><span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* INCLUDE_xTaskGetSchedulerState */</span></span>xPortSysTickHandler();<span class="hljs-meta">#<span class="hljs-keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1 )</span>&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* INCLUDE_xTaskGetSchedulerState */</span></span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif 初始化systick</span><span class="hljs-comment">SYSTICK 的时钟固定为 AHB 时钟，基础例程里面 SYSTICK 时钟频率为 AHB/8</span><span class="hljs-comment">这里为了兼容 FreeRTOS，所以将 SYSTICK 的时钟频率改为 AHB 的频率！</span><span class="hljs-comment"> * @param SYSCLK 系统时钟频率 unit: MHz</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_init</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> SYSCLK)</span>&#123;<span class="hljs-type">uint32_t</span> reload;<span class="hljs-comment">//SysTick 频率为 HCLK</span>SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);fac_us=SYSCLK; <span class="hljs-comment">//不论是否使用 OS,fac_us 都需要使用</span><span class="hljs-comment">//每秒钟的计数次数 单位为 K 根据 configTICK_RATE_HZ 设定溢出时间  reload = 168 K = 168 000 </span>reload= SYSCLK * <span class="hljs-number">1000000</span>/configTICK_RATE_HZ;<span class="hljs-comment">//reload 为 24 位寄存器,最大值:16777216,</span><span class="hljs-comment">//在 168M 下,约合 0.0998s 左右</span>fac_ms=<span class="hljs-number">1000</span>/configTICK_RATE_HZ; <span class="hljs-comment">//代表 OS 可以延时的最少单位</span>SysTick-&gt;CTRL|=SysTick_CTRL_TICKINT_Msk;<span class="hljs-comment">//开启 SYSTICK 中断</span>SysTick-&gt;LOAD=reload; <span class="hljs-comment">//每 1/configTICK_RATE_HZ 秒 中断一次</span>SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk; <span class="hljs-comment">//开启 SYSTICK</span>&#125;</code></pre></div><p>至此 心跳时基就已经OK了，但是有时候会使用延时函数（会引起任务调度或者不引起任务调度的延时），如下所示添加即可</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif delay us. Will not cause task scheduling.</span><span class="hljs-comment"> * @param nus time need to delay (unit|us)</span><span class="hljs-comment">range[0~204522252](max = 2^32/fac_us@fac_us=168)</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_us</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> nus)</span>&#123;<span class="hljs-type">uint32_t</span> ticks;<span class="hljs-type">uint32_t</span> told, tnow, tcnt=<span class="hljs-number">0</span>;<span class="hljs-type">uint32_t</span> reload = SysTick-&gt;LOAD;<span class="hljs-comment">//LOAD的值     </span>ticks = nus * fac_us; <span class="hljs-comment">//需要的节拍数 </span>told = SysTick-&gt;VAL;        <span class="hljs-comment">//刚进入时的计数器值</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;tnow = SysTick-&gt;VAL;<span class="hljs-keyword">if</span>(tnow != told)&#123;    <span class="hljs-keyword">if</span>(tnow &lt; told) tcnt += told - tnow;<span class="hljs-comment">//这里注意一下SYSTICK是一个递减的计数器就可以了.</span><span class="hljs-keyword">else</span> tcnt += reload - tnow + told;    told = tnow;<span class="hljs-keyword">if</span>(tcnt &gt;= ticks)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//时间超过/等于要延迟的时间,则退出.</span>&#125;  &#125;;    &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif delay Ms. Will cause task scheduling.</span><span class="hljs-comment"> * @param nms time need to delay (unit|Ms)</span><span class="hljs-comment">range[0~65535]</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_ms</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> nms)</span>&#123;<span class="hljs-keyword">if</span>(xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)<span class="hljs-comment">//系统已经运行</span>&#123; <span class="hljs-keyword">if</span>(nms &gt;= fac_ms) <span class="hljs-comment">//延时的时间大于 OS 的最少时间周期</span>&#123;vTaskDelay(nms / fac_ms);  <span class="hljs-comment">//FreeRTOS 延时</span>&#125;nms %= fac_ms;  <span class="hljs-comment">//OS 已经无法提供这么小的延时了,采用普通方式延时</span>&#125;delay_us((<span class="hljs-type">uint32_t</span>)(nms*<span class="hljs-number">1000</span>)); <span class="hljs-comment">//普通方式延时</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif delay Ms. Will not cause task scheduling.</span><span class="hljs-comment"> * @param nms time need to delay (unit|Ms)</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_xms</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> nms)</span>&#123;<span class="hljs-type">uint32_t</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;nms;i++) delay_us(<span class="hljs-number">1000</span>);&#125;</code></pre></div><hr><p>编译会提示 <code>xPortSysTickHandler</code> 函数隐式声明， 打开<code>FreeRTOSConfig.h</code>文件，在最后添加如下代码声明即可：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;</code></pre></div><hr><p>之后再次编译发现 几个Hook 函数报错，打开FreeRTOSConfig.h 文件 将如下几个宏定义定义改为0</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_IDLE_HOOK1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICK_HOOK1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCHECK_FOR_STACK_OVERFLOW2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MALLOC_FAILED_HOOK1</span></code></pre></div><p>如图所示：</p><p><img src="/2020/12/02/NOTE/ARM/FreeRTOS/STM32%E7%A7%BB%E6%A4%8DFreeRTOS/image-20201202175936488.png" alt="image-20201202175936488"></p><hr><h2 id="三、-如何开始任务调度"><a href="#三、-如何开始任务调度" class="headerlink" title="三、 如何开始任务调度"></a>三、 如何开始任务调度</h2><p>编译无错后，打开<code>main.c</code> 添加如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/** -----------------------------------------</span><span class="hljs-comment">FreeRTOS</span><span class="hljs-comment"> -----------------------------------------*/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><span class="hljs-comment">/* Task handle */</span><span class="hljs-comment">/* 创建任务句柄 */</span><span class="hljs-type">static</span> TaskHandle_t AppTaskCreate_Handle = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/* Timer任务句柄 */</span><span class="hljs-type">static</span> TaskHandle_t Timer_Task_Handle = <span class="hljs-literal">NULL</span>;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">AppTaskCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">/* 用于创建任务 */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Timer_Task</span><span class="hljs-params">(<span class="hljs-type">void</span>* pvParameters)</span>;<span class="hljs-comment">/* LED_Task任务实现 */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">bsp_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">/* bsp drivers init. */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;BaseType_t xReturn = pdPASS;<span class="hljs-comment">/* 定义一个创建信息返回值，默认为pdPASS */</span>bsp_init();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is F4 FreeRTOS Demo!\r\n&quot;</span>);<span class="hljs-comment">/* 创建AppTaskCreate任务 */</span>xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,  <span class="hljs-comment">/* 任务入口函数 */</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*    )<span class="hljs-string">&quot;AppTaskCreate&quot;</span>,<span class="hljs-comment">/* 任务名字 */</span>(<span class="hljs-type">uint16_t</span>       )<span class="hljs-number">128</span>,  <span class="hljs-comment">/* 任务栈大小 */</span>(<span class="hljs-type">void</span>*          )<span class="hljs-literal">NULL</span>,<span class="hljs-comment">/* 任务入口函数参数 */</span>(UBaseType_t    )<span class="hljs-number">1</span>, <span class="hljs-comment">/* 任务的优先级 */</span>(TaskHandle_t*  )&amp;AppTaskCreate_Handle);<span class="hljs-comment">/* 任务控制块指针 */</span> <span class="hljs-comment">/* 启动任务调度 */</span>           <span class="hljs-keyword">if</span>(pdPASS == xReturn)vTaskStartScheduler();   <span class="hljs-comment">/* 启动任务，开启调度 */</span><span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">/* 正常不会执行到这里 */</span>   &#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">AppTaskCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;BaseType_t xReturn = pdPASS;<span class="hljs-comment">/* 定义一个创建信息返回值，默认为pdPASS */</span> taskENTER_CRITICAL();           <span class="hljs-comment">//进入临界区</span><span class="hljs-comment">/* 创建Timer_Task任务 */</span>xReturn = xTaskCreate((TaskFunction_t )Timer_Task,  <span class="hljs-comment">/* 任务入口函数 */</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*    )<span class="hljs-string">&quot;Timer_Task&quot;</span>,<span class="hljs-comment">/* 任务名字 */</span>(<span class="hljs-type">uint16_t</span>       )<span class="hljs-number">128</span>,  <span class="hljs-comment">/* 任务栈大小 */</span>(<span class="hljs-type">void</span>*          )<span class="hljs-literal">NULL</span>,<span class="hljs-comment">/* 任务入口函数参数 */</span>(UBaseType_t    )<span class="hljs-number">2</span>, <span class="hljs-comment">/* 任务的优先级 */</span>(TaskHandle_t*  )&amp;Timer_Task_Handle);<span class="hljs-comment">/* 任务控制块指针 */</span> <span class="hljs-keyword">if</span>(xReturn == pdPASS)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Timer_Task Create succeed!\r\n&quot;</span>);<span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Timer_Task Create failed!\r\n&quot;</span>);vTaskDelete(AppTaskCreate_Handle);taskEXIT_CRITICAL(); <span class="hljs-comment">//退出临界区</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief Timer_Task task main body.</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Timer_Task</span><span class="hljs-params">(<span class="hljs-type">void</span>* parameter)</span>&#123;<span class="hljs-type">uint32_t</span> t = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;time(1s): %d\r\n&quot;</span>,t);delay_ms(<span class="hljs-number">1000</span>);t++;&#125;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">bsp_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;SystemInit();<span class="hljs-comment">//晶振时钟初始化</span>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);<span class="hljs-comment">//4位抢占优先级</span>delay_init(<span class="hljs-number">168</span>);usart1_init(<span class="hljs-number">115200</span>);&#125;</code></pre></div><p>编译运行测试。</p><hr><h2 id="四、优化配置"><a href="#四、优化配置" class="headerlink" title="四、优化配置"></a>四、优化配置</h2><p>中断服务函数中代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//systick  中断服务函数</span><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1 )</span><span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* INCLUDE_xTaskGetSchedulerState */</span></span>xPortSysTickHandler();<span class="hljs-meta">#<span class="hljs-keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1 )</span>&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* INCLUDE_xTaskGetSchedulerState */</span></span>&#125;</code></pre></div><p>可以看出，有宏定义判断<code>#if (INCLUDE_xTaskGetSchedulerState == 1 )</code> ， 所以我们可以打开<code>FreeRTOS.h</code> 文件 ，将宏<code>#define INCLUDE_xTaskGetSchedulerState 0</code> 改为1，启用任务可以获取调度器状态。</p><h2 id="五、其他代码"><a href="#五、其他代码" class="headerlink" title="五、其他代码"></a>五、其他代码</h2><h3 id="delay-h"><a href="#delay-h" class="headerlink" title="delay.h"></a>delay.h</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __DELAY_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __DELAY_H    </span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f4xx.h&quot;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_init</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> SYSCLK)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">delay_ms</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> nms)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">delay_us</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> nus)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><h3 id="delay-c"><a href="#delay-c" class="headerlink" title="delay.c"></a>delay.c</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;delay.h&quot;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">FreeRTOS</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><span class="hljs-comment">/** Macro define */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSTEM_SUPPORT_OS 1<span class="hljs-comment">/* Define it to support OS. */</span></span><span class="hljs-comment">/** Private var define */</span><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span>  fac_us=<span class="hljs-number">0</span>;<span class="hljs-comment">//us延时倍乘数, 1us 需要的 systick 计数次数   </span><span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> fac_ms=<span class="hljs-number">0</span>;<span class="hljs-comment">//ms延时倍乘数,在os下,代表每个节拍的ms数</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> SYSTEM_SUPPORT_OS<span class="hljs-comment">//如果SYSTEM_SUPPORT_OS定义了,说明要支持OS了(不限于UCOS).</span></span><span class="hljs-comment">/*****************SYSTEM_SUPPORT_OS********************/</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  This function handles SysTick Handler.</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1 )</span><span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* INCLUDE_xTaskGetSchedulerState */</span></span>xPortSysTickHandler();<span class="hljs-meta">#<span class="hljs-keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1 )</span>&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* INCLUDE_xTaskGetSchedulerState */</span></span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif 初始化systick</span><span class="hljs-comment">SYSTICK 的时钟固定为 AHB 时钟，基础例程里面 SYSTICK 时钟频率为 AHB/8</span><span class="hljs-comment">这里为了兼容 FreeRTOS，所以将 SYSTICK 的时钟频率改为 AHB 的频率！</span><span class="hljs-comment"> * @param SYSCLK 系统时钟频率 unit: MHz</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_init</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> SYSCLK)</span>&#123;<span class="hljs-type">uint32_t</span> reload;<span class="hljs-comment">//SysTick 频率为 HCLK</span>SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);fac_us=SYSCLK; <span class="hljs-comment">//不论是否使用 OS,fac_us 都需要使用</span><span class="hljs-comment">//每秒钟的计数次数 单位为 K 根据 configTICK_RATE_HZ 设定溢出时间  reload = 168 K = 168 000 </span>reload= SYSCLK * <span class="hljs-number">1000000</span>/configTICK_RATE_HZ;<span class="hljs-comment">//reload 为 24 位寄存器,最大值:16777216,</span><span class="hljs-comment">//在 168M 下,约合 0.0998s 左右</span>fac_ms=<span class="hljs-number">1000</span>/configTICK_RATE_HZ; <span class="hljs-comment">//代表 OS 可以延时的最少单位</span>SysTick-&gt;CTRL|=SysTick_CTRL_TICKINT_Msk;<span class="hljs-comment">//开启 SYSTICK 中断</span>SysTick-&gt;LOAD=reload; <span class="hljs-comment">//每 1/configTICK_RATE_HZ 秒 中断一次</span>SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk; <span class="hljs-comment">//开启 SYSTICK</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif delay us. Will not cause task scheduling.</span><span class="hljs-comment"> * @param nus time need to delay (unit|us)</span><span class="hljs-comment">range[0~204522252](max = 2^32/fac_us@fac_us=168)</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_us</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> nus)</span>&#123;<span class="hljs-type">uint32_t</span> ticks;<span class="hljs-type">uint32_t</span> told, tnow, tcnt=<span class="hljs-number">0</span>;<span class="hljs-type">uint32_t</span> reload = SysTick-&gt;LOAD;<span class="hljs-comment">//LOAD的值     </span>ticks = nus * fac_us; <span class="hljs-comment">//需要的节拍数 </span>told = SysTick-&gt;VAL;        <span class="hljs-comment">//刚进入时的计数器值</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;tnow = SysTick-&gt;VAL;<span class="hljs-keyword">if</span>(tnow != told)&#123;    <span class="hljs-keyword">if</span>(tnow &lt; told) tcnt += told - tnow;<span class="hljs-comment">//这里注意一下SYSTICK是一个递减的计数器就可以了.</span><span class="hljs-keyword">else</span> tcnt += reload - tnow + told;    told = tnow;<span class="hljs-keyword">if</span>(tcnt &gt;= ticks)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//时间超过/等于要延迟的时间,则退出.</span>&#125;  &#125;;    &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif delay Ms. Will cause task scheduling.</span><span class="hljs-comment"> * @param nms time need to delay (unit|Ms)</span><span class="hljs-comment">range[0~65535]</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_ms</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> nms)</span>&#123;<span class="hljs-keyword">if</span>(xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)<span class="hljs-comment">//系统已经运行</span>&#123; <span class="hljs-keyword">if</span>(nms &gt;= fac_ms) <span class="hljs-comment">//延时的时间大于 OS 的最少时间周期</span>&#123;vTaskDelay(nms / fac_ms);  <span class="hljs-comment">//FreeRTOS 延时</span>&#125;nms %= fac_ms;  <span class="hljs-comment">//OS 已经无法提供这么小的延时了,采用普通方式延时</span>&#125;delay_us((<span class="hljs-type">uint32_t</span>)(nms*<span class="hljs-number">1000</span>)); <span class="hljs-comment">//普通方式延时</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif delay Ms. Will not cause task scheduling.</span><span class="hljs-comment"> * @param nms time need to delay (unit|Ms)</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_xms</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> nms)</span>&#123;<span class="hljs-type">uint32_t</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;nms;i++) delay_us(<span class="hljs-number">1000</span>);&#125;<span class="hljs-comment">/*****************SYSTEM_SUPPORT_OS END********************/</span><span class="hljs-meta">#<span class="hljs-keyword">else</span>  </span><span class="hljs-comment">/*****************NO SYSTEM_SUPPORT_OS********************/</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif 初始化systick</span><span class="hljs-comment">SYSTICK的时钟固定为AHB时钟的1/8</span><span class="hljs-comment"> * @param SYSCLK 系统时钟频率 unit: MHz</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_init</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> SYSCLK)</span>&#123; SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); fac_us=SYSCLK/<span class="hljs-number">8</span>;<span class="hljs-comment">//不论是否使用OS,fac_us都需要使用</span>fac_ms=(<span class="hljs-type">uint16_t</span>)fac_us*<span class="hljs-number">1000</span>;<span class="hljs-comment">//非OS下,代表每个ms需要的systick时钟数   </span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif delay us.</span><span class="hljs-comment"> * @param nus time need to delay (unit [us])</span><span class="hljs-comment">range[0~798915](max = 2^24/fac_us@fac_us=21)</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_us</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> nus)</span>&#123;<span class="hljs-type">uint32_t</span> temp;     SysTick-&gt;LOAD=nus*fac_us; <span class="hljs-comment">//时间加载   </span>SysTick-&gt;VAL=<span class="hljs-number">0x00</span>;        <span class="hljs-comment">//清空计数器</span>SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ; <span class="hljs-comment">//开始倒数  </span><span class="hljs-keyword">do</span>&#123;temp=SysTick-&gt;CTRL;&#125;<span class="hljs-keyword">while</span>((temp&amp;<span class="hljs-number">0x01</span>)&amp;&amp;!(temp&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>)));<span class="hljs-comment">//等待时间到达   </span>SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk; <span class="hljs-comment">//关闭计数器</span>SysTick-&gt;VAL =<span class="hljs-number">0X00</span>;       <span class="hljs-comment">//清空计数器 </span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif delay Ms. </span><span class="hljs-comment">注意nms的范围，SysTick-&gt;LOAD为24位寄存器,所以,最大延时为:nms&lt;=0xffffff*8*1000/SYSCLK </span><span class="hljs-comment">SYSCLK单位为Hz,nms单位为ms。对168M条件下,nms&lt;=798ms </span><span class="hljs-comment"> * @param nms time need to delay (unit|Ms)</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_xms</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> nms)</span>&#123;     <span class="hljs-type">uint32_t</span> temp;   SysTick-&gt;LOAD=(<span class="hljs-type">uint32_t</span>)nms*fac_ms;<span class="hljs-comment">//时间加载(SysTick-&gt;LOAD为24bit)</span>SysTick-&gt;VAL =<span class="hljs-number">0x00</span>;           <span class="hljs-comment">//清空计数器</span>SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;    <span class="hljs-comment">//开始倒数 </span><span class="hljs-keyword">do</span>&#123;temp=SysTick-&gt;CTRL;&#125;<span class="hljs-keyword">while</span>((temp&amp;<span class="hljs-number">0x01</span>)&amp;&amp;!(temp&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>)));<span class="hljs-comment">//等待时间到达   </span>SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;    <span class="hljs-comment">//关闭计数器</span>SysTick-&gt;VAL =<span class="hljs-number">0X00</span>;       <span class="hljs-comment">//清空计数器      </span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * @breif delay Ms. Will cause task scheduling.</span><span class="hljs-comment"> * @param nms time need to delay (unit|Ms)</span><span class="hljs-comment">range[0~65535]</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">delay_ms</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> nms)</span>&#123;  <span class="hljs-type">uint8_t</span> repeat=nms/<span class="hljs-number">540</span>;<span class="hljs-comment">//这里用540,是考虑到某些客户可能超频使用,</span><span class="hljs-comment">//比如超频到248M的时候,delay_xms最大只能延时541ms左右了</span><span class="hljs-type">uint16_t</span> remain=nms%<span class="hljs-number">540</span>;<span class="hljs-keyword">while</span>(repeat)&#123;delay_xms(<span class="hljs-number">540</span>);repeat--;&#125;<span class="hljs-keyword">if</span>(remain)delay_xms(remain);&#125; <span class="hljs-comment">/*****************NO SYSTEM_SUPPORT_OS END********************/</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS中断浅析</title>
    <link href="/2020/11/27/NOTE/ARM/FreeRTOS/FreeRTOS%E4%B8%AD%E6%96%AD%E6%B5%85%E6%9E%90/"/>
    <url>/2020/11/27/NOTE/ARM/FreeRTOS/FreeRTOS%E4%B8%AD%E6%96%AD%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>@firestaradmin 2020年11月27日16:06:56</p><h1 id="FreeRTOS中断浅析"><a href="#FreeRTOS中断浅析" class="headerlink" title="FreeRTOS中断浅析"></a>FreeRTOS中断浅析</h1><h3 id="一、STM32中断屏蔽的特殊寄存器"><a href="#一、STM32中断屏蔽的特殊寄存器" class="headerlink" title="一、STM32中断屏蔽的特殊寄存器"></a>一、STM32中断屏蔽的特殊寄存器</h3><p>我们在 STM32 上移植 FreeRTOS 的时候需要重点关注 PRIMASK、FAULTMASK 和 BASEPRI 这三个寄存器，本节就来学习一下这三个寄存器。</p><h4 id="1-、PRIMASK-和-和-FAULTMASK-寄存器"><a href="#1-、PRIMASK-和-和-FAULTMASK-寄存器" class="headerlink" title="1 、PRIMASK 和 和 FAULTMASK  寄存器"></a>1 、PRIMASK 和 和 FAULTMASK  寄存器</h4><p>在许多应用中，需要暂时屏蔽所有的中断一执行一些对时序要求严格的任务，这个时候就可以使用 PRIMASK 寄存器，<strong>PRIMASK 用于禁止除 NMI 和 HardFalut 外的所有异常和中断</strong>，汇编编程的时候可以使用 CPS(修改处理器状态)指令修改 PRIMASK 寄存器的数值：</p><div class="hljs code-wrapper"><pre><code class="hljs asm">CPSIE I;  //清除 PRIMASK(使能中断)CPSID  I;  //设置 PRIMASK(禁止中断)</code></pre></div><p>PRIMASK 寄存器还可以通过 MRS 和 MSR 指令访问，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOVS R0, #1MSR PRIMASK,  R0  ;//将 1 写入 PRIMASK 禁止所有中断</code></pre></div><p>以及：</p><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOVS R0, #0 MSR PRIMASK,  R0  ;//将 0 写入 PRIMASK 以使能中断</code></pre></div><p>UCOS 中的临界区代码代码保护就是通过开关中断实现的(UCOSIII 也可以使用禁止任务调度的方法来实现临界区代码保护，这里不讨论这种情况)，而开关中断就是直接操作 PRIMASK寄存器的，所以在 UCOS 中关闭中断的时候时关闭了除复位、NMI 和 HardFault 以外的所有中断！</p><p><strong>FAULTMASK</strong> 比 PRIMASK 更狠，它可以连 HardFault 都屏蔽掉，使用方法和 PRIMASK 类似，FAULTMASK 会在退出时自动清零。汇编编程的时候可以利用 CPS 指令修改 FAULTMASK 的当前状态：</p><div class="hljs code-wrapper"><pre><code class="hljs assembly">CPSIE  F  ;清除 FAULTMASKCPSID F  ;设置 FAULTMASK</code></pre></div><p>还可以利用 MRS 和 MSR 指令访问 FAULTMASK 寄存器：</p><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOVS  R0, #1 MSR FAULTMASK, R0  ;将 1 写入 FAULTMASK 禁止所有中断</code></pre></div><p>以及：</p><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOVS R0, #0MSR FAULTMASK, R0  ;将 0 写入 FAULTMASK 使能中断</code></pre></div><h4 id="2-、BASEPRI-寄存器"><a href="#2-、BASEPRI-寄存器" class="headerlink" title="2 、BASEPRI 寄存器"></a>2 、BASEPRI 寄存器</h4><p>PRIMASK 和 FAULTMASK 寄存器太粗暴了，直接关闭除复位、NMI 和 HardFault 以外的其他所有中断，但是在有些场合需要对中断屏蔽进行更细腻的控制，比如<strong>只屏蔽优先级低于某一个阈值的中断</strong>。那么这个作为阈值的优先级值存储在哪里呢？在 BASEPRI 寄存器中，不过如果向 BASEPRI 写 0 的话就会停止屏蔽中断。比如，我们要屏蔽优先级不高于 0X60 （NVIC组4的时候）的中断，则可以使用如下汇编编程：</p><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV  R0， #0X60MSR BASEPRI, R0</code></pre></div><p>如果需要取消 BASEPRI 对中断的屏蔽，可以使用如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs asm">MOV  R0, #0MSR BASEPRI, R0</code></pre></div><p>注意！FreeRTOS 的开关中断就是操作 BASEPRI 寄存器来实现的！它可以关闭低于某个阈值的中断，高于这个阈值的中断就不会被关闭！</p><h3 id="二、FreeRTOS-中断配置宏"><a href="#二、FreeRTOS-中断配置宏" class="headerlink" title="二、FreeRTOS  中断配置宏"></a>二、FreeRTOS  中断配置宏</h3><h5 id="configPRIO-BITS"><a href="#configPRIO-BITS" class="headerlink" title="configPRIO_BITS"></a>configPRIO_BITS</h5><p>此宏用来设置 MCU 使用几位优先级，STM32 使用的是 4 位，因此此宏为 4！</p><h5 id="configLIBRARY-LOWEST-INTERRUPT-PRIORITY"><a href="#configLIBRARY-LOWEST-INTERRUPT-PRIORITY" class="headerlink" title="configLIBRARY_LOWEST_INTERRUPT_PRIORITY"></a>configLIBRARY_LOWEST_INTERRUPT_PRIORITY</h5><p>此宏是用来设置最低优先级，STM32 优先级使用了 4 位，而且 STM32 配置的使用组 4，也就是 4 位都是抢占优先级。因此优先级数就是 16 个，最低优先级那就是 15。所以此宏就是 15，注意！不同的 MCU 此值不同，具体是多少要看所使用的 MCU 的架构，这里只针对 STM32 讲解！</p><h5 id="configKERNEL-INTERRUPT-PRIORITY"><a href="#configKERNEL-INTERRUPT-PRIORITY" class="headerlink" title="configKERNEL_INTERRUPT_PRIORITY"></a>configKERNEL_INTERRUPT_PRIORITY</h5><p>此宏用来设置内核中断优先级，此宏定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configKERNEL_INTERRUPT_PRIORITY</span>( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (<span class="hljs-number">8</span> - configPRIO_BITS) )</code></pre></div><ul><li><p>宏 configKERNEL_INTERRUPT_PRIORITY 为 ， 宏configLIBRARY_LOWEST_INTERRUPT_PRIORITY 左移 8-configPRIO_BITS 位，也就是左移 4位。为什么要左移 4 位呢？前面我们说了，STM32 使用了 4 位作为优先级，而这 4 位是高 4 位，因 此 要 左 移 4 位 才 是 真 正 的 优 先 级 。 当 然 了 也 可 以 不 用 移 位 ， 直 接 将 宏configLIBRARY_LOWEST_INTERRUPT_PRIORITY 定义为 0XF0！不过这样看起来不直观。</p></li><li><p>宏configKERNEL_INTERRUPT_PRIORITY用来设置PendSV和滴答定时器的中断优先级，port.c 中有如下定义：</p></li><li><p>&#96;&#96;&#96;c<br>  #define portNVIC_PENDSV_PRI ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt;16UL )<br>  #define portNVIC_SYSTICK_PRI ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt;24UL )</p>  <div class="hljs code-wrapper"><pre><code class="hljs clean">- 可 以 看 出 ， portNVIC_PENDSV_PRI 和 portNVIC_SYSTICK_PRI 都 是 使 用 了 宏configKERNEL_INTERRUPT_PRIORITY ， 为 什 么 宏 portNVIC_PENDSV_PRI  是 宏configKERNEL_INTERRUPT_PRIORITY 左移 <span class="hljs-number">16</span> 位呢？宏 portNVIC_SYSTICK_PRI 也同样是左移 <span class="hljs-number">24</span> 位。的，这样一次写入的是个 <span class="hljs-number">32</span> 位的数据， SysTick 和 PendSV 的优先级寄存器分别对应这个 <span class="hljs-number">32</span>位数据的最高 <span class="hljs-number">8</span> 位和次高 <span class="hljs-number">8</span> 位，不就是一个左移 <span class="hljs-number">16</span> 位，一个左移 <span class="hljs-number">24</span> 位了。**可以看出在FreeRTOS中 PendSV 和 SysTick 的中断优先级都是最低的！**##### configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY此宏用来设置 FreeRTOS 系统可管理的最大优先级，也就是我们在前面讲解BASEPRI 寄存器说的那个阈值优先级，这个大家可以自由设置，这里我设置为了 <span class="hljs-number">5</span>。也就是高于 <span class="hljs-number">5</span> 的优先级(优先级的数字大小 小于 <span class="hljs-number">5</span>的优先级)不归 FreeRTOS 管理！##### configMAX_SYSCALL_INTERRUPT_PRIORITY此宏是 configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 左移 <span class="hljs-number">4</span> 位而来的，原因和宏 configKERNEL_INTERRUPT_PRIORITY 一样。此宏设置好以后，低于此优先级的中断可以安全的调用 FreeRTOS 的 API 函数，高于此优先级的中断 FreeRTOS 是不能禁止的，中断服务函数也不能调用 FreeRTOS 的 API 函数！##### configMAX_PRIORITIES                     此宏用来定义FreeRTOS自己的任务的最大优先级，和<span class="hljs-number">32</span>不同的是，数字越大优先级越高，<span class="hljs-number">32</span>则是相反的。在FreeRTOSConfig.h中有如下定义:```c#define configMAX_PRIORITIES                     ( <span class="hljs-number">7</span> )</code></pre></div></li></ul><h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><p>以 STM32 为例，有 16 个优先级，0 为最高优先级，15 为最低优先级，配置如下：</p><ul><li>configMAX_SYSCALL_INTERRUPT_PRIORITY&#x3D;&#x3D;5</li><li>configKERNEL_INTERRUPT_PRIORITY&#x3D;&#x3D;15</li></ul><p><img src="/2020/11/27/NOTE/ARM/FreeRTOS/FreeRTOS%E4%B8%AD%E6%96%AD%E6%B5%85%E6%9E%90/image-20201127161837420.png" alt="image-20201127161837420"></p><p>由于高于 configMAX_SYSCALL_INTERRUPT_PRIORITY 的优先级不会被 FreeRTOS 内核屏蔽，因此那些对实时性要求严格的任务就可以使用这些优先级，比如四轴飞行器中的壁障检测。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVGUI动态内存分配实现原理</title>
    <link href="/2020/10/18/NOTE/ARM/UVGUI/UVGUI%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2020/10/18/NOTE/ARM/UVGUI/UVGUI%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>@firestaradmin 2020年10月16日22:10:34</p><h1 id="UVGUI-动态内存分配实现原理"><a href="#UVGUI-动态内存分配实现原理" class="headerlink" title="UVGUI 动态内存分配实现原理"></a>UVGUI 动态内存分配实现原理</h1><p>UVGUI的动态内存管理是仿照LVGL写的，这里做一下记录。</p><h2 id="一、数据结构分析"><a href="#一、数据结构分析" class="headerlink" title="一、数据结构分析"></a>一、数据结构分析</h2><p>UVGUI的动态内存管理，是通过一个入口结构体进行管理和分配，其内存块由 <code>ug_mem_ent_t</code> 结构体表示。定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEM_UNIT uint32_t</span><span class="hljs-comment">/*The size of this union must be 4 bytes (uint32_t)*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        MEM_UNIT used : <span class="hljs-number">1</span>;    <span class="hljs-comment">/* 1: if the entry is used*/</span>        MEM_UNIT d_size : <span class="hljs-number">31</span>; <span class="hljs-comment">/* Size off the data (in bytes)*/</span>    &#125; s;    MEM_UNIT header; <span class="hljs-comment">/* The header (used + d_size)*/</span>&#125; <span class="hljs-type">ug_mem_header_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-type">ug_mem_header_t</span> header;    <span class="hljs-type">uint8_t</span> first_data; <span class="hljs-comment">/*First data byte in the allocated data (Just for easily create a pointer)*/</span>&#125; <span class="hljs-type">ug_mem_ent_t</span>;</code></pre></div><p>其中 有一些定义：</p><ul><li><p><code>MEM_UNIT</code>  为内存最小单位，主要根据系统位数决定。如32位系统一般使用uint32_t。</p></li><li><p><code>ug_mem_header_t</code> 联合为内存头信息。表示该内存块是否被使用以及内存块大小。</p></li><li><p><code>ug_mem_ent_t</code> 为内存块的入口结构体，其包含一个内存头信息，和一个char类型的变量<code>first_data</code>，<code>first_data</code>只是为了方便创建指针指向内存块储存区域的首地址。</p></li></ul><p>内存基本结构图如下：</p><p><img src="/2020/10/18/NOTE/ARM/UVGUI/UVGUI%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/image-20201016223619784.png" alt="image-20201016223619784"></p><p>UVGUI的内存是一块一块的，每一块内存的起始处，有一个头信息<code>union header</code> 来表示该内存块是否被使用，已经该内存块的大小。</p><p>系统刚开始运行，没有申请过内存，则整个内存池就是一个内存块，该内存块的头信息的<code>used </code> 属性为0，表示未被使用，<code>d_sized</code> 属性为整个内存池的大小减去头信息的大小，即为内存池可用空间。</p><h2 id="二、初始化"><a href="#二、初始化" class="headerlink" title="二、初始化"></a>二、初始化</h2><p>初始化函数 <code>void _ug_mem_init(void);</code> </p><ol><li><p>申请一个指定大小的数组，用于分配内存块。</p></li><li><p>用work_mem指针储存内存池的首地址，用变量mem_max_size追踪内存堆中申请过的最大内存大小。</p> <div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> * work_mem;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> mem_max_size; <span class="hljs-comment">/*Tracks the maximum total size of memory ever used from the internal heap*/</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div></li><li><p>初始化内存池的首个入口，将used属性设为0，并且更新内存池可用大小至首个入口的d_size属性中。</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize the dyn_mem module (work memory and other variables)</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_mem_init(<span class="hljs-type">void</span>)&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-comment">/*Allocate a large array to store the dynamically allocated data*/</span>    <span class="hljs-type">static</span> UG_MEM_ATTR MEM_UNIT work_mem_int[UG_MEM_SIZE / <span class="hljs-keyword">sizeof</span>(MEM_UNIT)];    work_mem = (<span class="hljs-type">uint8_t</span> *)work_mem_int;    mem_max_size = <span class="hljs-number">0</span>;    <span class="hljs-type">ug_mem_ent_t</span> * full = (<span class="hljs-type">ug_mem_ent_t</span> *)work_mem;    full-&gt;header.s.used = <span class="hljs-number">0</span>;    <span class="hljs-comment">/*The total mem size id reduced by the first header and the close patterns */</span>    full-&gt;header.s.d_size = UG_MEM_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;</code></pre></div><h2 id="三、API-接口"><a href="#三、API-接口" class="headerlink" title="三、API 接口"></a>三、API 接口</h2><h3 id="1-申请内存"><a href="#1-申请内存" class="headerlink" title="1|申请内存"></a>1|申请内存</h3><p>申请内存，由如下函数实现：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Allocate a memory dynamically</span><span class="hljs-comment"> * @param size size of the memory to allocate in bytes</span><span class="hljs-comment"> * @return pointer to the allocated memory</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * <span class="hljs-title function_">ug_mem_alloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>&#123;    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> &amp;zero_mem;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_ARCH_64</span>    <span class="hljs-comment">/*Round the size up to 8*/</span>    size = (size + <span class="hljs-number">7</span>) &amp; (~<span class="hljs-number">0x7</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">/*Round the size up to 4*/</span>    size = (size + <span class="hljs-number">3</span>) &amp; (~<span class="hljs-number">0x3</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-type">void</span> * alloc = <span class="hljs-literal">NULL</span>;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-comment">/*Use the built-in allocators*/</span>    <span class="hljs-type">ug_mem_ent_t</span> * e = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/* Search for a appropriate entry*/</span>    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-comment">/* Get the next entry*/</span>        e = ent_get_next(e);        <span class="hljs-comment">/*If there is next entry then try to allocate there*/</span>        <span class="hljs-keyword">if</span>(e != <span class="hljs-literal">NULL</span>) &#123;            alloc = ent_alloc(e, size);        &#125;        <span class="hljs-comment">/* End if there is not next entry OR the alloc. is successful*/</span>    &#125; <span class="hljs-keyword">while</span>(e != <span class="hljs-literal">NULL</span> &amp;&amp; alloc == <span class="hljs-literal">NULL</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span>                <span class="hljs-comment">/* UG_MEM_CUSTOM */</span></span>    <span class="hljs-keyword">if</span>(alloc == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> LOG(&quot;Couldn&#x27;t allocate memory&quot;);</span>    &#125;    <span class="hljs-keyword">else</span> &#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>        <span class="hljs-comment">/* just a safety check, should always be true */</span>        <span class="hljs-keyword">if</span>((<span class="hljs-type">uintptr_t</span>) alloc &gt; (<span class="hljs-type">uintptr_t</span>) work_mem) &#123;            <span class="hljs-keyword">if</span>((((<span class="hljs-type">uintptr_t</span>) alloc - (<span class="hljs-type">uintptr_t</span>) work_mem) + size) &gt; mem_max_size) &#123;                mem_max_size = ((<span class="hljs-type">uintptr_t</span>) alloc - (<span class="hljs-type">uintptr_t</span>) work_mem) + size;            &#125;        &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    &#125;    <span class="hljs-keyword">return</span> alloc;&#125;</code></pre></div><p><code>void * ug_mem_alloc(size_t size)</code> 函数申请指定大小的内存块，先将大小四字节对齐（32位系统下），然后申请一个入口结构体指针<code>e</code>，循环使用<code>e = ent_get_next(e)</code> 获取下一个入口地址，然后在<code>ent_alloc</code> 这个函数中做真正的内存申请，直到找不到一下个入口或者成功申请到内存。 </p><p>判断内存块是否被使用和大小是否足够，是在<code>ent_alloc</code> 这个函数中判断的，具体请继续往下看。</p><hr><p><code>ent_get_next</code> 函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Give the next entry after &#x27;act_e&#x27;</span><span class="hljs-comment"> * @param act_e pointer to an entry</span><span class="hljs-comment"> * @return pointer to an entry after &#x27;act_e&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ug_mem_ent_t</span> * <span class="hljs-title function_">ent_get_next</span><span class="hljs-params">(<span class="hljs-type">ug_mem_ent_t</span> * act_e)</span>&#123;    <span class="hljs-type">ug_mem_ent_t</span> * next_e = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span>(act_e == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*NULL means: get the first entry*/</span>        next_e = (<span class="hljs-type">ug_mem_ent_t</span> *)work_mem;    &#125;    <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">/*Get the next entry */</span>        <span class="hljs-type">uint8_t</span> * data = &amp;act_e-&gt;first_data;        next_e         = (<span class="hljs-type">ug_mem_ent_t</span> *)&amp;data[act_e-&gt;header.s.d_size];        <span class="hljs-keyword">if</span>(&amp;next_e-&gt;first_data &gt;= &amp;work_mem[UG_MEM_SIZE]) next_e = <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">return</span> next_e;&#125;</code></pre></div><p>每次申请内存时，都是从第一个入口开始往后寻找。</p><hr><p><code>ent_alloc</code> 函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Try to do the real allocation with a given size</span><span class="hljs-comment"> * @param e try to allocate to this entry</span><span class="hljs-comment"> * @param size size of the new memory in bytes</span><span class="hljs-comment"> * @return pointer to the allocated memory or NULL if not enough memory in the entry</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-title function_">ent_alloc</span><span class="hljs-params">(<span class="hljs-type">ug_mem_ent_t</span> * e, <span class="hljs-type">size_t</span> size)</span>&#123;    <span class="hljs-type">void</span> * alloc = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/*If the memory is free and big enough then use it */</span>    <span class="hljs-keyword">if</span>(e-&gt;header.s.used == <span class="hljs-number">0</span> &amp;&amp; e-&gt;header.s.d_size &gt;= size) &#123;        <span class="hljs-comment">/*Truncate the entry to the desired size */</span>        ent_trunc(e, size);        e-&gt;header.s.used = <span class="hljs-number">1</span>;        <span class="hljs-comment">/*Save the allocated data*/</span>        alloc = &amp;e-&gt;first_data;    &#125;    <span class="hljs-keyword">return</span> alloc;&#125;</code></pre></div><p>判断该内存块入口是否被使用以及大小是否足够用于申请内存，如果满足条件，则使用函数<code>ent_trunc()</code> 函数将此入口截断，然后返回申请的内存的储存首地址（即该内存块的头信息后的用户真正可以使用的储存首地址）。如果不满足条件，则返回NULL；</p><hr><p><code>ent_trunc()</code> 函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Truncate the data of entry to the given size</span><span class="hljs-comment"> * @param e Pointer to an entry</span><span class="hljs-comment"> * @param size new size in bytes</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ent_trunc</span><span class="hljs-params">(<span class="hljs-type">ug_mem_ent_t</span> * e, <span class="hljs-type">size_t</span> size)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_ARCH_64</span>    <span class="hljs-comment">/*Round the size up to 8*/</span>    size = (size + <span class="hljs-number">7</span>) &amp; (~<span class="hljs-number">0x7</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">/*Round the size up to 4*/</span>    size = (size + <span class="hljs-number">3</span>) &amp; (~<span class="hljs-number">0x3</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-comment">/*Don&#x27;t let empty space only for a header without data. </span><span class="hljs-comment">      如果分配后只剩仅能保存一个头部的内存，那么就直接全部分配给这个内存块*/</span>    <span class="hljs-keyword">if</span>(e-&gt;header.s.d_size == size + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>)) &#123;        size = e-&gt;header.s.d_size;    &#125;    <span class="hljs-comment">/* Create the new entry after the current if there is space for it */</span>    <span class="hljs-keyword">if</span>(e-&gt;header.s.d_size != size) &#123;        <span class="hljs-type">uint8_t</span> * e_data             = &amp;e-&gt;first_data;        <span class="hljs-type">ug_mem_ent_t</span> * after_new_e   = (<span class="hljs-type">ug_mem_ent_t</span> *)&amp;e_data[size];        after_new_e-&gt;header.s.used   = <span class="hljs-number">0</span>;        after_new_e-&gt;header.s.d_size = (<span class="hljs-type">uint32_t</span>)e-&gt;header.s.d_size - size - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>);    &#125;    <span class="hljs-comment">/* Set the new size for the original entry */</span>    e-&gt;header.s.d_size = (<span class="hljs-type">uint32_t</span>)size;&#125;</code></pre></div><p>该函数根据需要申请的内存大小截断内存块的数据区，将原来的内存块截断为两块，前面是这次申请的内存块，后面是剩余的内存块。</p><p>剩余的内存块的起始位置用于储存内存块的entry信息，初始化<code>used</code>和<code>d_size</code>属性，未被使用，并更新剩余内存块的大小。</p><p>至此，内存申请就完成了。</p><h3 id="2-释放内存"><a href="#2-释放内存" class="headerlink" title="2|释放内存"></a>2|释放内存</h3><p>释放内存，由如下函数实现：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Free an allocated data</span><span class="hljs-comment"> * @param data pointer to an allocated memory</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ug_mem_free</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> * data)</span>&#123;    <span class="hljs-keyword">if</span>(data == &amp;zero_mem) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(data == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_ADD_JUNK</span>    _ug_memset((<span class="hljs-type">void</span> *)data, <span class="hljs-number">0xbb</span>, _ug_mem_get_size(data));<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_ENABLE_GC == 0</span>    <span class="hljs-comment">/*e points to the header*/</span>    <span class="hljs-type">ug_mem_ent_t</span> * e = (<span class="hljs-type">ug_mem_ent_t</span> *)((<span class="hljs-type">uint8_t</span> *)data - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>));    e-&gt;header.s.used = <span class="hljs-number">0</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_AUTO_DEFRAG</span>    <span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> full_defrag_cnt = <span class="hljs-number">0</span>;    full_defrag_cnt++;    <span class="hljs-keyword">if</span>(full_defrag_cnt &lt; UG_MEM_FULL_DEFRAG_CNT) &#123;        <span class="hljs-comment">/* Make a simple defrag.</span><span class="hljs-comment">         * Join the following free entries after this*/</span>        <span class="hljs-type">ug_mem_ent_t</span> * e_next;        e_next = ent_get_next(e);        <span class="hljs-keyword">while</span>(e_next != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(e_next-&gt;header.s.used == <span class="hljs-number">0</span>) &#123;                e-&gt;header.s.d_size += e_next-&gt;header.s.d_size + <span class="hljs-keyword">sizeof</span>(e-&gt;header);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;            e_next = ent_get_next(e_next);        &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;        full_defrag_cnt = <span class="hljs-number">0</span>;        ug_mem_defrag();    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*UG_MEM_AUTO_DEFRAG*/</span></span><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/*Use custom, user defined free function*/</span></span>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_ENABLE_GC == 0</span>        UG_MEM_CUSTOM_FREE(e);    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>        UG_MEM_CUSTOM_FREE((<span class="hljs-type">void</span> *)data);    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*UG_ENABLE_GC*/</span></span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;</code></pre></div><p>主体内容先获取改内存块的入口地址，将<code>used</code> 属性设为0，表示未被使用。</p><hr><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_ADD_JUNK</span>    _ug_memset((<span class="hljs-type">void</span> *)data, <span class="hljs-number">0xbb</span>, _ug_mem_get_size(data));<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>上面部分用宏定义决定是否需要添加无效数据到将释放的内存块。</p><hr><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_AUTO_DEFRAG</span>    <span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> full_defrag_cnt = <span class="hljs-number">0</span>;    full_defrag_cnt++;    <span class="hljs-keyword">if</span>(full_defrag_cnt &lt; UG_MEM_FULL_DEFRAG_CNT) &#123;        <span class="hljs-comment">/* Make a simple defrag.</span><span class="hljs-comment">         * Join the following free entries after this*/</span>        <span class="hljs-type">ug_mem_ent_t</span> * e_next;        e_next = ent_get_next(e);        <span class="hljs-keyword">while</span>(e_next != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(e_next-&gt;header.s.used == <span class="hljs-number">0</span>) &#123;                e-&gt;header.s.d_size += e_next-&gt;header.s.d_size + <span class="hljs-keyword">sizeof</span>(e-&gt;header);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;            e_next = ent_get_next(e_next);        &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;        full_defrag_cnt = <span class="hljs-number">0</span>;        ug_mem_defrag();    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*UG_MEM_AUTO_DEFRAG*/</span></span></code></pre></div><p>上面部分，用宏定义决定是否开启自动合并未被使用的内存块。</p><p>用静态变量<code>full_defrag_cnt</code> 统计释放过的内存块数，如果次数小于宏<code>UG_MEM_FULL_DEFRAG_CNT</code> 则执行简单的块合并 (即碎片整理)，如果超过，则执行函数<code>ug_mem_defrag()</code>。</p><p>简单的合并，即循环寻找下一个内存块入口，如果该内存块，未被使用，则合并到此次释放的内存块中。如果下一个内存块，已经被使用，则跳出。</p><p><code>ug_mem_defrag()</code> 会合并整个内存池中所有相连的可用内存块， 如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Join the adjacent free memory blocks</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ug_mem_defrag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-type">ug_mem_ent_t</span> * e_free;    <span class="hljs-type">ug_mem_ent_t</span> * e_next;    e_free = ent_get_next(<span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">/*Search the next free entry*/</span>        <span class="hljs-keyword">while</span>(e_free != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(e_free-&gt;header.s.used != <span class="hljs-number">0</span>) &#123;                e_free = ent_get_next(e_free);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(e_free == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">/*Joint the following free entries to the free*/</span>        e_next = ent_get_next(e_free);        <span class="hljs-keyword">while</span>(e_next != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(e_next-&gt;header.s.used == <span class="hljs-number">0</span>) &#123;                e_free-&gt;header.s.d_size += e_next-&gt;header.s.d_size + <span class="hljs-keyword">sizeof</span>(e_next-&gt;header);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;            e_next = ent_get_next(e_next);        &#125;        <span class="hljs-keyword">if</span>(e_next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">/*Continue from the lastly checked entry*/</span>        e_free = e_next;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;</code></pre></div><p>第一个大循环首先循环寻找一个可用内存块，然后判断该内存块后紧接的内存块是否可用，如果可用则合并，直到没有相邻的内存块可以合并。然后开始下一轮的大循环，以此往复，合并所有相连的可用内存块。</p><h3 id="3-内存重申请"><a href="#3-内存重申请" class="headerlink" title="3|内存重申请"></a>3|内存重申请</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Reallocate a memory with a new size. The old content will be kept.</span><span class="hljs-comment"> * @param data pointer to an allocated memory.</span><span class="hljs-comment"> * Its content will be copied to the new memory block and freed</span><span class="hljs-comment"> * @param new_size the desired new size in byte</span><span class="hljs-comment"> * @return pointer to the new memory</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * <span class="hljs-title function_">ug_mem_realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> * data_p, <span class="hljs-type">size_t</span> new_size)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_ARCH_64</span>    <span class="hljs-comment">/*Round the size up to 8*/</span>    new_size = (new_size + <span class="hljs-number">7</span>) &amp; (~<span class="hljs-number">0x7</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">/*Round the size up to 4*/</span>    new_size = (new_size + <span class="hljs-number">3</span>) &amp; (~<span class="hljs-number">0x3</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-comment">/*data_p could be previously freed pointer (in this case it is invalid)*/</span>    <span class="hljs-keyword">if</span>(data_p != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-type">ug_mem_ent_t</span> * e = (<span class="hljs-type">ug_mem_ent_t</span> *)((<span class="hljs-type">uint8_t</span> *)data_p - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>));        <span class="hljs-keyword">if</span>(e-&gt;header.s.used == <span class="hljs-number">0</span>) &#123;            data_p = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-type">uint32_t</span> old_size = _ug_mem_get_size(data_p);    <span class="hljs-keyword">if</span>(old_size == new_size) <span class="hljs-keyword">return</span> data_p; <span class="hljs-comment">/*Also avoid reallocating the same memory*/</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-comment">/* Truncate the memory if the new size is smaller. */</span>    <span class="hljs-keyword">if</span>(new_size &lt; old_size) &#123;        <span class="hljs-type">ug_mem_ent_t</span> * e = (<span class="hljs-type">ug_mem_ent_t</span> *)((<span class="hljs-type">uint8_t</span> *)data_p - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>));        ent_trunc(e, new_size);        <span class="hljs-keyword">return</span> &amp;e-&gt;first_data;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-type">void</span> * new_p;    new_p = ug_mem_alloc(new_size);    <span class="hljs-keyword">if</span>(new_p == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-comment">//UG_LOG_WARN(&quot;Couldn&#x27;t allocate memory&quot;);</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">if</span>(data_p != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-comment">/*Copy the old data to the new. Use the smaller size*/</span>        <span class="hljs-keyword">if</span>(old_size != <span class="hljs-number">0</span>) &#123;            _ug_memcpy(new_p, data_p, UG_MATH_MIN(new_size, old_size));            ug_mem_free(data_p);        &#125;    &#125;    <span class="hljs-keyword">return</span> new_p;&#125;</code></pre></div><p>内存重申请，通过判断需要重申请的大小与原内存块的大小，如果需要重申请的大小小于原内存块的大小，直接根据需要重申请的大小截断原内存块。如果重申请的大小大于原内存块，则新申请一个大小为重申请的小，并且拷贝原内存块的数据至新的内存块，然后释放原内存块。</p><h2 id="四、源码"><a href="#四、源码" class="headerlink" title="四、源码"></a>四、源码</h2><p>整个动态内存申请的源码如下：</p><h3 id="File-“ug-mem-h”"><a href="#File-“ug-mem-h”" class="headerlink" title="File “ug_mem.h”"></a>File “ug_mem.h”</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UG_MEM_H__</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __UG_MEM_H__</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><span class="hljs-comment">//#include &quot;UVGUI.h&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_type.h&quot;</span></span><span class="hljs-comment">/*********************</span><span class="hljs-comment"> *      DEFINES</span><span class="hljs-comment"> *********************/</span><span class="hljs-comment">//#define UG_TEMPORAL_BUF</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UG_MEM_BUF_MAX_NUM</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UG_MEM_BUF_MAX_NUM    16</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">/**********************</span><span class="hljs-comment"> *      TYPEDEFS</span><span class="hljs-comment"> **********************/</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Heap information structure.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-type">uint32_t</span> total_size; <span class="hljs-comment">/**&lt; Total heap size */</span>    <span class="hljs-type">uint32_t</span> free_cnt;    <span class="hljs-type">uint32_t</span> free_size; <span class="hljs-comment">/**&lt; Size of available memory */</span>    <span class="hljs-type">uint32_t</span> free_biggest_size;    <span class="hljs-type">uint32_t</span> used_cnt;    <span class="hljs-type">uint32_t</span> max_used; <span class="hljs-comment">/**&lt; Max size of Heap memory used */</span>    <span class="hljs-type">uint8_t</span> used_pct; <span class="hljs-comment">/**&lt; Percentage used */</span>    <span class="hljs-type">uint8_t</span> frag_pct; <span class="hljs-comment">/**&lt; Amount of fragmentation */</span>&#125; <span class="hljs-type">ug_mem_monitor_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-type">void</span> * p;    <span class="hljs-type">uint16_t</span> size;    <span class="hljs-type">uint8_t</span> used    : <span class="hljs-number">1</span>;&#125; <span class="hljs-type">ug_mem_buf_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">ug_mem_buf_t</span> <span class="hljs-type">ug_mem_buf_arr_t</span>[UG_MEM_BUF_MAX_NUM];<span class="hljs-keyword">extern</span> <span class="hljs-type">ug_mem_buf_arr_t</span> _ug_mem_buf;<span class="hljs-comment">/**********************</span><span class="hljs-comment"> * GLOBAL PROTOTYPES</span><span class="hljs-comment"> **********************/</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize the dyn_mem module (work memory and other variables)</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_mem_init(<span class="hljs-type">void</span>);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Clean up the memory buffer which frees all the allocated memories.</span><span class="hljs-comment"> * @note It work only if `UG_MEM_CUSTOM == 0`</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_mem_deinit(<span class="hljs-type">void</span>);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Allocate a memory dynamically</span><span class="hljs-comment"> * @param size size of the memory to allocate in bytes</span><span class="hljs-comment"> * @return pointer to the allocated memory</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * <span class="hljs-title function_">ug_mem_alloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Free an allocated data</span><span class="hljs-comment"> * @param data pointer to an allocated memory</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ug_mem_free</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> * data)</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Reallocate a memory with a new size. The old content will be kept.</span><span class="hljs-comment"> * @param data pointer to an allocated memory.</span><span class="hljs-comment"> * Its content will be copied to the new memory block and freed</span><span class="hljs-comment"> * @param new_size the desired new size in byte</span><span class="hljs-comment"> * @return pointer to the new memory</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * <span class="hljs-title function_">ug_mem_realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> * data_p, <span class="hljs-type">size_t</span> new_size)</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Join the adjacent free memory blocks</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ug_mem_defrag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @return</span><span class="hljs-comment"> */</span><span class="hljs-type">ug_res_t</span> <span class="hljs-title function_">ug_mem_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Give information about the work memory of dynamic allocation</span><span class="hljs-comment"> * @param mon_p pointer to a dm_mon_p variable,</span><span class="hljs-comment"> *              the result of the analysis will be stored here</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ug_mem_monitor</span><span class="hljs-params">(<span class="hljs-type">ug_mem_monitor_t</span> * mon_p)</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Give the size of an allocated memory</span><span class="hljs-comment"> * @param data pointer to an allocated memory</span><span class="hljs-comment"> * @return the size of data memory in bytes</span><span class="hljs-comment"> */</span><span class="hljs-type">uint32_t</span> _ug_mem_get_size(<span class="hljs-type">const</span> <span class="hljs-type">void</span> * data);<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_TEMPORAL_BUF</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Get a temporal buffer with the given size.</span><span class="hljs-comment"> * @param size the required size</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_mem_buf_get(<span class="hljs-type">uint32_t</span> size);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Release a memory buffer</span><span class="hljs-comment"> * @param p buffer to release</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_mem_buf_release(<span class="hljs-type">void</span> * p);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Free all memory buffers</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_mem_buf_free_all(<span class="hljs-type">void</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">//! @cond Doxygen_Suppress</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Same as `memcpy` but optimized for 4 byte operation.</span><span class="hljs-comment"> * @param dst pointer to the destination buffer</span><span class="hljs-comment"> * @param src pointer to the source buffer</span><span class="hljs-comment"> * @param len number of byte to copy</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_memcpy(<span class="hljs-type">void</span> * dst, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * src, <span class="hljs-type">size_t</span> len);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Same as `memcpy` but optimized to copy only a few bytes.</span><span class="hljs-comment"> * @param dst pointer to the destination buffer</span><span class="hljs-comment"> * @param src pointer to the source buffer</span><span class="hljs-comment"> * @param len number of byte to copy</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> * _ug_memcpy_small(<span class="hljs-type">void</span> * dst, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * src, <span class="hljs-type">size_t</span> len)&#123;    <span class="hljs-type">uint8_t</span> * d8 = (<span class="hljs-type">uint8_t</span> *)dst;    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> * s8 = (<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *)src;    <span class="hljs-keyword">while</span>(len) &#123;        *d8 = *s8;        d8++;        s8++;        len--;    &#125;    <span class="hljs-keyword">return</span> dst;&#125;<span class="hljs-type">void</span> _ug_memset_00(<span class="hljs-type">void</span> * dst, <span class="hljs-type">size_t</span> len);<span class="hljs-type">void</span> _ug_memset(<span class="hljs-type">void</span> * dst, <span class="hljs-type">uint8_t</span> v, <span class="hljs-type">size_t</span> len);<span class="hljs-type">void</span> * _ug_memcpy(<span class="hljs-type">void</span> * dst, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * src, <span class="hljs-type">size_t</span> len);<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// !__UG_MEM_H__</span></span></code></pre></div><h3 id="File-“ug-mem-c”"><a href="#File-“ug-mem-c”" class="headerlink" title="File “ug_mem.c”"></a>File “ug_mem.c”</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_mem.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_type.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_math.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_draw_blend.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_user_config.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-comment">/**********************</span><span class="hljs-comment"> *      MACROS</span><span class="hljs-comment"> **********************/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> COPY32 *d32 = *s32; d32++; s32++;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> COPY8 *d8 = *s8; d8++; s8++;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET32(x) *d32 = x; d32++;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REPEAT8(expr) expr expr expr expr expr expr expr expr</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALIGN_MASK  0x3</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_ARCH_64</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> MEM_UNIT uint64_t</span><span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> MEM_UNIT uint32_t</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UG_MEM_FULL_DEFRAG_CNT</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> UG_MEM_FULL_DEFRAG_CNT 16</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEM_BUF_SMALL_SIZE 16</span><span class="hljs-comment">/**********************</span><span class="hljs-comment"> *      Typedef</span><span class="hljs-comment"> **********************/</span><span class="hljs-comment">/*The size of this union must be 4 bytes (uint32_t)*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        MEM_UNIT used : <span class="hljs-number">1</span>;    <span class="hljs-comment">/* 1: if the entry is used*/</span>        MEM_UNIT d_size : <span class="hljs-number">31</span>; <span class="hljs-comment">/* Size off the data (in bytes)*/</span>    &#125; s;    MEM_UNIT header; <span class="hljs-comment">/* The header (used + d_size)*/</span>&#125; <span class="hljs-type">ug_mem_header_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-type">ug_mem_header_t</span> header;    <span class="hljs-type">uint8_t</span> first_data; <span class="hljs-comment">/*First data byte in the allocated data (Just for easily create a pointer)*/</span>&#125; <span class="hljs-type">ug_mem_ent_t</span>;<span class="hljs-comment">/**********************</span><span class="hljs-comment"> *  STATIC PROTOTYPES</span><span class="hljs-comment"> **********************/</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-type">static</span> <span class="hljs-type">ug_mem_ent_t</span> * <span class="hljs-title function_">ent_get_next</span><span class="hljs-params">(<span class="hljs-type">ug_mem_ent_t</span> * act_e)</span>;    <span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-title function_">ent_alloc</span><span class="hljs-params">(<span class="hljs-type">ug_mem_ent_t</span> * e, <span class="hljs-type">size_t</span> size)</span>;    <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ent_trunc</span><span class="hljs-params">(<span class="hljs-type">ug_mem_ent_t</span> * e, <span class="hljs-type">size_t</span> size)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">/**********************</span><span class="hljs-comment"> *  STATIC VARIABLES</span><span class="hljs-comment"> **********************/</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> * work_mem;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> mem_max_size; <span class="hljs-comment">/*Tracks the maximum total size of memory ever used from the internal heap*/</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> zero_mem; <span class="hljs-comment">/*Give the address of this variable if 0 byte should be allocated*/</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_TEMPORAL_BUF</span>    <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> mem_buf1_32[MEM_BUF_SMALL_SIZE];    <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> mem_buf2_32[MEM_BUF_SMALL_SIZE];    <span class="hljs-type">static</span> <span class="hljs-type">ug_mem_buf_t</span> mem_buf_small[] = &#123;        &#123;.p = mem_buf1_32, .size = MEM_BUF_SMALL_SIZE, .used = <span class="hljs-number">0</span>&#125;,        &#123;.p = mem_buf2_32, .size = MEM_BUF_SMALL_SIZE, .used = <span class="hljs-number">0</span>&#125;    &#125;;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UG_TEMPORAL_BUF</span></span><span class="hljs-comment">/**********************</span><span class="hljs-comment"> *   GLOBAL FUNCTIONS</span><span class="hljs-comment"> **********************/</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize the dyn_mem module (work memory and other variables)</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_mem_init(<span class="hljs-type">void</span>)&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-comment">/*Allocate a large array to store the dynamically allocated data*/</span>    <span class="hljs-type">static</span> UG_MEM_ATTR MEM_UNIT work_mem_int[UG_MEM_SIZE / <span class="hljs-keyword">sizeof</span>(MEM_UNIT)];    work_mem = (<span class="hljs-type">uint8_t</span> *)work_mem_int;    mem_max_size = <span class="hljs-number">0</span>;    <span class="hljs-type">ug_mem_ent_t</span> * full = (<span class="hljs-type">ug_mem_ent_t</span> *)work_mem;    full-&gt;header.s.used = <span class="hljs-number">0</span>;    <span class="hljs-comment">/*The total mem size id reduced by the first header and the close patterns */</span>    full-&gt;header.s.d_size = UG_MEM_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Clean up the memory buffer which frees all the allocated memories.</span><span class="hljs-comment"> * @note It work only if `UG_MEM_CUSTOM == 0`</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_mem_deinit(<span class="hljs-type">void</span>)&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    _ug_memset_00(work_mem, (UG_MEM_SIZE / <span class="hljs-keyword">sizeof</span>(MEM_UNIT)) * <span class="hljs-keyword">sizeof</span>(MEM_UNIT));    <span class="hljs-type">ug_mem_ent_t</span> * full = (<span class="hljs-type">ug_mem_ent_t</span> *)work_mem;    full-&gt;header.s.used = <span class="hljs-number">0</span>;    <span class="hljs-comment">/*The total mem size id reduced by the first header and the close patterns */</span>    full-&gt;header.s.d_size = UG_MEM_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Allocate a memory dynamically</span><span class="hljs-comment"> * @param size size of the memory to allocate in bytes</span><span class="hljs-comment"> * @return pointer to the allocated memory</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * <span class="hljs-title function_">ug_mem_alloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>&#123;    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> &amp;zero_mem;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_ARCH_64</span>    <span class="hljs-comment">/*Round the size up to 8*/</span>    size = (size + <span class="hljs-number">7</span>) &amp; (~<span class="hljs-number">0x7</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">/*Round the size up to 4*/</span>    size = (size + <span class="hljs-number">3</span>) &amp; (~<span class="hljs-number">0x3</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-type">void</span> * alloc = <span class="hljs-literal">NULL</span>;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-comment">/*Use the built-in allocators*/</span>    <span class="hljs-type">ug_mem_ent_t</span> * e = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/* Search for a appropriate entry*/</span>    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-comment">/* Get the next entry*/</span>        e = ent_get_next(e);        <span class="hljs-comment">/*If there is next entry then try to allocate there*/</span>        <span class="hljs-keyword">if</span>(e != <span class="hljs-literal">NULL</span>) &#123;            alloc = ent_alloc(e, size);        &#125;        <span class="hljs-comment">/* End if there is not next entry OR the alloc. is successful*/</span>    &#125; <span class="hljs-keyword">while</span>(e != <span class="hljs-literal">NULL</span> &amp;&amp; alloc == <span class="hljs-literal">NULL</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span>                <span class="hljs-comment">/* UG_MEM_CUSTOM */</span></span>    <span class="hljs-keyword">if</span>(alloc == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> LOG(&quot;Couldn&#x27;t allocate memory&quot;);</span>    &#125;    <span class="hljs-keyword">else</span> &#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>        <span class="hljs-comment">/* just a safety check, should always be true */</span>        <span class="hljs-keyword">if</span>((<span class="hljs-type">uintptr_t</span>) alloc &gt; (<span class="hljs-type">uintptr_t</span>) work_mem) &#123;            <span class="hljs-keyword">if</span>((((<span class="hljs-type">uintptr_t</span>) alloc - (<span class="hljs-type">uintptr_t</span>) work_mem) + size) &gt; mem_max_size) &#123;                mem_max_size = ((<span class="hljs-type">uintptr_t</span>) alloc - (<span class="hljs-type">uintptr_t</span>) work_mem) + size;            &#125;        &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    &#125;    <span class="hljs-keyword">return</span> alloc;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Free an allocated data</span><span class="hljs-comment"> * @param data pointer to an allocated memory</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ug_mem_free</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> * data)</span>&#123;    <span class="hljs-keyword">if</span>(data == &amp;zero_mem) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(data == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_ADD_JUNK</span>    _ug_memset((<span class="hljs-type">void</span> *)data, <span class="hljs-number">0xbb</span>, _ug_mem_get_size(data));<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_ENABLE_GC == 0</span>    <span class="hljs-comment">/*e points to the header*/</span>    <span class="hljs-type">ug_mem_ent_t</span> * e = (<span class="hljs-type">ug_mem_ent_t</span> *)((<span class="hljs-type">uint8_t</span> *)data - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>));    e-&gt;header.s.used = <span class="hljs-number">0</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_AUTO_DEFRAG</span>    <span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> full_defrag_cnt = <span class="hljs-number">0</span>;    full_defrag_cnt++;    <span class="hljs-keyword">if</span>(full_defrag_cnt &lt; UG_MEM_FULL_DEFRAG_CNT) &#123;        <span class="hljs-comment">/* Make a simple defrag.</span><span class="hljs-comment">         * Join the following free entries after this*/</span>        <span class="hljs-type">ug_mem_ent_t</span> * e_next;        e_next = ent_get_next(e);        <span class="hljs-keyword">while</span>(e_next != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(e_next-&gt;header.s.used == <span class="hljs-number">0</span>) &#123;                e-&gt;header.s.d_size += e_next-&gt;header.s.d_size + <span class="hljs-keyword">sizeof</span>(e-&gt;header);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;            e_next = ent_get_next(e_next);        &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;        full_defrag_cnt = <span class="hljs-number">0</span>;        ug_mem_defrag();    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*UG_MEM_AUTO_DEFRAG*/</span></span><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/*Use custom, user defined free function*/</span></span>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_ENABLE_GC == 0</span>        UG_MEM_CUSTOM_FREE(e);    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>        UG_MEM_CUSTOM_FREE((<span class="hljs-type">void</span> *)data);    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*UG_ENABLE_GC*/</span></span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Reallocate a memory with a new size. The old content will be kept.</span><span class="hljs-comment"> * @param data pointer to an allocated memory.</span><span class="hljs-comment"> * Its content will be copied to the new memory block and freed</span><span class="hljs-comment"> * @param new_size the desired new size in byte</span><span class="hljs-comment"> * @return pointer to the new memory</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_ENABLE_GC == 0</span><span class="hljs-type">void</span> * <span class="hljs-title function_">ug_mem_realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> * data_p, <span class="hljs-type">size_t</span> new_size)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_ARCH_64</span>    <span class="hljs-comment">/*Round the size up to 8*/</span>    new_size = (new_size + <span class="hljs-number">7</span>) &amp; (~<span class="hljs-number">0x7</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">/*Round the size up to 4*/</span>    new_size = (new_size + <span class="hljs-number">3</span>) &amp; (~<span class="hljs-number">0x3</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-comment">/*data_p could be previously freed pointer (in this case it is invalid)*/</span>    <span class="hljs-keyword">if</span>(data_p != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-type">ug_mem_ent_t</span> * e = (<span class="hljs-type">ug_mem_ent_t</span> *)((<span class="hljs-type">uint8_t</span> *)data_p - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>));        <span class="hljs-keyword">if</span>(e-&gt;header.s.used == <span class="hljs-number">0</span>) &#123;            data_p = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-type">uint32_t</span> old_size = _ug_mem_get_size(data_p);    <span class="hljs-keyword">if</span>(old_size == new_size) <span class="hljs-keyword">return</span> data_p; <span class="hljs-comment">/*Also avoid reallocating the same memory*/</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-comment">/* Truncate the memory if the new size is smaller. */</span>    <span class="hljs-keyword">if</span>(new_size &lt; old_size) &#123;        <span class="hljs-type">ug_mem_ent_t</span> * e = (<span class="hljs-type">ug_mem_ent_t</span> *)((<span class="hljs-type">uint8_t</span> *)data_p - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>));        ent_trunc(e, new_size);        <span class="hljs-keyword">return</span> &amp;e-&gt;first_data;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-type">void</span> * new_p;    new_p = ug_mem_alloc(new_size);    <span class="hljs-keyword">if</span>(new_p == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-comment">//UG_LOG_WARN(&quot;Couldn&#x27;t allocate memory&quot;);</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">if</span>(data_p != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-comment">/*Copy the old data to the new. Use the smaller size*/</span>        <span class="hljs-keyword">if</span>(old_size != <span class="hljs-number">0</span>) &#123;            _ug_memcpy(new_p, data_p, UG_MATH_MIN(new_size, old_size));            ug_mem_free(data_p);        &#125;    &#125;    <span class="hljs-keyword">return</span> new_p;&#125;<span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* UG_ENABLE_GC */</span></span><span class="hljs-type">void</span> * <span class="hljs-title function_">ug_mem_realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> * data_p, <span class="hljs-type">size_t</span> new_size)</span>&#123;    <span class="hljs-type">void</span> * new_p = UG_MEM_CUSTOM_REALLOC(data_p, new_size);    <span class="hljs-keyword">if</span>(new_p == <span class="hljs-literal">NULL</span>) UG_LOG_WARN(<span class="hljs-string">&quot;Couldn&#x27;t allocate memory&quot;</span>);    <span class="hljs-keyword">return</span> new_p;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ug_enable_gc */</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Join the adjacent free memory blocks</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ug_mem_defrag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-type">ug_mem_ent_t</span> * e_free;    <span class="hljs-type">ug_mem_ent_t</span> * e_next;    e_free = ent_get_next(<span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">/*Search the next free entry*/</span>        <span class="hljs-keyword">while</span>(e_free != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(e_free-&gt;header.s.used != <span class="hljs-number">0</span>) &#123;                e_free = ent_get_next(e_free);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(e_free == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">/*Joint the following free entries to the free*/</span>        e_next = ent_get_next(e_free);        <span class="hljs-keyword">while</span>(e_next != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(e_next-&gt;header.s.used == <span class="hljs-number">0</span>) &#123;                e_free-&gt;header.s.d_size += e_next-&gt;header.s.d_size + <span class="hljs-keyword">sizeof</span>(e_next-&gt;header);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;            e_next = ent_get_next(e_next);        &#125;        <span class="hljs-keyword">if</span>(e_next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">/*Continue from the lastly checked entry*/</span>        e_free = e_next;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;<span class="hljs-type">ug_res_t</span> <span class="hljs-title function_">ug_mem_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-type">ug_mem_ent_t</span> * e;    e = ent_get_next(<span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">while</span>(e) &#123;        <span class="hljs-keyword">if</span>(e-&gt;header.s.d_size &gt; UG_MEM_SIZE) &#123;            <span class="hljs-keyword">return</span> UG_RES_INV;        &#125;        <span class="hljs-type">uint8_t</span> * e8 = (<span class="hljs-type">uint8_t</span> *) e;        <span class="hljs-keyword">if</span>(e8 + e-&gt;header.s.d_size &gt; work_mem + UG_MEM_SIZE) &#123;            <span class="hljs-keyword">return</span> UG_RES_INV;        &#125;        e = ent_get_next(e);    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-keyword">return</span> UG_RES_OK;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Give information about the work memory of dynamic allocation</span><span class="hljs-comment"> * @param mon_p pointer to a dm_mon_p variable,</span><span class="hljs-comment"> *              the result of the analysis will be stored here</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ug_mem_monitor</span><span class="hljs-params">(<span class="hljs-type">ug_mem_monitor_t</span> * mon_p)</span>&#123;    <span class="hljs-comment">/*Init the data*/</span>    _ug_memset(mon_p, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_monitor_t</span>));<span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span>    <span class="hljs-type">ug_mem_ent_t</span> * e;    e = <span class="hljs-literal">NULL</span>;    e = ent_get_next(e);    <span class="hljs-keyword">while</span>(e != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-keyword">if</span>(e-&gt;header.s.used == <span class="hljs-number">0</span>) &#123;            mon_p-&gt;free_cnt++;            mon_p-&gt;free_size += e-&gt;header.s.d_size;            <span class="hljs-keyword">if</span>(e-&gt;header.s.d_size &gt; mon_p-&gt;free_biggest_size) &#123;                mon_p-&gt;free_biggest_size = e-&gt;header.s.d_size;            &#125;        &#125;        <span class="hljs-keyword">else</span> &#123;            mon_p-&gt;used_cnt++;        &#125;        e = ent_get_next(e);    &#125;    mon_p-&gt;total_size = UG_MEM_SIZE;    mon_p-&gt;max_used = mem_max_size;    mon_p-&gt;used_pct   = <span class="hljs-number">100</span> - (<span class="hljs-number">100U</span> * mon_p-&gt;free_size) / mon_p-&gt;total_size;    <span class="hljs-keyword">if</span>(mon_p-&gt;free_size &gt; <span class="hljs-number">0</span>) &#123;        mon_p-&gt;frag_pct   = (<span class="hljs-type">uint32_t</span>)mon_p-&gt;free_biggest_size * <span class="hljs-number">100U</span> / mon_p-&gt;free_size;        mon_p-&gt;frag_pct   = <span class="hljs-number">100</span> - mon_p-&gt;frag_pct;    &#125;    <span class="hljs-keyword">else</span> &#123;        mon_p-&gt;frag_pct   = <span class="hljs-number">0</span>; <span class="hljs-comment">/*no fragmentation if all the RAM is used*/</span>    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Give the size of an allocated memory</span><span class="hljs-comment"> * @param data pointer to an allocated memory</span><span class="hljs-comment"> * @return the size of data memory in bytes</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_ENABLE_GC == 0</span><span class="hljs-type">uint32_t</span> _ug_mem_get_size(<span class="hljs-type">const</span> <span class="hljs-type">void</span> * data)&#123;    <span class="hljs-keyword">if</span>(data == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(data == &amp;zero_mem) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">ug_mem_ent_t</span> * e = (<span class="hljs-type">ug_mem_ent_t</span> *)((<span class="hljs-type">uint8_t</span> *)data - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>));    <span class="hljs-keyword">return</span> e-&gt;header.s.d_size;&#125;<span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* UG_ENABLE_GC */</span></span><span class="hljs-type">uint32_t</span> _ug_mem_get_size(<span class="hljs-type">const</span> <span class="hljs-type">void</span> * data)&#123;    <span class="hljs-keyword">return</span> UG_MEM_CUSTOM_GET_SIZE(data);&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*UG_ENABLE_GC*/</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_TEMPORAL_BUF</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Get a temporal buffer with the given size.</span><span class="hljs-comment"> * @param size the required size</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_mem_buf_get(<span class="hljs-type">uint32_t</span> size)&#123;    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/*Try small static buffers first*/</span>    <span class="hljs-type">uint8_t</span> i;    <span class="hljs-keyword">if</span>(size &lt;= MEM_BUF_SMALL_SIZE) &#123;        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(mem_buf_small) / <span class="hljs-keyword">sizeof</span>(mem_buf_small[<span class="hljs-number">0</span>]); i++) &#123;            <span class="hljs-keyword">if</span>(mem_buf_small[i].used == <span class="hljs-number">0</span>) &#123;                mem_buf_small[i].used = <span class="hljs-number">1</span>;                <span class="hljs-keyword">return</span> mem_buf_small[i].p;            &#125;        &#125;    &#125;    <span class="hljs-comment">/*Try to find a free buffer with suitable size */</span>    <span class="hljs-type">int8_t</span> i_guess = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; UG_MEM_BUF_MAX_NUM; i++) &#123;        <span class="hljs-keyword">if</span>(UG_GC_ROOT(_ug_mem_buf[i]).used == <span class="hljs-number">0</span> &amp;&amp; UG_GC_ROOT(_ug_mem_buf[i]).size &gt;= size) &#123;            <span class="hljs-keyword">if</span>(UG_GC_ROOT(_ug_mem_buf[i]).size == size) &#123;                UG_GC_ROOT(_ug_mem_buf[i]).used = <span class="hljs-number">1</span>;                <span class="hljs-keyword">return</span> UG_GC_ROOT(_ug_mem_buf[i]).p;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i_guess &lt; <span class="hljs-number">0</span>) &#123;                i_guess = i;            &#125;            <span class="hljs-comment">/*If size of `i` is closer to `size` prefer it*/</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(UG_GC_ROOT(_ug_mem_buf[i]).size &lt; UG_GC_ROOT(_ug_mem_buf[i_guess]).size) &#123;                i_guess = i;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(i_guess &gt;= <span class="hljs-number">0</span>) &#123;        UG_GC_ROOT(_ug_mem_buf[i_guess]).used = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> UG_GC_ROOT(_ug_mem_buf[i_guess]).p;    &#125;    <span class="hljs-comment">/*Reallocate a free buffer*/</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; UG_MEM_BUF_MAX_NUM; i++) &#123;        <span class="hljs-keyword">if</span>(UG_GC_ROOT(_ug_mem_buf[i]).used == <span class="hljs-number">0</span>) &#123;            UG_GC_ROOT(_ug_mem_buf[i]).used = <span class="hljs-number">1</span>;            UG_GC_ROOT(_ug_mem_buf[i]).size = size;            <span class="hljs-comment">/*if this fails you probably need to increase your UG_MEM_SIZE/heap size*/</span>            UG_GC_ROOT(_ug_mem_buf[i]).p = ug_mem_realloc(UG_GC_ROOT(_ug_mem_buf[i]).p, size);            <span class="hljs-keyword">if</span>(UG_GC_ROOT(_ug_mem_buf[i]).p == <span class="hljs-literal">NULL</span>) &#123;                UG_DEBUG_ASSERT(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;Out of memory, can&#x27;t allocate a new  buffer (increase your UG_MEM_SIZE/heap size&quot;</span>, <span class="hljs-number">0x00</span>);            &#125;            <span class="hljs-keyword">return</span>  UG_GC_ROOT(_ug_mem_buf[i]).p;        &#125;    &#125;    UG_DEBUG_ASSERT(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;No free buffer. Increase UG_DRAW_BUF_MAX_NUM.&quot;</span>, <span class="hljs-number">0x00</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Release a memory buffer</span><span class="hljs-comment"> * @param p buffer to release</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_mem_buf_release(<span class="hljs-type">void</span> * p)&#123;    <span class="hljs-type">uint8_t</span> i;    <span class="hljs-comment">/*Try small static buffers first*/</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(mem_buf_small) / <span class="hljs-keyword">sizeof</span>(mem_buf_small[<span class="hljs-number">0</span>]); i++) &#123;        <span class="hljs-keyword">if</span>(mem_buf_small[i].p == p) &#123;            mem_buf_small[i].used = <span class="hljs-number">0</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; UG_MEM_BUF_MAX_NUM; i++) &#123;        <span class="hljs-keyword">if</span>(UG_GC_ROOT(_ug_mem_buf[i]).p == p) &#123;            UG_GC_ROOT(_ug_mem_buf[i]).used = <span class="hljs-number">0</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    UG_LOG_ERROR(<span class="hljs-string">&quot;ug_mem_buf_release: p is not a known buffer&quot;</span>)&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Free all memory buffers</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_mem_buf_free_all(<span class="hljs-type">void</span>)&#123;    <span class="hljs-type">uint8_t</span> i;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(mem_buf_small) / <span class="hljs-keyword">sizeof</span>(mem_buf_small[<span class="hljs-number">0</span>]); i++) &#123;        mem_buf_small[i].used = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; UG_MEM_BUF_MAX_NUM; i++) &#123;        <span class="hljs-keyword">if</span>(UG_GC_ROOT(_ug_mem_buf[i]).p) &#123;            ug_mem_free(UG_GC_ROOT(_ug_mem_buf[i]).p);            UG_GC_ROOT(_ug_mem_buf[i]).p = <span class="hljs-literal">NULL</span>;            UG_GC_ROOT(_ug_mem_buf[i]).used = <span class="hljs-number">0</span>;            UG_GC_ROOT(_ug_mem_buf[i]).size = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Same as `memset` but optimized for 4 byte operation.</span><span class="hljs-comment"> * `dst` should be word aligned else normal `memcpy` will be used</span><span class="hljs-comment"> * @param dst pointer to the destination buffer</span><span class="hljs-comment"> * @param v value to set [0..255]</span><span class="hljs-comment"> * @param len number of byte to set</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_memset(<span class="hljs-type">void</span> * dst, <span class="hljs-type">uint8_t</span> v, <span class="hljs-type">size_t</span> len)&#123;    <span class="hljs-type">uint8_t</span> * d8 = (<span class="hljs-type">uint8_t</span> *) dst;    <span class="hljs-type">uintptr_t</span> d_align = (<span class="hljs-type">ug_uintptr_t</span>) d8 &amp; ALIGN_MASK;    <span class="hljs-comment">/*Make the address aligned*/</span>    <span class="hljs-keyword">if</span>(d_align) &#123;        d_align = ALIGN_MASK + <span class="hljs-number">1</span> - d_align;        <span class="hljs-keyword">while</span>(d_align &amp;&amp; len) &#123;            *d8 = v;            d8++;            len--;            d_align--;        &#125;    &#125;    <span class="hljs-type">uint32_t</span> v32 = v + (v &lt;&lt; <span class="hljs-number">8</span>) + (v &lt;&lt; <span class="hljs-number">16</span>) + (v &lt;&lt; <span class="hljs-number">24</span>);    <span class="hljs-type">uint32_t</span> * d32 = (<span class="hljs-type">uint32_t</span> *)d8;    <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">32</span>) &#123;        SET32(v32);        SET32(v32);        SET32(v32);        SET32(v32);        SET32(v32);        SET32(v32);        SET32(v32);        SET32(v32);        len -= <span class="hljs-number">32</span>;    &#125;    <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">4</span>) &#123;        SET32(v32);        len -= <span class="hljs-number">4</span>;    &#125;    d8 = (<span class="hljs-type">uint8_t</span> *)d32;    <span class="hljs-keyword">while</span>(len) &#123;        *d8 = v;        d8++;        len--;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Same as `memset(dst, 0x00, len)` but optimized for 4 byte operation.</span><span class="hljs-comment"> * `dst` should be word aligned else normal `memcpy` will be used</span><span class="hljs-comment"> * @param dst pointer to the destination buffer</span><span class="hljs-comment"> * @param len number of byte to set</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_memset_00(<span class="hljs-type">void</span> * dst, <span class="hljs-type">size_t</span> len)&#123;    <span class="hljs-type">uint8_t</span> * d8 = (<span class="hljs-type">uint8_t</span> *) dst;    <span class="hljs-type">uintptr_t</span> d_align = (<span class="hljs-type">ug_uintptr_t</span>) d8 &amp; ALIGN_MASK;    <span class="hljs-comment">/*Make the address aligned*/</span>    <span class="hljs-keyword">if</span>(d_align) &#123;        d_align = ALIGN_MASK + <span class="hljs-number">1</span> - d_align;        <span class="hljs-keyword">while</span>(d_align &amp;&amp; len) &#123;            *d8 = <span class="hljs-number">0x00</span>;            d8++;            len--;            d_align--;        &#125;    &#125;    <span class="hljs-type">uint32_t</span> * d32 = (<span class="hljs-type">uint32_t</span> *)d8;    <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">32</span>) &#123;        SET32(<span class="hljs-number">0</span>);        SET32(<span class="hljs-number">0</span>);        SET32(<span class="hljs-number">0</span>);        SET32(<span class="hljs-number">0</span>);        SET32(<span class="hljs-number">0</span>);        SET32(<span class="hljs-number">0</span>);        SET32(<span class="hljs-number">0</span>);        SET32(<span class="hljs-number">0</span>);        len -= <span class="hljs-number">32</span>;    &#125;    <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">4</span>) &#123;        SET32(<span class="hljs-number">0</span>);        len -= <span class="hljs-number">4</span>;    &#125;    d8 = (<span class="hljs-type">uint8_t</span> *)d32;    <span class="hljs-keyword">while</span>(len) &#123;        *d8 = <span class="hljs-number">0</span>;        d8++;        len--;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Same as `memcpy` but optimized for 4 byte operation.</span><span class="hljs-comment"> * @param dst pointer to the destination buffer</span><span class="hljs-comment"> * @param src pointer to the source buffer</span><span class="hljs-comment"> * @param len number of byte to copy</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_memcpy(<span class="hljs-type">void</span> * dst, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * src, <span class="hljs-type">size_t</span> len)&#123;    <span class="hljs-type">uint8_t</span> * d8 = dst;    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> * s8 = src;    <span class="hljs-type">ug_uintptr_t</span> d_align = (<span class="hljs-type">ug_uintptr_t</span>)d8 &amp; ALIGN_MASK;    <span class="hljs-type">ug_uintptr_t</span> s_align = (<span class="hljs-type">ug_uintptr_t</span>)s8 &amp; ALIGN_MASK;    <span class="hljs-comment">/*Byte copy for unaligned memories*/</span>    <span class="hljs-keyword">if</span>(s_align != d_align) &#123;        <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">32</span>) &#123;            REPEAT8(COPY8);            REPEAT8(COPY8);            REPEAT8(COPY8);            REPEAT8(COPY8);            len -= <span class="hljs-number">32</span>;        &#125;        <span class="hljs-keyword">while</span>(len) &#123;            COPY8            len--;        &#125;        <span class="hljs-keyword">return</span> dst;    &#125;    <span class="hljs-comment">/*Make the memories aligned*/</span>    <span class="hljs-keyword">if</span>(d_align) &#123;        d_align = ALIGN_MASK + <span class="hljs-number">1</span> - d_align;        <span class="hljs-keyword">while</span>(d_align &amp;&amp; len) &#123;            COPY8;            d_align--;            len--;        &#125;    &#125;    <span class="hljs-type">uint32_t</span> * d32 = (<span class="hljs-type">uint32_t</span> *)d8;    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> * s32 = (<span class="hljs-type">uint32_t</span> *)s8;    <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">32</span>) &#123;        REPEAT8(COPY32)        len -= <span class="hljs-number">32</span>;    &#125;    <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">4</span>) &#123;        COPY32;        len -= <span class="hljs-number">4</span>;    &#125;    d8 = (<span class="hljs-type">uint8_t</span> *)d32;    s8 = (<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *)s32;    <span class="hljs-keyword">while</span>(len) &#123;        COPY8        len--;    &#125;    <span class="hljs-keyword">return</span> dst;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Same as `memset(dst, 0xFF, len)` but optimized for 4 byte operation.</span><span class="hljs-comment"> * `dst` should be word aligned else normal `memcpy` will be used</span><span class="hljs-comment"> * @param dst pointer to the destination buffer</span><span class="hljs-comment"> * @param len number of byte to set</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_memset_ff(<span class="hljs-type">void</span> * dst, <span class="hljs-type">size_t</span> len)&#123;    <span class="hljs-type">uint8_t</span> * d8 = (<span class="hljs-type">uint8_t</span> *) dst;    <span class="hljs-type">uintptr_t</span> d_align = (<span class="hljs-type">ug_uintptr_t</span>) d8 &amp; ALIGN_MASK;    <span class="hljs-comment">/*Make the address aligned*/</span>    <span class="hljs-keyword">if</span>(d_align) &#123;        d_align = ALIGN_MASK + <span class="hljs-number">1</span> - d_align;        <span class="hljs-keyword">while</span>(d_align &amp;&amp; len) &#123;            *d8 = <span class="hljs-number">0xFF</span>;            d8++;            len--;            d_align--;        &#125;    &#125;    <span class="hljs-type">uint32_t</span> * d32 = (<span class="hljs-type">uint32_t</span> *)d8;    <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">32</span>) &#123;        SET32(<span class="hljs-number">0xFFFFFFFF</span>);        SET32(<span class="hljs-number">0xFFFFFFFF</span>);        SET32(<span class="hljs-number">0xFFFFFFFF</span>);        SET32(<span class="hljs-number">0xFFFFFFFF</span>);        SET32(<span class="hljs-number">0xFFFFFFFF</span>);        SET32(<span class="hljs-number">0xFFFFFFFF</span>);        SET32(<span class="hljs-number">0xFFFFFFFF</span>);        SET32(<span class="hljs-number">0xFFFFFFFF</span>);        len -= <span class="hljs-number">32</span>;    &#125;    <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">4</span>) &#123;        SET32(<span class="hljs-number">0xFFFFFFFF</span>);        len -= <span class="hljs-number">4</span>;    &#125;    d8 = (<span class="hljs-type">uint8_t</span> *)d32;    <span class="hljs-keyword">while</span>(len) &#123;        *d8 = <span class="hljs-number">0xFF</span>;        d8++;        len--;    &#125;&#125;<span class="hljs-comment">/**********************</span><span class="hljs-comment"> *   STATIC FUNCTIONS</span><span class="hljs-comment"> **********************/</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> UG_MEM_CUSTOM == 0</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Give the next entry after &#x27;act_e&#x27;</span><span class="hljs-comment"> * @param act_e pointer to an entry</span><span class="hljs-comment"> * @return pointer to an entry after &#x27;act_e&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ug_mem_ent_t</span> * <span class="hljs-title function_">ent_get_next</span><span class="hljs-params">(<span class="hljs-type">ug_mem_ent_t</span> * act_e)</span>&#123;    <span class="hljs-type">ug_mem_ent_t</span> * next_e = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span>(act_e == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*NULL means: get the first entry*/</span>        next_e = (<span class="hljs-type">ug_mem_ent_t</span> *)work_mem;    &#125;    <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">/*Get the next entry */</span>        <span class="hljs-type">uint8_t</span> * data = &amp;act_e-&gt;first_data;        next_e         = (<span class="hljs-type">ug_mem_ent_t</span> *)&amp;data[act_e-&gt;header.s.d_size];        <span class="hljs-keyword">if</span>(&amp;next_e-&gt;first_data &gt;= &amp;work_mem[UG_MEM_SIZE]) next_e = <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">return</span> next_e;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Try to do the real allocation with a given size</span><span class="hljs-comment"> * @param e try to allocate to this entry</span><span class="hljs-comment"> * @param size size of the new memory in bytes</span><span class="hljs-comment"> * @return pointer to the allocated memory or NULL if not enough memory in the entry</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-title function_">ent_alloc</span><span class="hljs-params">(<span class="hljs-type">ug_mem_ent_t</span> * e, <span class="hljs-type">size_t</span> size)</span>&#123;    <span class="hljs-type">void</span> * alloc = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/*If the memory is free and big enough then use it */</span>    <span class="hljs-keyword">if</span>(e-&gt;header.s.used == <span class="hljs-number">0</span> &amp;&amp; e-&gt;header.s.d_size &gt;= size) &#123;        <span class="hljs-comment">/*Truncate the entry to the desired size */</span>        ent_trunc(e, size);        e-&gt;header.s.used = <span class="hljs-number">1</span>;        <span class="hljs-comment">/*Save the allocated data*/</span>        alloc = &amp;e-&gt;first_data;    &#125;    <span class="hljs-keyword">return</span> alloc;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Truncate the data of entry to the given size</span><span class="hljs-comment"> * @param e Pointer to an entry</span><span class="hljs-comment"> * @param size new size in bytes</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ent_trunc</span><span class="hljs-params">(<span class="hljs-type">ug_mem_ent_t</span> * e, <span class="hljs-type">size_t</span> size)</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UG_ARCH_64</span>    <span class="hljs-comment">/*Round the size up to 8*/</span>    size = (size + <span class="hljs-number">7</span>) &amp; (~<span class="hljs-number">0x7</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">/*Round the size up to 4*/</span>    size = (size + <span class="hljs-number">3</span>) &amp; (~<span class="hljs-number">0x3</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-comment">/*Don&#x27;t let empty space only for a header without data. </span><span class="hljs-comment">      如果分配后只剩仅能保存一个头部的内存，那么就直接全部分配给这个内存块*/</span>    <span class="hljs-keyword">if</span>(e-&gt;header.s.d_size == size + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>)) &#123;        size = e-&gt;header.s.d_size;    &#125;    <span class="hljs-comment">/* Create the new entry after the current if there is space for it */</span>    <span class="hljs-keyword">if</span>(e-&gt;header.s.d_size != size) &#123;        <span class="hljs-type">uint8_t</span> * e_data             = &amp;e-&gt;first_data;        <span class="hljs-type">ug_mem_ent_t</span> * after_new_e   = (<span class="hljs-type">ug_mem_ent_t</span> *)&amp;e_data[size];        after_new_e-&gt;header.s.used   = <span class="hljs-number">0</span>;        after_new_e-&gt;header.s.d_size = (<span class="hljs-type">uint32_t</span>)e-&gt;header.s.d_size - size - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ug_mem_header_t</span>);    &#125;    <span class="hljs-comment">/* Set the new size for the original entry */</span>    e-&gt;header.s.d_size = (<span class="hljs-type">uint32_t</span>)size;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>UVGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UVGUI</tag>
      
      <tag>memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVGUI链表实现原理</title>
    <link href="/2020/10/18/NOTE/ARM/UVGUI/UVGUI%E9%93%BE%E8%A1%A8%E5%8E%9F%E7%90%86/"/>
    <url>/2020/10/18/NOTE/ARM/UVGUI/UVGUI%E9%93%BE%E8%A1%A8%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>@firestaradmin 2020年10月17日22:08:27</p><h1 id="UVGUI-的链表实现原理"><a href="#UVGUI-的链表实现原理" class="headerlink" title="UVGUI 的链表实现原理"></a>UVGUI 的链表实现原理</h1><hr><p>UVGUI的链表是参考LVGL GUI库写的，在此做一下记录。</p><h2 id="一、数据结构分析"><a href="#一、数据结构分析" class="headerlink" title="一、数据结构分析"></a>一、数据结构分析</h2><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/** Dummy type to make handling easier*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint8_t</span> <span class="hljs-type">ug_ll_node_t</span>;<span class="hljs-comment">/** Description of a linked list*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-type">uint32_t</span> n_size;        <span class="hljs-comment">/* node size in bytes */</span>    <span class="hljs-type">ug_ll_node_t</span> * head;    <span class="hljs-type">ug_ll_node_t</span> * tail;&#125; <span class="hljs-type">ug_ll_t</span>;</code></pre></div><p>UVGUI 的链表通过结构体<code>ug_ll_t</code> 表示。</p><p>节点则是<code>typedef uint8_t ug_ll_node_t</code>  定义，这只是虚假类型，只是为了处理时更方便。而实际储存的节点类型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* in fact, the node type is as follows  */</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct _ug_ll_node&#123;</span><span class="hljs-comment">    uint8_t node[node_size];</span><span class="hljs-comment">    ug_ll_node_t * prev;</span><span class="hljs-comment">    ug_ll_node_t * next;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span></code></pre></div><p>UVGUI 的链表使用时，先声明一个链表变量，用于储存链表信息，每创建一个节点，都会申请相应大小的内存块用于储存节点（即链表节点大小是固定的等于节点数据大小）。</p><h2 id="二、初始化"><a href="#二、初始化" class="headerlink" title="二、初始化"></a>二、初始化</h2><p>初始化函数，根据指定的节点大小来初始化一个链表。将链表的头节点指针和尾节点指针设为NULL，然后设置节点大小。</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize linked list</span><span class="hljs-comment"> * @param ll_dsc pointer to ll_dsc variable</span><span class="hljs-comment"> * @param node_size the size of 1 node in bytes</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_init(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">uint32_t</span> node_size)&#123;    ll_p-&gt;head = <span class="hljs-literal">NULL</span>;    ll_p-&gt;tail = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/*Round the size up to 4*/</span>    node_size = (node_size + <span class="hljs-number">3</span>) &amp; (~<span class="hljs-number">0x3</span>);    ll_p-&gt;n_size = node_size;&#125;</code></pre></div><h2 id="三、API"><a href="#三、API" class="headerlink" title="三、API"></a>三、API</h2><h3 id="1-插入节点"><a href="#1-插入节点" class="headerlink" title="1|插入节点"></a>1|插入节点</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Add a new head to a linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the new head</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_ins_head(<span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-type">ug_ll_node_t</span> * n_new;    n_new = ug_mem_alloc(ll_p-&gt;n_size + LL_NODE_META_SIZE);    <span class="hljs-keyword">if</span>(n_new != <span class="hljs-literal">NULL</span>) &#123;        node_set_prev(ll_p, n_new, <span class="hljs-literal">NULL</span>);       <span class="hljs-comment">/*No prev. before the new head*/</span>        node_set_next(ll_p, n_new, ll_p-&gt;head); <span class="hljs-comment">/*After new comes the old head*/</span>        <span class="hljs-keyword">if</span>(ll_p-&gt;head != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is old head then before it goes the new*/</span>            node_set_prev(ll_p, ll_p-&gt;head, n_new);        &#125;        ll_p-&gt;head = n_new;      <span class="hljs-comment">/*Set the new head in the dsc.*/</span>        <span class="hljs-keyword">if</span>(ll_p-&gt;tail == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is no tail (1. node) set the tail too*/</span>            ll_p-&gt;tail = n_new;        &#125;    &#125;    <span class="hljs-keyword">return</span> n_new;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Insert a new node in front of the n_act node</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param n_act pointer a node</span><span class="hljs-comment"> * @return pointer to the new head</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_ins_prev(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">void</span> * n_act)&#123;    <span class="hljs-type">ug_ll_node_t</span> * n_new;    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == ll_p || <span class="hljs-literal">NULL</span> == n_act) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span>(_ug_ll_get_head(ll_p) == n_act) &#123;        n_new = _ug_ll_ins_head(ll_p);        <span class="hljs-keyword">if</span>(n_new == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;        n_new = ug_mem_alloc(ll_p-&gt;n_size + LL_NODE_META_SIZE);        <span class="hljs-keyword">if</span>(n_new == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-type">ug_ll_node_t</span> * n_prev;        n_prev = _ug_ll_get_prev(ll_p, n_act);        node_set_next(ll_p, n_prev, n_new);        node_set_prev(ll_p, n_new, n_prev);        node_set_prev(ll_p, n_act, n_new);        node_set_next(ll_p, n_new, n_act);    &#125;    <span class="hljs-keyword">return</span> n_new;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Add a new tail to a linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the new tail</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_ins_tail(<span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-type">ug_ll_node_t</span> * n_new;    n_new = ug_mem_alloc(ll_p-&gt;n_size + LL_NODE_META_SIZE);    <span class="hljs-keyword">if</span>(n_new != <span class="hljs-literal">NULL</span>) &#123;        node_set_next(ll_p, n_new, <span class="hljs-literal">NULL</span>);       <span class="hljs-comment">/*No next after the new tail*/</span>        node_set_prev(ll_p, n_new, ll_p-&gt;tail); <span class="hljs-comment">/*The prev. before new is the old tail*/</span>        <span class="hljs-keyword">if</span>(ll_p-&gt;tail != <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-comment">/*If there is old tail then the new comes after it*/</span>            node_set_next(ll_p, ll_p-&gt;tail, n_new);        &#125;        ll_p-&gt;tail = n_new;      <span class="hljs-comment">/*Set the new tail in the dsc.*/</span>        <span class="hljs-keyword">if</span>(ll_p-&gt;head == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is no head (1. node) set the head too*/</span>            ll_p-&gt;head = n_new;        &#125;    &#125;    <span class="hljs-keyword">return</span> n_new;&#125;</code></pre></div><p>上述为三个插入节点的函数，插入的位置不同而已。</p><p>其中<code>LL_NODE_META_SIZE</code> 宏定义为两个节点指针的大小，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL_NODE_META_SIZE (sizeof(ug_ll_node_t *) + sizeof(ug_ll_node_t *))</span></code></pre></div><p>其中有两个辅助函数<code>node_set_prev</code> , <code>node_set_next</code>  ，用来设置节点的指针，使其指向相应的节点。定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Set the previous node pointer of a node</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param act pointer to a node which prev. node pointer should be set</span><span class="hljs-comment"> * @param prev pointer to a node which should be the previous node before &#x27;act&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">node_set_prev</span><span class="hljs-params">(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">ug_ll_node_t</span> * act, <span class="hljs-type">ug_ll_node_t</span> * prev)</span>&#123;    <span class="hljs-keyword">if</span>(act == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/*Can&#x27;t set the prev node of `NULL`*/</span>    <span class="hljs-type">uint8_t</span> * act8 = (<span class="hljs-type">uint8_t</span> *) act;    act8 += LL_PREV_P_OFFSET(ll_p);    <span class="hljs-type">ug_ll_node_t</span> ** act_node_p = (<span class="hljs-type">ug_ll_node_t</span> **) act8;    <span class="hljs-type">ug_ll_node_t</span> ** prev_node_p = (<span class="hljs-type">ug_ll_node_t</span> **) &amp;prev;    *act_node_p = *prev_node_p;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Set the &#x27;next node pointer&#x27; of a node</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param act pointer to a node which next node pointer should be set</span><span class="hljs-comment"> * @param next pointer to a node which should be the next node before &#x27;act&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">node_set_next</span><span class="hljs-params">(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">ug_ll_node_t</span> * act, <span class="hljs-type">ug_ll_node_t</span> * next)</span>&#123;    <span class="hljs-keyword">if</span>(act == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/*Can&#x27;t set the next node of `NULL`*/</span>    <span class="hljs-type">uint8_t</span> * act8 = (<span class="hljs-type">uint8_t</span> *) act;    act8 += LL_NEXT_P_OFFSET(ll_p);    <span class="hljs-type">ug_ll_node_t</span> ** act_node_p = (<span class="hljs-type">ug_ll_node_t</span> **) act8;    <span class="hljs-type">ug_ll_node_t</span> ** next_node_p = (<span class="hljs-type">ug_ll_node_t</span> **) &amp;next;    *act_node_p = *next_node_p;&#125;</code></pre></div><p>上述有两个宏定义，是根据节点结构计算指针的位置，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL_PREV_P_OFFSET(ll_p) (ll_p-&gt;n_size)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL_NEXT_P_OFFSET(ll_p) (ll_p-&gt;n_size + sizeof(ug_ll_node_t *))</span></code></pre></div><h3 id="2-删除节点"><a href="#2-删除节点" class="headerlink" title="2|删除节点"></a>2|删除节点</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Remove the node &#x27;node_p&#x27; from &#x27;ll_p&#x27; linked list.</span><span class="hljs-comment"> * It does not free the the memory of node.</span><span class="hljs-comment"> * @param ll_p pointer to the linked list of &#x27;node_p&#x27;</span><span class="hljs-comment"> * @param node_p pointer to node in &#x27;ll_p&#x27; linked list</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_remove(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">void</span> * node_p)&#123;    <span class="hljs-keyword">if</span>(_ug_ll_get_head(ll_p) == node_p) &#123;        <span class="hljs-comment">/*The new head will be the node after &#x27;n_act&#x27;*/</span>        ll_p-&gt;head = _ug_ll_get_next(ll_p, node_p);        <span class="hljs-keyword">if</span>(ll_p-&gt;head == <span class="hljs-literal">NULL</span>) &#123;            ll_p-&gt;tail = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            node_set_prev(ll_p, ll_p-&gt;head, <span class="hljs-literal">NULL</span>);        &#125;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_ug_ll_get_tail(ll_p) == node_p) &#123;        <span class="hljs-comment">/*The new tail will be the  node before &#x27;n_act&#x27;*/</span>        ll_p-&gt;tail = _ug_ll_get_prev(ll_p, node_p);        <span class="hljs-keyword">if</span>(ll_p-&gt;tail == <span class="hljs-literal">NULL</span>) &#123;            ll_p-&gt;head = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            node_set_next(ll_p, ll_p-&gt;tail, <span class="hljs-literal">NULL</span>);        &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">ug_ll_node_t</span> * n_prev = _ug_ll_get_prev(ll_p, node_p);        <span class="hljs-type">ug_ll_node_t</span> * n_next = _ug_ll_get_next(ll_p, node_p);        node_set_next(ll_p, n_prev, n_next);        node_set_prev(ll_p, n_next, n_prev);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Remove and free all elements from a linked list. The list remain valid but become empty.</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_clear(<span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-type">void</span> * i;    <span class="hljs-type">void</span> * i_next;    i      = _ug_ll_get_head(ll_p);    i_next = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span>(i != <span class="hljs-literal">NULL</span>) &#123;        i_next = _ug_ll_get_next(ll_p, i);        _ug_ll_remove(ll_p, i);        ug_mem_free(i);        i = i_next;    &#125;&#125;</code></pre></div><hr><p>其他相关函数请看源码。</p><h2 id="四、源码"><a href="#四、源码" class="headerlink" title="四、源码"></a>四、源码</h2><h3 id="File-“ug-ll-h”"><a href="#File-“ug-ll-h”" class="headerlink" title="File “ug_ll.h”"></a>File “ug_ll.h”</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UG_LL_H__</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __UG_LL_H__</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_type.h&quot;</span></span><span class="hljs-comment">/**********************</span><span class="hljs-comment"> *      MACROS</span><span class="hljs-comment"> **********************/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _UG_LL_READ(list, i) for(i = _ug_ll_get_head(&amp;list); i != NULL; i = _ug_ll_get_next(&amp;list, i))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _UG_LL_READ_BACK(list, i) for(i = _ug_ll_get_tail(&amp;list); i != NULL; i = _ug_ll_get_prev(&amp;list, i))</span><span class="hljs-comment">/** Dummy type to make handling easier*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint8_t</span> <span class="hljs-type">ug_ll_node_t</span>;<span class="hljs-comment">/* in fact, the node type is as follows  */</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct _ug_ll_node&#123;</span><span class="hljs-comment">    uint8_t node[node_size];</span><span class="hljs-comment">    ug_ll_node_t * prev;</span><span class="hljs-comment">    ug_ll_node_t * next;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-comment">/** Description of a linked list*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-type">uint32_t</span> n_size;        <span class="hljs-comment">/* node size in bytes */</span>    <span class="hljs-type">ug_ll_node_t</span> * head;    <span class="hljs-type">ug_ll_node_t</span> * tail;&#125; <span class="hljs-type">ug_ll_t</span>;<span class="hljs-comment">/**********************</span><span class="hljs-comment"> * GLOBAL PROTOTYPES</span><span class="hljs-comment"> **********************/</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize linked list</span><span class="hljs-comment"> * @param ll_dsc pointer to ll_dsc variable</span><span class="hljs-comment"> * @param node_size the size of 1 node in bytes</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_init(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">uint32_t</span> node_size);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Add a new head to a linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the new head</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_ins_head(<span class="hljs-type">ug_ll_t</span> * ll_p);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Insert a new node in front of the n_act node</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param n_act pointer a node</span><span class="hljs-comment"> * @return pointer to the new head</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_ins_prev(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">void</span> * n_act);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Add a new tail to a linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the new tail</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_ins_tail(<span class="hljs-type">ug_ll_t</span> * ll_p);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Remove the node &#x27;node_p&#x27; from &#x27;ll_p&#x27; linked list.</span><span class="hljs-comment"> * It does not free the the memory of node.</span><span class="hljs-comment"> * @param ll_p pointer to the linked list of &#x27;node_p&#x27;</span><span class="hljs-comment"> * @param node_p pointer to node in &#x27;ll_p&#x27; linked list</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_remove(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">void</span> * node_p);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Remove and free all elements from a linked list. The list remain valid but become empty.</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_clear(<span class="hljs-type">ug_ll_t</span> * ll_p);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Move a node to a new linked list</span><span class="hljs-comment"> * @param ll_ori_p pointer to the original (old) linked list</span><span class="hljs-comment"> * @param ll_new_p pointer to the new linked list</span><span class="hljs-comment"> * @param node pointer to a node</span><span class="hljs-comment"> * @param head true: be the head in the new list</span><span class="hljs-comment"> *             false be the head in the new list</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_chg_list(<span class="hljs-type">ug_ll_t</span> * ll_ori_p, <span class="hljs-type">ug_ll_t</span> * ll_new_p, <span class="hljs-type">void</span> * node, <span class="hljs-type">bool</span> head);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return with head node of the linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the head of &#x27;ll_p&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_get_head(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return with tail node of the linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the head of &#x27;ll_p&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_get_tail(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return with the pointer of the next node after &#x27;n_act&#x27;</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param n_act pointer a node</span><span class="hljs-comment"> * @return pointer to the next node</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_get_next(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * n_act);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return with the pointer of the previous node after &#x27;n_act&#x27;</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param n_act pointer a node</span><span class="hljs-comment"> * @return pointer to the previous node</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_get_prev(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * n_act);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return the length of the linked list.</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return length of the linked list</span><span class="hljs-comment"> */</span><span class="hljs-type">uint32_t</span> _ug_ll_get_len(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p);<span class="hljs-comment">/**</span><span class="hljs-comment"> * TODO</span><span class="hljs-comment"> * @param ll_p</span><span class="hljs-comment"> * @param n1_p</span><span class="hljs-comment"> * @param n2_p</span><span class="hljs-comment">void ug_ll_swap(ug_ll_t * ll_p, void * n1_p, void * n2_p);</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Move a node before an other node in the same linked list</span><span class="hljs-comment"> * @param ll_p pointer to a linked list</span><span class="hljs-comment"> * @param n_act pointer to node to move</span><span class="hljs-comment"> * @param n_after pointer to a node which should be after `n_act`</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_move_before(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">void</span> * n_act, <span class="hljs-type">void</span> * n_after);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Check if a linked list is empty</span><span class="hljs-comment"> * @param ll_p pointer to a linked list</span><span class="hljs-comment"> * @return true: the linked list is empty; false: not empty</span><span class="hljs-comment"> */</span><span class="hljs-type">bool</span> _ug_ll_is_empty(<span class="hljs-type">ug_ll_t</span> * ll_p);<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// !__UG_LL_H__</span></span></code></pre></div><h3 id="File-“ug-ll-c”"><a href="#File-“ug-ll-c”" class="headerlink" title="File “ug_ll.c”"></a>File “ug_ll.c”</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_ll.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ug_mem.h&quot;</span></span><span class="hljs-comment">/*********************</span><span class="hljs-comment"> *      DEFINES</span><span class="hljs-comment"> *********************/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL_NODE_META_SIZE (sizeof(ug_ll_node_t *) + sizeof(ug_ll_node_t *))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL_PREV_P_OFFSET(ll_p) (ll_p-&gt;n_size)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL_NEXT_P_OFFSET(ll_p) (ll_p-&gt;n_size + sizeof(ug_ll_node_t *))</span><span class="hljs-comment">/**********************</span><span class="hljs-comment"> *      TYPEDEFS</span><span class="hljs-comment"> **********************/</span><span class="hljs-comment">/**********************</span><span class="hljs-comment"> *  STATIC PROTOTYPES</span><span class="hljs-comment"> **********************/</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">node_set_prev</span><span class="hljs-params">(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">ug_ll_node_t</span> * act, <span class="hljs-type">ug_ll_node_t</span> * prev)</span>;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">node_set_next</span><span class="hljs-params">(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">ug_ll_node_t</span> * act, <span class="hljs-type">ug_ll_node_t</span> * next)</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize linked list</span><span class="hljs-comment"> * @param ll_dsc pointer to ll_dsc variable</span><span class="hljs-comment"> * @param node_size the size of 1 node in bytes</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_init(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">uint32_t</span> node_size)&#123;    ll_p-&gt;head = <span class="hljs-literal">NULL</span>;    ll_p-&gt;tail = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/*Round the size up to 4*/</span>    node_size = (node_size + <span class="hljs-number">3</span>) &amp; (~<span class="hljs-number">0x3</span>);    ll_p-&gt;n_size = node_size;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Add a new head to a linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the new head</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_ins_head(<span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-type">ug_ll_node_t</span> * n_new;    n_new = ug_mem_alloc(ll_p-&gt;n_size + LL_NODE_META_SIZE);    <span class="hljs-keyword">if</span>(n_new != <span class="hljs-literal">NULL</span>) &#123;        node_set_prev(ll_p, n_new, <span class="hljs-literal">NULL</span>);       <span class="hljs-comment">/*No prev. before the new head*/</span>        node_set_next(ll_p, n_new, ll_p-&gt;head); <span class="hljs-comment">/*After new comes the old head*/</span>        <span class="hljs-keyword">if</span>(ll_p-&gt;head != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is old head then before it goes the new*/</span>            node_set_prev(ll_p, ll_p-&gt;head, n_new);        &#125;        ll_p-&gt;head = n_new;      <span class="hljs-comment">/*Set the new head in the dsc.*/</span>        <span class="hljs-keyword">if</span>(ll_p-&gt;tail == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is no tail (1. node) set the tail too*/</span>            ll_p-&gt;tail = n_new;        &#125;    &#125;    <span class="hljs-keyword">return</span> n_new;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Insert a new node in front of the n_act node</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param n_act pointer a node</span><span class="hljs-comment"> * @return pointer to the new head</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_ins_prev(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">void</span> * n_act)&#123;    <span class="hljs-type">ug_ll_node_t</span> * n_new;    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == ll_p || <span class="hljs-literal">NULL</span> == n_act) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span>(_ug_ll_get_head(ll_p) == n_act) &#123;        n_new = _ug_ll_ins_head(ll_p);        <span class="hljs-keyword">if</span>(n_new == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;        n_new = ug_mem_alloc(ll_p-&gt;n_size + LL_NODE_META_SIZE);        <span class="hljs-keyword">if</span>(n_new == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-type">ug_ll_node_t</span> * n_prev;        n_prev = _ug_ll_get_prev(ll_p, n_act);        node_set_next(ll_p, n_prev, n_new);        node_set_prev(ll_p, n_new, n_prev);        node_set_prev(ll_p, n_act, n_new);        node_set_next(ll_p, n_new, n_act);    &#125;    <span class="hljs-keyword">return</span> n_new;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Add a new tail to a linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the new tail</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_ins_tail(<span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-type">ug_ll_node_t</span> * n_new;    n_new = ug_mem_alloc(ll_p-&gt;n_size + LL_NODE_META_SIZE);    <span class="hljs-keyword">if</span>(n_new != <span class="hljs-literal">NULL</span>) &#123;        node_set_next(ll_p, n_new, <span class="hljs-literal">NULL</span>);       <span class="hljs-comment">/*No next after the new tail*/</span>        node_set_prev(ll_p, n_new, ll_p-&gt;tail); <span class="hljs-comment">/*The prev. before new is the old tail*/</span>        <span class="hljs-keyword">if</span>(ll_p-&gt;tail != <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-comment">/*If there is old tail then the new comes after it*/</span>            node_set_next(ll_p, ll_p-&gt;tail, n_new);        &#125;        ll_p-&gt;tail = n_new;      <span class="hljs-comment">/*Set the new tail in the dsc.*/</span>        <span class="hljs-keyword">if</span>(ll_p-&gt;head == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is no head (1. node) set the head too*/</span>            ll_p-&gt;head = n_new;        &#125;    &#125;    <span class="hljs-keyword">return</span> n_new;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Remove the node &#x27;node_p&#x27; from &#x27;ll_p&#x27; linked list.</span><span class="hljs-comment"> * It does not free the the memory of node.</span><span class="hljs-comment"> * @param ll_p pointer to the linked list of &#x27;node_p&#x27;</span><span class="hljs-comment"> * @param node_p pointer to node in &#x27;ll_p&#x27; linked list</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_remove(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">void</span> * node_p)&#123;    <span class="hljs-keyword">if</span>(_ug_ll_get_head(ll_p) == node_p) &#123;        <span class="hljs-comment">/*The new head will be the node after &#x27;n_act&#x27;*/</span>        ll_p-&gt;head = _ug_ll_get_next(ll_p, node_p);        <span class="hljs-keyword">if</span>(ll_p-&gt;head == <span class="hljs-literal">NULL</span>) &#123;            ll_p-&gt;tail = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            node_set_prev(ll_p, ll_p-&gt;head, <span class="hljs-literal">NULL</span>);        &#125;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_ug_ll_get_tail(ll_p) == node_p) &#123;        <span class="hljs-comment">/*The new tail will be the  node before &#x27;n_act&#x27;*/</span>        ll_p-&gt;tail = _ug_ll_get_prev(ll_p, node_p);        <span class="hljs-keyword">if</span>(ll_p-&gt;tail == <span class="hljs-literal">NULL</span>) &#123;            ll_p-&gt;head = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            node_set_next(ll_p, ll_p-&gt;tail, <span class="hljs-literal">NULL</span>);        &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">ug_ll_node_t</span> * n_prev = _ug_ll_get_prev(ll_p, node_p);        <span class="hljs-type">ug_ll_node_t</span> * n_next = _ug_ll_get_next(ll_p, node_p);        node_set_next(ll_p, n_prev, n_next);        node_set_prev(ll_p, n_next, n_prev);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Remove and free all elements from a linked list. The list remain valid but become empty.</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_clear(<span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-type">void</span> * i;    <span class="hljs-type">void</span> * i_next;    i      = _ug_ll_get_head(ll_p);    i_next = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span>(i != <span class="hljs-literal">NULL</span>) &#123;        i_next = _ug_ll_get_next(ll_p, i);        _ug_ll_remove(ll_p, i);        ug_mem_free(i);        i = i_next;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Move a node to a new linked list</span><span class="hljs-comment"> * @param ll_ori_p pointer to the original (old) linked list</span><span class="hljs-comment"> * @param ll_new_p pointer to the new linked list</span><span class="hljs-comment"> * @param node pointer to a node</span><span class="hljs-comment"> * @param head true: be the head in the new list</span><span class="hljs-comment"> *             false be the head in the new list</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_chg_list(<span class="hljs-type">ug_ll_t</span> * ll_ori_p, <span class="hljs-type">ug_ll_t</span> * ll_new_p, <span class="hljs-type">void</span> * node, <span class="hljs-type">bool</span> head)&#123;    _ug_ll_remove(ll_ori_p, node);    <span class="hljs-keyword">if</span>(head) &#123;        <span class="hljs-comment">/*Set node as head*/</span>        node_set_prev(ll_new_p, node, <span class="hljs-literal">NULL</span>);        node_set_next(ll_new_p, node, ll_new_p-&gt;head);        <span class="hljs-keyword">if</span>(ll_new_p-&gt;head != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is old head then before it goes the new*/</span>            node_set_prev(ll_new_p, ll_new_p-&gt;head, node);        &#125;        ll_new_p-&gt;head = node;       <span class="hljs-comment">/*Set the new head in the dsc.*/</span>        <span class="hljs-keyword">if</span>(ll_new_p-&gt;tail == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is no tail (first node) set the tail too*/</span>            ll_new_p-&gt;tail = node;        &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">/*Set node as tail*/</span>        node_set_prev(ll_new_p, node, ll_new_p-&gt;tail);        node_set_next(ll_new_p, node, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">if</span>(ll_new_p-&gt;tail != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is old tail then after it goes the new*/</span>            node_set_next(ll_new_p, ll_new_p-&gt;tail, node);        &#125;        ll_new_p-&gt;tail = node;       <span class="hljs-comment">/*Set the new tail in the dsc.*/</span>        <span class="hljs-keyword">if</span>(ll_new_p-&gt;head == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*If there is no head (first node) set the head too*/</span>            ll_new_p-&gt;head = node;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return with head node of the linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the head of &#x27;ll_p&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_get_head(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-type">void</span> * head = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span>(ll_p != <span class="hljs-literal">NULL</span>) &#123;        head = ll_p-&gt;head;    &#125;    <span class="hljs-keyword">return</span> head;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return with tail node of the linked list</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return pointer to the head of &#x27;ll_p&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_get_tail(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-type">void</span> * tail = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span>(ll_p != <span class="hljs-literal">NULL</span>) &#123;        tail = ll_p-&gt;tail;    &#125;    <span class="hljs-keyword">return</span> tail;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return with the pointer of the next node after &#x27;n_act&#x27;</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param n_act pointer a node</span><span class="hljs-comment"> * @return pointer to the next node</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_get_next(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * n_act)&#123;    <span class="hljs-keyword">if</span>(ll_p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/* Pointer to the next node is stored in the end of this node.</span><span class="hljs-comment">     * Go there and return the address found there */</span>    <span class="hljs-type">const</span> <span class="hljs-type">ug_ll_node_t</span> * n_act_d = n_act;    n_act_d += LL_NEXT_P_OFFSET(ll_p);    <span class="hljs-keyword">return</span> *((<span class="hljs-type">ug_ll_node_t</span> **)n_act_d);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return with the pointer of the previous node after &#x27;n_act&#x27;</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param n_act pointer a node</span><span class="hljs-comment"> * @return pointer to the previous node</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> * _ug_ll_get_prev(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * n_act)&#123;    <span class="hljs-keyword">if</span>(ll_p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/* Pointer to the prev. node is stored in the end of this node.</span><span class="hljs-comment">     * Go there and return the address found there */</span>    <span class="hljs-type">const</span> <span class="hljs-type">ug_ll_node_t</span> * n_act_d = n_act;    n_act_d += LL_PREV_P_OFFSET(ll_p);    <span class="hljs-keyword">return</span> *((<span class="hljs-type">ug_ll_node_t</span> **)n_act_d);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Return the length of the linked list.</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @return length of the linked list</span><span class="hljs-comment"> */</span><span class="hljs-type">uint32_t</span> _ug_ll_get_len(<span class="hljs-type">const</span> <span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-type">uint32_t</span> len = <span class="hljs-number">0</span>;    <span class="hljs-type">void</span> * node;    <span class="hljs-keyword">for</span>(node = _ug_ll_get_head(ll_p); node != <span class="hljs-literal">NULL</span>; node = _ug_ll_get_next(ll_p, node)) &#123;        len++;    &#125;    <span class="hljs-keyword">return</span> len;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Move a node before an other node in the same linked list</span><span class="hljs-comment"> * @param ll_p pointer to a linked list</span><span class="hljs-comment"> * @param n_act pointer to node to move</span><span class="hljs-comment"> * @param n_after pointer to a node which should be after `n_act`</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> _ug_ll_move_before(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">void</span> * n_act, <span class="hljs-type">void</span> * n_after)&#123;    <span class="hljs-keyword">if</span>(n_act == n_after) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/*Can&#x27;t move before itself*/</span>    <span class="hljs-type">void</span> * n_before;    <span class="hljs-keyword">if</span>(n_after != <span class="hljs-literal">NULL</span>)        n_before = _ug_ll_get_prev(ll_p, n_after);    <span class="hljs-keyword">else</span>        n_before = _ug_ll_get_tail(ll_p); <span class="hljs-comment">/*if `n_after` is NULL `n_act` should be the new tail*/</span>    <span class="hljs-keyword">if</span>(n_act == n_before) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/*Already before `n_after`*/</span>    <span class="hljs-comment">/*It&#x27;s much easier to remove from the list and add again*/</span>    _ug_ll_remove(ll_p, n_act);    <span class="hljs-comment">/*Add again by setting the prev. and next nodes*/</span>    node_set_next(ll_p, n_before, n_act);    node_set_prev(ll_p, n_act, n_before);    node_set_prev(ll_p, n_after, n_act);    node_set_next(ll_p, n_act, n_after);    <span class="hljs-comment">/*If `n_act` was moved before NULL then it become the new tail*/</span>    <span class="hljs-keyword">if</span>(n_after == <span class="hljs-literal">NULL</span>) ll_p-&gt;tail = n_act;    <span class="hljs-comment">/*If `n_act` was moved before `NULL` then it&#x27;s the new head*/</span>    <span class="hljs-keyword">if</span>(n_before == <span class="hljs-literal">NULL</span>) ll_p-&gt;head = n_act;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Check if a linked list is empty</span><span class="hljs-comment"> * @param ll_p pointer to a linked list</span><span class="hljs-comment"> * @return true: the linked list is empty; false: not empty</span><span class="hljs-comment"> */</span><span class="hljs-type">bool</span> _ug_ll_is_empty(<span class="hljs-type">ug_ll_t</span> * ll_p)&#123;    <span class="hljs-keyword">if</span>(ll_p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(ll_p-&gt;head == <span class="hljs-literal">NULL</span> &amp;&amp; ll_p-&gt;tail == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">/**********************</span><span class="hljs-comment"> *   STATIC FUNCTIONS</span><span class="hljs-comment"> **********************/</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Set the previous node pointer of a node</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param act pointer to a node which prev. node pointer should be set</span><span class="hljs-comment"> * @param prev pointer to a node which should be the previous node before &#x27;act&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">node_set_prev</span><span class="hljs-params">(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">ug_ll_node_t</span> * act, <span class="hljs-type">ug_ll_node_t</span> * prev)</span>&#123;    <span class="hljs-keyword">if</span>(act == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/*Can&#x27;t set the prev node of `NULL`*/</span>    <span class="hljs-type">uint8_t</span> * act8 = (<span class="hljs-type">uint8_t</span> *) act;    act8 += LL_PREV_P_OFFSET(ll_p);    <span class="hljs-type">ug_ll_node_t</span> ** act_node_p = (<span class="hljs-type">ug_ll_node_t</span> **) act8;    <span class="hljs-type">ug_ll_node_t</span> ** prev_node_p = (<span class="hljs-type">ug_ll_node_t</span> **) &amp;prev;    *act_node_p = *prev_node_p;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Set the &#x27;next node pointer&#x27; of a node</span><span class="hljs-comment"> * @param ll_p pointer to linked list</span><span class="hljs-comment"> * @param act pointer to a node which next node pointer should be set</span><span class="hljs-comment"> * @param next pointer to a node which should be the next node before &#x27;act&#x27;</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">node_set_next</span><span class="hljs-params">(<span class="hljs-type">ug_ll_t</span> * ll_p, <span class="hljs-type">ug_ll_node_t</span> * act, <span class="hljs-type">ug_ll_node_t</span> * next)</span>&#123;    <span class="hljs-keyword">if</span>(act == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/*Can&#x27;t set the next node of `NULL`*/</span>    <span class="hljs-type">uint8_t</span> * act8 = (<span class="hljs-type">uint8_t</span> *) act;    act8 += LL_NEXT_P_OFFSET(ll_p);    <span class="hljs-type">ug_ll_node_t</span> ** act_node_p = (<span class="hljs-type">ug_ll_node_t</span> **) act8;    <span class="hljs-type">ug_ll_node_t</span> ** next_node_p = (<span class="hljs-type">ug_ll_node_t</span> **) &amp;next;    *act_node_p = *next_node_p;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>UVGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UVGUI</tag>
      
      <tag>linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kite_V1.0 [ESP32开发板]</title>
    <link href="/2020/09/18/PROJECT/hardware/Kite_V1/"/>
    <url>/2020/09/18/PROJECT/hardware/Kite_V1/</url>
    
    <content type="html"><![CDATA[<p>项目以开源至GIthub:<a href="https://github.com/firestaradmin/Kite_V1">点我传送</a></p><h1 id="Kite-V1-0-ESP32-WROOM-32D"><a href="#Kite-V1-0-ESP32-WROOM-32D" class="headerlink" title="Kite_V1.0[ESP32-WROOM-32D]"></a>Kite_V1.0[ESP32-WROOM-32D]</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>此开发板是以ESP32-WROOM-32D模组为主体的开发板。</p><p><img src="/2020/09/18/PROJECT/hardware/Kite_V1/image-20200906201651331.png" alt="image-20200906201651331"></p><h3 id="1-资源介绍"><a href="#1-资源介绍" class="headerlink" title="1| 资源介绍"></a>1| 资源介绍</h3><p><strong>ESP32-D0WD 内置双核低功耗 Xtensa ® 32-bit LX6 MCU。片上存储包括：</strong></p><ul><li>448 KB 的 ROM，用于程序启动和内核功能调用</li><li>520 KB 片上 SRAM  用于数据和指令存储 </li><li>4&#x2F;8&#x2F;16MB QSPI-FLASH</li></ul><blockquote><p>ESP32-WROOM-32D 和 ESP32-WROOM-32U 集成了4&#x2F;8&#x2F;16MB QSPI-FLASH，连接 ESP32 的管脚 GPIO6，GPIO7，GPIO8，GPIO9，GPIO10 和 GPIO11。这六个管脚不建议用于其他功能。</p></blockquote><hr><p><strong>Kite_V1.0添加了以下外设资源：</strong></p><ul><li>USB转串口</li><li>0.96inch-IPS-SPI-屏幕</li><li>KEY*3 [RES、IO0、USERKEY0]</li><li>LED*2 [POWER、USERLED0]</li><li>etc..</li></ul><h3 id="2-功能介绍"><a href="#2-功能介绍" class="headerlink" title="2| 功能介绍"></a>2| 功能介绍</h3><ul><li><p>KiteV1.0 具备240MHz双核CPU，同时支持 WIFI&amp;BT 的通信。可以很方便的开发物联网产品。</p></li><li><p>板载0.96inch的ips屏幕，分辨率 80*160. </p></li><li><p>此板为最小系统板，后续会发布一些扩展板，底板，方便更多的应用开发，如：蓝牙音箱</p></li></ul><h3 id="3-引脚引出"><a href="#3-引脚引出" class="headerlink" title="3| 引脚引出"></a>3| 引脚引出</h3><p><img src="/2020/09/18/PROJECT/hardware/Kite_V1/image-20200906202444114.png" alt="image-20200906202444114"></p><h2 id="二、外观"><a href="#二、外观" class="headerlink" title="二、外观"></a>二、外观</h2><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染:"></a>渲染:</h3><p><img src="/2020/09/18/PROJECT/hardware/Kite_V1/image-20200906201651331.png" alt="image-20200906201651331"></p><p><img src="/2020/09/18/PROJECT/hardware/Kite_V1/image-20200906202320206.png" alt="image-20200906202320206"></p><h3 id="实物"><a href="#实物" class="headerlink" title="实物:"></a>实物:</h3><p><img src="/2020/09/18/PROJECT/hardware/Kite_V1/20200916_IMG_0005.JPG" alt="20200916_IMG_0005"></p><p><img src="/2020/09/18/PROJECT/hardware/Kite_V1/20200916_IMG_0006.JPG" alt="20200916_IMG_0006"></p>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
      <category>hardware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>ESP32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArtistV1——艺术家V1 [写字机|绘图仪]</title>
    <link href="/2020/09/18/PROJECT/product/Artist_V1/"/>
    <url>/2020/09/18/PROJECT/product/Artist_V1/</url>
    
    <content type="html"><![CDATA[<h1 id="ArtistV1——艺术家V1"><a href="#ArtistV1——艺术家V1" class="headerlink" title="ArtistV1——艺术家V1"></a>ArtistV1——艺术家V1</h1><p><strong>项目已开源至Github：<a href="https://github.com/firestaradmin/ArtistV1">点我传送</a></strong></p><p><strong>项目演示视频bilibili：<a href="https://www.bilibili.com/video/BV1Li4y1g7Up/">点我传送</a></strong></p><hr><h2 id="一、项目总览"><a href="#一、项目总览" class="headerlink" title="一、项目总览"></a>一、项目总览</h2><h4 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li><strong>本项目基于STM32F1,移植了著名的GRBL——G-code解释器，做的一款写字机（或激光雕刻），使用LVGL的GUI库设计屏幕交互，扩展了SD卡脱机打印功能，板载ESP8266-E12SWIFI模块（由于STM32F1的性能有限，同时兼顾刷屏和G代码解释以及榨干了性能，所以WIFI连接模式暂时未开发），暂时可以通过串口连接电脑使用上位机进行打印，或者使用SD卡脱机打印。</strong></li></ul><p><strong>外观：</strong><br><img src="/2020/09/18/PROJECT/product/Artist_V1/20200812160329425.png" alt="在这里插入图片描述"></p><p><img src="/2020/09/18/PROJECT/product/Artist_V1/20200812151322966.JPG" alt="在这里插入图片描述"><br><img src="/2020/09/18/PROJECT/product/Artist_V1/202008121513437.JPG" alt="在这里插入图片描述"></p><hr><h4 id="硬件介绍："><a href="#硬件介绍：" class="headerlink" title="硬件介绍："></a>硬件介绍：</h4><ul><li>主控    ：STM32F103ZET6</li><li>WIFI    ：ESP8266-E12S</li><li>屏幕    ：3.5寸LCD-16并口RGB16bit-40Pin</li><li>触摸IC：XTP2046电阻触摸</li><li>接口    ：步进电机接口x3、舵机接口x2、12V激光头接口x1、限位开关x3、USBx1、UART-USBx1<br>ETC..</li></ul><p>预览图：</p><p><img src="/2020/09/18/PROJECT/product/Artist_V1/20200812152253547.png" alt="在这里插入图片描述"><br><img src="/2020/09/18/PROJECT/product/Artist_V1/20200812154358239.png" alt="在这里插入图片描述"></p><hr><h4 id="软件控制部分："><a href="#软件控制部分：" class="headerlink" title="软件控制部分："></a>软件控制部分：</h4><ul><li>移植GRBL解释器进行控制机械控制</li><li>使用LittleVGL创建用户交互界面</li><li>FATS文件系统，进行脱机打印</li></ul><p>具体参考我开源的代码吧</p><hr><h4 id="机械结构部分："><a href="#机械结构部分：" class="headerlink" title="机械结构部分："></a>机械结构部分：</h4><ul><li>使用经典巧妙的CoreXY结构，这里扒下来一张图，具体百度看看吧</li><li><img src="/2020/09/18/PROJECT/product/Artist_V1/20200812154210236.png" alt="在这里插入图片描述"><br><img src="/2020/09/18/PROJECT/product/Artist_V1/20200812155642203.png" alt="aa"></li></ul>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
      <category>product</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>STM32</tag>
      
      <tag>product</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HouseKeeperV1.0智能物联家居</title>
    <link href="/2020/09/18/PROJECT/product/HouseKeeper_V1/"/>
    <url>/2020/09/18/PROJECT/product/HouseKeeper_V1/</url>
    
    <content type="html"><![CDATA[<hr><p><em><em>本项目已开源至GitHub：</em><a href="https://github.com/firestaradmin/HouseKeeper_V1">点我传送</a></em>**</p><hr><h1 id="一、HouseKeeperV1-0介绍"><a href="#一、HouseKeeperV1-0介绍" class="headerlink" title="一、HouseKeeperV1.0介绍"></a>一、HouseKeeperV1.0介绍</h1><h3 id="1-项目简介："><a href="#1-项目简介：" class="headerlink" title="1.项目简介："></a>1.项目简介：</h3><ul><li>HouseKeeper_V1.0  是一款智能物联家居产品，它可以根据需求方便的扩展各种家居家电控制，例如门的控制，窗帘的控制，和一些其他家电的控制，只需要简单外接一个继电器便可。本次我们将用指纹门锁控制，来阐述HouseKeeper的功能。<h3 id="2-项目图片外观实例："><a href="#2-项目图片外观实例：" class="headerlink" title="2.项目图片外观实例："></a>2.项目图片外观实例：</h3><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625111921519.png" alt="在这里插入图片描述"><h5 id="·-初步产品图如下"><a href="#·-初步产品图如下" class="headerlink" title="· 初步产品图如下"></a>· 初步产品图如下</h5><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200624210547431.png" alt="在这里插入图片描述"><h5 id="·-指纹门锁实例图"><a href="#·-指纹门锁实例图" class="headerlink" title="· 指纹门锁实例图"></a>· 指纹门锁实例图</h5><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200624210606104.png" alt="在这里插入图片描述"><h3 id="3-项目板载资源及功能介绍："><a href="#3-项目板载资源及功能介绍：" class="headerlink" title="3.项目板载资源及功能介绍："></a>3.项目板载资源及功能介绍：</h3></li><li>本次项目PCB使用STM32F103C8T6作为主控芯片，板载了WIFI和LD3320语音识别芯片。 有板载麦克风，和0.5W的扬声器输出。<br>PCB周边具有舵机接口，指纹模块接口，和将近十个IO扩展，可方便的扩展其他应用。<br>另外Type-C的usb串口供电二合一，很方便产品开发阶段使用。</li></ul><p><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625111241892.png" alt="在这里插入图片描述"></p><ul><li>板载资源：<br>MCU：STM32F103<br>SPI-FLASH：    W25Q64-8MB<br>WIFI：ESP8266EX<br>语音识别： LD3320<br>锂电池电源管理：TP4056<br>等等</li></ul><h1 id="二、HouseKeeperV1-0部分原理图"><a href="#二、HouseKeeperV1-0部分原理图" class="headerlink" title="二、HouseKeeperV1.0部分原理图"></a>二、HouseKeeperV1.0部分原理图</h1><h3 id="1-主控部分："><a href="#1-主控部分：" class="headerlink" title="1.主控部分："></a>1.主控部分：</h3><p><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625111711390.png" alt="在这里插入图片描述"></p><h3 id="2-ESP8266EX-WIFI部分："><a href="#2-ESP8266EX-WIFI部分：" class="headerlink" title="2.ESP8266EX-WIFI部分："></a>2.ESP8266EX-WIFI部分：</h3><p><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625111721341.png" alt="在这里插入图片描述"></p><h3 id="3-LD3320语音识别部分："><a href="#3-LD3320语音识别部分：" class="headerlink" title="3.LD3320语音识别部分："></a>3.LD3320语音识别部分：</h3><p><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625111749710.png" alt="在这里插入图片描述"></p><h1 id="三、基于HouseKeeperV1-0的案例-物联网指纹门锁"><a href="#三、基于HouseKeeperV1-0的案例-物联网指纹门锁" class="headerlink" title="三、基于HouseKeeperV1.0的案例-物联网指纹门锁"></a>三、基于HouseKeeperV1.0的案例-物联网指纹门锁</h1><ul><li>程序会识别指纹id，判断是谁开了门，并且实时更新到云服务器上的数据库中。 QT中可以实时查看到服务器数据库的信息。</li></ul><h3 id="1-基础流程图："><a href="#1-基础流程图：" class="headerlink" title="1.基础流程图："></a>1.基础流程图：</h3><p><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625112031756.png" alt="在这里插入图片描述"></p><h3 id="2-软件部分框架："><a href="#2-软件部分框架：" class="headerlink" title="2.软件部分框架："></a>2.软件部分框架：</h3><ul><li><p>主控程序使用keil编写STM32—C程序</p></li><li><p>WIFI固件，采用arduino编写C++程序</p></li><li><p>服务器后台使用Python编写SOCKET TCP服务程序</p></li><li><p>服务器部署了Mysql数据库用于记录开门信息</p></li><li><p>上位机查看数据库使用QT-C++编写</p><h5 id="1-ESP8266WIFI固件功能："><a href="#1-ESP8266WIFI固件功能：" class="headerlink" title="1.ESP8266WIFI固件功能："></a>1.ESP8266WIFI固件功能：</h5></li><li><p>首先连接指定WIFI，循环检查连接状态 如果接受到了，主控发送来的指纹ID，说明该ID开了门 </p></li><li><p>使用socket连接服务器Serve端。 发送指定格式的JSON数据包，根据ID识别是某位开的门，上传不同的信息</p></li><li><p><strong>JSON数据包格式：”{“opreation”:“close”, “Note”:“firestaradmin”}”</strong></p><h5 id="2-Python服务端功能："><a href="#2-Python服务端功能：" class="headerlink" title="2.Python服务端功能："></a>2.Python服务端功能：</h5></li><li><p>使用socket 建立TCP服务器，等待Client的连接。</p></li><li><p>如果有数据接收到，就进行JSON解析，如果正确，无缺失内容，则和系统时间，一起插入至Mysql数据库。</p></li><li><p>接受客户端发送JSON数据包并解析，解析成功后讲数据插入Mysql数据库</p></li></ul><h3 id="3-实例开发过程的一些图片："><a href="#3-实例开发过程的一些图片：" class="headerlink" title="3.实例开发过程的一些图片："></a>3.实例开发过程的一些图片：</h3><p><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625112757239.png" alt="在这里插入图片描述"></p><p><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625112809446.png" alt="在这里插入图片描述"></p><ul><li>具体演示视频已上传至GitHub项目文件下的report文件夹下，可一起下载后观看</li></ul><h1 id="四、制作过程部分图片"><a href="#四、制作过程部分图片" class="headerlink" title="四、制作过程部分图片"></a>四、制作过程部分图片</h1><p><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625113107640.JPG" alt="在这里插入图片描述"></p><p><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625113147203.JPG" alt="在这里插入图片描述"><br><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625113130479.JPG" alt="在这里插入图片描述"><br><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625113227224.png" alt="在这里插入图片描述"><br><img src="/2020/09/18/PROJECT/product/HouseKeeper_V1/20200625113258221.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
      <category>product</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>STM32</tag>
      
      <tag>product</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ShaoBing_V1 [STM32数字网络温度计]</title>
    <link href="/2020/09/18/PROJECT/product/ShaoBing_V1/"/>
    <url>/2020/09/18/PROJECT/product/ShaoBing_V1/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32数字网络温度计-ShaoBing-No-1"><a href="#STM32数字网络温度计-ShaoBing-No-1" class="headerlink" title="STM32数字网络温度计    ShaoBing-No.1"></a>STM32数字网络温度计    ShaoBing-No.1</h1><p> <em><strong>本项目所有源码文件包括原理图PCB已开源到GitHub上    供大家学习讨论-&gt; <a href="https://github.com/firestaradmin/ShaoBing-No.1">ShaoBing-No.1</a></strong></em><br> <em><strong>视频实况已上传至BiliBili  <a href="https://www.bilibili.com/video/av80249560">点我观看</a></strong></em></p><hr><h2 id="项目概括"><a href="#项目概括" class="headerlink" title="项目概括"></a>项目概括</h2><ul><li><p><strong>项目简介：stm32项目，时间片论询结构，驱动OLED显示温度历史曲线，具备物联网功能发送数据至手机APP，可PI计算输出控制温度方案</strong></p></li><li><p><img src="/2020/09/18/PROJECT/product/ShaoBing_V1/2019121514003442.jpg" alt="在这里插入图片描述"></p></li><li><p><strong>项目起因：</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大学专业课程设计，需设计一款基于DS18B20 的数字温度计</p></li></ul><p>​    </p><ul><li><p><strong>项目要求：</strong></p><ol><li>实现测温范围 -5~125℃，误差+-0.1℃</li><li>实时采集温度数据，并实时显示记录温度曲线</li><li>设置控制的期望值范围，超出范围则声光报警</li></ol></li><li><p><strong>扩展要求：</strong></p><ol start="4"><li>可与计算机进行通讯 ，可上传温度数据</li><li>具有PI控制算法，可计算输出值</li><li>具有物联网功能，将数据传递至服务器，手机显示温度曲线 基于ESP8266-01S</li><li>位式或连续温度调节</li></ol></li><li><p><strong>项目器件：</strong></p><ol><li>STM32F103C8T6 主控芯片*1</li><li>DS18B20 测温*1</li><li>OLED_IIC 屏幕*1</li><li>ESP8266-01S WIFI模块*1</li><li>LED灯</li><li>蜂鸣器</li><li>etc..</li></ol></li></ul><hr><h2 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h2><p>​        </p><h3 id="1-原理图设计"><a href="#1-原理图设计" class="headerlink" title="1. 原理图设计:"></a>1. 原理图设计:</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先进行原理图设计，基于最基础的STM32F103C8T6芯片，将需要用到的元器件模块等等，连接至主控。<br>具体可以参考以下原理图。(如有错误请指正 谢谢)</p><p><img src="/2020/09/18/PROJECT/product/ShaoBing_V1/20191215133941893.png" alt="在这里插入图片描述"></p><h3 id="2-PCB设计："><a href="#2-PCB设计：" class="headerlink" title="2. PCB设计："></a>2. PCB设计：</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将原理图画成PCB文件，并找一个商家发板。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;每次发板子，等待都是漫长的过程。但是还好，嘉立创每月可以发两次5元的板子，算是对学生和工程师的优惠了<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PCB设计如下：(如有错误请指正 谢谢)</p><p><img src="/2020/09/18/PROJECT/product/ShaoBing_V1/20191215135042270.png" alt="在这里插入图片描述"></p><h3 id="3-Code-代码部分"><a href="#3-Code-代码部分" class="headerlink" title="3. Code 代码部分"></a>3. Code 代码部分</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;板子到手后，就急急忙忙的焊完了，通电测试正常后，开始编写程序。</p><ul><li>程序部分分为两块：主控STM32的程序和ESP8266-01S的固件<br>  主控采用Keil编写，ESP采用Arduino编写，因为Arduino的Wifi库真的很好用。</li></ul><h4 id="STM32F103主控部分："><a href="#STM32F103主控部分：" class="headerlink" title="STM32F103主控部分："></a>STM32F103主控部分：</h4><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;主控的思路基本就是，一个循环里做各任务的调用，如按键扫描键值处理，屏幕的动态更新，等等<br>每个任务都是采用Void形式，不返回数值，全部使用全局变量的标志来实现各函数间的通讯信息传递。<br>这样的好处就是不会阻塞程序的运行，使得程序的每一个部分都会被执行到。与RTOS等时间片论相比<br>就有那味儿了！！<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;主控部分我的大部分精力都花在了OLED的刷新速率优化和按键处理上</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;OLED最后采用硬件IIC + DMA 的行为传送，在主控RAM里模拟一个1024B的显存，每次显存有变化则刷新至OLED，以OLED-IIC 400Kpbs的速率下，刷新整屏幕只需要 <em>0.02332s</em> 理论上刷新率可以达到42帧，而采用DMA传输，还不浪费CPU的资源。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;主循环中的进程主要有下面四个</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//while(1)主循环里 顺序执行以下进程，进程基本无阻碍，使用全局变量消息传递机制，可保证实时性。</span>myKey_GetKeyValue();<span class="hljs-comment">//获取键值</span>app_Handle_KeyState();<span class="hljs-comment">//键值处理</span>app_Updata_Interface();<span class="hljs-comment">//界面更新</span>app_Dynamic_Display();<span class="hljs-comment">//动态显示</span></code></pre></div><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;先硬件层上，中断处理按键，是否有按键按下，然后调用</p><div class="hljs code-wrapper"><pre><code class="hljs c">myKey_GetKeyValue();<span class="hljs-comment">//获取键值</span></code></pre></div><p>根据按下的时间更新按键消息。再根据按键消息来执行各个函数功能。<br>具体按键处理机制，可以参考我的另一篇博客   <em><a href="https://blog.csdn.net/yougeng123/article/details/103733592">STM32按键处理机制</a></em></p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之后是界面更新函数进程和动态更新函数进程。<br>界面更新函数进程主要根据当前页面序号与上次页面序号是否相同，来决定是不是要更新界面，具体定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//界面显示</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> </span><span class="hljs-class">&#123;</span>No_Interface = <span class="hljs-number">256</span>,Main_Interface = <span class="hljs-number">0</span>,Menu_Interface = <span class="hljs-number">1</span>,Menu_ENTER_Interface = <span class="hljs-number">2</span>,Input_Interface = <span class="hljs-number">3</span>&#125;Interface_Num_enumTypedef;<span class="hljs-comment">//页面序号定义</span>Interface_Num_enumTypedef now_Interface_Num = No_Interface ; <span class="hljs-comment">//当前的页面序号</span>Interface_Num_enumTypedef next_Interface_Num = Main_Interface;<span class="hljs-comment">//下次需要更新到的页面序号</span></code></pre></div><p>页面静态更新函数：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//静态显示 aka 静态页面更新进程</span><span class="hljs-type">void</span> <span class="hljs-title function_">app_Updata_Interface</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">if</span>(now_Interface_Num != next_Interface_Num)&#123;OLED_RamClear();<span class="hljs-keyword">switch</span> (next_Interface_Num)&#123;<span class="hljs-keyword">case</span> Main_Interface:OLED_ShowBMP(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">127</span>,<span class="hljs-number">63</span>, (u8 *)Interface_Main);now_Interface_Num = Main_Interface;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> Menu_Interface:OLED_ShowBMP(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">127</span>,<span class="hljs-number">63</span>, (u8 *)Interface_Menu);now_Interface_Num = Menu_Interface;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> Menu_ENTER_Interface:OLED_ShowBMP(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">127</span>,<span class="hljs-number">63</span>, (u8 *)MENU_ENTER_INTERFACE);············省略</code></pre></div><p>动态更新每一个主循环进行一次，就会动态更新一次，以便于显示按键动画，温度曲线等动态效果。当处于哪个页面就会更新相应的效果，具体应用具体设计。篇幅过大就不贴出来了。源码已上传至Github</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;那么界面显示最主要的还是OLED的驱动显示，OLED驱动好了，更新速率上去了，动画才会更加流畅。可以参考   <em><a href="https://blog.csdn.net/yougeng123/article/details/103734303"> STM32 DMA-IIC刷新OLED屏(理论可达42+帧率)</a></em></p><h4 id="ESP8266-01S部分："><a href="#ESP8266-01S部分：" class="headerlink" title="ESP8266-01S部分："></a>ESP8266-01S部分：</h4><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ESP的程序相对来说简单了很多，需要做的只是连接WIFI然后串口接受温度数据，并HTTP-POST请求上传数据置服务器即可。（其实可以做的复杂点，就是自己设计一个通讯协议，这样通讯更严谨，但由于时间问题，就草草的设计了简单的通讯，无帧头帧尾和校验位）</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;本来打算加个选择连接WIFI的功能，并且增加软键盘输入密码等功能，但是学期末了，时间不太够了，想想觉得很麻烦，就算了，直接将WIFI名和密码写在了程序里。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ESP的程序编写用到了Arduino的ESP8266的库，网上可以下载到，也可以到我的GitHub上下载。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;思路：先连接WIFI  然后一直循环在串口接收的函数里，判断是否有正确的温度数据被接受，有则POST请求至服务器</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)  &#123;    <span class="hljs-keyword">if</span> (Serial.<span class="hljs-built_in">available</span>() &gt; <span class="hljs-number">0</span>)    &#123;      inByte = Serial.<span class="hljs-built_in">read</span>();      <span class="hljs-comment">//Serial.print(inByte);</span>      <span class="hljs-keyword">if</span> (inByte == <span class="hljs-string">&#x27;[&#x27;</span>)      &#123;        isCommand = <span class="hljs-literal">true</span>;        rxBuffer_tail = <span class="hljs-number">0</span>;        <span class="hljs-comment">//rxBuffer[0] = 0;</span>      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inByte == <span class="hljs-string">&#x27;]&#x27;</span>)      &#123;        isCommand = <span class="hljs-literal">false</span>;        rxBuffer[rxBuffer_tail] = <span class="hljs-string">&#x27;\0&#x27;</span>;        <span class="hljs-keyword">return</span> rxBuffer;      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isCommand)      &#123;        rxBuffer[rxBuffer_tail++] = inByte;      &#125;    &#125;  &#125;&#125;</code></pre></div><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;具体代码已开源至GitHub。</p><p>@firestaradmin</p>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
      <category>product</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>STM32</tag>
      
      <tag>product</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WorldEdit_V1 [双模机械键盘]</title>
    <link href="/2020/09/18/PROJECT/product/WorldEdit_V1/"/>
    <url>/2020/09/18/PROJECT/product/WorldEdit_V1/</url>
    
    <content type="html"><![CDATA[<h1 id="WorldEdit-V1-双模机械键盘"><a href="#WorldEdit-V1-双模机械键盘" class="headerlink" title="WorldEdit_V1 [双模机械键盘]"></a>WorldEdit_V1 [双模机械键盘]</h1><p><em><strong>——创世一号 WorldEdit_1.0</strong></em></p><p><strong>本项目已开源至Github：<a href="https://github.com/firestaradmin/WorldEdit-No.1">点我传送</a></strong></p><p><strong>项目制作全过程视频BiliBili：<a href="https://www.bilibili.com/video/av81005730#reply2225849370">点我传送</a></strong></p><hr><h3 id="项目起因：-“想”"><a href="#项目起因：-“想”" class="headerlink" title="项目起因： “想”"></a>项目起因： “想”</h3><h3 id="项目简介："><a href="#项目简介：" class="headerlink" title="项目简介："></a>项目简介：</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 为什么叫创世一号（WorldEdit）呢？<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 因为想着以后用这把键盘，闯荡天下，制造更多东西，就像一个创世神一样，<br>所以就叫<strong>创世一号WorldEdit</strong>了</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 创世一号采用STM32F103RCT6主控，整合有锂电池充放电管理，稳压，蓝牙串口HID，USB-HID，LED灯阵列驱动，按键检测电路。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 可实现蓝牙连接模式（支持IOS、Android等平台），和USB连接模式。蓝牙连接时响应时间约15ms，USB连接模式主控响应时间约为0.3Ms。</p><p> 靓照如下：<br><img src="/2020/09/18/PROJECT/product/WorldEdit_V1/20200102145259734.png" alt="在这里插入图片描述"></p><h2 id="一、准备材料阶段"><a href="#一、准备材料阶段" class="headerlink" title="一、准备材料阶段"></a>一、准备材料阶段</h2><h4 id="1-键盘配列"><a href="#1-键盘配列" class="headerlink" title="1.键盘配列"></a>1.键盘配列</h4><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 首先做机械键盘，需要了解键盘的配列。制作配列有很多工具可以用，我们在这一步需要把定位板的CAD图生成，用到以下两个网站：<br>配列编辑网站：  <em><a href="http://www.keyboard-layout-editor.com/">http://www.keyboard-layout-editor.com/</a></em><br>定位板CAD生成网站： <em><a href="http://builder.swillkb.com/">http://builder.swillkb.com/</a></em><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 如果要做的配列和我的一样，可以直接使用我的配列CAD文件<br> 我要做的配列如下：（这个网站可以很方便的修改配列，网上教程已经很多了，我就不详细介绍了）<br><img src="/2020/09/18/PROJECT/product/WorldEdit_V1/20200102143220108.png" alt="在这里插入图片描述"><br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 然后将你的配列的Raw data复制到CAD生成网站。生成CAD定位板文件<br> （该文件在画PCB和键盘外壳都需要用到）<br><img src="/2020/09/18/PROJECT/product/WorldEdit_V1/202001021433424.png" alt="在这里插入图片描述"> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 然后底下的这些是和轴体有关的，一般来说默认就行了。<br><img src="/2020/09/18/PROJECT/product/WorldEdit_V1/20200102143600945.png" alt="在这里插入图片描述"><br>点击<br><img src="/2020/09/18/PROJECT/product/WorldEdit_V1/20200102143633257.png" alt="在这里插入图片描述"><br>生成文件，然后点击右上DXF并将文件下载保存。<br><img src="/2020/09/18/PROJECT/product/WorldEdit_V1/20200102143722760.png" alt="在这里插入图片描述"> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 到这里，键盘配列就完成了。然后去网上冲浪 淘一淘 ，   买键帽、蓝牙HID模块、主控啊、一些电容电阻啊、锂电池啊、等等需要用到的东西。</p><h4 id="2-元器件、模块、电池、轴体、键帽等采购"><a href="#2-元器件、模块、电池、轴体、键帽等采购" class="headerlink" title="2. 元器件、模块、电池、轴体、键帽等采购"></a>2. 元器件、模块、电池、轴体、键帽等采购</h4><p> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我的整个键盘需要的物品清单如下：<br><img src="/2020/09/18/PROJECT/product/WorldEdit_V1/20200102144700819.png" alt="在这里插入图片描述"> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 元器件购买完毕后，就可以开始画电路了（不会的可以用我的PCB去加工，我100元做了5张PCB）由于整个项目都已开源，这里就不介绍具体电路了。<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 然后是设计外壳。由于没有加工条件，只能网上订制，所以就简单的设计了一个不包底的钢板做框架。最后成品也还可以。<br> <img src="/2020/09/18/PROJECT/product/WorldEdit_V1/2020010214553562.png" alt="在这里插入图片描述"><br> <img src="/2020/09/18/PROJECT/product/WorldEdit_V1/20200102145621387.png" alt="在这里插入图片描述"></p><h2 id="二、组装调试"><a href="#二、组装调试" class="headerlink" title="二、组装调试"></a>二、组装调试</h2><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 以上都准备完成后，就是焊电路，装轴，上键帽了。具体步骤，可以看我的制作视频。</p><h2 id="三、优化程序代码"><a href="#三、优化程序代码" class="headerlink" title="三、优化程序代码"></a>三、优化程序代码</h2><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代码部分的思路就是检查键盘消息是否更新，更新了就生成按键数据包，然后串口传输给蓝牙模块。如果是USB模式的话就直接USB发送给电脑主机。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;按键物理上如何快速与程序代码链接起来呢，这里有一个思路，如果有更好的方法或建议请留言或私信，谢谢啦。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这里将按键的位置与数组的顺序对应了起来，在后面处理按键消息的时候用起来很方便。</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xxCKmyKeyBoard_ControlKey </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> xxSKmyKeyBoard_SpecialKey </span><span class="hljs-type">const</span> <span class="hljs-type">char</span> * myKeyBoard_KeyMap_Name[<span class="hljs-number">6</span>][<span class="hljs-number">16</span>] = &#123;<span class="hljs-string">&quot;Esc&quot;</span>,<span class="hljs-string">&quot;F1&quot;</span>,<span class="hljs-string">&quot;F2&quot;</span>,<span class="hljs-string">&quot;F3&quot;</span>,<span class="hljs-string">&quot;F4&quot;</span>,<span class="hljs-string">&quot;F5&quot;</span>,<span class="hljs-string">&quot;F6&quot;</span>,<span class="hljs-string">&quot;F7&quot;</span>,<span class="hljs-string">&quot;F8&quot;</span>,<span class="hljs-string">&quot;F9&quot;</span>,<span class="hljs-string">&quot;F10&quot;</span>,<span class="hljs-string">&quot;F11&quot;</span>,<span class="hljs-string">&quot;F12&quot;</span>,<span class="hljs-string">&quot;PrtSc&quot;</span>,<span class="hljs-string">&quot;ScrollLock&quot;</span>,<span class="hljs-string">&quot;PauseBreak&quot;</span>,<span class="hljs-string">&quot;~&quot;</span>,<span class="hljs-string">&quot;!&quot;</span>,<span class="hljs-string">&quot;@&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;$&quot;</span>,<span class="hljs-string">&quot;%&quot;</span>,<span class="hljs-string">&quot;^&quot;</span>,<span class="hljs-string">&quot;&amp;&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;)&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;BackSpace&quot;</span>,<span class="hljs-string">&quot;Insert&quot;</span>,<span class="hljs-string">&quot;Home&quot;</span>,<span class="hljs-string">&quot;Tab&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;W&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;R&quot;</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;Y&quot;</span>,<span class="hljs-string">&quot;U&quot;</span>,<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;P&quot;</span>,<span class="hljs-string">&quot;&#123;&quot;</span>,<span class="hljs-string">&quot;&#125;&quot;</span>,<span class="hljs-string">&quot;|&quot;</span>,<span class="hljs-string">&quot;Delete&quot;</span>,<span class="hljs-string">&quot;End&quot;</span>,<span class="hljs-string">&quot;CapsLock&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>,<span class="hljs-string">&quot;;&quot;</span>,<span class="hljs-string">&quot;&#x27;&quot;</span>,<span class="hljs-string">&quot;Enter&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;PageUp&quot;</span>,<span class="hljs-string">&quot;LShift&quot;</span>,<span class="hljs-string">&quot;Z&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;V&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;N&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;,&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;RShift&quot;</span>,<span class="hljs-string">&quot;Up&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;PageDown&quot;</span>,<span class="hljs-string">&quot;LCtrl&quot;</span>,<span class="hljs-string">&quot;Win&quot;</span>,<span class="hljs-string">&quot;LAlt&quot;</span>,<span class="hljs-string">&quot;Space&quot;</span>,<span class="hljs-string">&quot;RAlt&quot;</span>,<span class="hljs-string">&quot;FN&quot;</span>,<span class="hljs-string">&quot;Menu&quot;</span>,<span class="hljs-string">&quot;RCtrl&quot;</span>,<span class="hljs-string">&quot;Left&quot;</span>,<span class="hljs-string">&quot;Down&quot;</span>,<span class="hljs-string">&quot;Right&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>&#125;;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> myKeyBoard_KeyMap_ATValue[<span class="hljs-number">6</span>][<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">0x29</span>,<span class="hljs-number">0x3A</span>,<span class="hljs-number">0x3B</span>,<span class="hljs-number">0x3C</span>,<span class="hljs-number">0x3D</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x41</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x43</span>,<span class="hljs-number">0x44</span>,<span class="hljs-number">0x45</span>,<span class="hljs-number">0x46</span>,<span class="hljs-number">0x47</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x35</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x21</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">0x23</span>,<span class="hljs-number">0x24</span>,<span class="hljs-number">0x25</span>,<span class="hljs-number">0x26</span>,<span class="hljs-number">0x27</span>,<span class="hljs-number">0x2D</span>,<span class="hljs-number">0x2E</span>,<span class="hljs-number">0x2A</span>,<span class="hljs-number">0x49</span>,<span class="hljs-number">0x4A</span>,<span class="hljs-number">0x2B</span>,<span class="hljs-number">0x14</span>,<span class="hljs-number">0x1A</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x15</span>,<span class="hljs-number">0x17</span>,<span class="hljs-number">0x1C</span>,<span class="hljs-number">0x18</span>,<span class="hljs-number">0x0C</span>,<span class="hljs-number">0x12</span>,<span class="hljs-number">0x13</span>,<span class="hljs-number">0x2F</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0x31</span>,<span class="hljs-number">0x4C</span>,<span class="hljs-number">0x4D</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x16</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x09</span>,<span class="hljs-number">0x0A</span>,<span class="hljs-number">0x0B</span>,<span class="hljs-number">0x0D</span>,<span class="hljs-number">0x0E</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x33</span>,<span class="hljs-number">0x34</span>,<span class="hljs-number">0x28</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x4B</span>,xxCK,<span class="hljs-number">0x1D</span>,<span class="hljs-number">0x1B</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x19</span>,<span class="hljs-number">0x05</span>,<span class="hljs-number">0x11</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x36</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x38</span>,xxCK,<span class="hljs-number">0x52</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x4E</span>,xxCK,xxCK,xxCK,<span class="hljs-number">0x2C</span>,xxCK,xxSK,xxSK,xxCK,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x51</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,&#125;;</code></pre></div><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;main 函数如下：（具体代码已开源至GitHub）</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;sysInit();<span class="hljs-comment">//BTK05_Wake();//唤醒BTK05</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123; <span class="hljs-keyword">if</span>(g_USBModeFlag)<span class="hljs-comment">//USB模式下</span>&#123;<span class="hljs-keyword">if</span>(sleepTime1SCounter &lt;= <span class="hljs-number">1000</span>)&#123;myKeyBoard_ScanKeyAndUpdataATBuffer();<span class="hljs-comment">//键盘事件更新</span><span class="hljs-keyword">if</span>(g_myKeyBoard_DataWaitForUploadFlag == <span class="hljs-number">1</span>)&#123;g_myKeyBoard_DataWaitForUploadFlag = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(bDeviceState == CONFIGURED)<span class="hljs-comment">//如果连接上了 USB</span>Keyboard_Send(BTK05_ATKeyDataPack+<span class="hljs-number">4</span>);GPIO_SetBits(LED_LOGO_GPIOPort,LED_LOGO_GPIOPin);&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(system_Status == <span class="hljs-number">0</span>)&#123;myKeyBoard_ScanKeyAndUpdataATBuffer();<span class="hljs-comment">//键盘事件更新</span><span class="hljs-keyword">if</span>(g_myKeyBoard_DataWaitForUploadFlag == <span class="hljs-number">1</span>)&#123;g_myKeyBoard_DataWaitForUploadFlag = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(bDeviceState == CONFIGURED)<span class="hljs-comment">//如果连接上了 USB</span>Keyboard_Send(BTK05_ATKeyDataPack+<span class="hljs-number">4</span>);GPIO_SetBits(LED_LOGO_GPIOPort,LED_LOGO_GPIOPin);system_Status = <span class="hljs-number">1</span>;TIM_Cmd(TIM2, ENABLE);  <span class="hljs-comment">//使能TIMx</span>sleepTime1SCounter = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(LED_Status)LED_WakeUp();&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sleepTime1SCounter &gt; <span class="hljs-number">1000</span>)&#123;TIM_Cmd(TIM2, DISABLE);  <span class="hljs-comment">//失能TIMx</span>system_Status = <span class="hljs-number">0</span>;LED_GoToSleep();&#125;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//蓝牙模块模式</span>&#123;<span class="hljs-comment">//如果键盘休眠计时器小于400并且键盘处于醒着的状态</span><span class="hljs-keyword">if</span>(sleepTime1SCounter &lt;= <span class="hljs-number">400</span> &amp;&amp; BTK05_Status == BTK_WAKE)&#123;myKeyBoard_ScanKeyAndUpdataATBuffer();<span class="hljs-comment">//键盘事件更新</span><span class="hljs-keyword">if</span>(g_myKeyBoard_DataWaitForUploadFlag == <span class="hljs-number">1</span>)&#123;g_myKeyBoard_DataWaitForUploadFlag = <span class="hljs-number">0</span>;<span class="hljs-comment">//GPIO_ResetBits(LED_LOGO_GPIOPort,LED_LOGO_GPIOPin);</span>BTK05_UART_SendKeyData(BTK05_ATKeyDataPack,<span class="hljs-number">12</span>);sleepTime1SCounter = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ATKeyControlByte5 != <span class="hljs-number">0</span>)&#123;GPIO_SetBits(LED_LOGO_GPIOPort,LED_LOGO_GPIOPin);&#125;<span class="hljs-keyword">else</span>&#123;GPIO_ResetBits(LED_LOGO_GPIOPort,LED_LOGO_GPIOPin);&#125;&#125;&#125;<span class="hljs-comment">//如果蓝牙处于休眠状态</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(BTK05_Status == BTK_SLEEP)&#123;myKeyBoard_ScanKeyAndUpdataATBuffer();<span class="hljs-keyword">if</span>(g_myKeyBoard_DataWaitForUploadFlag == <span class="hljs-number">1</span>)&#123;system_Status = <span class="hljs-number">1</span>;BTK05_Wake();<span class="hljs-comment">//唤醒BTK05</span>TIM_Cmd(TIM2, ENABLE);  <span class="hljs-comment">//使能TIMx</span>sleepTime1SCounter = <span class="hljs-number">0</span>;g_myKeyBoard_DataWaitForUploadFlag = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(LED_Status)LED_WakeUp();BTK05_UART_SendKeyData(BTK05_ATKeyDataPack,<span class="hljs-number">12</span>);&#125;&#125;<span class="hljs-comment">//如果 键盘休眠计时器大于600   即600S没有按下任何按键则然键盘进入休眠状态</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sleepTime1SCounter &gt; <span class="hljs-number">400</span>)&#123;<span class="hljs-comment">//进入休眠模式...</span>BTK05_Sleep();<span class="hljs-comment">//休眠BTK05</span>TIM_Cmd(TIM2, DISABLE);  <span class="hljs-comment">//失能TIMx</span>system_Status = <span class="hljs-number">0</span>;LED_GoToSleep();&#125;&#125;<span class="hljs-keyword">if</span>(LED_BreathEfectFlag &amp;&amp; LED_breath_Flag)&#123;LED_BreathProcess();LED_breath_Flag = <span class="hljs-number">0</span>;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
      <category>product</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>STM32</tag>
      
      <tag>product</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>exArtist_3D打印机</title>
    <link href="/2020/09/18/PROJECT/product/exArtist_3D%E6%89%93%E5%8D%B0%E6%9C%BA/"/>
    <url>/2020/09/18/PROJECT/product/exArtist_3D%E6%89%93%E5%8D%B0%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="exArtist-3D打印机"><a href="#exArtist-3D打印机" class="headerlink" title="exArtist_3D打印机"></a>exArtist_3D打印机</h1><p>开源至Github:<a href="https://github.com/firestaradmin/exArtist_3DPrinter">点我传送</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>exArtist_3D打印机基于arduino主控制作的第二款，Artist系列作品。</p><p>主控用的是arduino官方开发板，软件使用Marlin固件。</p><p>机械部分设计，是使用solidworks设计的。</p><p>此作品为测试，和兴趣。初学建模、单片机，水平有限。</p><h3 id="靓照："><a href="#靓照：" class="headerlink" title="靓照："></a>靓照：</h3><p><img src="/2020/09/18/PROJECT/product/exArtist_3D%E6%89%93%E5%8D%B0%E6%9C%BA/20191115_IMG_9943.JPG" alt="20191115_IMG_9943"></p>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
      <category>product</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>product</tag>
      
      <tag>arduino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>exArtist_写字机</title>
    <link href="/2020/09/18/PROJECT/product/exArtist_%E5%86%99%E5%AD%97%E6%9C%BA/"/>
    <url>/2020/09/18/PROJECT/product/exArtist_%E5%86%99%E5%AD%97%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="exArtist-写字机"><a href="#exArtist-写字机" class="headerlink" title="exArtist_写字机"></a>exArtist_写字机</h1><p>Github:<a href="https://github.com/firestaradmin/exArtist_drawer">点我传送</a></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>exArtist_写字机是我基于arduino主控制作的第一款，Artist系列作品。</p><p>主控用的是arduino官方开发板，G-code解释器是网上开源的grbl。</p><p>机械部分设计，是使用solidworks设计的。</p><p>此作品为测试，和兴趣。初学建模，和单片机，水平有限。</p><h3 id="靓照："><a href="#靓照：" class="headerlink" title="靓照："></a>靓照：</h3><p><img src="/2020/09/18/PROJECT/product/exArtist_%E5%86%99%E5%AD%97%E6%9C%BA/image-20200908003602471.png" alt="image-20200908003602471"></p><p><img src="/2020/09/18/PROJECT/product/exArtist_%E5%86%99%E5%AD%97%E6%9C%BA/20190504_IMG_8107.JPG" alt="20190504_IMG_8107"></p><p><img src="/2020/09/18/PROJECT/product/exArtist_%E5%86%99%E5%AD%97%E6%9C%BA/20190503_IMG_8096.JPG" alt="20190503_IMG_8096"></p>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
      <category>product</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>product</tag>
      
      <tag>arduino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32串口烧录BIN文件、字库文件【QT上位机】</title>
    <link href="/2020/09/16/PROJECT/software/uart_xfer_BIN/"/>
    <url>/2020/09/16/PROJECT/software/uart_xfer_BIN/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32串口烧录BIN文件、字库文件【QT上位机】"><a href="#STM32串口烧录BIN文件、字库文件【QT上位机】" class="headerlink" title="STM32串口烧录BIN文件、字库文件【QT上位机】"></a>STM32串口烧录BIN文件、字库文件【QT上位机】</h1><p><strong>项目已开源至GitHub，供大家一起学习使用 <a href="https://github.com/firestaradmin/Uart_Transfer_BIN_to_exFlash"><em>点我传送</em></a></strong></p><h2 id="一-上位机部分"><a href="#一-上位机部分" class="headerlink" title="一.上位机部分"></a>一.上位机部分</h2><ul><li>使用QT-C++ 编写的上位机    预览图如下<br><img src="/2020/09/16/PROJECT/software/uart_xfer_BIN/20200722123313745.png" alt="在这里插入图片描述"></li><li>程序思路：<br>   使用串口通讯进行发送规定的帧数据，上位机会将BIN文件数据分析打包成每一帧传送给下位机。<br>下位机，接受到数据后，进行ACK应答，程序接受到应答后，继续发送数据，直至完成发送。<h3 id="1-帧协议格式："><a href="#1-帧协议格式：" class="headerlink" title="1.帧协议格式："></a>1.帧协议格式：</h3><img src="/2020/09/16/PROJECT/software/uart_xfer_BIN/20200722123934499.png" alt="在这里插入图片描述"><br><img src="/2020/09/16/PROJECT/software/uart_xfer_BIN/20200722123946578.png" alt="在这里插入图片描述"></li></ul><p>如发送数据：<strong>C5 5C 00 00 04 22 33 44 FF AE 5C C5</strong><br>BCC &#x3D; 除了帧头帧尾和bcc本身的异或<br>BCC &#x3D; 00 ^ 00 ^ 04 ^ 22 ^ 33 ^ 44 ^ FF &#x3D; AE</p><h3 id="2-QT部分程序"><a href="#2-QT部分程序" class="headerlink" title="2.QT部分程序"></a>2.QT部分程序</h3><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//将串口的 readyread 信号绑定到 read_com 这个槽函数上</span><span class="hljs-built_in">connect</span>(&amp;mySerial,<span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">readyRead</span>()),<span class="hljs-keyword">this</span>,<span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">read_COM</span>()));</code></pre></div><p>此处读取到下位机的ACK应答后，触发自定义信号[readOK]，再进行下一步发送</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::read_COM</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    QByteArray mytemp = mySerial.<span class="hljs-built_in">readAll</span>();    <span class="hljs-keyword">if</span>(!mytemp.<span class="hljs-built_in">isEmpty</span>())    &#123;        <span class="hljs-comment">//qDebug() &lt;&lt; mytemp.toHex();</span>        <span class="hljs-keyword">if</span>((mytemp.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xff</span>) != <span class="hljs-number">0xC5</span>)            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>((mytemp.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xff</span>) != <span class="hljs-number">0x5C</span>)            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>((mytemp.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>) &amp; <span class="hljs-number">0xff</span>) == <span class="hljs-number">0x00</span>)&#123;            ui-&gt;textEdit_Log-&gt;<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;send Data OK!&quot;</span>);            sendedBytes += currentLen;            unSendedBytes = file_length - sendedBytes;            <span class="hljs-keyword">if</span>(unSendedBytes &lt; <span class="hljs-number">0</span>)                unSendedBytes = <span class="hljs-number">0</span>;            ui-&gt;label_sendedBytes-&gt;<span class="hljs-built_in">setNum</span>(sendedBytes);            ui-&gt;label_unSendedBytes-&gt;<span class="hljs-built_in">setNum</span>(unSendedBytes);            ui-&gt;progressBar-&gt;<span class="hljs-built_in">setValue</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;((<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(sendedBytes) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(file_length)) * <span class="hljs-number">100</span>));            <span class="hljs-keyword">if</span>(unSendedBytes &gt; <span class="hljs-number">0</span>)&#123;                <span class="hljs-built_in">emit</span>(<span class="hljs-built_in">recvOK</span>());            &#125;<span class="hljs-keyword">else</span> &#123;                ui-&gt;textEdit_Log-&gt;<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;all data send over!&quot;</span>);                ui-&gt;pushButton_StartSending-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">true</span>);            &#125;        &#125;        <span class="hljs-keyword">else</span> &#123;            ui-&gt;pushButton_StartSending-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">true</span>);            ui-&gt;textEdit_Log-&gt;<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;send Data failed!&quot;</span>);            ui-&gt;textEdit_Log-&gt;<span class="hljs-built_in">append</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;ERROR:%1&quot;</span>).<span class="hljs-built_in">arg</span>(mytemp.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>) &amp; <span class="hljs-number">0xff</span>));        &#125;        <span class="hljs-comment">//mytemp.clear();</span>    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//将自定义的信号和发送函数连接</span><span class="hljs-built_in">connect</span>(<span class="hljs-keyword">this</span>, &amp;MainWindow::recvOK, <span class="hljs-keyword">this</span>, &amp;MainWindow::sendOnce);</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::sendOnce</span><span class="hljs-params">()</span></span>&#123;    QByteArray sendBuf, dataBuf;    <span class="hljs-type">char</span> file_length0,file_length1;    QString str;    <span class="hljs-type">char</span> bcc = <span class="hljs-number">0x00</span>;    <span class="hljs-keyword">if</span>(unSendedBytes &gt;= ui-&gt;lineEdit_ByteNum-&gt;<span class="hljs-built_in">text</span>().<span class="hljs-built_in">toInt</span>())&#123;        dataBuf = file_array.<span class="hljs-built_in">mid</span>(sendedBytes, ui-&gt;lineEdit_ByteNum-&gt;<span class="hljs-built_in">text</span>().<span class="hljs-built_in">toInt</span>());        currentLen = ui-&gt;lineEdit_ByteNum-&gt;<span class="hljs-built_in">text</span>().<span class="hljs-built_in">toInt</span>();     &#125;    <span class="hljs-keyword">else</span> &#123;        dataBuf = file_array.<span class="hljs-built_in">mid</span>(sendedBytes, unSendedBytes);        currentLen = unSendedBytes;    &#125;    <span class="hljs-comment">//qDebug() &lt;&lt; dataBuf.size();</span>    sendBuf.<span class="hljs-built_in">clear</span>();    sendBuf.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\xC5\x5C&quot;</span>);    sendBuf.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-number">0</span>));    file_length0 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(currentLen / <span class="hljs-number">0xFF</span>);    file_length1 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(currentLen % <span class="hljs-number">0xFF</span>);    sendBuf.<span class="hljs-built_in">append</span>(file_length0);    sendBuf.<span class="hljs-built_in">append</span>(file_length1);    <span class="hljs-comment">//qDebug() &lt;&lt; sendBuf.toHex().toUpper();</span>    sendBuf.<span class="hljs-built_in">append</span>(dataBuf);    <span class="hljs-comment">//qDebug() &lt;&lt; sendBuf.toHex().toUpper();</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; sendBuf.<span class="hljs-built_in">size</span>(); i++)&#123;        <span class="hljs-comment">//str.append((QString(&quot;%1  &quot;).arg(file_array.at(i) &amp; 0xff, 2, 16, QLatin1Char(&#x27;0&#x27;)).toUpper()));</span>        bcc ^= sendBuf.<span class="hljs-built_in">at</span>(i) &amp; <span class="hljs-number">0xff</span>;    &#125;    sendBuf.<span class="hljs-built_in">append</span>(bcc);    sendBuf.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\x5C\xC5&quot;</span>);    <span class="hljs-comment">//qDebug() &lt;&lt; sendBuf.toHex().toUpper();</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &lt; sendBuf.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>; i++)&#123;        str.<span class="hljs-built_in">append</span>((<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;%1  &quot;</span>).<span class="hljs-built_in">arg</span>(sendBuf.<span class="hljs-built_in">at</span>(i) &amp; <span class="hljs-number">0xff</span>, <span class="hljs-number">2</span>, <span class="hljs-number">16</span>, <span class="hljs-built_in">QLatin1Char</span>(<span class="hljs-string">&#x27;0&#x27;</span>)).<span class="hljs-built_in">toUpper</span>()));    &#125;    ui-&gt;textEdit_Status-&gt;<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;---------------------------------------&quot;</span>);    ui-&gt;textEdit_Status-&gt;<span class="hljs-built_in">append</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;地址[ %1 ] to [ %2 ] 的数据：&quot;</span>).<span class="hljs-built_in">arg</span>(sendedBytes).<span class="hljs-built_in">arg</span>(sendedBytes + currentLen - <span class="hljs-number">1</span>));    ui-&gt;textEdit_Status-&gt;<span class="hljs-built_in">append</span>(str);    ui-&gt;textEdit_Status-&gt;<span class="hljs-built_in">append</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;---  BCC校验码: %1  ---&quot;</span>).<span class="hljs-built_in">arg</span>(bcc &amp; <span class="hljs-number">0xff</span>, <span class="hljs-number">2</span>, <span class="hljs-number">16</span>, <span class="hljs-built_in">QLatin1Char</span>(<span class="hljs-string">&#x27;0&#x27;</span>)).<span class="hljs-built_in">toUpper</span>());    ui-&gt;textEdit_Log-&gt;<span class="hljs-built_in">append</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;send [ %1 ] to [ %2 ] Data ...&quot;</span>).<span class="hljs-built_in">arg</span>(sendedBytes).<span class="hljs-built_in">arg</span>(sendedBytes + currentLen - <span class="hljs-number">1</span>));    mySerial.<span class="hljs-built_in">write</span>(sendBuf);&#125;</code></pre></div><h2 id="二-下位机部分"><a href="#二-下位机部分" class="headerlink" title="二.下位机部分"></a>二.下位机部分</h2><h3 id="1-接收与处理"><a href="#1-接收与处理" class="headerlink" title="1.接收与处理"></a>1.接收与处理</h3><p>上位机将BIN文件分成若干可设置数据长度的帧数据，以帧的形式串口发送给下位机，下位机接收帧，检验帧头帧尾和BCC校验码，如果正确无误，将数据烧写至外部储存器，烧写完成后，发送应答给上位机。上位机发送一帧数据后，会等待下位机的应答，接收到应答后，再继续发送下一帧数据，直至全部发送完成。</p><h3 id="2-ACK应答帧格式"><a href="#2-ACK应答帧格式" class="headerlink" title="2.ACK应答帧格式"></a>2.ACK应答帧格式</h3><p><img src="/2020/09/16/PROJECT/software/uart_xfer_BIN/20200722124646551.png" alt="在这里插入图片描述"></p><h3 id="3-下位机通用C-代码（Lib）"><a href="#3-下位机通用C-代码（Lib）" class="headerlink" title="3.下位机通用C++代码（Lib）"></a>3.下位机通用C++代码（Lib）</h3><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//&quot;transfer_BIN_to_EX_FLASH.h&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __transfer_BIN_to_EX_FLASH</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __transfer_BIN_to_EX_FLASH</span><span class="hljs-keyword">extern</span> u8 TBEF_uart_recv_finish , TBEF_uart_recving_flag , rTBEF_uart_recv_tim_cnt;<span class="hljs-comment">//extern u8 TBEF_recvBuf[400];</span><span class="hljs-comment">//extern u16 TBEF_recvBuf_tail;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_uart_receive_process</span><span class="hljs-params">(u8 data)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_tim_process</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_SendACK</span><span class="hljs-params">(u8 ERROR)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_clearRecvBuf</span><span class="hljs-params">()</span></span>;<span class="hljs-function">u8 <span class="hljs-title">TBEF_framePrasing</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_mainFun</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_data_CallBack</span><span class="hljs-params">(u8 *dataBuf, u16 len)</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/************************************************************************************</span><span class="hljs-comment">*  Copyright (c), 2020, LXG.</span><span class="hljs-comment">*</span><span class="hljs-comment">* FileName:</span><span class="hljs-comment">* Author:firestaradmin</span><span class="hljs-comment">* Version:1.0</span><span class="hljs-comment">* Date:2020.7.21</span><span class="hljs-comment">* Description:串口接收BIN文件数据烧录至外部储存器</span><span class="hljs-comment">* History:</span><span class="hljs-comment">*</span><span class="hljs-comment">*</span><span class="hljs-comment">*************************************************************************************</span><span class="hljs-comment">帧协议格式:</span><span class="hljs-comment">Byte0Byte1Byte2Byte3Byte4Byte5…last but two Bytelast but one ByteLast Byte</span><span class="hljs-comment">0xC50x5CXXXXXXXXXXXX0x5C0xC5</span><span class="hljs-comment">帧头帧头命令长度高字节长度低字节数据数据BCC校验码帧尾帧尾</span><span class="hljs-comment"></span><span class="hljs-comment">如发送数据：C5 5C 00 00 04 22 33 44 FF AE 5C C5</span><span class="hljs-comment">BCC = 除了帧头帧尾和bcc本身的异或</span><span class="hljs-comment">BCC = 00 ^ 00 ^ 04 ^ 22 ^ 33 ^ 44 ^ FF = AE</span><span class="hljs-comment"></span><span class="hljs-comment">命令:0x000x010x020xFF</span><span class="hljs-comment">备注:数据数据传输开始数据传输结束应答</span><span class="hljs-comment"></span><span class="hljs-comment">*************************************************************************************/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../bsp/transfer_BIN_to_EX_FLASH/transfer_BIN_to_EX_FLASH.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../bsp/w25qxx/w25qxx.h&quot;</span> </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../BSP/usart/usart.h&quot;</span></span><span class="hljs-comment">//W25Q64</span><span class="hljs-comment">//容量为8M字节,共有128个Block,2048个Sector </span><span class="hljs-comment">//4Kbytes为一个Sector</span><span class="hljs-comment">//16个扇区为1个Block</span><span class="hljs-comment">//以下表示地址为W25QXX的第一个区块的第0个扇区的第0个地址</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25QXX_STORAGE_Block1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25QXX_STORAGE_Sector0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25QXX_STORAGE_Sector_OFFSET0</span>u32 TBEF_W25QXX_StorageAddress = W25QXX_STORAGE_Block * <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">16</span> + <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * W25QXX_STORAGE_Sector + W25QXX_STORAGE_Sector_OFFSET;<span class="hljs-comment">//要烧录的具体地址</span>u32 bytesStored = <span class="hljs-number">0</span>;<span class="hljs-comment">//已经储存的字节</span>u8 TBEF_recvBuf[<span class="hljs-number">1000</span>];<span class="hljs-comment">//接受buf，最大单次传输字节数应不大于buf大小-8</span>u16 TBEF_recvBuf_tail = <span class="hljs-number">0</span>;u8 TBEF_uart_recv_finish = <span class="hljs-number">0</span>, TBEF_uart_recving_flag = <span class="hljs-number">0</span>, TBEF_uart_recv_tim_cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//用户回调函数，此处修改需要烧录的函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_data_CallBack</span><span class="hljs-params">(u8 *dataBuf, u16 len)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//根据需求修改此处</span><span class="hljs-built_in">W25QXX_Write</span>(dataBuf, TBEF_W25QXX_StorageAddress + bytesStored, len);<span class="hljs-comment">//写入flash</span>bytesStored += len;&#125;<span class="hljs-comment">//串口处理函数，在串口中断中调用，将接收到的字节传入data</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_uart_receive_process</span><span class="hljs-params">(u8 data)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">if</span>(TBEF_uart_recv_finish == <span class="hljs-number">0</span>)&#123;TBEF_recvBuf[TBEF_recvBuf_tail++] = data;<span class="hljs-comment">// 存入缓存数组</span>TBEF_uart_recving_flag = <span class="hljs-number">1</span>;                     <span class="hljs-comment">// 串口 接收标志</span>TBEF_uart_recv_tim_cnt = <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 串口接收定时器计数清零</span>&#125;<span class="hljs-keyword">if</span>(TBEF_recvBuf_tail &gt;= <span class="hljs-built_in">sizeof</span>(TBEF_recvBuf))&#123; TBEF_recvBuf_tail = <span class="hljs-number">0</span>;                               <span class="hljs-comment">// 防止数据量过大</span>&#125;&#125;<span class="hljs-comment">//定时器处理函数，在定时器中断中调用，1Ms一次</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_tim_process</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//1MS调用一次</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/* 串口接收完成判断处理 */</span><span class="hljs-keyword">if</span>(TBEF_uart_recving_flag)                        <span class="hljs-comment">// 如果 usart接收数据标志为1</span>&#123;TBEF_uart_recv_tim_cnt++;             <span class="hljs-comment">// usart 接收计数</span><span class="hljs-keyword">if</span>(TBEF_uart_recv_tim_cnt &gt; <span class="hljs-number">10</span>)       <span class="hljs-comment">// 当超过 3 ms 未接收到数据，则认为数据接收完成。</span>&#123;TBEF_uart_recv_finish = <span class="hljs-number">1</span>;TBEF_uart_recving_flag = <span class="hljs-number">0</span>;TBEF_uart_recv_tim_cnt = <span class="hljs-number">0</span>;&#125;&#125;&#125;<span class="hljs-comment">//在主函数中调用，需要一直循环调用，此函数为阻塞函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_mainFun</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;u8 ret = <span class="hljs-built_in">TBEF_framePrasing</span>();TBEF_recvBuf_tail = <span class="hljs-number">0</span>;TBEF_uart_recv_finish = <span class="hljs-number">0</span>;<span class="hljs-built_in">TBEF_SendACK</span>(ret);&#125;<span class="hljs-function">u8 <span class="hljs-title">TBEF_framePrasing</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;u16 length = <span class="hljs-number">0</span>;u8 cmd = <span class="hljs-number">0</span>;u8 bcc = <span class="hljs-number">0x00</span>;<span class="hljs-keyword">while</span>(TBEF_uart_recv_finish != <span class="hljs-number">1</span>);<span class="hljs-comment">//wait receive finish</span><span class="hljs-keyword">if</span>(TBEF_recvBuf[<span class="hljs-number">0</span>] != <span class="hljs-number">0xC5</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//帧头错误</span><span class="hljs-keyword">if</span>(TBEF_recvBuf[<span class="hljs-number">1</span>] != <span class="hljs-number">0x5C</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//帧头错误</span>cmd = TBEF_recvBuf[<span class="hljs-number">2</span>];length = TBEF_recvBuf[<span class="hljs-number">3</span>] * <span class="hljs-number">0xFF</span> + TBEF_recvBuf[<span class="hljs-number">4</span>];<span class="hljs-keyword">for</span>(u16 i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">5</span> + length; i ++)&#123;bcc ^= TBEF_recvBuf[i];&#125;<span class="hljs-keyword">if</span>(bcc != TBEF_recvBuf[<span class="hljs-number">5</span> + length])<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//bcc校验码错误</span><span class="hljs-keyword">if</span>(TBEF_recvBuf[<span class="hljs-number">6</span> + length] != <span class="hljs-number">0x5C</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-comment">//帧尾错误</span><span class="hljs-keyword">if</span>(TBEF_recvBuf[<span class="hljs-number">7</span> + length] != <span class="hljs-number">0xC5</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-comment">//帧尾错误</span><span class="hljs-keyword">if</span>(cmd == <span class="hljs-number">0x00</span>)&#123;<span class="hljs-built_in">TBEF_data_CallBack</span>(TBEF_recvBuf + <span class="hljs-number">5</span>, length);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmd == <span class="hljs-number">0x01</span>)&#123;bytesStored = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmd == <span class="hljs-number">0x02</span>)&#123;&#125;<span class="hljs-keyword">else</span> &#123;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//如：C5 5C FF 00 01 00 FE 5C C5表示没有错误</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_SendACK</span><span class="hljs-params">(u8 ERROR)</span></span><span class="hljs-function"></span>&#123;u8 sendBuf[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0xC5</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>, ERROR, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0xC5</span>&#125;;sendBuf[<span class="hljs-number">6</span>] = sendBuf[<span class="hljs-number">2</span>] ^ sendBuf[<span class="hljs-number">3</span>] ^ sendBuf[<span class="hljs-number">4</span>] ^ sendBuf[<span class="hljs-number">5</span>] ; <span class="hljs-built_in">UartSendMultByte</span>(USART1, sendBuf, <span class="hljs-number">9</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TBEF_clearRecvBuf</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">while</span>(TBEF_recvBuf_tail--)&#123;TBEF_recvBuf[TBEF_recvBuf_tail] = <span class="hljs-number">0</span>;&#125;&#125;</code></pre></div><h2 id="三、使用教程"><a href="#三、使用教程" class="headerlink" title="三、使用教程"></a>三、使用教程</h2><ol><li>下位机移植完成后，连接串口至电脑。</li><li>点击refresh按钮，刷新串口列表，选择下位机终端的COM口，连接</li><li>加载BIN文件</li><li>设置单次发送字节数</li><li>开始发送，等待发送完成即可</li></ol>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
      <category>software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>QT</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20| Linux UART串口实验</title>
    <link href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/20%E3%80%81Linux_UART%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/20%E3%80%81Linux_UART%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-UART串口实验"><a href="#Linux-UART串口实验" class="headerlink" title="Linux UART串口实验"></a>Linux UART串口实验</h1>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19| Linux SPI驱动实验</title>
    <link href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-SPI驱动实验"><a href="#Linux-SPI驱动实验" class="headerlink" title="Linux SPI驱动实验"></a>Linux SPI驱动实验</h1><p>上一章我们讲解了如何编写 Linux 下的 I2C 设备驱动，SPI 也是很常用的串行通信协议，本章我们就来学习如何在 Linux 下编写 SPI 设备驱动。本章实验的最终目的就是驱动 I.MX6U-ALPHA 开发板上的 ICM-20608 这个 SPI 接口的六轴传感器，可以在应用程序中读取 ICM-20608的原始传感器数据。</p><h2 id="1-Linux-下-下-SPI-驱动框架简介"><a href="#1-Linux-下-下-SPI-驱动框架简介" class="headerlink" title="1| Linux 下 下 SPI 驱动框架简介"></a>1| Linux 下 下 SPI 驱动框架简介</h2><p>SPI 驱动框架和 I2C 很类似，都分为主机控制器驱动和设备驱动，主机控制器也就是 SOC的SPI控制器接口。我们编写好 SPI 控制器驱动以后就可以直接使用了，不管是什么 SPI 设备，SPI 控制器部分的驱动都是一样，我们的重点就落在了种类繁多的 SPI 设备驱动。</p><h3 id="1-SPI-主机驱动"><a href="#1-SPI-主机驱动" class="headerlink" title="1. SPI  主机驱动"></a>1. SPI  主机驱动</h3><p>SPI 主机驱动就是 SOC 的 SPI 控制器驱动，类似 I2C 驱动里面的适配器驱动。Linux 内核使用 spi_master 表示 SPI 主机驱动，spi_master 是个结构体，定义在 include&#x2F;linux&#x2F;spi&#x2F;spi.h 文件中，内容如下(有缩减)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">315</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_master</span> &#123;</span><span class="hljs-number">316</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span><span class="hljs-number">317</span><span class="hljs-number">318</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span>......<span class="hljs-number">326</span> s16 bus_num;<span class="hljs-number">327</span><span class="hljs-number">328</span> <span class="hljs-comment">/* chipselects will be integral to many controllers; some others</span><span class="hljs-comment">329 * might use board-specific GPIOs.</span><span class="hljs-comment">330 */</span><span class="hljs-number">331</span> u16 num_chipselect;<span class="hljs-number">332</span><span class="hljs-number">333</span> <span class="hljs-comment">/* some SPI controllers pose alignment requirements on DMAable</span><span class="hljs-comment">334 * buffers; let protocol drivers know about these requirements.</span><span class="hljs-comment">335 */</span><span class="hljs-number">336</span> u16 dma_alignment;<span class="hljs-number">337</span><span class="hljs-number">338</span> <span class="hljs-comment">/* spi_device.mode flags understood by this controller driver */</span><span class="hljs-number">339</span> u16 mode_bits;<span class="hljs-number">340</span><span class="hljs-number">341</span> <span class="hljs-comment">/* bitmask of supported bits_per_word for transfers */</span><span class="hljs-number">342</span> u32 bits_per_word_mask;......<span class="hljs-number">347</span> <span class="hljs-comment">/* limits on transfer speed */</span><span class="hljs-number">348</span> u32 min_speed_hz;<span class="hljs-number">349</span> u32 max_speed_hz;<span class="hljs-number">350</span><span class="hljs-number">351</span> <span class="hljs-comment">/* other constraints relevant to this driver */</span><span class="hljs-number">352</span> u16 flags;......<span class="hljs-number">359</span> <span class="hljs-comment">/* lock and mutex for SPI bus locking */</span><span class="hljs-number">360</span> <span class="hljs-type">spinlock_t</span> bus_lock_spinlock;<span class="hljs-number">361</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">bus_lock_mutex</span>;</span><span class="hljs-number">362</span><span class="hljs-number">363</span> <span class="hljs-comment">/* flag indicating that the SPI bus is locked for exclusive use */</span><span class="hljs-number">364</span> <span class="hljs-type">bool</span> bus_lock_flag;......<span class="hljs-number">372</span> <span class="hljs-type">int</span> (*setup)(<span class="hljs-keyword">struct</span> spi_device *spi);<span class="hljs-number">373</span>......<span class="hljs-number">393</span> <span class="hljs-type">int</span> (*transfer)(<span class="hljs-keyword">struct</span> spi_device *spi,<span class="hljs-number">394</span> <span class="hljs-keyword">struct</span> spi_message *mesg);......<span class="hljs-number">434</span> <span class="hljs-type">int</span> (*transfer_one_message)(<span class="hljs-keyword">struct</span> spi_master *master,<span class="hljs-number">435</span> <span class="hljs-keyword">struct</span> spi_message *mesg);......<span class="hljs-number">462</span> &#125;;</code></pre></div><p>第 393 行，transfer 函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函数。</p><p>第 434 行，transfer_one_message 函数，也用于 SPI 数据发送，用于发送一个 spi_message，SPI 的数据会打包成 spi_message，然后以队列方式发送出去。也就是 SPI 主机端最终会通过 transfer 函数与 SPI 设备进行通信，因此对于 SPI 主机控制器的驱动编写者而言 transfer 函数是需要实现的，因为不同的 SOC 其 SPI 控制器不同，寄存器都不一样。和 I2C 适配器驱动一样，SPI 主机驱动一般都是 SOC 厂商去编写的，所以我们作为 SOC 的使用者，这一部分的驱动就不用操心了，除非你是在 SOC 原厂工作，内容就是写 SPI 主机驱动。</p><p>SPI 主机驱动的核心就是申请 spi_master，然后初始化 spi_master，最后向 Linux 内核注册spi_master。</p><h4 id="1-、spi-master-申请与释放"><a href="#1-、spi-master-申请与释放" class="headerlink" title="1 、spi_master 申请与释放"></a>1 、spi_master 申请与释放</h4><p>spi_alloc_master 函数用于<strong>申请 spi_master</strong>，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> spi_master *<span class="hljs-title function_">spi_alloc_master</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">unsigned</span> size)</span></code></pre></div><p>函数参数和返回值含义如下：</p><p><strong>dev</strong>：设备，一般是 platform_device 中的 dev 成员变量。<br><strong>size</strong> ：私有数据大小，可以通过 spi_master_get_devdata 函数获取到这些私有数据。<br><strong>返回值</strong>：申请到的 spi_master。</p><hr><p><strong>spi_master 的释放</strong>通过 spi_master_put 函数来完成，当我们删除一个 SPI 主机驱动的时候就需要释放掉前面申请的 spi_master，spi_master_put 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_master_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_master *master)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>master</strong>：要释放的 spi_master。<br><strong>返回值</strong>：无。</p><h4 id="2、spi-master-的注册与注销"><a href="#2、spi-master-的注册与注销" class="headerlink" title="2、spi_master 的注册与注销"></a>2、spi_master 的注册与注销</h4><p>当 spi_master 初始化完成以后就需要将其注册到 Linux 内核，spi_master <strong>注册函数</strong>为<br>spi_register_master，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_register_master</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_master *master)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>master</strong>：要注册的 spi_master。<br><strong>返回值</strong>：0，成功；负值，失败。</p><p>I.MX6U 的 SPI 主机驱动会采用 spi_bitbang_start 这个 API 函数来完成 spi_master 的注册，spi_bitbang_start 函数内部其实也是通过调用 spi_register_master 函数来完成 spi_master 的注册。</p><hr><p>如果要<strong>注销 spi_master</strong> 的话可以使用 spi_unregister_master 函数，此函数原型为：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_unregister_master</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_master *master)</span></code></pre></div><p>函数参数和返回值含义如下：</p><p><strong>master</strong>：要注销的 spi_master。<br><strong>返回值</strong>：无。<br>如果使用 spi_bitbang_start 注册 spi_master 的话就要使用 spi_bitbang_stop 来注销掉spi_master。</p><h3 id="2-SPI-设备驱动"><a href="#2-SPI-设备驱动" class="headerlink" title="2. SPI  设备驱动"></a>2. SPI  设备驱动</h3><p>spi 设备驱动也和 i2c 设备驱动也很类似，Linux 内核使用 spi_driver 结构体来表示 spi 设备驱动，我们在编写 SPI 设备驱动的时候需要实现 spi_driver。spi_driver 结构体定义在include&#x2F;linux&#x2F;spi&#x2F;spi.h 文件中，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">180</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_driver</span> &#123;</span><span class="hljs-number">181</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device_id</span> *<span class="hljs-title">id_table</span>;</span><span class="hljs-number">182</span> <span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> spi_device *spi);<span class="hljs-number">183</span> <span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> spi_device *spi);<span class="hljs-number">184</span> <span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> spi_device *spi);<span class="hljs-number">185</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span><span class="hljs-number">186</span> &#125;;</code></pre></div><p>可以看出，spi_driver 和 i2c_driver、platform_driver 基本一样，当 SPI 设备和驱动匹配成功以后 probe 函数就会执行。</p><p>同样的，spi_driver 初始化完成以后需要向 Linux 内核注册，spi_driver 注册函数为spi_register_driver，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_driver *sdrv)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>sdrv</strong> ：要注册的 spi_driver。<br><strong>返回值</strong>：0，注册成功；赋值，注册失败。</p><hr><p>注销 SPI 设备驱动以后也需要注销掉前面注册的 spi_driver，使用 spi_unregister_driver 函数完成 spi_driver 的注销，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_unregister_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_driver *sdrv)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>sdrv</strong> ：要注销的 spi_driver。</p><p><strong>返回值</strong>：无。</p><p>spi_driver 注册示例程序如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* probe 函数 */</span><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span>3 &#123;<span class="hljs-number">4</span> <span class="hljs-comment">/* 具体函数内容 */</span><span class="hljs-number">5</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">6</span> &#125;<span class="hljs-number">7</span><span class="hljs-number">8</span> <span class="hljs-comment">/* remove 函数 */</span><span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span>10 &#123;<span class="hljs-number">11</span> <span class="hljs-comment">/* 具体函数内容 */</span><span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">13</span> &#125;<span class="hljs-number">14</span> <span class="hljs-comment">/* 传统匹配方式 ID 列表 */</span><span class="hljs-number">15</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device_id</span> <span class="hljs-title">xxx_id</span>[] =</span> &#123;<span class="hljs-number">16</span> &#123;<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">0</span>&#125;,<span class="hljs-number">17</span> &#123;&#125;<span class="hljs-number">18</span> &#125;;<span class="hljs-number">19</span><span class="hljs-number">20</span> <span class="hljs-comment">/* 设备树匹配列表 */</span><span class="hljs-number">21</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;<span class="hljs-number">22</span> &#123; .compatible = <span class="hljs-string">&quot;xxx&quot;</span> &#125;,<span class="hljs-number">23</span> &#123; <span class="hljs-comment">/* Sentinel */</span> &#125;<span class="hljs-number">24</span> &#125;;<span class="hljs-number">25</span><span class="hljs-number">26</span> <span class="hljs-comment">/* SPI 驱动结构体 */</span><span class="hljs-number">27</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_driver</span> <span class="hljs-title">xxx_driver</span> =</span> &#123;<span class="hljs-number">28</span> .probe = xxx_probe,<span class="hljs-number">29</span> .remove = xxx_remove,<span class="hljs-number">30</span> .driver = &#123;<span class="hljs-number">31</span> .owner = THIS_MODULE,<span class="hljs-number">32</span> .name = <span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-number">33</span> .of_match_table = xxx_of_match,<span class="hljs-number">34</span> &#125;,<span class="hljs-number">35</span> .id_table = xxx_id,<span class="hljs-number">36</span> &#125;;<span class="hljs-number">37</span><span class="hljs-number">38</span> <span class="hljs-comment">/* 驱动入口函数 */</span><span class="hljs-number">39</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>40 &#123;<span class="hljs-number">41</span> <span class="hljs-keyword">return</span> spi_register_driver(&amp;xxx_driver);<span class="hljs-number">42</span> &#125;<span class="hljs-number">43</span><span class="hljs-number">44</span> <span class="hljs-comment">/* 驱动出口函数 */</span><span class="hljs-number">45</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>46 &#123;<span class="hljs-number">47</span> spi_unregister_driver(&amp;xxx_driver);<span class="hljs-number">48</span> &#125;<span class="hljs-number">49</span><span class="hljs-number">50</span> module_init(xxx_init);<span class="hljs-number">51</span> module_exit(xxx_exit);</code></pre></div><p>第 1~36 行，spi_driver 结构体，需要 SPI 设备驱动人员编写，包括匹配表、probe 函数等。和 i2c_driver、platform_driver 一样，就不详细讲解了。</p><p>第 39~42 行，在驱动入口函数中调用 spi_register_driver 来注册 spi_driver。</p><p>第 45~48 行，在驱动出口函数中调用 spi_unregister_driver 来注销 spi_driver。</p><h3 id="3-SPI-设备和驱动匹配过程"><a href="#3-SPI-设备和驱动匹配过程" class="headerlink" title="3. SPI  设备和驱动匹配过程"></a>3. SPI  设备和驱动匹配过程</h3><p>具体参考正点原子IMX6UL驱动开发指南62.1.3节</p><h2 id="2-I-MX6U-SPI-主机驱动分析"><a href="#2-I-MX6U-SPI-主机驱动分析" class="headerlink" title="2| I.MX6U SPI  主机驱动分析"></a>2| I.MX6U SPI  主机驱动分析</h2><p>和 I2C 的适配器驱动一样，SPI 主机驱动一般都由 SOC 厂商编写好了，打开 imx6ull.dtsi文件，找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ecspi3: ecspi@<span class="hljs-number">02010000</span> &#123;<span class="hljs-number">2</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">3</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><span class="hljs-number">4</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="hljs-string">&quot;fsl,imx51-ecspi&quot;</span>;<span class="hljs-number">5</span> reg = &lt;<span class="hljs-number">0x02010000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">6</span> interrupts = &lt;GIC_SPI <span class="hljs-number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-number">7</span> clocks = &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;,<span class="hljs-number">8</span>  &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;;<span class="hljs-number">9</span> clock-names = <span class="hljs-string">&quot;ipg&quot;</span>, <span class="hljs-string">&quot;per&quot;</span>;<span class="hljs-number">10</span> dmas = &lt;&amp;sdma <span class="hljs-number">7</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span>&gt;, &lt;&amp;sdma <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span>&gt;;<span class="hljs-number">11</span> dma-names = <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-string">&quot;tx&quot;</span>;<span class="hljs-number">12</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<span class="hljs-number">13</span> &#125;;</code></pre></div><p>重点来看一下第 4 行的 compatible 属性值，compatible 属性有两个值“fsl,imx6ul-ecspi”和“fsl,imx51-ecspi”，在 Linux 内核源码中搜素这两个属性值即可找到 I.MX6U 对应的 ECSPI(SPI)主机驱动。I.MX6U 的 ECSPI 主机驱动文件为 drivers&#x2F;spi&#x2F;spi-imx.c。</p><p><strong>具体参考正点原子IMX6UL驱动开发指南62.2节</strong></p><h2 id="3-SPI设备驱动编写流程"><a href="#3-SPI设备驱动编写流程" class="headerlink" title="3| SPI设备驱动编写流程"></a>3| SPI设备驱动编写流程</h2><h3 id="1-SPI-设备信息描述"><a href="#1-SPI-设备信息描述" class="headerlink" title="1.SPI  设备信息描述"></a>1.SPI  设备信息描述</h3><h4 id="1-、IO-的-的-pinctrl-子节点创建与修改"><a href="#1-、IO-的-的-pinctrl-子节点创建与修改" class="headerlink" title="1 、IO 的 的 pinctrl  子节点创建与修改"></a>1 、IO 的 的 pinctrl  子节点创建与修改</h4><p>首先肯定是根据所使用的 IO 来创建或修改 pinctrl 子节点，这个没什么好说的，唯独要注意的就是检查相应的 IO 有没有被其他的设备所使用，如果有的话需要将其删除掉！</p><h4 id="2-、SPI-设备节点的创建与修改"><a href="#2-、SPI-设备节点的创建与修改" class="headerlink" title="2 、SPI  设备节点的创建与修改"></a>2 、SPI  设备节点的创建与修改</h4><p>采用设备树的情况下，SPI 设备信息描述就通过创建相应的设备子节点来完成，我们可以打开 imx6qdl-sabresd.dtsi 这个设备树头文件，在此文件里面找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">308</span> &amp;ecspi1 &#123;<span class="hljs-number">309</span> fsl,spi-num-chipselects = &lt;<span class="hljs-number">1</span>&gt;;<span class="hljs-number">310</span> cs-gpios = &lt;&amp;gpio4 <span class="hljs-number">9</span> <span class="hljs-number">0</span>&gt;;<span class="hljs-number">311</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">312</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_ecspi1&gt;;<span class="hljs-number">313</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">314</span><span class="hljs-number">315</span> flash: m25p80@<span class="hljs-number">0</span> &#123;<span class="hljs-number">316</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">317</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">318</span> compatible = <span class="hljs-string">&quot;st,m25p32&quot;</span>;<span class="hljs-number">319</span> spi-max-frequency = &lt;<span class="hljs-number">20000000</span>&gt;;<span class="hljs-number">320</span> reg = &lt;<span class="hljs-number">0</span>&gt;;<span class="hljs-number">321</span> &#125;;<span class="hljs-number">322</span> &#125;;</code></pre></div><p>示例代码是 I.MX6Q 的一款板子上的一个 SPI 设备节点，在这个板子的 ECSPI 接口上接了一个 m25p80，这是一个 SPI 接口的设备。</p><ul><li>第 309 行，设置“fsl,spi-num-chipselects”属性为 1，表示只有一个设备。</li><li>第 310 行，设置“cs-gpios”属性，也就是片选信号为 GPIO4_IO09。</li><li>第 311 行，设置“pinctrl-names”属性，也就是 SPI 设备所使用的 IO 名字。</li><li>第 312 行，设置“pinctrl-0”属性，也就是所使用的 IO 对应的 pinctrl 节点。</li><li>第 313 行，将 ecspi1 节点的“status”属性改为“okay”。</li><li>第 315~320 行，ecspi1 下的 m25p80 设备信息，每一个 SPI 设备都采用一个子节点来描述其设备信息。第 315 行的“m25p80@0”后面的“0”表示 m25p80 的接到了 ECSPI 的通道 0上。这个要根据自己的具体硬件来设置。</li><li>第 318 行，SPI 设备的 compatible 属性值，用于匹配设备驱动。</li><li>第 319 行，“spi-max-frequency”属性设置 SPI 控制器的最高频率，这个要根据所使用的SPI 设备来设置，比如在这里将 SPI 控制器最高频率设置为 20MHz。</li><li>第 320 行，reg 属性设置 m25p80 这个设备所使用的 ECSPI 通道，和“m25p80@0”后面的“0”一样。</li></ul><p>我们一会在编写 ICM20608 的设备树节点信息的时候就参考示例代码中的内容即可。</p><h3 id="2-SPI-设备数据收发处理流程"><a href="#2-SPI-设备数据收发处理流程" class="headerlink" title="2.SPI  设备数据收发处理流程"></a>2.SPI  设备数据收发处理流程</h3><p>SPI 设备驱动的核心是 spi_driver，这个我们已经在前面讲过了。当我们向 Linux 内核注册成功 spi_driver 以后就可以使用 SPI 核心层提供的 API 函数来对设备进行读写操作了。</p><p>首先是 spi_transfer 结构体，此结构体用于描述 SPI 传输信息，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">603</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> &#123;</span><span class="hljs-number">604</span> <span class="hljs-comment">/* it&#x27;s ok if tx_buf == rx_buf (right?)</span><span class="hljs-comment">605 * for MicroWire, one buffer must be null</span><span class="hljs-comment">606 * buffers must work with dma_*map_single() calls, unless</span><span class="hljs-comment">607 * spi_message.is_dma_mapped reports a pre-existing mapping</span><span class="hljs-comment">608 */</span><span class="hljs-number">609</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *tx_buf;<span class="hljs-number">610</span> <span class="hljs-type">void</span> *rx_buf;<span class="hljs-number">611</span> <span class="hljs-type">unsigned</span> len;<span class="hljs-number">612</span><span class="hljs-number">613</span> <span class="hljs-type">dma_addr_t</span> tx_dma;<span class="hljs-number">614</span> <span class="hljs-type">dma_addr_t</span> rx_dma;<span class="hljs-number">615</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> <span class="hljs-title">tx_sg</span>;</span><span class="hljs-number">616</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> <span class="hljs-title">rx_sg</span>;</span><span class="hljs-number">617</span><span class="hljs-number">618</span> <span class="hljs-type">unsigned</span> cs_change:<span class="hljs-number">1</span>;<span class="hljs-number">619</span> <span class="hljs-type">unsigned</span> tx_nbits:<span class="hljs-number">3</span>;<span class="hljs-number">620</span> <span class="hljs-type">unsigned</span> rx_nbits:<span class="hljs-number">3</span>;<span class="hljs-number">621</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_NBITS_SINGLE 0x01 <span class="hljs-comment">/* 1bit transfer */</span></span><span class="hljs-number">622</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_NBITS_DUAL 0x02 <span class="hljs-comment">/* 2bits transfer */</span></span><span class="hljs-number">623</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_NBITS_QUAD 0x04 <span class="hljs-comment">/* 4bits transfer */</span></span><span class="hljs-number">624</span> u8 bits_per_word;<span class="hljs-number">625</span> u16 delay_usecs;<span class="hljs-number">626</span> u32 speed_hz;<span class="hljs-number">627</span><span class="hljs-number">628</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">transfer_list</span>;</span><span class="hljs-number">629</span> &#125;;</code></pre></div><p>第 609 行，tx_buf 保存着要发送的数据。<br>第 610 行，rx_buf 用于保存接收到的数据。<br>第 611 行，len 是要进行传输的数据长度，SPI 是全双工通信，因此在一次通信中发送和接收的字节数都是一样的，所以 spi_transfer 中也就没有发送长度和接收长度之分。</p><p><strong>spi_transfer 需要组织成 spi_message</strong>，spi_message 也是一个结构体，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">660</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> &#123;</span><span class="hljs-number">661</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">transfers</span>;</span><span class="hljs-number">662</span><span class="hljs-number">663</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device</span> *<span class="hljs-title">spi</span>;</span><span class="hljs-number">664</span><span class="hljs-number">665</span> <span class="hljs-type">unsigned</span> is_dma_mapped:<span class="hljs-number">1</span>;......<span class="hljs-number">678</span> <span class="hljs-comment">/* completion is reported through a callback */</span><span class="hljs-number">679</span> <span class="hljs-type">void</span> (*complete)(<span class="hljs-type">void</span> *context);<span class="hljs-number">680</span> <span class="hljs-type">void</span> *context;<span class="hljs-number">681</span> <span class="hljs-type">unsigned</span> frame_length;<span class="hljs-number">682</span> <span class="hljs-type">unsigned</span> actual_length;<span class="hljs-number">683</span> <span class="hljs-type">int</span> status;<span class="hljs-number">684</span><span class="hljs-number">685</span> <span class="hljs-comment">/* for optional use by whatever driver currently owns the</span><span class="hljs-comment">686 * spi_message ... between calls to spi_async and then later</span><span class="hljs-comment">687 * complete(), that&#x27;s the spi_master controller driver.</span><span class="hljs-comment">688 */</span><span class="hljs-number">689</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">queue</span>;</span><span class="hljs-number">690</span> <span class="hljs-type">void</span> *state;<span class="hljs-number">691</span> &#125;;</code></pre></div><p>在使用spi_message之前需要对其进行初始化，<strong>spi_message初始化函数为spi_message_init</strong>，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_message_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_message *m)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>m</strong> ：要初始化的 spi_message。<br><strong>返回值</strong>：无。</p><hr><p>spi_message 初始化完成以后需要<strong>将 spi_transfer 添加到 spi_message 队列</strong>中，这里我们要用到 spi_message_add_tail 函数，此函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_message_add_tail</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_transfer *t, <span class="hljs-keyword">struct</span> spi_message *m)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>t</strong> ：要添加到队列中的 spi_transfer。<br><strong>m</strong>：spi_transfer 要加入的 spi_message。<br><strong>返回值</strong>：无。</p><hr><p>spi_message 准备好以后既可以进行数据传输了，数据传输分为同步传输和异步传输，同步传输会阻塞的等待 SPI 数据传输完成，<strong>同步传输函数为 spi_sync</strong>，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-keyword">struct</span> spi_message *message)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>spi</strong> ：要进行数据传输的 spi_device。<br><strong>message</strong>：要传输的 spi_message。<br><strong>返回值</strong>：无。</p><hr><p>异步传输不会阻塞的等到 SPI 数据传输完成，异步传输需要设置 spi_message 中的 complete成员变量，complete 是一个回调函数，当 SPI 异步传输完成以后此函数就会被调用。<strong>SPI 异步传输函数为 spi_async</strong>，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_async</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-keyword">struct</span> spi_message *message)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>spi</strong> ：要进行数据传输的 spi_device。<br><strong>message</strong>：要传输的 spi_message。<br><strong>返回值</strong>：无。</p><p>在本章实验中，我们采用同步传输方式来完成 SPI 数据的传输工作，也就是 spi_sync 函数。综上所述，SPI 数据传输步骤如下：</p><ul><li>①、申请并初始化 spi_transfer，设置 spi_transfer 的 tx_buf 成员变量，tx_buf 为要发送的数据。然后设置 rx_buf 成员变量，rx_buf 保存着接收到的数据。最后设置 len 成员变量，也就是要进行数据通信的长度。</li><li>②、使用 spi_message_init 函数初始化 spi_message。</li><li>③、使用spi_message_add_tail函数将前面设置好的spi_transfer添加到spi_message队列中。</li><li>④、使用 spi_sync 函数完成 SPI 数据同步传输。</li></ul><p>通过 SPI 进行 n 个字节的数据发送和接收的示例代码如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* SPI 多字节发送 */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_send</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, u8 *buf, <span class="hljs-type">int</span> len)</span>&#123;    <span class="hljs-type">int</span> ret;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> <span class="hljs-title">t</span> =</span> &#123;        .tx_buf = buf,        .len = len,    &#125;;    spi_message_init(&amp;m); <span class="hljs-comment">/* 初始化 spi_message */</span>    spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span>    ret = spi_sync(spi, &amp;m); <span class="hljs-comment">/* 同步传输 */</span>    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-comment">/* SPI 多字节接收 */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_receive</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, u8 *buf, <span class="hljs-type">int</span> len)</span>&#123;    <span class="hljs-type">int</span> ret;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> <span class="hljs-title">t</span> =</span> &#123;        .rx_buf = buf,        .len = len,    &#125;;    spi_message_init(&amp;m); <span class="hljs-comment">/* 初始化 spi_message */</span>    spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span>    ret = spi_sync(spi, &amp;m); <span class="hljs-comment">/* 同步传输 */</span>    <span class="hljs-keyword">return</span> ret;&#125;</code></pre></div><h2 id="4-硬件原理图分析"><a href="#4-硬件原理图分析" class="headerlink" title="4| 硬件原理图分析"></a>4| 硬件原理图分析</h2><p>ICM-20608 是在 I.MX6U-ALPHA 开发板底板上，原理图如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200904113227640.png" alt="image-20200904113227640"></p><h2 id="5-实验程序编写"><a href="#5-实验程序编写" class="headerlink" title="5| 实验程序编写"></a>5| 实验程序编写</h2><h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1.修改设备树"></a>1.修改设备树</h3><h4 id="1-、添加-ICM20608-所使用的IO"><a href="#1-、添加-ICM20608-所使用的IO" class="headerlink" title="1 、添加 ICM20608 所使用的IO"></a>1 、添加 ICM20608 所使用的IO</h4><p>首先在 imx6ull-lxg-emmc.dts 文件中添加 ICM20608 所使用的 IO 信息，在 iomuxc 节点中添加一个新的子节点来描述 ICM20608 所使用的 SPI 引脚，子节点名字为 pinctrl_ecspi3，节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_ecspi3: icm20608 &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 <span class="hljs-number">0x10b0</span> <span class="hljs-comment">/* CS */</span><span class="hljs-number">4</span> MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK <span class="hljs-number">0x10b1</span> <span class="hljs-comment">/* SCLK */</span><span class="hljs-number">5</span> MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO <span class="hljs-number">0x10b1</span> <span class="hljs-comment">/* MISO */</span><span class="hljs-number">6</span> MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI <span class="hljs-number">0x10b1</span> <span class="hljs-comment">/* MOSI */</span><span class="hljs-number">7</span> &gt;;<span class="hljs-number">8</span> &#125;;</code></pre></div><p>UART2_TX_DATA 这个 IO 是 ICM20608 的片选信号，这里我们并没有将其复用为 ECSPI3的 SS0 信号，而是将其复用为了普通的 GPIO。因为我们需要自己控制片选信号，所以将其复用为普通的 GPIO。</p><h4 id="2-、在-ecspi3-节点追加-icm20608-子节点"><a href="#2-、在-ecspi3-节点追加-icm20608-子节点" class="headerlink" title="2 、在 ecspi3  节点追加 icm20608  子节点"></a>2 、在 ecspi3  节点追加 icm20608  子节点</h4><p>在 imx6ull-lxg-emmc.dts 文件中并没有任何向 ecspi3 节点追加内容的代码，这是因为NXP 官方的 6ULL EVK 开发板上没有连接 SPI 设备。在 imx6ull-lxg-emmc.dts 文件最后面加入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;ecspi3 &#123;<span class="hljs-number">2</span> fsl,spi-num-chipselects = &lt;<span class="hljs-number">1</span>&gt;;<span class="hljs-number">3</span> cs-gpio = &lt;&amp;gpio1 <span class="hljs-number">20</span> GPIO_ACTIVE_LOW&gt;; <span class="hljs-comment">/* cant&#x27;t use cs-gpios! */</span><span class="hljs-number">4</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">5</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;<span class="hljs-number">6</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">7</span><span class="hljs-number">8</span> spidev: icm20608@<span class="hljs-number">0</span> &#123;<span class="hljs-number">9</span> compatible = <span class="hljs-string">&quot;alientek,icm20608&quot;</span>;<span class="hljs-number">10</span> spi-max-frequency = &lt;<span class="hljs-number">8000000</span>&gt;;<span class="hljs-number">11</span> reg = &lt;<span class="hljs-number">0</span>&gt;;<span class="hljs-number">12</span> &#125;;<span class="hljs-number">13</span> &#125;;</code></pre></div><ul><li>第 2 行，设置当前片选数量为 1，因为就只接了一个 ICM20608。</li><li>第 3 行，注意！这里并没有用到“cs-gpios”属性，而是用了一个自己定义的“cs-gpio”属性，因为我们要自己控制片选引脚。如果使用“cs-gpios”属性的话 SPI 主机驱动就会控制片选引脚。</li><li>第 5 行，设置 IO 要使用的 pinctrl 子节点，也就是我们在前面示例代码中新建的pinctrl_ecspi3。</li><li>第 6 行，imx6ull.dtsi 文件中默认将 ecspi3 节点状态(status)设置为“disable”，这里我们要将其改为“okay”。</li><li>第 8~12 行，icm20608 设备子节点，因为 icm20608 连接在 ECSPI3 的第 0 个通道上，因此@后面为 0。第 9 行设置节点属性兼容值为“alientek,icm20608”，第 10 行设置 SPI 最大时钟频率为 8MHz，这是ICM20608 的 SPI 接口所能支持的最大的时钟频率。第 11 行，icm20608 连接在通道 0 上，因此 reg 为 0。</li></ul><p>imx6ull-lxg-emmc.dts 文件修改完成以后重新编译一下，得到新的 dtb 文件，并使用新的 dtb 启动 Linux 系统。</p><h3 id="2-编写-ICM20608-驱动"><a href="#2-编写-ICM20608-驱动" class="headerlink" title="2.编写 ICM20608 驱动"></a>2.编写 ICM20608 驱动</h3><p>新建名为“22_spi”的文件夹，然后在 22_spi 文件夹里面创建 vscode 工程，工作区命名为“spi”。工程创建好以后新建 icm20608.c 和 icm20608reg.h 这两个文件，icm20608.c 为 ICM20608的驱动代码，icm20608reg.h是 ICM20608寄存器头文件。</p><p>先在 icm20608reg.h中定义好 ICM20608的寄存器，输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ICM20608_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ICM20608_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ICM20608G_ID0XAF<span class="hljs-comment">/* ID值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ICM20608D_ID0XAE<span class="hljs-comment">/* ID值 */</span></span><span class="hljs-comment">/* ICM20608寄存器 </span><span class="hljs-comment"> *复位后所有寄存器地址都为0，除了</span><span class="hljs-comment"> *Register 107(0X6B) Power Management 1 = 0x40</span><span class="hljs-comment"> *Register 117(0X75) WHO_AM_I = 0xAF或0xAE</span><span class="hljs-comment"> */</span><span class="hljs-comment">/* 陀螺仪和加速度自测(出产时设置，用于与用户的自检输出值比较） */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_SELF_TEST_X_GYRO0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_SELF_TEST_Y_GYRO0x01</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_SELF_TEST_Z_GYRO0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_SELF_TEST_X_ACCEL0x0D</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_SELF_TEST_Y_ACCEL0x0E</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_SELF_TEST_Z_ACCEL0x0F</span><span class="hljs-comment">/* 陀螺仪静态偏移 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_XG_OFFS_USRH0x13</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_XG_OFFS_USRL0x14</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_YG_OFFS_USRH0x15</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_YG_OFFS_USRL0x16</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ZG_OFFS_USRH0x17</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ZG_OFFS_USRL0x18</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_SMPLRT_DIV0x19</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_CONFIG0x1A</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_GYRO_CONFIG0x1B</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_CONFIG0x1C</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_CONFIG20x1D</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_LP_MODE_CFG0x1E</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_WOM_THR0x1F</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_FIFO_EN0x23</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_FSYNC_INT0x36</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_INT_PIN_CFG0x37</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_INT_ENABLE0x38</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_INT_STATUS0x3A</span><span class="hljs-comment">/* 加速度输出 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_XOUT_H0x3B</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_XOUT_L0x3C</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_YOUT_H0x3D</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_YOUT_L0x3E</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_ZOUT_H0x3F</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_ZOUT_L0x40</span><span class="hljs-comment">/* 温度输出 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_TEMP_OUT_H0x41</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_TEMP_OUT_L0x42</span><span class="hljs-comment">/* 陀螺仪输出 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_GYRO_XOUT_H0x43</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_GYRO_XOUT_L0x44</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_GYRO_YOUT_H0x45</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_GYRO_YOUT_L0x46</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_GYRO_ZOUT_H0x47</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_GYRO_ZOUT_L0x48</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_SIGNAL_PATH_RESET0x68</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ACCEL_INTEL_CTRL 0x69</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_USER_CTRL0x6A</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_PWR_MGMT_10x6B</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_PWR_MGMT_20x6C</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_FIFO_COUNTH0x72</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_FIFO_COUNTL0x73</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_FIFO_R_W0x74</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_WHO_AM_I 0x75</span><span class="hljs-comment">/* 加速度静态偏移 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_XA_OFFSET_H0x77</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_XA_OFFSET_L0x78</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_YA_OFFSET_H0x7A</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_YA_OFFSET_L0x7B</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ZA_OFFSET_H0x7D</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ICM20_ZA_OFFSET_L 0x7E</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>接下来继续编写 icm20608.c 文件，因为 icm20608.c 文件内容比较长，因此这里就将其分开来讲解。</p><h4 id="1、icm20608-设备结构体创建"><a href="#1、icm20608-设备结构体创建" class="headerlink" title="1、icm20608  设备结构体创建"></a>1、icm20608  设备结构体创建</h4><p>首先创建一个 icm20608 设备结构体，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icm20608_dev</span> &#123;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-comment">/* 设备号  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-comment">/* cdev */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-comment">/* 类 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-comment">/* 设备  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>*<span class="hljs-title">nd</span>;</span> <span class="hljs-comment">/* 设备节点 */</span><span class="hljs-type">int</span> major;<span class="hljs-comment">/* 主设备号 */</span><span class="hljs-type">void</span> *private_data;<span class="hljs-comment">/* 私有数据 */</span><span class="hljs-type">int</span> cs_gpio;<span class="hljs-comment">/* 片选所使用的GPIO编号*/</span><span class="hljs-type">signed</span> <span class="hljs-type">int</span> gyro_x_adc;<span class="hljs-comment">/* 陀螺仪X轴原始值  */</span><span class="hljs-type">signed</span> <span class="hljs-type">int</span> gyro_y_adc;<span class="hljs-comment">/* 陀螺仪Y轴原始值*/</span><span class="hljs-type">signed</span> <span class="hljs-type">int</span> gyro_z_adc;<span class="hljs-comment">/* 陀螺仪Z轴原始值 */</span><span class="hljs-type">signed</span> <span class="hljs-type">int</span> accel_x_adc;<span class="hljs-comment">/* 加速度计X轴原始值 */</span><span class="hljs-type">signed</span> <span class="hljs-type">int</span> accel_y_adc;<span class="hljs-comment">/* 加速度计Y轴原始值*/</span><span class="hljs-type">signed</span> <span class="hljs-type">int</span> accel_z_adc;<span class="hljs-comment">/* 加速度计Z轴原始值 */</span><span class="hljs-type">signed</span> <span class="hljs-type">int</span> temp_adc;<span class="hljs-comment">/* 温度原始值 */</span>&#125;;</code></pre></div><p>icm20608 的设备结构体 icm20608_dev 没什么好讲的，重点看一下 <strong>private_data</strong>，对于 SPI 设备驱动来讲最核心的就是 spi_device。probe 函数会向驱动提供当前 SPI 设备对应的spi_device，因此在 probe 函数中设置 private_data 为 probe 函数传递进来的 spi_device 参数。</p><h4 id="2-、icm20608-的-的-spi-driver-注册与注销"><a href="#2-、icm20608-的-的-spi-driver-注册与注销" class="headerlink" title="2 、icm20608 的 的 spi_driver  注册与注销"></a>2 、icm20608 的 的 spi_driver  注册与注销</h4><p>对于 SPI 设备驱动，首先就是要初始化并向系统注册 spi_driver，icm20608 的 spi_driver 初始化、注册与注销代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 传统匹配方式ID列表 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device_id</span> <span class="hljs-title">icm20608_id</span>[] =</span> &#123;&#123;<span class="hljs-string">&quot;alientek,icm20608&quot;</span>, <span class="hljs-number">0</span>&#125;,  &#123;&#125;&#125;;<span class="hljs-comment">/* 设备树匹配列表 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">icm20608_of_match</span>[] =</span> &#123;&#123; .compatible = <span class="hljs-string">&quot;alientek,icm20608&quot;</span> &#125;,&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;&#125;;<span class="hljs-comment">/* SPI驱动结构体 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_driver</span> <span class="hljs-title">icm20608_driver</span> =</span> &#123;.probe = icm20608_probe,.remove = icm20608_remove,.driver = &#123;.owner = THIS_MODULE,   .name = <span class="hljs-string">&quot;icm20608&quot;</span>,   .of_match_table = icm20608_of_match,    &#125;,.id_table = icm20608_id,&#125;;   <span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动入口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">icm20608_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-keyword">return</span> spi_register_driver(&amp;icm20608_driver);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动出口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">icm20608_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;spi_unregister_driver(&amp;icm20608_driver);&#125;module_init(icm20608_init);module_exit(icm20608_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>当 icm20608 设备和此驱动匹配成功以后 icm20608_probe 函数就会执行。同样的，当注销此驱动的时候 icm20608_remove 函数会执行。</p><h4 id="3-、probe-amp-remove-函数"><a href="#3-、probe-amp-remove-函数" class="headerlink" title="3 、probe&amp;remove  函数"></a>3 、probe&amp;remove  函数</h4><div class="hljs code-wrapper"><pre><code class="hljs c"> <span class="hljs-comment">/*</span><span class="hljs-comment">  * @description     : spi驱动的probe函数，当驱动与</span><span class="hljs-comment">  *                    设备匹配以后此函数就会执行</span><span class="hljs-comment">  * @param - client  : spi设备</span><span class="hljs-comment">  * @param - id      : spi设备ID</span><span class="hljs-comment">  * </span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 1、构建设备号 */</span><span class="hljs-keyword">if</span> (icm20608dev.major) &#123;icm20608dev.devid = MKDEV(icm20608dev.major, <span class="hljs-number">0</span>);register_chrdev_region(icm20608dev.devid, ICM20608_CNT, ICM20608_NAME);&#125; <span class="hljs-keyword">else</span> &#123;alloc_chrdev_region(&amp;icm20608dev.devid, <span class="hljs-number">0</span>, ICM20608_CNT, ICM20608_NAME);icm20608dev.major = MAJOR(icm20608dev.devid);&#125;<span class="hljs-comment">/* 2、注册设备 */</span>cdev_init(&amp;icm20608dev.cdev, &amp;icm20608_ops);cdev_add(&amp;icm20608dev.cdev, icm20608dev.devid, ICM20608_CNT);<span class="hljs-comment">/* 3、创建类 */</span>icm20608dev.class = class_create(THIS_MODULE, ICM20608_NAME);<span class="hljs-keyword">if</span> (IS_ERR(icm20608dev.class)) &#123;<span class="hljs-keyword">return</span> PTR_ERR(icm20608dev.class);&#125;<span class="hljs-comment">/* 4、创建设备 */</span>icm20608dev.device = device_create(icm20608dev.class, <span class="hljs-literal">NULL</span>, icm20608dev.devid, <span class="hljs-literal">NULL</span>, ICM20608_NAME);<span class="hljs-keyword">if</span> (IS_ERR(icm20608dev.device)) &#123;<span class="hljs-keyword">return</span> PTR_ERR(icm20608dev.device);&#125;<span class="hljs-comment">/* 获取设备树中cs片选信号 */</span>icm20608dev.nd = of_find_node_by_path(<span class="hljs-string">&quot;/soc/aips-bus@02000000/spba-bus@02000000/ecspi@02010000&quot;</span>);<span class="hljs-keyword">if</span>(icm20608dev.nd == <span class="hljs-literal">NULL</span>) &#123;printk(<span class="hljs-string">&quot;ecspi3 node not find!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125; <span class="hljs-comment">/* 2、 获取设备树中的gpio属性，得到CS所使用的编号 */</span>icm20608dev.cs_gpio = of_get_named_gpio(icm20608dev.nd, <span class="hljs-string">&quot;cs-gpio&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(icm20608dev.cs_gpio &lt; <span class="hljs-number">0</span>) &#123;printk(<span class="hljs-string">&quot;can&#x27;t get cs-gpio&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-comment">/* 3、设置GPIO1_IO20为输出，并且输出高电平 */</span>ret = gpio_direction_output(icm20608dev.cs_gpio, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;printk(<span class="hljs-string">&quot;can&#x27;t set gpio!\r\n&quot;</span>);&#125;<span class="hljs-comment">/*初始化spi_device */</span>spi-&gt;mode = SPI_MODE_0;<span class="hljs-comment">/*MODE0，CPOL=0，CPHA=0*/</span>spi_setup(spi);icm20608dev.private_data = spi; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-comment">/* 初始化ICM20608内部寄存器 */</span>icm20608_reginit();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description     : spi驱动的remove函数，移除spi驱动的时候此函数会执行</span><span class="hljs-comment"> * @param - client : spi设备</span><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span>&#123;<span class="hljs-comment">/* 删除设备 */</span>cdev_del(&amp;icm20608dev.cdev);unregister_chrdev_region(icm20608dev.devid, ICM20608_CNT);<span class="hljs-comment">/* 注销掉类和设备 */</span>device_destroy(icm20608dev.class, icm20608dev.devid);class_destroy(icm20608dev.class);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>probe 函数，当设备与驱动匹配成功以后此函数就会执行，先是标准的注册字符设备驱动。然后获取设备节点中的“cs-gpio”属性，也就是获取到设备的片选 IO。</p><p>设置 SPI 为模式 0，也就是 CPOL&#x3D;0，CPHA&#x3D;0。<br>设置好 spi_device 以后需要使用 spi_setup 配置一下。<br>设置 icm20608dev 的 private_data 成员变量为 spi_device。<br>调用 icm20608_reginit 函数初始化 ICM20608，主要是初始化 ICM20608 指定寄存器。<br>icm20608_remove 函数，注销驱动的时候此函数就会执行。</p><h4 id="4-、icm20608-寄存器读写与初始化"><a href="#4-、icm20608-寄存器读写与初始化" class="headerlink" title="4 、icm20608  寄存器读写与初始化"></a>4 、icm20608  寄存器读写与初始化</h4><p>SPI 驱动最终是通过读写 icm20608 的寄存器来实现的，因此需要编写相应的寄存器读写函数，并且使用这些读写函数来完成对 icm20608 的初始化。icm20608 的寄存器读写以及初始化代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 从icm20608读取多个寄存器数据</span><span class="hljs-comment"> * @param - dev:  icm20608设备</span><span class="hljs-comment"> * @param - reg:  要读取的寄存器首地址</span><span class="hljs-comment"> * @param - val:  读取到的数据</span><span class="hljs-comment"> * @param - len:  要读取的数据长度</span><span class="hljs-comment"> * @return : 操作结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> len)</span>&#123;<span class="hljs-type">int</span> ret;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> txdata[len];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> *<span class="hljs-title">t</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device</span> *<span class="hljs-title">spi</span> =</span> (<span class="hljs-keyword">struct</span> spi_device *)dev-&gt;private_data;gpio_set_value(dev-&gt;cs_gpio, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 片选拉低，选中ICM20608 */</span>t = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> spi_transfer), GFP_KERNEL);<span class="hljs-comment">/* 申请内存 */</span><span class="hljs-comment">/* 第1次，发送要读取的寄存地址 */</span>txdata[<span class="hljs-number">0</span>] = reg | <span class="hljs-number">0x80</span>;<span class="hljs-comment">/* 写数据的时候寄存器地址bit8要置1 */</span>t-&gt;tx_buf = txdata;<span class="hljs-comment">/* 要发送的数据 */</span>t-&gt;len = <span class="hljs-number">1</span>;<span class="hljs-comment">/* 1个字节 */</span>spi_message_init(&amp;m);<span class="hljs-comment">/* 初始化spi_message */</span>spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将spi_transfer添加到spi_message队列 */</span>ret = spi_sync(spi, &amp;m);<span class="hljs-comment">/* 同步发送 */</span><span class="hljs-comment">/* 第2次，读取数据 */</span>txdata[<span class="hljs-number">0</span>] = <span class="hljs-number">0xff</span>;<span class="hljs-comment">/* 随便一个值，此处无意义 */</span>t-&gt;rx_buf = buf;<span class="hljs-comment">/* 读取到的数据 */</span>t-&gt;len = len;<span class="hljs-comment">/* 要读取的数据长度 */</span>spi_message_init(&amp;m);<span class="hljs-comment">/* 初始化spi_message */</span>spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将spi_transfer添加到spi_message队列 */</span>ret = spi_sync(spi, &amp;m);<span class="hljs-comment">/* 同步发送 */</span>kfree(t);<span class="hljs-comment">/* 释放内存 */</span>gpio_set_value(dev-&gt;cs_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 片选拉高，释放ICM20608 */</span><span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向icm20608多个寄存器写入数据</span><span class="hljs-comment"> * @param - dev:  icm20608设备</span><span class="hljs-comment"> * @param - reg:  要写入的寄存器首地址</span><span class="hljs-comment"> * @param - val:  要写入的数据缓冲区</span><span class="hljs-comment"> * @param - len:  要写入的数据长度</span><span class="hljs-comment"> * @return   :   操作结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> s32 <span class="hljs-title function_">icm20608_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev, u8 reg, u8 *buf, u8 len)</span>&#123;<span class="hljs-type">int</span> ret;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> txdata[len];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> *<span class="hljs-title">t</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device</span> *<span class="hljs-title">spi</span> =</span> (<span class="hljs-keyword">struct</span> spi_device *)dev-&gt;private_data;t = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> spi_transfer), GFP_KERNEL);<span class="hljs-comment">/* 申请内存 */</span>gpio_set_value(dev-&gt;cs_gpio, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 片选拉低 */</span><span class="hljs-comment">/* 第1次，发送要读取的寄存地址 */</span>txdata[<span class="hljs-number">0</span>] = reg &amp; ~<span class="hljs-number">0x80</span>;<span class="hljs-comment">/* 写数据的时候寄存器地址bit8要清零 */</span>t-&gt;tx_buf = txdata;<span class="hljs-comment">/* 要发送的数据 */</span>t-&gt;len = <span class="hljs-number">1</span>;<span class="hljs-comment">/* 1个字节 */</span>spi_message_init(&amp;m);<span class="hljs-comment">/* 初始化spi_message */</span>spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将spi_transfer添加到spi_message队列 */</span>ret = spi_sync(spi, &amp;m);<span class="hljs-comment">/* 同步发送 */</span><span class="hljs-comment">/* 第2次，发送要写入的数据 */</span>t-&gt;tx_buf = buf;<span class="hljs-comment">/* 要写入的数据 */</span>t-&gt;len = len;<span class="hljs-comment">/* 写入的字节数 */</span>spi_message_init(&amp;m);<span class="hljs-comment">/* 初始化spi_message */</span>spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将spi_transfer添加到spi_message队列 */</span>ret = spi_sync(spi, &amp;m);<span class="hljs-comment">/* 同步发送 */</span>kfree(t);<span class="hljs-comment">/* 释放内存 */</span>gpio_set_value(dev-&gt;cs_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 片选拉高，释放ICM20608 */</span><span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 读取icm20608指定寄存器值，读取一个寄存器</span><span class="hljs-comment"> * @param - dev:  icm20608设备</span><span class="hljs-comment"> * @param - reg:  要读取的寄存器</span><span class="hljs-comment"> * @return   :   读取到的寄存器值</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">icm20608_read_onereg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev, u8 reg)</span>&#123;u8 data = <span class="hljs-number">0</span>;icm20608_read_regs(dev, reg, &amp;data, <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> data;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向icm20608指定寄存器写入指定的值，写一个寄存器</span><span class="hljs-comment"> * @param - dev:  icm20608设备</span><span class="hljs-comment"> * @param - reg:  要写的寄存器</span><span class="hljs-comment"> * @param - data: 要写入的值</span><span class="hljs-comment"> * @return   :    无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">icm20608_write_onereg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev, u8 reg, u8 value)</span>&#123;u8 buf = value;icm20608_write_regs(dev, reg, &amp;buf, <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 读取ICM20608的数据，读取原始数据，包括三轴陀螺仪、</span><span class="hljs-comment"> * : 三轴加速度计和内部温度。</span><span class="hljs-comment"> * @param - dev: ICM20608设备</span><span class="hljs-comment"> * @return : 无。</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">icm20608_readdata</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> icm20608_dev *dev)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">14</span>];icm20608_read_regs(dev, ICM20_ACCEL_XOUT_H, data, <span class="hljs-number">14</span>);dev-&gt;accel_x_adc = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">1</span>]); dev-&gt;accel_y_adc = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">3</span>]); dev-&gt;accel_z_adc = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">5</span>]); dev-&gt;temp_adc    = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">6</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">7</span>]); dev-&gt;gyro_x_adc  = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">8</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">9</span>]); dev-&gt;gyro_y_adc  = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">10</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">11</span>]);dev-&gt;gyro_z_adc  = (<span class="hljs-type">signed</span> <span class="hljs-type">short</span>)((data[<span class="hljs-number">12</span>] &lt;&lt; <span class="hljs-number">8</span>) | data[<span class="hljs-number">13</span>]);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * ICM20608内部寄存器初始化函数 </span><span class="hljs-comment"> * @param  : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">icm20608_reginit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;u8 value = <span class="hljs-number">0</span>;icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="hljs-number">0x80</span>);mdelay(<span class="hljs-number">50</span>);icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="hljs-number">0x01</span>);mdelay(<span class="hljs-number">50</span>);value = icm20608_read_onereg(&amp;icm20608dev, ICM20_WHO_AM_I);printk(<span class="hljs-string">&quot;ICM20608 ID = %#X\r\n&quot;</span>, value);icm20608_write_onereg(&amp;icm20608dev, ICM20_SMPLRT_DIV, <span class="hljs-number">0x00</span>); <span class="hljs-comment">/* 输出速率是内部采样率*/</span>icm20608_write_onereg(&amp;icm20608dev, ICM20_GYRO_CONFIG, <span class="hljs-number">0x18</span>); <span class="hljs-comment">/* 陀螺仪±2000dps量程 */</span>icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG, <span class="hljs-number">0x18</span>); <span class="hljs-comment">/* 加速度计±16G量程 */</span>icm20608_write_onereg(&amp;icm20608dev, ICM20_CONFIG, <span class="hljs-number">0x04</span>); <span class="hljs-comment">/* 陀螺仪低通滤波BW=20Hz */</span>icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG2, <span class="hljs-number">0x04</span>); <span class="hljs-comment">/* 加速度计低通滤波BW=21.2Hz */</span>icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_2, <span class="hljs-number">0x00</span>); <span class="hljs-comment">/* 打开加速度计和陀螺仪所有轴 */</span>icm20608_write_onereg(&amp;icm20608dev, ICM20_LP_MODE_CFG, <span class="hljs-number">0x00</span>); <span class="hljs-comment">/* 关闭低功耗 */</span>icm20608_write_onereg(&amp;icm20608dev, ICM20_FIFO_EN, <span class="hljs-number">0x00</span>);<span class="hljs-comment">/* 关闭FIFO*/</span>&#125;</code></pre></div><p><strong>icm20608_read_regs 函数</strong>，从 icm20608 中读取连续多个寄存器数据。</p><p><strong>icm20608_write_regs 函数</strong>，向 icm20608 连续写入多个寄存器数据。</p><p><strong>icm20608_read_onereg 函数</strong>，读取 icm20608 指定寄存器数据。</p><p><strong>icm20608_write_onereg 函数</strong>，向 icm20608 指定寄存器写入数据。</p><p><strong>icm20608_readdata 函数</strong>，读取 icm20608 六轴传感器和温度传感器原始数据值，应用程序读取icm20608 的时候这些传感器原始数据就会上报给应用程序。</p><p><strong>icm20608_reginit 函数</strong>，初始化 icm20608，和我们 spi 裸机实验里面的初始化过程一样。</p><h4 id="5-、字符设备驱动框架"><a href="#5-、字符设备驱动框架" class="headerlink" title="5 、字符设备驱动框架"></a>5 、字符设备驱动框架</h4><p>icm20608 的字符设备驱动框架如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 打开设备</span><span class="hljs-comment"> * @param - inode : 传递给驱动的inode</span><span class="hljs-comment"> * @param - filp : 设备文件，file结构体有个叫做pr似有ate_data的成员变量</span><span class="hljs-comment"> *   一般在open的时候将private_data似有向设备结构体。</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;icm20608dev; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 从设备读取数据 </span><span class="hljs-comment"> * @param - filp : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @param - buf : 返回给用户空间的数据缓冲区</span><span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span><span class="hljs-comment"> * @param - offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">icm20608_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *off)</span>&#123;<span class="hljs-type">signed</span> <span class="hljs-type">int</span> data[<span class="hljs-number">7</span>];<span class="hljs-type">long</span> err = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icm20608_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> icm20608_dev *)filp-&gt;private_data;icm20608_readdata(dev);data[<span class="hljs-number">0</span>] = dev-&gt;gyro_x_adc;data[<span class="hljs-number">1</span>] = dev-&gt;gyro_y_adc;data[<span class="hljs-number">2</span>] = dev-&gt;gyro_z_adc;data[<span class="hljs-number">3</span>] = dev-&gt;accel_x_adc;data[<span class="hljs-number">4</span>] = dev-&gt;accel_y_adc;data[<span class="hljs-number">5</span>] = dev-&gt;accel_z_adc;data[<span class="hljs-number">6</span>] = dev-&gt;temp_adc;err = copy_to_user(buf, data, <span class="hljs-keyword">sizeof</span>(data));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 关闭/释放设备</span><span class="hljs-comment"> * @param - filp : 要关闭的设备文件(文件描述符)</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">icm20608_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* icm20608操作函数 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">icm20608_ops</span> =</span> &#123;.owner = THIS_MODULE,.open = icm20608_open,.read = icm20608_read,.release = icm20608_release,&#125;;</code></pre></div><p>字符设备驱动框架没什么好说的，重点是 icm20608_read 函数，当应用程序调用 read 函数读取 icm20608 设备文件的时候此函数就会执行。此函数调用上面编写好的icm20608_readdata 函数读取 icm20608 的原始数据并将其上报给应用程序。大家注意，在内核中尽量不要使用浮点运算，所以不要在驱动将 icm20608 的原始值转换为对应的实际值，因为会涉及到浮点计算。</p><h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3.编写测试 APP"></a>3.编写测试 APP</h3><p>新建 icm20608App.c 文件，然后在里面输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/ioctl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: main主程序</span><span class="hljs-comment"> * @param - argc : argv数组元素个数</span><span class="hljs-comment"> * @param - argv : 具体参数</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<span class="hljs-type">int</span> fd;<span class="hljs-type">char</span> *filename;<span class="hljs-type">signed</span> <span class="hljs-type">int</span> databuf[<span class="hljs-number">7</span>];<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">14</span>];<span class="hljs-type">signed</span> <span class="hljs-type">int</span> gyro_x_adc, gyro_y_adc, gyro_z_adc;<span class="hljs-type">signed</span> <span class="hljs-type">int</span> accel_x_adc, accel_y_adc, accel_z_adc;<span class="hljs-type">signed</span> <span class="hljs-type">int</span> temp_adc;<span class="hljs-type">float</span> gyro_x_act, gyro_y_act, gyro_z_act;<span class="hljs-type">float</span> accel_x_act, accel_y_act, accel_z_act;<span class="hljs-type">float</span> temp_act;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;filename = argv[<span class="hljs-number">1</span>];fd = open(filename, O_RDWR);<span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;ret = read(fd, databuf, <span class="hljs-keyword">sizeof</span>(databuf));<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 数据读取成功 */</span>gyro_x_adc = databuf[<span class="hljs-number">0</span>];gyro_y_adc = databuf[<span class="hljs-number">1</span>];gyro_z_adc = databuf[<span class="hljs-number">2</span>];accel_x_adc = databuf[<span class="hljs-number">3</span>];accel_y_adc = databuf[<span class="hljs-number">4</span>];accel_z_adc = databuf[<span class="hljs-number">5</span>];temp_adc = databuf[<span class="hljs-number">6</span>];<span class="hljs-comment">/* 计算实际值 */</span>gyro_x_act = (<span class="hljs-type">float</span>)(gyro_x_adc)  / <span class="hljs-number">16.4</span>;gyro_y_act = (<span class="hljs-type">float</span>)(gyro_y_adc)  / <span class="hljs-number">16.4</span>;gyro_z_act = (<span class="hljs-type">float</span>)(gyro_z_adc)  / <span class="hljs-number">16.4</span>;accel_x_act = (<span class="hljs-type">float</span>)(accel_x_adc) / <span class="hljs-number">2048</span>;accel_y_act = (<span class="hljs-type">float</span>)(accel_y_adc) / <span class="hljs-number">2048</span>;accel_z_act = (<span class="hljs-type">float</span>)(accel_z_adc) / <span class="hljs-number">2048</span>;temp_act = ((<span class="hljs-type">float</span>)(temp_adc) - <span class="hljs-number">25</span> ) / <span class="hljs-number">326.8</span> + <span class="hljs-number">25</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n原始值:\r\n&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;gx = %d, gy = %d, gz = %d\r\n&quot;</span>, gyro_x_adc, gyro_y_adc, gyro_z_adc);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ax = %d, ay = %d, az = %d\r\n&quot;</span>, accel_x_adc, accel_y_adc, accel_z_adc);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;temp = %d\r\n&quot;</span>, temp_adc);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;实际值:&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;act gx = %.2f°/S, act gy = %.2f°/S, act gz = %.2f°/S\r\n&quot;</span>, gyro_x_act, gyro_y_act, gyro_z_act);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;act ax = %.2fg, act ay = %.2fg, act az = %.2fg\r\n&quot;</span>, accel_x_act, accel_y_act, accel_z_act);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;act temp = %.2f°C\r\n&quot;</span>, temp_act);&#125;usleep(<span class="hljs-number">100000</span>); <span class="hljs-comment">/*100ms */</span>&#125;close(fd);<span class="hljs-comment">/* 关闭文件 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>在 while 循环中每隔 100ms 从 icm20608 中读取一次数据，读取到 icm20608原始数据以后将其转换为实际值，比如陀螺仪就是角速度、加速度计就是 g 值。注意，我们在icm20608 驱动中将陀螺仪和加速度计的测量范围全部设置到了最大，分别为±2000 和±16g。因此，在计算实际值的时候陀螺仪使用 16.4，加速度计使用 2048。最终将传感器原始数据和得到的实际值显示在终端上。</p><h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4.运行测试"></a>4.运行测试</h3><p>编译运行。</p><p>在 icm20608App.c 这个测试 APP 中我们用到了浮点计算，而 I.MX6U 是支持硬件浮点的，因此我们在编译 icm20608App.c 的时候就可以使能硬件浮点，这样可以加速浮点计算。使能硬件浮点很简单，在编译的时候加入如下参数即可：</p><div class="hljs code-wrapper"><pre><code class="hljs c">-march-armv7-a -mfpu-neon -mfloat=hard</code></pre></div><p>输入如下命令使能硬件浮点编译 icm20608App.c 这个测试程序：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-gcc -march=armv7-a -mfpu=neon -mfloat-abi=hard icm20608App.c -o icm20608App</code></pre></div><p>编译成功以后就会生成 icm20608App 这个应用程序，那么究竟有没有使用硬件浮点呢？使用 <code>arm-linux-gnueabihf-readelf</code> 查看一下编译出来的 icm20608App 就知道了，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-readelf -A icm20608App</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/19%E3%80%81Linux_SPI%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200904121240231.png" alt="image-20200904121240231"></p><p>从图 可以看出 FPU 架构为 VFPv3，SIMD 使用了 NEON，并且使用了 SP 和 DP，说明 icm20608App 这个应用程序使用了硬件浮点。</p><p>当驱动模块加载成功以后使用 icm20608App 来测试，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/icm20608App /</span>dev/icm20608</code></pre></div><p>测试 APP 会不断的从 ICM20608 中读取数据，然后输出到终端上，如图所示：</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21| Linux 电容触摸实验</title>
    <link href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-电容触摸实验"><a href="#Linux-电容触摸实验" class="headerlink" title="Linux 电容触摸实验"></a>Linux 电容触摸实验</h1><h2 id="Linux-下电容触摸屏驱动框架简介"><a href="#Linux-下电容触摸屏驱动框架简介" class="headerlink" title="Linux 下电容触摸屏驱动框架简介"></a>Linux 下电容触摸屏驱动框架简介</h2><h3 id="1-多点触摸-MT-协议详解"><a href="#1-多点触摸-MT-协议详解" class="headerlink" title="1| 多点触摸(MT) 协议详解"></a>1| 多点触摸(MT) 协议详解</h3><p><strong>电容触摸驱动的基本原理回顾一下几个重要的知识点：</strong></p><ul><li>①、电容触摸屏是 IIC 接口的，需要触摸 IC，以正点原子的 ATK7016 为例，其所使用的触摸屏控制 IC 为 FT5426，因此所谓的电容触摸驱动就是 IIC 设备驱动。</li><li>②、触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。</li><li>③、电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。</li><li>④、电容触摸屏不需要校准，当然了，这只是理论上的，如果电容触摸屏质量比较差，或者触摸玻璃和 TFT 之间没有完全对齐，那么也是需要校准的。</li></ul><p><strong>根据以上几个知识点，我们可以得出电容触摸屏驱动其实就是以下几种 linux 驱动框架的组合：</strong></p><ul><li>①、IIC 设备驱动，因为电容触摸 IC 基本都是 IIC 接口的，因此大框架就是 IIC 设备驱动。</li><li>②、通过中断引脚(INT)向 linux 内核上报触摸信息，因此需要用到 linux 中断驱动框架。坐标的上报在中断服务函数中完成。</li><li>③、触摸屏的坐标信息、屏幕按下和抬起信息都属于 linux 的 input 子系统，因此向 linux 内核上报触摸屏坐标信息就得使用 input 子系统。只是，我们得按照 linux 内核规定的规则来上报坐标信息。</li></ul><p>经过简单的分析，我们发现 IIC 驱动、中断驱动、input 子系统我们都已经在前面学过了，唯独没学过的就是 input 子系统下的多点电容触摸协议，这个才是我们本章学习的重点。linux内核中有一份文档详细的讲解了多点电容触摸屏协议，文档路径为：<code>Documentation/input/multi-touch-protocol.txt</code></p><p>老版本的 linux 内核是不支持多点电容触摸的(Multi-touch，简称 MT)，MT 协议是后面加入的，因此如果使用 2.x 版本 linux 内核的话可能找不到 MT 协议。</p><p><strong>MT 协议被分为两种类型，TypeA 和 TypeB，这两种类型的区别如下：</strong></p><ul><li>Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少！)。</li><li>Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息，FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。</li></ul><p>触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核，只有ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 linux&#x2F;input.h 中，相关事件如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">852</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_SLOT 0x2f  <span class="hljs-comment">/* MT slot being modified */</span></span><span class="hljs-number">853</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOUCH_MAJOR 0x30  <span class="hljs-comment">/* Major axis of touching ellipse */</span></span><span class="hljs-number">854</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOUCH_MINOR 0x31  <span class="hljs-comment">/* Minor axis (omit if circular) */</span></span><span class="hljs-number">855</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_WIDTH_MAJOR 0x32  <span class="hljs-comment">/* Major axis of approaching ellipse */</span></span><span class="hljs-number">856</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_WIDTH_MINOR 0x33  <span class="hljs-comment">/* Minor axis (omit if circular) */</span></span><span class="hljs-number">857</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_ORIENTATION 0x34  <span class="hljs-comment">/* Ellipse orientation */</span></span><span class="hljs-number">858</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_POSITION_X 0x35  <span class="hljs-comment">/* Center X touch position */</span></span><span class="hljs-number">859</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_POSITION_Y 0x36  <span class="hljs-comment">/* Center Y touch position */</span></span><span class="hljs-number">860</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOOL_TYPE 0x37  <span class="hljs-comment">/* Type of touching device */</span></span><span class="hljs-number">861</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_BLOB_ID 0x38  <span class="hljs-comment">/* Group a set of packets as a blob */</span></span><span class="hljs-number">862</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TRACKING_ID 0x39  <span class="hljs-comment">/* Unique ID of initiated contact */</span></span><span class="hljs-number">863</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_PRESSURE 0x3a  <span class="hljs-comment">/* Pressure on contact area */</span></span><span class="hljs-number">864</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_DISTANCE 0x3b  <span class="hljs-comment">/* Contact hover distance */</span></span><span class="hljs-number">865</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOOL_X 0x3c  <span class="hljs-comment">/* Center X tool position */</span></span><span class="hljs-number">866</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS_MT_TOOL_Y 0x3d  <span class="hljs-comment">/* Center Y tool position */</span></span></code></pre></div><p>在 上 面 这 些 众 多 的 ABS_MT 事 件 中 ， 我 们 最 常 用 的 就 是 <strong>ABS_MT_SLOT</strong> 、<strong>ABS_MT_POSITION_X</strong> 、 <strong>ABS_MT_POSITION_Y</strong> 和 <strong>ABS_MT_TRACKING_ID</strong> 。 其 中ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 用来上报触摸点的(X,Y)坐标信息，ABS_MT_SLOT 用 来 上 报 触 摸 点 ID ， 对 于 Type B 类 型 的 设 备 ， 需 要 用 到ABS_MT_TRACKING_ID 事件来区分触摸点。</p><p><strong>对于 Type A 类型的设备</strong>，通过 input_mt_sync()函数来隔离不同的触摸点数据信息，此函数原型如下所示</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div><p>此函数只要一个参数，类型为 input_dev，用于指定具体的 input_dev 设备。input_mt_sync()函数会触发 SYN_MT_REPORT 事件，此事件会通知接收者获取当前触摸数据，并且准备接收下一个触摸点数据。</p><hr><p><strong>对于 Type B 类型的设备</strong>，上报触摸点信息的时候需要通过 input_mt_slot()函数区分是哪一个触摸点，input_mt_slot()函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_slot</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">int</span> slot)</span></code></pre></div><p>此函数有两个参数，第一个参数是 input_dev 设备，第二个参数 slot 用于指定当前上报的是哪个触摸点信息。input_mt_slot()函数会触发 ABS_MT_SLOT 事件，此事件会告诉接收者当前正在更新的是哪个触摸点(slot)的数据。</p><hr><p>不管是哪个类型的设备，最终都要调用 input_sync()函数来标识多点触摸信息传输完成，告诉接收者处理之前累计的所有消息，并且准备好下一次接收。</p><p>Type B 和 Type A 相比最大的区别就是 Type B 可以区分出触摸点， 因此可以减少发送到用户空间的数据。Type B 使用 slot 协议区分具体的触摸点，slot 需要用到 ABS_MT_TRACKING_ID 消息，这个 ID 需要硬件提供，或者通过原始数据计算出来。</p><p>对于 Type A 设备，内核驱动需要一次性将触摸屏上所有的触摸点信息全部上报，每个触摸点的信息在本次上报事件流中的顺序不重要，因为事件的过滤和手指(触摸点)跟踪是在内核空间处理的。</p><p>Type B 设备驱动需要给每个识别出来的触摸点分配一个 slot，后面使用这个 slot 来上报触摸点信息。可以通过 slot 的 ABS_MT_TRACKING_ID 来新增、替换或删除触摸点。一个非负数的 ID 表示一个有效的触摸点，-1 这个 ID 表示未使用 slot。一个以前不存在的 ID 表示这是一个新加的触摸点，一个 ID 如果再也不存在了就表示删除了。</p><p>有些设备识别或追踪的触摸点信息要比他上报的多，这些设备驱动应该给硬件上报的每个触摸点分配一个 Type B 的 slot。一旦检测到某一个 slot 关联的触摸点 ID 发生了变化，驱动就应该改变这个 slot 的 ABS_MT_TRACKING_ID，使这个 slot 失效。如果硬件设备追踪到了比他正在上报的还要多的触摸点，那么驱动程序应该发送 BTN_TOOL_*TAP 消息，并且调用input_mt_report_pointer_emulation()函数，将此函数的第二个参数 use_count 设置为 false。</p><h3 id="2-Type-A-触摸点信息上报时序"><a href="#2-Type-A-触摸点信息上报时序" class="headerlink" title="2| Type A 触摸点信息上报时序"></a>2| Type A 触摸点信息上报时序</h3><p>对于 Type A 类型的设备，发送触摸点信息的时序如下所示，这里以 2 个触摸点为例：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ABS_MT_POSITION_X x[<span class="hljs-number">0</span>]<span class="hljs-number">2</span> ABS_MT_POSITION_Y y[<span class="hljs-number">0</span>]<span class="hljs-number">3</span> SYN_MT_REPORT<span class="hljs-number">4</span> ABS_MT_POSITION_X x[<span class="hljs-number">1</span>]<span class="hljs-number">5</span> ABS_MT_POSITION_Y y[<span class="hljs-number">1</span>]<span class="hljs-number">6</span> SYN_MT_REPORT<span class="hljs-number">7</span> SYN_REPORT</code></pre></div><p>第 1 行，通过 ABS_MT_POSITION_X 事件上报第一个触摸点的 X 坐标数据，<strong>通过input_report_abs 函数实现</strong>，下面同理。<br>第 2 行，通过 ABS_MT_POSITION_Y 事件上报第一个触摸点的 Y 坐标数据。<br>第 3 行，上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。<br>第 4 行，通过 ABS_MT_POSITION_X 事件上报第二个触摸点的 X 坐标数据。<br>第 5 行，通过 ABS_MT_POSITION_Y 事件上报第二个触摸点的 Y 坐标数据。<br>第 6 行，上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。<br>第 7 行，上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</p><p>我们在编写 Type A 类型的多点触摸驱动的时候就需要按照示例代码中的时序上报坐标信息。Linux 内核里面也有 Type A 类型的多点触摸驱动，找到 st2332.c 这个驱动文件，路径为 drivers&#x2F;input&#x2F;touchscreen&#x2F;st1232.c，找到 st1232_ts_irq_handler 函数，此函数里面就是上报触摸点坐标信息的。</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">103</span> <span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">st1232_ts_irq_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>104 &#123;......<span class="hljs-number">111</span> ret = st1232_ts_read_data(ts);<span class="hljs-number">112</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<span class="hljs-number">113</span> <span class="hljs-keyword">goto</span> end;<span class="hljs-number">114</span><span class="hljs-number">115</span> <span class="hljs-comment">/* multi touch protocol */</span><span class="hljs-number">116</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_FINGERS; i++) &#123;<span class="hljs-number">117</span> <span class="hljs-keyword">if</span> (!finger[i].is_valid)<span class="hljs-number">118</span> <span class="hljs-keyword">continue</span>;<span class="hljs-number">119</span><span class="hljs-number">120</span> input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, finger[i].t);<span class="hljs-number">121</span> input_report_abs(input_dev, ABS_MT_POSITION_X, finger[i].x);<span class="hljs-number">122</span> input_report_abs(input_dev, ABS_MT_POSITION_Y, finger[i].y);<span class="hljs-number">123</span> input_mt_sync(input_dev);<span class="hljs-number">124</span> count++;<span class="hljs-number">125</span> &#125;......<span class="hljs-number">140</span><span class="hljs-number">141</span> <span class="hljs-comment">/* SYN_REPORT */</span><span class="hljs-number">142</span> input_sync(input_dev);<span class="hljs-number">143</span><span class="hljs-number">144</span> end:<span class="hljs-number">145</span> <span class="hljs-keyword">return</span> IRQ_HANDLED;<span class="hljs-number">146</span> &#125;</code></pre></div><ul><li>第 111 行，获取所有触摸点信息。</li><li>第 116~125 行，按照 Type A 类型轮流上报所有的触摸点坐标信息，第 121 和 122 行分别上报触摸点的(X,Y)轴坐标，也就是 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 事件。每上报完一个触摸点坐标，都要在第 123 行调用 input_mt_sync 函数上报一个 SYN_MT_REPORT信息。</li><li>第 142 行，每上报完一轮触摸点信息就调用一次 input_sync 函数，也就是发送一个SYN_REPORT 事件</li></ul><h3 id="3-Type-B-触摸点信息上报时序"><a href="#3-Type-B-触摸点信息上报时序" class="headerlink" title="3| Type B  触摸点信息上报时序"></a>3| Type B  触摸点信息上报时序</h3><p>对于 Type B 类型的设备，发送触摸点信息的时序如下所示，这里以 2 个触摸点为例：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ABS_MT_SLOT <span class="hljs-number">0</span><span class="hljs-number">2</span> ABS_MT_TRACKING_ID <span class="hljs-number">45</span><span class="hljs-number">3</span> ABS_MT_POSITION_X x[<span class="hljs-number">0</span>]<span class="hljs-number">4</span> ABS_MT_POSITION_Y y[<span class="hljs-number">0</span>]<span class="hljs-number">5</span> ABS_MT_SLOT <span class="hljs-number">1</span><span class="hljs-number">6</span> ABS_MT_TRACKING_ID <span class="hljs-number">46</span><span class="hljs-number">7</span> ABS_MT_POSITION_X x[<span class="hljs-number">1</span>]<span class="hljs-number">8</span> ABS_MT_POSITION_Y y[<span class="hljs-number">1</span>]<span class="hljs-number">9</span> SYN_REPORT</code></pre></div><ul><li>第 1 行，上报 ABS_MT_SLOT 事件，也就是触摸点对应的 SLOT。每次上报一个触摸点坐标之前要先使用input_mt_slot函数上报当前触摸点SLOT，触摸点的SLOT其实就是触摸点ID，需要由触摸 IC 提供。</li><li>第 2 行，根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。具体用到的函数就是input_mt_report_slot_state，如果是添加一个新的触摸点，那么此函数的第三个参数active 要设置为 true，linux 内核会自动分配一个 ABS_MT_TRACKING_ID 值，不需要用户去指定具体的 ABS_MT_TRACKING_ID 值。</li><li>第 3 行，上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成。</li><li>第 4 行，上报触摸点 0 的 Y 轴坐标，使用函数 input_report_abs 来完成。</li><li>第 5<del>8 行，和第 1</del>4 行类似，只是换成了上报触摸点 0 的(X,Y)坐标信息</li><li>第9行，当所有的触摸点坐标都上传完毕以后就得发送SYN_REPORT事件，使用input_sync函数来完成。</li></ul><p>当一个触摸点移除以后，同样需要通过 SLOT 关联的 ABS_MT_TRACKING_ID 来处理，时序如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ABS_MT_TRACKING_ID <span class="hljs-number">-1</span><span class="hljs-number">2</span> SYN_REPORT</code></pre></div><ul><li>第 1 行，当一个触摸点(SLOT)移除以后，需要通过 ABS_MT_TRACKING_ID 事件发送一个-1 给内核。方法很简单，同样使用 input_mt_report_slot_state 函数来完成，只需要将此函数的第三个参数 active 设置为 false 即可，不需要用户手动去设置-1。</li><li>第 2 行，当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件。</li></ul><p>当要编写 Type B 类型的多点触摸驱动的时候就需要按照示例代码中的时序上报坐标信息。Linux 内核里面有大量的 Type B 类型的多点触摸驱动程序，我们可以参考这些现成的驱动程序来编写自己的驱动代码。这里就以 ili210x 这个触摸驱动 IC 为例，看看是 Type B 类型是 如 何 上 报 触 摸 点 坐 标 信 息 的 。 找 到 ili210x.c 这 个 驱 动 文 件 ， 路 径 为drivers&#x2F;input&#x2F;touchscreen&#x2F;ili210x.c，找到 ili210x_report_events 函数，此函数就是用于上报 ili210x触摸坐标信息的，函数内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">78</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ili210x_report_events</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *input,</span><span class="hljs-params"><span class="hljs-number">79</span>   <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> touchdata *touchdata)</span>80 &#123;<span class="hljs-number">81</span> <span class="hljs-type">int</span> i;<span class="hljs-number">82</span> <span class="hljs-type">bool</span> touch;<span class="hljs-number">83</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x, y;<span class="hljs-number">84</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">finger</span> *<span class="hljs-title">finger</span>;</span><span class="hljs-number">85</span><span class="hljs-number">86</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_TOUCHES; i++) &#123;<span class="hljs-number">87</span> input_mt_slot(input, i);<span class="hljs-number">88</span><span class="hljs-number">89</span> finger = &amp;touchdata-&gt;finger[i];<span class="hljs-number">90</span><span class="hljs-number">91</span> touch = touchdata-&gt;status &amp; (<span class="hljs-number">1</span> &lt;&lt; i);<span class="hljs-number">92</span> input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);<span class="hljs-number">93</span> <span class="hljs-keyword">if</span> (touch) &#123;<span class="hljs-number">94</span> x = finger-&gt;x_low | (finger-&gt;x_high &lt;&lt; <span class="hljs-number">8</span>);<span class="hljs-number">95</span> y = finger-&gt;y_low | (finger-&gt;y_high &lt;&lt; <span class="hljs-number">8</span>);<span class="hljs-number">96</span><span class="hljs-number">97</span> input_report_abs(input, ABS_MT_POSITION_X, x);<span class="hljs-number">98</span> input_report_abs(input, ABS_MT_POSITION_Y, y);<span class="hljs-number">99</span> &#125;<span class="hljs-number">100</span> &#125;<span class="hljs-number">101</span><span class="hljs-number">102</span> input_mt_report_pointer_emulation(input, <span class="hljs-literal">false</span>);<span class="hljs-number">103</span> input_sync(input);<span class="hljs-number">104</span> &#125;</code></pre></div><ul><li>第 86~100 行，使用 for 循环实现上报所有的触摸点坐标，第 87 行调用 input_mt_slot 函数上 报 ABS_MT_SLOT 事 件 。 第 92 行 调 用 input_mt_report_slot_state 函 数 上 报ABS_MT_TRACKING_ID 事件，也就是给 SLOT 关联一个 ABS_MT_TRACKING_ID。第 97 和98 行使用 input_report_abs 函数上报触摸点对应的(X,Y)坐标值。</li><li>第 103 行，使用 input_sync 函数上报 SYN_REPORT 事件。</li></ul><h3 id="4-MT-其他事件的使用"><a href="#4-MT-其他事件的使用" class="headerlink" title="4| MT  其他事件的使用"></a>4| MT  其他事件的使用</h3><p>在前面示例代码 中给出了 Linux 所支持的所有 ABS_MT 事件，大家可以根据实际需求将 这 些 事 件 组 成 各 种 事 件 组 合 。 最 简 单 的 组 合 就 是 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y，可以通过在这两个事件上报触摸点，如果设备支持的话，还可以使用ABS_MT_TOUCH_MAJOR 和ABS_MT_WIDTH_MAJOR 这两个消息上报触摸面积信息，关于其他 ABS_MT 事件的具体含义大家可以查看 Linux 内核中的 multi-touch-protocol.txt 文档，这里我们重点补充一下 ABS_MT_TOOL_TYPE 事件。</p><p><strong>ABS_MT_TOOL_TYPE 事件</strong>用于上报触摸工具类型，很多内核驱动都不能区分出触摸设备类型，是手指还是触摸笔？这种情况下，这个事件可以忽略掉。</p><p>目前的协议支持MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)和 MT_TOOL_PALM(手掌)这三种触摸设备类型， 于 Type B 类型，此事件 由 input 子系统内核处理。 如果驱动程序需要上 报ABS_MT_TOOL_TYPE 事件，那么可以使用 input_mt_report_slot_state 函数来完成此工作。</p><p>关于 Linux 系统下的多点触摸(MT)协议就讲解到这里，简单总结一下，MT 协议隶属于 linux的 input 子系统，驱动通过大量的 ABS_MT 事件向 linux 内核上报多点触摸坐标数据。根据触摸 IC 的不同，分为 Type A 和 Type B 两种类型，不同的类型其上报时序不同，目前使用最多的是 Type B 类型。接下来我们就根据前面学习过的 MT 协议来编写一个多点电容触摸驱动程序，</p><p>本章节所使用的触摸屏是正点原子的 ATK7084(7 寸 800<em>480)和 ATK7016(7 寸 1024</em>600)这两款触摸屏，这两款触摸屏都使用 FT5426 这款触摸 IC，因此驱动程序是完全通用的。</p><h3 id="5-多点触摸所使用到的-API-函数"><a href="#5-多点触摸所使用到的-API-函数" class="headerlink" title="5| 多点触摸所使用到的 API  函数"></a>5| 多点触摸所使用到的 API  函数</h3><p>根据前面的讲解，我们知道 linux 下的多点触摸协议其实就是通过不同的事件来上报触摸点坐标信息，这些事件都是通过 Linux 内核提供的对应 API 函数实现的，本小节我们来看一下一些常见的 API 函数。</p><h4 id="1-、input-mt-init-slots-函数"><a href="#1-、input-mt-init-slots-函数" class="headerlink" title="1 、input_mt_init_slots  函数"></a>1 、input_mt_init_slots  函数</h4><p><strong>input_mt_init_slots 函数用于初始化 MT 的输入 slots</strong>，编写 MT 驱动的时候必须先调用此函<br>数初始化 slots，此函数定义在文件 drivers&#x2F;input&#x2F;input-mt.c 中，函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">input_mt_init_slots</span><span class="hljs-params">( <span class="hljs-keyword">struct</span> input_dev *dev,</span><span class="hljs-params">                        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_slots,</span><span class="hljs-params">                        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev。<br><strong>num_slots</strong>：设备要使用的 SLOT 数量，也就是触摸点的数量。<br><strong>flags</strong> ：其他一些 flags 信息，可设置的 flags 如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_POINTER  0x0001 <span class="hljs-comment">/* pointer device, e.g. trackpad */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_DIRECT  0x0002 <span class="hljs-comment">/* direct device, e.g. touchscreen */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_DROP_UNUSED 0x0004 <span class="hljs-comment">/* drop contacts not seen in frame */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_TRACK  0x0008 <span class="hljs-comment">/* use in-kernel tracking */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MT_SEMI_MT 0x0010 <span class="hljs-comment">/* semi-mt device, finger count handled manually */</span></span></code></pre></div><p>可以采用‘|’运算来同时设置多个 flags 标识。<br><strong>返回值</strong>：0，成功；负值，失败。</p><h4 id="2-、input-mt-slot"><a href="#2-、input-mt-slot" class="headerlink" title="2 、input_mt_slot"></a>2 、input_mt_slot</h4><p>此函数用于 Type B 类型，此函数用于产生 ABS_MT_SLOT 事件，告诉内核当前上报的是哪个触摸点的坐标数据，此函数定义在文件 include&#x2F;linux&#x2F;input&#x2F;mt.h 中，函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_slot</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev,</span><span class="hljs-params">                   <span class="hljs-type">int</span> slot)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev。<br><strong>slot</strong>：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点。<br><strong>返回值</strong>：无。</p><h4 id="3-、input-mt-report-slot-state-函数"><a href="#3-、input-mt-report-slot-state-函数" class="headerlink" title="3 、input_mt_report_slot_state  函数"></a>3 、input_mt_report_slot_state  函数</h4><p>此函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE事 件 ， ABS_MT_TRACKING_ID 事 件 给 slot 关 联 一 个 ABS_MT_TRACKING_ID ，ABS_MT_TOOL_TYPE 事件指定触摸类型（是笔还是手指等）。此函数定义在文件drivers&#x2F;input&#x2F;input-mt.c 中，此函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_report_slot_state</span><span class="hljs-params">( <span class="hljs-keyword">struct</span> input_dev *dev,</span><span class="hljs-params">                                <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tool_type,</span><span class="hljs-params">                                <span class="hljs-type">bool</span> active)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev。<br><strong>tool_type</strong>：触摸类型，可以选择 MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或MT_TOOL_PALM(手掌)，对于多点电容触摸屏来说一般都是手指。<br><strong>active</strong>：true，连续触摸，input子系统内核会自动分配一个ABS_MT_TRACKING_ID 给 slot ; false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个-1 给 slot，表示触摸点溢出。<br><strong>返回值</strong>：无。</p><h4 id="4-、input-report-abs-函数"><a href="#4-、input-report-abs-函数" class="headerlink" title="4 、input_report_abs  函数"></a>4 、input_report_abs  函数</h4><p>Type A 和 Type B 类型都使用此函数上报触摸点坐标信息，通过 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y 事 件 实 现 X 和 Y 轴 坐 标 信 息 上 报 。 此 函 数 定 义 在 文 件include&#x2F;linux&#x2F;input.h 中，函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_report_abs</span><span class="hljs-params">( <span class="hljs-keyword">struct</span> input_dev *dev,</span><span class="hljs-params">                      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code,</span><span class="hljs-params">                      <span class="hljs-type">int</span> value)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev。<br><strong>code</strong>：要上报的是什么数据，可以设置为 ABS_MT_POSITION_X 或 ABS_MT_POSITION_Y，也就是 X 轴或者 Y 轴坐标数据。<br><strong>value</strong>：具体的 X 轴或 Y 轴坐标数据值。<br><strong>返回值</strong>：无。</p><h4 id="5-、input-mt-report-pointer-emulation-函数"><a href="#5-、input-mt-report-pointer-emulation-函数" class="headerlink" title="5 、input_mt_report_pointer_emulation  函数"></a>5 、input_mt_report_pointer_emulation  函数</h4><p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量，然后调用 input_mt_report_pointer_emulation 函数将use_count 参数设置为false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)，此函数定义在文件 drivers&#x2F;input&#x2F;input-mt.c中，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_report_pointer_emulation</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev,</span><span class="hljs-params">                                       <span class="hljs-type">bool</span> use_count)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong> ： MT 设备对应的 input_dev。<br><strong>use_count</strong>：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量。<br><strong>返回值</strong>：无。</p><h3 id="6-多点电容触摸驱动框架"><a href="#6-多点电容触摸驱动框架" class="headerlink" title="6| 多点电容触摸驱动框架"></a>6| 多点电容触摸驱动框架</h3><p>前面几小节已经详细的讲解了 linux 下多点触摸屏驱动原理，本小节我们来梳理一下 linux下多点电容触摸驱动的编写框架和步骤。首先确定驱动需要用到哪些知识点，哪些框架？根据前面的分析，我们在编写驱动的时候需要注意一下几点：</p><p>①、多点电容触摸芯片的接口，一般都为 I2C 接口，因此驱动主框架肯定是 I2C。<br>②、linux 里面一般都是通过中断来上报触摸点坐标信息，因此需要用到中断框架。<br>③、多点电容触摸属于 input 子系统，因此还要用到 input 子系统框架。<br>④、在中断处理程序中按照 linux 的 MT 协议上报坐标信息。</p><p>根据上面的分析，多点电容触摸驱动编写框架以及步骤如下：</p><h4 id="1-、I2C-驱动框架"><a href="#1-、I2C-驱动框架" class="headerlink" title="1 、I2C  驱动框架"></a>1 、I2C  驱动框架</h4><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 设备树匹配表 */</span><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">xxx_ts_id</span>[] =</span> &#123;<span class="hljs-number">3</span> &#123; <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">0</span>, &#125;,<span class="hljs-number">4</span> &#123; <span class="hljs-comment">/* sentinel */</span> &#125;<span class="hljs-number">5</span> &#125;;<span class="hljs-number">6</span><span class="hljs-number">7</span> <span class="hljs-comment">/* 设备树匹配表 */</span><span class="hljs-number">8</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;<span class="hljs-number">9</span> &#123; .compatible = <span class="hljs-string">&quot;xxx&quot;</span>, &#125;,<span class="hljs-number">10</span> &#123; <span class="hljs-comment">/* sentinel */</span> &#125;<span class="hljs-number">11</span> &#125;;<span class="hljs-number">12</span><span class="hljs-number">13</span> <span class="hljs-comment">/* i2c 驱动结构体 */</span><span class="hljs-number">14</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">ft5x06_ts_driver</span> =</span> &#123;<span class="hljs-number">15</span> .driver = &#123;<span class="hljs-number">16</span> .owner = THIS_MODULE,<span class="hljs-number">17</span> .name = <span class="hljs-string">&quot;edt_ft5x06&quot;</span>,<span class="hljs-number">18</span> .of_match_table = of_match_ptr(xxx_of_match),<span class="hljs-number">19</span> &#125;,<span class="hljs-number">20</span> .id_table = xxx_ts_id,<span class="hljs-number">21</span> .probe = xxx_ts_probe,<span class="hljs-number">22</span> .remove = xxx_ts_remove,<span class="hljs-number">23</span> &#125;;<span class="hljs-number">24</span><span class="hljs-number">25</span> <span class="hljs-comment">/*</span><span class="hljs-comment">26 * @description : 驱动入口函数</span><span class="hljs-comment">27 * @param : 无</span><span class="hljs-comment">28 * @return : 无</span><span class="hljs-comment">29 */</span><span class="hljs-number">30</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>31 &#123;<span class="hljs-number">32</span> <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-number">33</span><span class="hljs-number">34</span> ret = i2c_add_driver(&amp;xxx_ts_driver);<span class="hljs-number">35</span><span class="hljs-number">36</span> <span class="hljs-keyword">return</span> ret;<span class="hljs-number">37</span> &#125;<span class="hljs-number">38</span><span class="hljs-number">39</span> <span class="hljs-comment">/*</span><span class="hljs-comment">40 * @description : 驱动出口函数</span><span class="hljs-comment">41 * @param : 无</span><span class="hljs-comment">42 * @return : 无</span><span class="hljs-comment">43 */</span><span class="hljs-number">44</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>45 &#123;<span class="hljs-number">46</span> i2c_del_driver(&amp;ft5x06_ts_driver);<span class="hljs-number">47</span> &#125;<span class="hljs-number">48</span><span class="hljs-number">49</span> module_init(xxx_init);<span class="hljs-number">50</span> module_exit(xxx_exit);<span class="hljs-number">51</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-number">52</span> MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>I2C 驱动框架已经进行了详细的讲解，这里就不再赘述了。当设备树中触摸 IC的设备节点和驱动匹配以后，示例代码中第 21 行的 xxx_ts_probe 函数就会执行，我们可以在此函数中初始化触摸 IC，中断和 input 子系统等。</p><h4 id="2、初始化触摸-IC-、中断和-input-子系统"><a href="#2、初始化触摸-IC-、中断和-input-子系统" class="headerlink" title="2、初始化触摸 IC 、中断和 input 子系统"></a>2、初始化触摸 IC 、中断和 input 子系统</h4><p>初始化操作都是在 xxx_ts_probe 函数中完成，参考框架如下所示(以下代码中步骤顺序可以自行调整，不一定按照示例框架来)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_ts_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>2 &#123;<span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input</span>;</span><span class="hljs-number">4</span><span class="hljs-number">5</span> <span class="hljs-comment">/* 1、初始化 I2C */</span><span class="hljs-number">6</span> ......<span class="hljs-number">7</span><span class="hljs-number">8</span> <span class="hljs-comment">/* 2，申请中断， */</span><span class="hljs-number">9</span> devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="hljs-literal">NULL</span>,<span class="hljs-number">10</span> xxx_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,<span class="hljs-number">11</span> client-&gt;name, &amp;xxx);<span class="hljs-number">12</span> ......<span class="hljs-number">13</span><span class="hljs-number">14</span> <span class="hljs-comment">/* 3，input 设备申请与初始化 */</span><span class="hljs-number">15</span> input = devm_input_allocate_device(&amp;client-&gt;dev);<span class="hljs-number">16</span><span class="hljs-number">17</span> input-&gt;name = client-&gt;name;<span class="hljs-number">18</span> input-&gt;id.bustype = BUS_I2C;<span class="hljs-number">19</span> input-&gt;dev.parent = &amp;client-&gt;dev;<span class="hljs-number">20</span> ......<span class="hljs-number">21</span><span class="hljs-number">22</span> <span class="hljs-comment">/* 4，初始化 input 和 MT */</span><span class="hljs-number">23</span> __set_bit(EV_ABS, input-&gt;evbit);<span class="hljs-number">24</span> __set_bit(BTN_TOUCH, input-&gt;keybit);<span class="hljs-number">25</span><span class="hljs-number">26</span> input_set_abs_params(input, ABS_X, <span class="hljs-number">0</span>, width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-number">27</span> input_set_abs_params(input, ABS_Y, <span class="hljs-number">0</span>, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-number">28</span> input_set_abs_params(input, ABS_MT_POSITION_X,<span class="hljs-number">0</span>, width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-number">29</span> input_set_abs_params(input, ABS_MT_POSITION_Y,<span class="hljs-number">0</span>, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-number">30</span> input_mt_init_slots(input, MAX_SUPPORT_POINTS, <span class="hljs-number">0</span>);<span class="hljs-number">31</span> ......<span class="hljs-number">32</span><span class="hljs-number">33</span> <span class="hljs-comment">/* 5，注册 input_dev */</span><span class="hljs-number">34</span> input_register_device(input);<span class="hljs-number">35</span> ......<span class="hljs-number">36</span> &#125;</code></pre></div><ul><li><p>第 5~7 行，首先肯定是初始化触摸芯片，包括芯片的相关 IO，比如复位、中断等 IO 引脚，然后就是芯片本身的初始化，也就是配置触摸芯片的相关寄存器。</p></li><li><p>第 9 行，因为一般触摸芯片都是通过中断来向系统上报触摸点坐标信息的，因此我们需要初始化中断，这里又和第五十一章内容结合起来了。大家可能会发现第 9 行并没有使用request_irq 函数申请中断，而是采用了 devm_request_threaded_irq 这个函数，为什么使用这个函数呢？是不是 request_irq 函数不能使用？答案肯定不是的，这里用 request_irq 函数是绝对没问题的。那为何要用devm_request_threaded_irq 呢？这里我们就简单的介绍一下这个 API 函数，devm_request_threaded_irq 函数特点如下：</p><ul><li>①、用于申请中断，作用和 request_irq 函数类似。</li><li>②、此函数的作用是中断线程化，大家如果直接在网上搜索“devm_request_threaded_irq”会发现相关解释很少。但是大家去搜索 request_threaded_irq 函数就会有很多讲解的博客和帖子，这两个函数在名字上的差别就是前者比后者多了个“devm_”前缀，“devm_”前缀稍后讲解。大家应该注意到了“request_threaded_irq”相比“request_irq”多了个 threaded 函数，也就是线程的意思。那么为什么要中断线程化呢？我们都是知道硬件中断具有最高优先级，不论什么时候只要硬件中断发生，那么内核都会终止当前正在执行的操作，转而去执行中断处理程序(不考虑关闭中断和中断优先级的情况)，如果中断非常频繁的话那么内核将会频繁的执行中断处理程序，导致任务得不到及时的处理。中断线程化以后中断将作为内核线程运行，而且也可以被赋予不同的优先级，任务的优先级可能比中断线程的优先级高，这样做的目的就是保证高优先级的任务能被优先处理。大家可能会疑问，前面不是说可以将比较耗时的中断放到下半部(bottom half)处理吗？虽然下半部可以被延迟处理，但是依旧先于线程执行，中断线程化可以让这些比<br>较耗时的下半部与进程进行公平竞争。要注意，并不是所有的中断都可以被线程化，重要的中断就不能这么操作。对于触摸屏而言只要手指放到屏幕上，它可能就会一直产生中断(视具体芯片而定，FT5426 是这样的)，中断处理程序里面需要通过 I2C 读取触摸信息并上报给内核，I2C 的速度最大只有 400KHz，算是低速外设。不断的产生中断、读取触摸信息、上报信息会导致处理器在触摸中断上花费大量的时间，但是触摸相对来说不是那么重要的事件，因此可以将触摸中断线程化。如果你觉得触摸中断很重要，那么就可以不将其进行线程化处理。总之，要不要将一个中断进行线程化处理是需要自己根据实际情况去衡量的。linux 内核自带的 goodix.c(汇顶科技)、mms114.c(MELFAS 公司)、zforce_ts.c(zForce 公司)等多点电容触摸 IC 驱动程序都采用了中断线程化，当然也有一些驱动没有采用中断线程化。</li><li>③、最后来看一下“devm_”前缀，在 linux 内核中有很多的申请资源类的 API 函数都有对应的“devm_”前缀版本。比如 devm_request_irq 和 request_irq 这两个函数，这两个函数都是申请中断的，我们使用 request_irq 函数申请中断的时候，如果驱动初始化失败的话就要调用free_irq 函数对申请成功的 irq 进行释放，卸载驱动的时候也需要我们手动调用 free_irq 来释放irq。假如我们的驱动里面申请了很多资源，比如：gpio、irq、input_dev，那么就需要添加很多goto 语句对其做处理，当这样的标签多了以后代码看起来就不整洁了。“devm_”函数就是为了处理这种情况而诞生的，“devm_”函数最大的作用就是：<ul><li>使用“devm_ ”前缀的函数申请到的资源可以由系统自动释放，不需要我们手动处理。如果我们使用 devm_request_threaded_irq 函数来申请中断，那么就不需要我们再调用free_irq 函数对其进行释放。大家可以注意一下，带有“devm_”前缀的都是一些和设备资源管理有关的函数。关于“devm_”函数的实现原理这里就不做详细的讲解了，我们的重点在于学会如何使用这些 API 函数，感兴趣的可以查阅一些其他文档或者帖子来看一下“devm_”函数的实现原理。</li></ul></li></ul></li><li><p>第 15 行，接下来就是申请 input_dev，因为多点电容触摸属于 input 子系统。这里同样使用devm_input_allocate_device 函数来申请 input_dev，也就是我们前面讲解的 input_allocate_device函数加“devm_”前缀版本。申请到 input_dev 以后还需要对其进行初始化操作。</p></li><li><p>第 23~24 行，设置 input_dev 需要上报的事件为 EV_ABS 和 BTN_TOUCH，因为多点电容屏的触摸坐标为绝对值，因此需要上报 EV_ABS 事件。触摸屏有按下和抬起之分，因此需要上报 BTN_TOUCH 按键。</p></li><li><p>第 26~29 行，调用 input_set_abs_params 函数设置 EV_ABS 事件需要上报 ABS_X、ABS_Y、ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。单点触摸需要上报 ABS_X 和 ABS_Y，对于多点触摸需要上报 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。</p></li><li><p>第 30 行，调用 input_mt_init_slots 函数初始化多点电容触摸的 slots。</p></li><li><p>第 34 行，调用 input_register_device 函数系统注册前面申请到的 input_dev。</p></li></ul><h4 id="3、上报坐标信息"><a href="#3、上报坐标信息" class="headerlink" title="3、上报坐标信息"></a>3、上报坐标信息</h4><p>最后就是在中断服务程序中上报读取到的坐标信息，根据所使用的多点电容触摸设备类型选择使用 Type A 还是 Type B 时序。由于大多数的设备都是 Type B 类型，因此这里就以 Type B类型为例讲解一下上报过程，参考驱动框架如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">xxx_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>2 &#123;<span class="hljs-number">3</span><span class="hljs-number">4</span> <span class="hljs-type">int</span> num; <span class="hljs-comment">/* 触摸点数量 */</span><span class="hljs-number">5</span> <span class="hljs-type">int</span> x[n], y[n]; <span class="hljs-comment">/* 保存坐标值 */</span><span class="hljs-number">6</span><span class="hljs-number">7</span> <span class="hljs-comment">/* 1、从触摸芯片获取各个触摸点坐标值 */</span><span class="hljs-number">8</span> ......<span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-comment">/* 2、上报每一个触摸点坐标 */</span><span class="hljs-number">11</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<span class="hljs-number">12</span> input_mt_slot(input, id);<span class="hljs-number">13</span> input_mt_report_slot_state(input, MT_TOOL_FINGER, <span class="hljs-literal">true</span>);<span class="hljs-number">14</span> input_report_abs(input, ABS_MT_POSITION_X, x[i]);<span class="hljs-number">15</span> input_report_abs(input, ABS_MT_POSITION_Y, y[i]);<span class="hljs-number">16</span> &#125;<span class="hljs-number">17</span> ......<span class="hljs-number">18</span><span class="hljs-number">19</span> input_sync(input);<span class="hljs-number">20</span> ......<span class="hljs-number">21</span><span class="hljs-number">22</span> <span class="hljs-keyword">return</span> IRQ_HANDLED;<span class="hljs-number">23</span> &#125;</code></pre></div><p>进入中断处理程序以后首先肯定是从触摸 IC 里面读取触摸坐标以及触摸点数量，假设触摸点数量保存到 num 变量，触摸点坐标存放到 x，y 数组里面。</p><ul><li>第 11~16 行，循环上报每一个触摸点坐标，一定要按照 Type B 类型的时序进行，这个已经在前面小节进行详细的讲解，这里就不再赘述了。</li><li>第 19 行，每一轮触摸点坐标上报完毕以后就调用一次 input_sync 函数发送一个SYN_REPORT 事件。</li></ul><p>关于多点电容触摸驱动框架就讲解到这里，接下来我们就实际编写一个多点电容触摸驱动程序。</p><h2 id="硬件原理图分析"><a href="#硬件原理图分析" class="headerlink" title="硬件原理图分析"></a>硬件原理图分析</h2><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905142552964.png" alt="image-20200905142552964"></p><h2 id="试验程序编写"><a href="#试验程序编写" class="headerlink" title="试验程序编写"></a>试验程序编写</h2><p>本试验以正点原子的 ATK7084(7 寸 800*480 分辨率)和 ATK7016(7 寸 1024*600 分辨率)这两款屏幕所使用的 FT5426 触摸芯片为例，讲解如何编写多点电容触摸驱动。</p><h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1| 修改设备树"></a>1| 修改设备树</h3><h4 id="1、添加-FT5426-所使用的-IO"><a href="#1、添加-FT5426-所使用的-IO" class="headerlink" title="1、添加 FT5426  所使用的 IO"></a>1、添加 FT5426  所使用的 IO</h4><p>FT5426 触摸芯片用到了 4 个 IO，一个复位 IO、一个中断 IO、I2C2 的 SCL 和 SDA，所以我们需要先在设备树中添加 IO 相关的信息。复位 IO 和中断 IO 是普通的 GPIO，因此这两个 IO可以放到同一个节点下去描述，I2C2 的 SCL 和 SDA 属于 I2C2，因此这两个要放到同一个节点下去描述。首先是复位 IO 和中断 IO，imx6ull-lxg-emmc.dts 文件里面默认有个名为“pinctrl_tsc”的节点，如果被删除了的话就自行创建，在此节点下添加触摸屏的中断引脚信息，修改以后的“pinctrl_tsc”节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_tsc: tscgrp &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6UL_PAD_GPIO1_IO09__GPIO1_IO09 <span class="hljs-number">0xF080</span> <span class="hljs-comment">/* TSC_INT */</span><span class="hljs-number">4</span> &gt;;<span class="hljs-number">5</span> &#125;;</code></pre></div><p>触摸屏复位引脚使用的是 SNVS_TAMPER9，因此复位引脚信息要添加到 iomuxc_snvs 节点下，在 iomuxc_snvs 节点新建一个名为 pinctrl_tsc_reset 的子节点，然后在此子节点里面输入复位引脚配置信息即可，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_tsc_reset: tsc_reset &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09 <span class="hljs-number">0x10B0</span><span class="hljs-number">4</span> &gt;;<span class="hljs-number">5</span> &#125;;</code></pre></div><p>继续添加 I2C2 的 SCL 和 SDA 这两个 IO 信息，imx6ull-lxg-emmc.dts 里面默认就已经添加了 I2C2 的 IO 信息，这是 NXP 官方添加的，所以不需要我们去修改。找到“pinctrl_i2c2”节点，此节点就是用于描述 I2C2 的 IO 信息，节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_i2c2: i2c2grp &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6UL_PAD_UART5_TX_DATA__I2C2_SCL <span class="hljs-number">0x4001b8b0</span><span class="hljs-number">4</span> MX6UL_PAD_UART5_RX_DATA__I2C2_SDA <span class="hljs-number">0x4001b8b0</span><span class="hljs-number">5</span> &gt;;<span class="hljs-number">6</span> &#125;;</code></pre></div><p>最后，一定要检查一下设备树，确保触摸屏所使用的 IO 没有被其他的外设使用，如果有的话就需要将其屏蔽掉，保证只有触摸屏用到了这四个 IO。</p><h4 id="2-、添加-FT5426-节点"><a href="#2-、添加-FT5426-节点" class="headerlink" title="2 、添加 FT5426  节点"></a>2 、添加 FT5426  节点</h4><p>FT5426 这个触摸 IC 挂载 I2C2 下，因此需要向 I2C2 节点下添加一个子节点，此子节点用于描述 FT5426，添加完成以后的 I2C2 节点内容如下所示(省略掉其他挂载到 I2C2 下的设备)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;i2c2 &#123;<span class="hljs-number">2</span> clock_frequency = &lt;<span class="hljs-number">100000</span>&gt;;<span class="hljs-number">3</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">4</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c2&gt;;<span class="hljs-number">5</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">6</span><span class="hljs-number">7</span> <span class="hljs-comment">/****************************/</span><span class="hljs-number">8</span> <span class="hljs-comment">/* 省略掉其他的设备节点 */</span><span class="hljs-number">9</span> <span class="hljs-comment">/****************************/</span><span class="hljs-number">10</span><span class="hljs-number">11</span> <span class="hljs-comment">/* firestaradmin FT5406/FT5426 */</span><span class="hljs-number">12</span> ft5426: ft5426@<span class="hljs-number">38</span> &#123;<span class="hljs-number">13</span> compatible = <span class="hljs-string">&quot;edt,edt-ft5426&quot;</span>;<span class="hljs-number">14</span> reg = &lt;<span class="hljs-number">0x38</span>&gt;;<span class="hljs-number">15</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">16</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_tsc<span class="hljs-number">17</span>    &amp;pinctrl_tsc_reset &gt;; <span class="hljs-number">18</span> interrupt-parent = &lt;&amp;gpio1&gt;;<span class="hljs-number">19</span> interrupts = &lt;<span class="hljs-number">9</span> <span class="hljs-number">0</span>&gt;;<span class="hljs-number">20</span> reset-gpios = &lt;&amp;gpio5 <span class="hljs-number">9</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">21</span> interrupt-gpios = &lt;&amp;gpio1 <span class="hljs-number">9</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">22</span> &#125;;<span class="hljs-number">23</span> &#125;;</code></pre></div><p>第 12 行，触摸屏所使用的 FT5426 芯片节点，挂载 I2C2 节点下，FT5426 的器件地址为0X38。<br>第 14 行，reg 属性描述 FT5426 的器件地址为 0x38。<br>第 16 和 17 行，pinctrl-0 属性描述 FT5426 的复位 IO 和中断 IO 所使用的节点为 pinctrl_tsc和 pinctrl_tsc_reset。<br>第 18 行，interrupt-parent 属性描述中断 IO 对应的 GPIO 组为 GPIO1。<br>第 19 行，interrupts 属性描述中断 IO 对应的是 GPIO1 组的 IOI09。<br>第 20 行，reset-gpios 属性描述复位 IO 对应的 GPIO 为 GPIO5_IO09。<br>第 21 行，interrupt-gpios 属性描述中断 IO 对应的 GPIO 为 GPIO1_IO09。</p><h3 id="2-编写多点电容触摸驱动"><a href="#2-编写多点电容触摸驱动" class="headerlink" title="2| 编写多点电容触摸驱动"></a>2| 编写多点电容触摸驱动</h3><p>新建名为“23_multitouch”的文件夹，然后在 23_multitouch 文件夹里面创建 vscode 工程，工作区命名为“multitouch”。工程创建好以后新建 ft5x06.c 这个驱动文件，在里面输入如下所示内容:</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ratelimit.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/debugfs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/mt.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/touchscreen.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/edt-ft5x06.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span><span class="hljs-comment">/***************************************************************</span><span class="hljs-comment">文件名: ft5x06.c</span><span class="hljs-comment">版本   : V1.0</span><span class="hljs-comment">描述   : FT5X06，包括FT5206、FT5426等触摸屏驱动程序</span><span class="hljs-comment">***************************************************************/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SUPPORT_POINTS5<span class="hljs-comment">/* 5点触摸 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_DOWN0x00<span class="hljs-comment">/* 按下 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_UP0x01<span class="hljs-comment">/* 抬起 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_ON0x02<span class="hljs-comment">/* 接触 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_RESERVED0x03<span class="hljs-comment">/* 保留 */</span></span><span class="hljs-comment">/* FT5X06寄存器相关宏定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FT5X06_TD_STATUS_REG0X02<span class="hljs-comment">/*状态寄存器地址 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FT5x06_DEVICE_MODE_REG0X00 <span class="hljs-comment">/* 模式寄存器 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FT5426_IDG_MODE_REG0XA4<span class="hljs-comment">/* 中断模式*/</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FT5X06_READLEN29<span class="hljs-comment">/* 要读取的寄存器个数 */</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ft5x06_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>*<span class="hljs-title">nd</span>;</span> <span class="hljs-comment">/* 设备节点 */</span><span class="hljs-type">int</span> irq_pin,reset_pin;<span class="hljs-comment">/* 中断和复位IO*/</span><span class="hljs-type">int</span> irqnum;<span class="hljs-comment">/* 中断号    */</span><span class="hljs-type">void</span> *private_data;<span class="hljs-comment">/* 私有数据 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input</span>;</span><span class="hljs-comment">/* input结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span>;</span><span class="hljs-comment">/* I2C客户端 */</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ft5x06_dev</span> <span class="hljs-title">ft5x06</span>;</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description     : 复位FT5X06</span><span class="hljs-comment"> * @param - client : 要操作的i2c</span><span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_ts_reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> ft5x06_dev *dev)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (gpio_is_valid(dev-&gt;reset_pin)) &#123;  <span class="hljs-comment">/* 检查IO是否有效 */</span><span class="hljs-comment">/* 申请复位IO，并且默认输出低电平 */</span>ret = devm_gpio_request_one(&amp;client-&gt;dev,dev-&gt;reset_pin, GPIOF_OUT_INIT_LOW,<span class="hljs-string">&quot;edt-ft5x06 reset&quot;</span>);<span class="hljs-keyword">if</span> (ret) &#123;<span class="hljs-keyword">return</span> ret;&#125;msleep(<span class="hljs-number">5</span>);gpio_set_value(dev-&gt;reset_pin, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 输出高电平，停止复位 */</span>msleep(<span class="hljs-number">300</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 从FT5X06读取多个寄存器数据</span><span class="hljs-comment"> * @param - dev:  ft5x06设备</span><span class="hljs-comment"> * @param - reg:  要读取的寄存器首地址</span><span class="hljs-comment"> * @param - val:  读取到的数据</span><span class="hljs-comment"> * @param - len:  要读取的数据长度</span><span class="hljs-comment"> * @return : 操作结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ft5x06_dev *dev, u8 reg, <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> len)</span>&#123;<span class="hljs-type">int</span> ret;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>[2];</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;client;<span class="hljs-comment">/* msg[0]为发送要读取的首地址 */</span>msg[<span class="hljs-number">0</span>].addr = client-&gt;addr;<span class="hljs-comment">/* ft5x06地址 */</span>msg[<span class="hljs-number">0</span>].flags = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 标记为发送数据 */</span>msg[<span class="hljs-number">0</span>].buf = &amp;reg;<span class="hljs-comment">/* 读取的首地址 */</span>msg[<span class="hljs-number">0</span>].len = <span class="hljs-number">1</span>;<span class="hljs-comment">/* reg长度*/</span><span class="hljs-comment">/* msg[1]读取数据 */</span>msg[<span class="hljs-number">1</span>].addr = client-&gt;addr;<span class="hljs-comment">/* ft5x06地址 */</span>msg[<span class="hljs-number">1</span>].flags = I2C_M_RD;<span class="hljs-comment">/* 标记为读取数据*/</span>msg[<span class="hljs-number">1</span>].buf = val;<span class="hljs-comment">/* 读取数据缓冲区 */</span>msg[<span class="hljs-number">1</span>].len = len;<span class="hljs-comment">/* 要读取的数据长度*/</span>ret = i2c_transfer(client-&gt;adapter, msg, <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">2</span>) &#123;ret = <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> &#123;ret = -EREMOTEIO;&#125;<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向ft5x06多个寄存器写入数据</span><span class="hljs-comment"> * @param - dev:  ft5x06设备</span><span class="hljs-comment"> * @param - reg:  要写入的寄存器首地址</span><span class="hljs-comment"> * @param - val:  要写入的数据缓冲区</span><span class="hljs-comment"> * @param - len:  要写入的数据长度</span><span class="hljs-comment"> * @return   :   操作结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> s32 <span class="hljs-title function_">ft5x06_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 *buf, u8 len)</span>&#123;u8 b[<span class="hljs-number">256</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;client;b[<span class="hljs-number">0</span>] = reg;<span class="hljs-comment">/* 寄存器首地址 */</span><span class="hljs-built_in">memcpy</span>(&amp;b[<span class="hljs-number">1</span>],buf,len);<span class="hljs-comment">/* 将要写入的数据拷贝到数组b里面 */</span>msg.addr = client-&gt;addr;<span class="hljs-comment">/* ft5x06地址 */</span>msg.flags = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 标记为写数据 */</span>msg.buf = b;<span class="hljs-comment">/* 要写入的数据缓冲区 */</span>msg.len = len + <span class="hljs-number">1</span>;<span class="hljs-comment">/* 要写入的数据长度 */</span><span class="hljs-keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向ft5x06指定寄存器写入指定的值，写一个寄存器</span><span class="hljs-comment"> * @param - dev:  ft5x06设备</span><span class="hljs-comment"> * @param - reg:  要写的寄存器</span><span class="hljs-comment"> * @param - data: 要写入的值</span><span class="hljs-comment"> * @return   :    无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ft5x06_write_reg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 data)</span>&#123;u8 buf = <span class="hljs-number">0</span>;buf = data;ft5x06_write_regs(dev, reg, &amp;buf, <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description     : FT5X06中断服务函数</span><span class="hljs-comment"> * @param - irq : 中断号 </span><span class="hljs-comment"> * @param - dev_id: 设备结构。</span><span class="hljs-comment"> * @return : 中断执行结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">ft5x06_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ft5x06_dev</span> *<span class="hljs-title">multidata</span> =</span> dev_id;u8 rdbuf[<span class="hljs-number">29</span>];<span class="hljs-type">int</span> i, type, x, y, id;<span class="hljs-type">int</span> offset, tplen;<span class="hljs-type">int</span> ret;<span class="hljs-type">bool</span> down;offset = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 偏移1，也就是0X02+1=0x03,从0X03开始是触摸值 */</span>tplen = <span class="hljs-number">6</span>;<span class="hljs-comment">/* 一个触摸点有6个寄存器来保存触摸值 */</span><span class="hljs-built_in">memset</span>(rdbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(rdbuf));<span class="hljs-comment">/* 清除 */</span><span class="hljs-comment">/* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 */</span>ret = ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);<span class="hljs-keyword">if</span> (ret) &#123;<span class="hljs-keyword">goto</span> fail;&#125;<span class="hljs-comment">/* 上报每一个触摸点坐标 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_SUPPORT_POINTS; i++) &#123;u8 *buf = &amp;rdbuf[i * tplen + offset];<span class="hljs-comment">/* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span><span class="hljs-comment"> * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span><span class="hljs-comment"> * bit5:4  保留</span><span class="hljs-comment"> * bit3:0  X轴触摸点的11~8位。</span><span class="hljs-comment"> */</span>type = buf[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">6</span>;     <span class="hljs-comment">/* 获取触摸类型 */</span><span class="hljs-keyword">if</span> (type == TOUCH_EVENT_RESERVED)<span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* 我们所使用的触摸屏和FT5X06是反过来的 */</span>x = ((buf[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">3</span>]) &amp; <span class="hljs-number">0x0fff</span>;y = ((buf[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">1</span>]) &amp; <span class="hljs-number">0x0fff</span>;<span class="hljs-comment">/* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span><span class="hljs-comment"> * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span><span class="hljs-comment"> * bit3:0  Y轴触摸点的11~8位。</span><span class="hljs-comment"> */</span>id = (buf[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>;down = type != TOUCH_EVENT_UP;input_mt_slot(multidata-&gt;input, id);input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);<span class="hljs-keyword">if</span> (!down)<span class="hljs-keyword">continue</span>;input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);&#125;input_mt_report_pointer_emulation(multidata-&gt;input, <span class="hljs-literal">true</span>);input_sync(multidata-&gt;input);fail:<span class="hljs-keyword">return</span> IRQ_HANDLED;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description     : FT5x06中断初始化</span><span class="hljs-comment"> * @param - client : 要操作的i2c</span><span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_ts_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> ft5x06_dev *dev)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 1,申请中断GPIO */</span><span class="hljs-keyword">if</span> (gpio_is_valid(dev-&gt;irq_pin)) &#123;ret = devm_gpio_request_one(&amp;client-&gt;dev, dev-&gt;irq_pin,GPIOF_IN, <span class="hljs-string">&quot;edt-ft5x06 irq&quot;</span>);<span class="hljs-keyword">if</span> (ret) &#123;dev_err(&amp;client-&gt;dev,<span class="hljs-string">&quot;Failed to request GPIO %d, error %d\n&quot;</span>,dev-&gt;irq_pin, ret);<span class="hljs-keyword">return</span> ret;&#125;&#125;<span class="hljs-comment">/* 2，申请中断,client-&gt;irq就是IO中断， */</span>ret = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="hljs-literal">NULL</span>,ft5x06_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,client-&gt;name, &amp;ft5x06);<span class="hljs-keyword">if</span> (ret) &#123;dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to request touchscreen IRQ.\n&quot;</span>);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125; <span class="hljs-comment">/*</span><span class="hljs-comment">  * @description     : i2c驱动的probe函数，当驱动与</span><span class="hljs-comment">  *                    设备匹配以后此函数就会执行</span><span class="hljs-comment">  * @param - client  : i2c设备</span><span class="hljs-comment">  * @param - id      : i2c设备ID</span><span class="hljs-comment">  * @return          : 0，成功;其他负值,失败</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_ts_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ft5x06.client = client;<span class="hljs-comment">/* 1，获取设备树中的中断和复位引脚 */</span>ft5x06.irq_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="hljs-string">&quot;interrupt-gpios&quot;</span>, <span class="hljs-number">0</span>);ft5x06.reset_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="hljs-string">&quot;reset-gpios&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 2，复位FT5x06 */</span>ret = ft5x06_ts_reset(client, &amp;ft5x06);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">goto</span> fail;&#125;<span class="hljs-comment">/* 3，初始化中断 */</span>ret = ft5x06_ts_irq(client, &amp;ft5x06);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">goto</span> fail;&#125;<span class="hljs-comment">/* 4，初始化FT5X06 */</span>ft5x06_write_reg(&amp;ft5x06, FT5x06_DEVICE_MODE_REG, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 进入正常模式 */</span>ft5x06_write_reg(&amp;ft5x06, FT5426_IDG_MODE_REG, <span class="hljs-number">1</span>); <span class="hljs-comment">/* FT5426中断模式*/</span><span class="hljs-comment">/* 5，input设备注册 */</span>ft5x06.input = devm_input_allocate_device(&amp;client-&gt;dev);<span class="hljs-keyword">if</span> (!ft5x06.input) &#123;ret = -ENOMEM;<span class="hljs-keyword">goto</span> fail;&#125;ft5x06.input-&gt;name = client-&gt;name;ft5x06.input-&gt;id.bustype = BUS_I2C;ft5x06.input-&gt;dev.parent = &amp;client-&gt;dev;__set_bit(EV_KEY, ft5x06.input-&gt;evbit);__set_bit(EV_ABS, ft5x06.input-&gt;evbit);__set_bit(BTN_TOUCH, ft5x06.input-&gt;keybit);input_set_abs_params(ft5x06.input, ABS_X, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);input_set_abs_params(ft5x06.input, ABS_Y, <span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);input_set_abs_params(ft5x06.input, ABS_MT_POSITION_X,<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);input_set_abs_params(ft5x06.input, ABS_MT_POSITION_Y,<span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     ret = input_mt_init_slots(ft5x06.input, MAX_SUPPORT_POINTS, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (ret) &#123;<span class="hljs-keyword">goto</span> fail;&#125;ret = input_register_device(ft5x06.input);<span class="hljs-keyword">if</span> (ret)<span class="hljs-keyword">goto</span> fail;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail:<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span><span class="hljs-comment"> * @param - client : i2c设备</span><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ft5x06_ts_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span>&#123;<span class="hljs-comment">/* 释放input_dev */</span>input_unregister_device(ft5x06.input);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> *  传统驱动匹配表</span><span class="hljs-comment"> */</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">ft5x06_ts_id</span>[] =</span> &#123;&#123; <span class="hljs-string">&quot;edt-ft5206&quot;</span>, <span class="hljs-number">0</span>, &#125;,&#123; <span class="hljs-string">&quot;edt-ft5426&quot;</span>, <span class="hljs-number">0</span>, &#125;,&#123; <span class="hljs-comment">/* sentinel */</span> &#125;&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * 设备树匹配表 </span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">ft5x06_of_match</span>[] =</span> &#123;&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5206&quot;</span>, &#125;,&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5426&quot;</span>, &#125;,&#123; <span class="hljs-comment">/* sentinel */</span> &#125;&#125;;<span class="hljs-comment">/* i2c驱动结构体 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">ft5x06_ts_driver</span> =</span> &#123;.driver = &#123;.owner = THIS_MODULE,.name = <span class="hljs-string">&quot;edt_ft5x06&quot;</span>,.of_match_table = of_match_ptr(ft5x06_of_match),&#125;,.id_table = ft5x06_ts_id,.probe    = ft5x06_ts_probe,.remove   = ft5x06_ts_remove,&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动入口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ft5x06_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = i2c_add_driver(&amp;ft5x06_ts_driver);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动出口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">ft5x06_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;i2c_del_driver(&amp;ft5x06_ts_driver);&#125;module_init(ft5x06_init);module_exit(ft5x06_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><ul><li><code>struct ft5x06_dev</code>定义一个设备结构体，存放多点电容触摸设备相关属性信息。</li><li><code>static struct ft5x06_dev ft5x06;</code>定义一个名为 ft5x06 的全局变量，变量类型就是上面定义的 ft5x06_dev 结构体。</li><li><strong>ft5x06_ts_reset 函数</strong>，用于初始化 FT5426 触摸芯片，其实就是设置 FT5426的复位 IO 为高电平，防止芯片复位。使用 devm_gpio_request_one 函数来申请复位 IO，关于“devm_”前缀的作用已经在前面小节做了详细的讲解。使用“devm_”前缀的API 函数申请的资源不需要我们手动释放，内核会处理，所以这里使用 devm_gpio_request_one函数申请 IO 以后不需要我们在卸载驱动的时候手动去释放此 IO。</li><li><strong>ft5x06_read_regs 函数</strong>，用于连续的读取 FT5426 内部寄存器数据，就是 I2C读取函数，在之前I2C实验有详细的讲解。</li><li><strong>ft5x06_write_regs 函数</strong>，用于向 FT5426 寄存器写入连续的数据，也就是 I2C写函数，同样在之前I2C实验有详细的讲解. ft5x06_write_reg 函数，对 ft5x06_write_regs 函数的简单封装，向 FT5426 指定寄存器写入一个数据，用于配置 FT5426。</li><li><strong>ft5x06_handler 函数</strong>，触摸屏中断服务函数，触摸点坐标的上报就是在此函数中完成的。通过 ft5x06_read_regs 函数读取 FT5426 的所有触摸点信息寄存器数据，从 0X02 这个地址开始，一共 29 个寄存器。 for 循环就是一个一个的上报触摸点坐标数据，使用Type B时序，这个我们已经在前面说了很多次了。最后通过input_sync函数上报 SYN_REPORT 事件。如果理解了前面讲解的 Type B 时序，那么此函数就很好看懂。</li><li><strong>ft5x06_ts_irq 函数</strong>，初始化 FT5426 的中断 IO，使用devm_gpio_request_one 函数申请中断 IO。使用函数 devm_request_threaded_irq 申请中断，中断处理函数为 ft5x06_handler。</li><li><strong>ft5x06_ts_probe函数</strong>，当 I2C 设备与驱动匹配以后此函数就会执行，一般在此函数中完成一些初始化工作。我们重点来看一下关于 input_dev 设备的初始化，申请并简单的初始化input_dev，设置input_dev需要上报的事件为 EV_KEY 和 EV_ABS，需要上报的按键码为 BTN_TOUCH。EV_KEY 是按键事件，用于上报触摸屏是否被按下，相当于把触摸屏当做一个按键。EV_ABS 是触摸点坐标数据，BTN_TOUCH 表示将触摸屏的按下和抬起用作 BTN_TOUCH 按键。调用input_set_abs_params函数设置EV_ABS 事件需要上报ABS_X、ABS_Y、ABS_MT_POSITION_X和 ABS_MT_POSITION_Y。单点触摸需要上报 ABS_X 和 ABS_Y，对于多点触摸需要上报ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。调用 input_mt_init_slots 函数初始化 slots，也就是最大触摸点数量，FT5426 是个 5 点电容触摸芯片，因此一共 5 个 slot。最后调用input_register_device 函数向系统注册 input_dev。</li><li><strong>当卸载驱动的时候 ft5x06_ts_remove 函数就会执行</strong>，因为前面很多资源我们都是用“devm_”前缀函数来申请的，因此不需要手动释放。此函数只需要调用input_unregister_device 来释放掉前面添加到内核中的 input_dev。</li><li><strong>结束</strong>，剩下的就是 I2C 驱动框架那一套，已经在之前实验进行了详细的讲解。</li></ul><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><h3 id="1-编译驱动程序"><a href="#1-编译驱动程序" class="headerlink" title="1| 编译驱动程序"></a>1| 编译驱动程序</h3><p>编译成功以后就会生成一个名为“ft5x06.ko”的驱动模块文件。</p><h3 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2| 运行测试"></a>2| 运行测试</h3><p>编译设备树，然后使用新的设备树启动 linux 内核。多点电容触摸屏测试不需要编写专门的 APP，将上一小节编译出来 ft5x06.ko 拷贝到rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15 目录中，启动开发板，进入到目录lib&#x2F;modules&#x2F;4.1.15 中，输入如下命令加载 ft5x06.ko 这个驱动模块。</p><div class="hljs code-wrapper"><pre><code class="hljs sh">depmod //第一次加载驱动的时候需要运行此命令modprobe ft5x06.ko  //加载驱动模块</code></pre></div><p>当驱动模块加载成功以后会有如图 所示信息输入：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150121781.png" alt="image-20200905150121781"></p><p>驱动加载成功以后就会生成&#x2F;dev&#x2F;input&#x2F;eventX(X&#x3D;1,2,3…)，比如本实验的多点电容触摸驱动就会在我所使用的 ALPHA 开发板平台下就会生成&#x2F;dev&#x2F;input&#x2F;event2 这个文件，如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150208249.png" alt="image-20200905150208249"></p><p>不同的平台 event 序号不同，也可能是 event3，event4 等，一切以实际情况为准！输入如下命令查看 event2，也就是多点电容触摸屏上报的原始数据：</p><div class="hljs code-wrapper"><pre><code class="hljs c">hexdump /dev/input/event2</code></pre></div><p>现在用一根手指触摸屏幕的右上角，然后再抬起，理论坐标值为(1023,0)，但是由于触摸误差的原因，大概率不会是绝对的(1023,0)，应该是在此值附近的一个触摸坐标值，实际的上报数据如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150308374.png" alt="image-20200905150308374"></p><p>图上报的信息是按照 input_event 类型呈现的，这个同样在前面INPUT子系统实验做了详细的介绍，这里我们重点来分析一下，在多点电容触摸屏上其所代表的具体含义，将图中的数据进行整理，结果如下所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905150825437.png" alt="image-20200905150825437"></p><p>第 1 行，type 为 0x3，说明是一个 EV_ABS 事件，code 为 0x2f，为 ABS_MT_SLOT，因此这一行就是 input_mt_slot 函数上报的 ABS_MT_SLOT 事件。value&#x3D;0，说明接下来上报的是第一个触摸点坐标。</p><p>第 2 行 ， type 为 0x3 ， 说 明 是 一 个 EV_ABS 事 件 ， code 为 0x39 ， 也 就 是ABS_MT_TRACKING_ID ， 这 一 行 就 是 input_mt_report_slot_state 函 数 上 报ABS_MT_TRACKING_ID 事件。value&#x3D;5 说明给SLOT0 分配的 ID 为 5。</p><p>第 3 行，type 为 0x3，是一个 EV_ABS 事件，code 为 0x35，为 ABS_MT_POSITION_X，这一行就是 input_report_abs 函数上报的 ABS_MT_POSITION_X 事件，也就是触摸点的 X 轴坐标。value&#x3D;0x03ec&#x3D;1004，说明触摸点 X 轴坐标为 1004，属于屏幕右上角区域。</p><p>第 4 行，type 为 0x3，是一个 EV_ABS 事件，code 为 0x36，为 ABS_MT_POSITION_Y，这一行就是 input_mt_report_slot_state 函数上报的 ABS_MT_POSITION_Y 事件，也就是触摸点的 Y 轴坐标。value&#x3D;0x17&#x3D;23，说明 Y 轴坐标为 23，由此可以看出本次触摸的坐标为(1004,23)，处于屏幕右上角区域。</p><p>第 5 行，type 为 0x1，是一个 EV_KEY 事件，code&#x3D;0x14a，为 BTN_TOUCH，value&#x3D;0x1 表示触摸屏被按下。</p><p>第 6 行，type 为 0x3，是一个 EV_ABS 事件，code 为 0x0，为 ABS_X，用于单点触摸的时候上报 X 轴坐标。在这里和 ABS_MT_POSITION_X 相同，value 也为 0x3f0&#x3D;1008。ABS_X 是由input_mt_report_pointer_emulation 函数上报的。</p><p>第 7 行，type 为 0x3，是一个 EV_ABS 事件，code 为 0x1，为 ABS_Y，用于单点触摸的时候上报 Y 轴坐标。在这里和 ABS_MT_POSITION_Y 相同，value 也为 0x29&#x3D;41。ABS_Y 是由input_mt_report_pointer_emulation 函数上报的。</p><p>第 8 行，type 为 0x0，是一个 EV_SYN 事件，由 input_sync 函数上报。</p><p>第9行，type为0x3，是一个EV_ABS事件，code为0x39，也就是ABS_MT_TRACKING_ID，value&#x3D;0xffffffff&#x3D;-1，说明触摸点离开了屏幕。</p><p>第 10 行，type 为 0x1，是一个 EV_KEY 事件，code&#x3D;0x14a，为 BTN_TOUCH，value&#x3D;0x0表示手指离开触摸屏，也就是触摸屏没有被按下了。</p><p>第 11 行，type 为 0x0，是一个 EV_SYN 事件，由 input_sync 函数上报。以上就是一个触摸点的坐标上报过程，和我们前面讲解的 Type B 类型设备一致。</p><h3 id="3-将驱动添加到内核中"><a href="#3-将驱动添加到内核中" class="headerlink" title="3| 将驱动添加到内核中"></a>3| 将驱动添加到内核中</h3><p>前面我们一直将触摸驱动编译为模块，每次系统启动以后在手动加载驱动模块，这样很不方便。当我们把驱动调试成功以后一般都会将其编译到内核中，这样内核启动以后就会自动加载驱动，不需要我们再手动 modprobe 了。本节我们就来学习一下如何将 ft5x06.c 添加到 linux内核里面，步骤如下所示：</p><h4 id="1-、将驱动文件放到合适的位置"><a href="#1-、将驱动文件放到合适的位置" class="headerlink" title="1 、将驱动文件放到合适的位置"></a>1 、将驱动文件放到合适的位置</h4><p>首先肯定是在内核源码中找个合适的位置将 ft5x06.c 放进去，ft5x06.c 是个触摸屏驱动，因此我们需要查找一下 linux 内核里面触摸屏驱动放到了哪个目录下。linux 内核里面将触摸屏驱动放到了drivers&#x2F;input&#x2F;touchscreen 目录下，因此我们要将 ft5x06.c 拷贝到此目录下，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> ft5x06.c (内核源码目录)/drivers/input/touchscreen/ -f</code></pre></div><h4 id="2-、修改对应的-Makefile"><a href="#2-、修改对应的-Makefile" class="headerlink" title="2 、修改对应的 Makefile"></a>2 、修改对应的 Makefile</h4><p>修改 drivers&#x2F;input&#x2F;touchscreen 目录下的 Makefile，在最下面添加下面一行：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">obj-y += ft5x06.o</code></pre></div><p>完成以后如图 所示:</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905151355239.png" alt="image-20200905151355239"></p><p>修改完成以后重新编译 linux 内核，然后用新的 zImage 启动开发板。如果驱动添加成功的话系统启动的时候就会输出如图所示的信息：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905151639612.png" alt="image-20200905151639612"></p><p>从图可以看出，触摸屏驱动已经启动了，这个时候就会自动生成&#x2F;dev&#x2F;input&#x2F;evenvtX。在本实验中将触摸屏驱动添加到 linux 内核里面以后触摸屏对应的是 event1，而不是前面编译为模块对应的 event2，这一点一定要注意！输入如下命令，查看驱动工作是否正常：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">hexdump /dev/input/event1 //查看触摸屏原始数据上报信息</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905151800603.png" alt="image-20200905151800603"></p><p>可以看出，坐标数据上报正常，说明驱动工作没问题。</p><h2 id="tslib-移植与使用"><a href="#tslib-移植与使用" class="headerlink" title="tslib  移植与使用"></a>tslib  移植与使用</h2><h3 id="1-tslib-移植"><a href="#1-tslib-移植" class="headerlink" title="1| tslib 移植"></a>1| tslib 移植</h3><p>tslib 是一个开源的第三方库，用于触摸屏性能调试，使用电阻屏的时候一般使用 tslib 进行校准。虽然电容屏不需要校准，但是由于电容屏加工的原因，有的时候其不一定精准，因此有时候也需要进行校准。最主要的是 tslib 提供了一些其他软件，我们可以通过这些软件来测试触摸屏工作是否正常。最新版本的 tslib 已经支持了多点电容触摸屏，因此可以通过 tslib 来直观的测试多点电容触摸屏驱动，这个要比观看 eventX 原始数据方便的多。tslib 的移植很简单，步骤如下：</p><h4 id="1-、获取-tslib-源码"><a href="#1-、获取-tslib-源码" class="headerlink" title="1 、获取 tslib  源码"></a>1 、获取 tslib  源码</h4><p>首先肯定是获取 tslib 的源码，git 地址为 <a href="https://github.com/kergoth/tslib%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AF1.21%E3%80%82%E5%B0%86tslib%E6%BA%90%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%8F%91%E9%80%81%E5%88%B0">https://github.com/kergoth/tslib，目前最新的版本是1.21。将tslib源码压缩包发送到</a> ubuntu 中并解压，得到名为“tslib-1.21”的目录，此目录下就是 tslib 源码。</p><h4 id="2-、修改-tslib-源码所属用户"><a href="#2-、修改-tslib-源码所属用户" class="headerlink" title="2 、修改 tslib  源码所属用户"></a>2 、修改 tslib  源码所属用户</h4><p>修改解压得到的 tslib-1.21 目录所属用户为当前用户，这一步一定要做！否则在稍后的编译中会遇到各种问题。我当前 ubuntu 的登录用户名为“firestaradmin”，那么修改命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chown</span> firestaradmin:firestaradmin tslib-1.21 -R</code></pre></div><h4 id="3-、ubuntu-工具安装"><a href="#3-、ubuntu-工具安装" class="headerlink" title="3 、ubuntu  工具安装"></a>3 、ubuntu  工具安装</h4><p>编译 tslib 的时候需要先在 ubuntu 中安装一些文件，防止编译 tslib 过程中出错，命令如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo apt-get install autoconfsudo apt-get install automakesudo apt-get install libtool</code></pre></div><h4 id="4-、编译-tslib"><a href="#4-、编译-tslib" class="headerlink" title="4 、编译 tslib"></a>4 、编译 tslib</h4><p>首先在 ubuntu 中创建一个名为“tslib”的目录存放编译结果，比如我们创建的 tslib 目录全路为：&#x2F;home&#x2F;firestaradmin&#x2F;linux&#x2F;tools&#x2F;tslib。接下来输入如下命令配置并编译 talib：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> tslib-1.21/ //进入 tslib 源码目录./autogen.sh ./configure --host=arm-linux-gnueabihf --prefix=/home/firestaradmin/linux/tools/tslibmake  //编译make install  //安装</code></pre></div><p>注意，在使用.&#x2F;configure 配置 tslib 的时候“–host”参数指定编译器，“–prefix”参数指定编<br>译完成以后的 tslib 文件安装到哪里，这里肯定是安装到我们刚刚创建的“tslib”目录下。</p><p>完成以后 tslib 目录下的内容如图  所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905152923501.png" alt="image-20200905152923501"></p><p>bin 目录下是可执行文件，包括 tslib 的测试工具。etc 目录下是 tslib 的配置文件，lib 目录下是相关的库文件。</p><p>将图 中的所有文件拷贝到开发板的根文件系统中，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo <span class="hljs-built_in">cp</span> * -rf /home/firestaradmin/linux/nfs/rootfs</code></pre></div><h4 id="5、配置-tslib"><a href="#5、配置-tslib" class="headerlink" title="5、配置 tslib"></a>5、配置 tslib</h4><p>打开&#x2F;etc&#x2F;ts.conf 文件，找到下面这一行：</p><div class="hljs code-wrapper"><pre><code class="hljs ceylon"><span class="hljs-keyword">module</span><span class="hljs-number">_</span>raw input</code></pre></div><p>如果上面这句前面有“#”的话就删除掉“#”。</p><p>打开&#x2F;etc&#x2F;profile 文件，在里面加入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> export TSLIB_TSDEVICE=/dev/input/event1<span class="hljs-number">2</span> export TSLIB_CALIBFILE=/etc/pointercal<span class="hljs-number">3</span> export TSLIB_CONFFILE=/etc/ts.conf<span class="hljs-number">4</span> export TSLIB_PLUGINDIR=/lib/ts<span class="hljs-number">5</span> export TSLIB_CONSOLEDEVICE=none<span class="hljs-number">6</span> export TSLIB_FBDEVICE=/dev/fb0</code></pre></div><ul><li>第 1 行，TSLIB_TSDEVICE 表示触摸设备文件，这里设置为&#x2F;dev&#x2F;input&#x2F;event1，这个要根据具体情况设置，如果你的触摸设备文件为event2那么就应该设置为&#x2F;dev&#x2F;input&#x2F;event2，以此类推。</li><li>第 2 行，TSLIB_CALIBFILE 表示校准文件，如果进行屏幕校准的话校准结果就保存在这个文件中，这里设置校准文件为&#x2F;etc&#x2F;pointercal，此文件可以不存在，校准的时候会自动生成。</li><li>第 3 行，TSLIB_CONFFILE 表示触摸配置文件，文件为&#x2F;etc&#x2F;ts.conf，此文件在移植 tslib 的时候会生成。</li><li>第 4 行，TSLIB_PLUGINDIR 表示 tslib 插件目录位置，目录为&#x2F;lib&#x2F;ts。</li><li>第 5 行，TSLIB_CONSOLEDEVICE 表示控制台设置，这里不设置，因此为 none。</li><li>第 6 行，TSLIB_FBDEVICE 表示 FB 设备，也就是屏幕，根据实际情况配置，我的屏幕文件为&#x2F;dev&#x2F;fb0，因此这里设置为&#x2F;dev&#x2F;fb0。</li></ul><p>全部配置好以后重启开发板，然后就可以进行测试了。</p><h3 id="2-tslib-测试"><a href="#2-tslib-测试" class="headerlink" title="2| tslib  测试"></a>2| tslib  测试</h3><p>电容屏可以不用校准，如果是电阻屏就要先进行校准！校准的话输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">ts_calibrate</code></pre></div><p>校准完成以后如果不满意，或者不小心对电容屏做了校准，那么直接删除掉&#x2F;etc&#x2F;pointercal文件即可。</p><p>最后我们使用 ts_test_mt 这个软件来测试触摸屏工作是否正常，以及多点触摸是否有效，执行如下所示命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">ts_test_mt</code></pre></div><p>此命令会打开一个触摸测试界面，如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905153548331.png" alt="image-20200905153548331"></p><p>在图 上有三个按钮“Drag”、“Draw”和“Quit”，这三个按钮的功能如下：</p><ul><li>Drag： ：拖拽按钮，默认就是此功能，大家可以看到屏幕中间有一个十字光标，我们可以通过触摸屏幕来拖拽此光标。一个触摸点一个十字光标，对于 5 点电容触摸屏，如果 5 个手指都放到屏幕上，那么就有 5 个光标，一个手指一个。</li><li>Draw： ：绘制按钮，按下此按钮我们就可以在屏幕上进行简单的绘制，可以通过此功能检测多点触摸工作是否正常。</li><li>Quit ：退出按钮，退出 ts_test_mt 测试软件。</li></ul><p>点击“Draw”按钮，使用绘制功能，5 个手指一起划过屏幕，如果多点电容屏工作正常的话就会在屏幕上留下 5 条线，如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905153619823.png" alt="image-20200905153619823"></p><p>从图可以看出，屏幕上有 5 条线，说明 5 点电容触摸工作正常。这 5 跳线都是白色的，图 中由于拍照并处理的原因，导致 5 条线开起来不是白色的。</p><h2 id="使用内核自带的驱动"><a href="#使用内核自带的驱动" class="headerlink" title="使用内核自带的驱动"></a>使用内核自带的驱动</h2><p>Linux 内核已经集成了很多电容触摸 IC 的驱动文件，比如本章实验我们所使用 FT5426，本节我们就来学习一下，如何使用 Linux 内核自带的多点电容触摸驱动。在使用之前要先将前面我们自己添加到内核的 ft5x06.c这个文件从内核中去除掉 ， 只 需 要 修 改drivers&#x2F;input&#x2F;touchscreen&#x2F;Makefile 这个文件即可，将下面这一行删除掉：</p><div class="hljs code-wrapper"><pre><code class="hljs fix"><span class="hljs-attr">obj-y  +</span>=<span class="hljs-string"> ft5x06.o</span></code></pre></div><p>内核自带的 FT5426 的驱动文件为 drivers&#x2F;input&#x2F;touchscreen&#x2F;edt-ft5x06.c，此驱动文件不仅仅能够驱动 FT5426，FT5206、FT5406 这些都可以驱动。按照如下步骤来操作，学习如何使用此驱动。</p><h3 id="1-、修改-edt-ft5x06-c"><a href="#1-、修改-edt-ft5x06-c" class="headerlink" title="1 、修改 edt-ft5x06.c"></a>1 、修改 edt-ft5x06.c</h3><p>edt-ft5x06.c 直接使用的话是不行的，需要对其做修改，由于此文件太大，这里就不一一指出来如何修改了。我会将代码放到本篇末尾，大家可以参考看下，对比和原本的文件修改了哪里。</p><h3 id="2-、使能内核自带的-FT5X06-驱动"><a href="#2-、使能内核自带的-FT5X06-驱动" class="headerlink" title="2 、使能内核自带的 FT5X06  驱动"></a>2 、使能内核自带的 FT5X06  驱动</h3><p>edt-ft5x06.c 这个驱动默认是没有使能的，我们需要配置 Linux 内核，使能此驱动，通过图形化配置界面即可完成配置。进入 linux 内核源码目录，输入如下所示命令打开图形化配置界面：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span></code></pre></div><p>配置路径如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">Location:-&gt; Device Drivers    -&gt; Input device support        -&gt; Generic input <span class="hljs-title function_">layer</span> <span class="hljs-params">(needed <span class="hljs-keyword">for</span> keyboard, mouse, ...)</span> <span class="hljs-params">(INPUT [=y])</span>            -&gt; <span class="hljs-title function_">Touchscreens</span> <span class="hljs-params">(INPUT_TOUCHSCREEN [=y])</span>            -&gt; &lt;*&gt; EDT FocalTech FT5x06 I2C Touchscreen support</code></pre></div><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905154305722.png" alt="image-20200905154305722"></p><p>配置好以后重新编译 linux 内核，生成 zImage，但是还不能直接用，要修改设备树。</p><h3 id="3-、修改设备树"><a href="#3-、修改设备树" class="headerlink" title="3 、修改设备树"></a>3 、修改设备树</h3><p>修改我们在前面中编写的 ft5426 这个设备节点，需要在里面添加 compatible 属性，添加的内容就要参考 edt-ft5x06.c 文件了，edt-ft5x06.c 所支持的 compatible 属性列表如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">edt_ft5x06_of_match</span>[] =</span> &#123;    &#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5206&quot;</span>, &#125;,    &#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5306&quot;</span>, &#125;,    &#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5406&quot;</span>, &#125;,    &#123; <span class="hljs-comment">/* sentinel */</span> &#125;&#125;;</code></pre></div><p>可以看出，edt-ft5x06.c 文件默认支持的 compatible 属性只要三个“edt,edt-ft5206”、“edt,edt-ft5306”和“edt,edt-ft5406”。</p><p>我们可以修改设备树中的 ft5426 节点，在 compatible 属性值添加一条“edt,edt-ft5406”(示例代码中三选一即可)。或者修改示例代码中的 edt_ft5x06_of_match 表，在里面添加一条：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">&#123; <span class="hljs-string">.compatible</span> = <span class="hljs-string">&quot;edt,edt-ft5426&quot;</span>, &#125;</code></pre></div><p>总之一句话，让 ft5426 这个设备和 edt-ft5x06.c 这个驱动匹配起来！这里我选择修改设备树中的 ft5426 这个节点，修改后的 ft5426 节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> ft5426: ft5426@<span class="hljs-number">38</span> &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;edt,edt-ft5426&quot;</span>,<span class="hljs-string">&quot;edt,edt-ft5406&quot;</span>;<span class="hljs-number">3</span> reg = &lt;<span class="hljs-number">0x38</span>&gt;;。。。。。。</code></pre></div><p>第 2 行，添加一条“edt,edt-ft5406”兼容性值。</p><p>修改完成以后重新编译设备树，然后使用新得到的.dtb 和 zImage 文件启动 linux 内核。如果一切正常的话系统启动的时候就会输出如图所示信息：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/21%E3%80%81Linux%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%AE%9E%E9%AA%8C/image-20200905154521160.png" alt="image-20200905154521160"></p><p>直接运行 ts_test_mt 来测试触摸屏是否可以使用。至此，关于 Linux 下的多点电容触摸驱动就结束了，重点就是掌握 linux 下的触摸屏上报时序，大多数都是 Type B 类型。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="修改过的edt-ft5x06-c"><a href="#修改过的edt-ft5x06-c" class="headerlink" title="修改过的edt-ft5x06.c"></a>修改过的edt-ft5x06.c</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright (C) 2012 Simon Budig, &lt;simon.budig@kernelconcepts.de&gt;</span><span class="hljs-comment"> * Daniel Wagener &lt;daniel.wagener@kernelconcepts.de&gt; (M09 firmware support)</span><span class="hljs-comment"> * Lothar Waßmann &lt;LW@KARO-electronics.de&gt; (DT support)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * This software is licensed under the terms of the GNU General Public</span><span class="hljs-comment"> * License version 2, as published by the Free Software Foundation, and</span><span class="hljs-comment"> * may be copied, distributed, and modified under those terms.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * This program is distributed in the hope that it will be useful,</span><span class="hljs-comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span><span class="hljs-comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><span class="hljs-comment"> * GNU General Public License for more details.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * You should have received a copy of the GNU General Public</span><span class="hljs-comment"> * License along with this library; if not, write to the Free Software</span><span class="hljs-comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span><span class="hljs-comment"> */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * This is a driver for the EDT &quot;Polytouch&quot; family of touch controllers</span><span class="hljs-comment"> * based on the FocalTech FT5x06 line of chips.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Development of this driver has been sponsored by Glyn:</span><span class="hljs-comment"> *    http://www.glyn.com/Products/Displays</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ratelimit.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/debugfs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/mt.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/touchscreen.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/edt-ft5x06.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SUPPORT_POINTS5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_THRESHOLD0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_REPORT_RATE0x08</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_GAIN0x30</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_OFFSET0x31</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_NUM_X0x33</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_NUM_Y0x34</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_THRESHOLD0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_GAIN0x92</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_OFFSET0x93</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_NUM_X0x94</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> M09_REGISTER_NUM_Y0x95</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_REGISTER0xff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WORK_REGISTER_OPMODE0x3c</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FACTORY_REGISTER_OPMODE0x01</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_DOWN0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_UP0x01</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_ON0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOUCH_EVENT_RESERVED0x03</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_NAME_LEN23</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_SWITCH_MODE_RETRIES10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_SWITCH_MODE_DELAY5 <span class="hljs-comment">/* msec */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_RAW_DATA_RETRIES10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_RAW_DATA_DELAY1 <span class="hljs-comment">/* msec */</span></span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">edt_ver</span> &#123;</span>M06,M09,&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> &#123;</span><span class="hljs-type">int</span> reg_threshold;<span class="hljs-type">int</span> reg_report_rate;<span class="hljs-type">int</span> reg_gain;<span class="hljs-type">int</span> reg_offset;<span class="hljs-type">int</span> reg_num_x;<span class="hljs-type">int</span> reg_num_y;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input</span>;</span>u16 num_x;u16 num_y;<span class="hljs-type">int</span> reset_pin;<span class="hljs-type">int</span> irq_pin;<span class="hljs-type">int</span> wake_pin;<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_DEBUG_FS)</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">debug_dir</span>;</span>u8 *raw_buffer;<span class="hljs-type">size_t</span> raw_bufsize;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span><span class="hljs-type">bool</span> factory_mode;<span class="hljs-type">int</span> threshold;<span class="hljs-type">int</span> gain;<span class="hljs-type">int</span> offset;<span class="hljs-type">int</span> report_rate;<span class="hljs-type">char</span> name[EDT_NAME_LEN];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> <span class="hljs-title">reg_addr</span>;</span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">edt_ver</span> <span class="hljs-title">version</span>;</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_readwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client,</span><span class="hljs-params">   u16 wr_len, u8 *wr_buf,</span><span class="hljs-params">   u16 rd_len, u8 *rd_buf)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">wrmsg</span>[2];</span><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> ret;<span class="hljs-keyword">if</span> (wr_len) &#123;wrmsg[i].addr  = client-&gt;addr;wrmsg[i].flags = <span class="hljs-number">0</span>;wrmsg[i].len = wr_len;wrmsg[i].buf = wr_buf;i++;&#125;<span class="hljs-keyword">if</span> (rd_len) &#123;wrmsg[i].addr  = client-&gt;addr;wrmsg[i].flags = I2C_M_RD;wrmsg[i].len = rd_len;wrmsg[i].buf = rd_buf;i++;&#125;ret = i2c_transfer(client-&gt;adapter, wrmsg, i);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ret;<span class="hljs-keyword">if</span> (ret != i)<span class="hljs-keyword">return</span> -EIO;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">edt_ft5x06_ts_check_crc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span><span class="hljs-params">    u8 *buf, <span class="hljs-type">int</span> buflen)</span>&#123;<span class="hljs-type">int</span> i;u8 crc = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; buflen - <span class="hljs-number">1</span>; i++)crc ^= buf[i];<span class="hljs-keyword">if</span> (crc != buf[buflen<span class="hljs-number">-1</span>]) &#123;dev_err_ratelimited(&amp;tsdata-&gt;client-&gt;dev,    <span class="hljs-string">&quot;crc error: 0x%02x expected, got 0x%02x\n&quot;</span>,    crc, buf[buflen<span class="hljs-number">-1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">edt_ft5x06_ts_isr</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> dev_id;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;tsdata-&gt;client-&gt;dev;u8 cmd;u8 rdbuf[<span class="hljs-number">29</span>];<span class="hljs-type">int</span> i, type, x, y, id;<span class="hljs-type">int</span> offset, tplen, datalen;<span class="hljs-type">int</span> error;<span class="hljs-type">bool</span> down;cmd = <span class="hljs-number">0x02</span>; <span class="hljs-comment">/* 0X02是触摸状态寄存器 */</span>offset = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 偏移1，也就是0X02+1=0x03,从0X03开始是触摸值 */</span>tplen = <span class="hljs-number">6</span>;<span class="hljs-comment">/* 一个触摸点有6个寄存器来保存触摸值 */</span>datalen = <span class="hljs-number">29</span>;<span class="hljs-comment">/* 数据读取长度为29 */</span><span class="hljs-built_in">memset</span>(rdbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(rdbuf));error = edt_ft5x06_ts_readwrite(tsdata-&gt;client,<span class="hljs-keyword">sizeof</span>(cmd), &amp;cmd,datalen, rdbuf);<span class="hljs-keyword">if</span> (error) &#123;dev_err_ratelimited(dev, <span class="hljs-string">&quot;Unable to fetch data, error: %d\n&quot;</span>,    error);<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-comment">/* 上报每一个触摸点坐标 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_SUPPORT_POINTS; i++) &#123;u8 *buf = &amp;rdbuf[i * tplen + offset];<span class="hljs-comment">/* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span><span class="hljs-comment"> * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span><span class="hljs-comment"> * bit5:4  保留</span><span class="hljs-comment"> * bit3:0  X轴触摸点的11~8位。</span><span class="hljs-comment"> */</span>type = buf[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">6</span>;     <span class="hljs-comment">/* 获取触摸类型 */</span><span class="hljs-keyword">if</span> (type == TOUCH_EVENT_RESERVED)<span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* 我们所使用的触摸屏和FT5X06是反过来的 */</span>x = ((buf[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">3</span>]) &amp; <span class="hljs-number">0x0fff</span>;y = ((buf[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">1</span>]) &amp; <span class="hljs-number">0x0fff</span>;<span class="hljs-comment">/* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span><span class="hljs-comment"> * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span><span class="hljs-comment"> * bit3:0  Y轴触摸点的11~8位。</span><span class="hljs-comment"> */</span>id = (buf[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>;down = type != TOUCH_EVENT_UP;input_mt_slot(tsdata-&gt;input, id);input_mt_report_slot_state(tsdata-&gt;input, MT_TOOL_FINGER, down);<span class="hljs-keyword">if</span> (!down)<span class="hljs-keyword">continue</span>;input_report_abs(tsdata-&gt;input, ABS_MT_POSITION_X, x);input_report_abs(tsdata-&gt;input, ABS_MT_POSITION_Y, y);&#125;input_mt_report_pointer_emulation(tsdata-&gt;input, <span class="hljs-literal">true</span>);input_sync(tsdata-&gt;input);out:<span class="hljs-keyword">return</span> IRQ_HANDLED;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_register_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span><span class="hljs-params">     u8 addr, u8 value)</span>&#123;u8 wrbuf[<span class="hljs-number">4</span>];<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;<span class="hljs-keyword">case</span> M06:wrbuf[<span class="hljs-number">0</span>] = tsdata-&gt;factory_mode ? <span class="hljs-number">0xf3</span> : <span class="hljs-number">0xfc</span>;wrbuf[<span class="hljs-number">1</span>] = tsdata-&gt;factory_mode ? addr &amp; <span class="hljs-number">0x7f</span> : addr &amp; <span class="hljs-number">0x3f</span>;wrbuf[<span class="hljs-number">2</span>] = value;wrbuf[<span class="hljs-number">3</span>] = wrbuf[<span class="hljs-number">0</span>] ^ wrbuf[<span class="hljs-number">1</span>] ^ wrbuf[<span class="hljs-number">2</span>];<span class="hljs-keyword">return</span> edt_ft5x06_ts_readwrite(tsdata-&gt;client, <span class="hljs-number">4</span>,wrbuf, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">case</span> M09:wrbuf[<span class="hljs-number">0</span>] = addr;wrbuf[<span class="hljs-number">1</span>] = value;<span class="hljs-keyword">return</span> edt_ft5x06_ts_readwrite(tsdata-&gt;client, <span class="hljs-number">2</span>,wrbuf, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> -EINVAL;&#125;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_register_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span><span class="hljs-params">    u8 addr)</span>&#123;u8 wrbuf[<span class="hljs-number">2</span>], rdbuf[<span class="hljs-number">2</span>];<span class="hljs-type">int</span> error;<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;<span class="hljs-keyword">case</span> M06:wrbuf[<span class="hljs-number">0</span>] = tsdata-&gt;factory_mode ? <span class="hljs-number">0xf3</span> : <span class="hljs-number">0xfc</span>;wrbuf[<span class="hljs-number">1</span>] = tsdata-&gt;factory_mode ? addr &amp; <span class="hljs-number">0x7f</span> : addr &amp; <span class="hljs-number">0x3f</span>;wrbuf[<span class="hljs-number">1</span>] |= tsdata-&gt;factory_mode ? <span class="hljs-number">0x80</span> : <span class="hljs-number">0x40</span>;error = edt_ft5x06_ts_readwrite(tsdata-&gt;client, <span class="hljs-number">2</span>, wrbuf, <span class="hljs-number">2</span>,rdbuf);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">return</span> error;<span class="hljs-keyword">if</span> ((wrbuf[<span class="hljs-number">0</span>] ^ wrbuf[<span class="hljs-number">1</span>] ^ rdbuf[<span class="hljs-number">0</span>]) != rdbuf[<span class="hljs-number">1</span>]) &#123;dev_err(&amp;tsdata-&gt;client-&gt;dev,<span class="hljs-string">&quot;crc error: 0x%02x expected, got 0x%02x\n&quot;</span>,wrbuf[<span class="hljs-number">0</span>] ^ wrbuf[<span class="hljs-number">1</span>] ^ rdbuf[<span class="hljs-number">0</span>],rdbuf[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> -EIO;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> M09:wrbuf[<span class="hljs-number">0</span>] = addr;error = edt_ft5x06_ts_readwrite(tsdata-&gt;client, <span class="hljs-number">1</span>,wrbuf, <span class="hljs-number">1</span>, rdbuf);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">return</span> error;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-keyword">return</span> rdbuf[<span class="hljs-number">0</span>];&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_attribute</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_attribute</span> <span class="hljs-title">dattr</span>;</span><span class="hljs-type">size_t</span> field_offset;u8 limit_low;u8 limit_high;u8 addr_m06;u8 addr_m09;&#125;;<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_ATTR(_field, _mode, _addr_m06, _addr_m09,\</span><span class="hljs-meta">_limit_low, _limit_high)\</span><span class="hljs-meta">struct edt_ft5x06_attribute edt_ft5x06_attr_##_field = &#123;\</span><span class="hljs-meta">.dattr = __ATTR(_field, _mode,\</span><span class="hljs-meta">edt_ft5x06_setting_show,\</span><span class="hljs-meta">edt_ft5x06_setting_store),\</span><span class="hljs-meta">.field_offset = offsetof(struct edt_ft5x06_ts_data, _field), \</span><span class="hljs-meta">.addr_m06 = _addr_m06,\</span><span class="hljs-meta">.addr_m09 = _addr_m09,\</span><span class="hljs-meta">.limit_low = _limit_low,\</span><span class="hljs-meta">.limit_high = _limit_high,\</span><span class="hljs-meta">&#125;</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">edt_ft5x06_setting_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span><span class="hljs-params">       <span class="hljs-keyword">struct</span> device_attribute *dattr,</span><span class="hljs-params">       <span class="hljs-type">char</span> *buf)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> to_i2c_client(dev);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> i2c_get_clientdata(client);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_attribute</span> *<span class="hljs-title">attr</span> =</span>container_of(dattr, <span class="hljs-keyword">struct</span> edt_ft5x06_attribute, dattr);u8 *field = (u8 *)tsdata + attr-&gt;field_offset;<span class="hljs-type">int</span> val;<span class="hljs-type">size_t</span> count = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;u8 addr;mutex_lock(&amp;tsdata-&gt;mutex);<span class="hljs-keyword">if</span> (tsdata-&gt;factory_mode) &#123;error = -EIO;<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;<span class="hljs-keyword">case</span> M06:addr = attr-&gt;addr_m06;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> M09:addr = attr-&gt;addr_m09;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:error = -ENODEV;<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-keyword">if</span> (addr != NO_REGISTER) &#123;val = edt_ft5x06_register_read(tsdata, addr);<span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) &#123;error = val;dev_err(&amp;tsdata-&gt;client-&gt;dev,<span class="hljs-string">&quot;Failed to fetch attribute %s, error %d\n&quot;</span>,dattr-&gt;attr.name, error);<span class="hljs-keyword">goto</span> out;&#125;&#125; <span class="hljs-keyword">else</span> &#123;val = *field;&#125;<span class="hljs-keyword">if</span> (val != *field) &#123;dev_warn(&amp;tsdata-&gt;client-&gt;dev, <span class="hljs-string">&quot;%s: read (%d) and stored value (%d) differ\n&quot;</span>, dattr-&gt;attr.name, val, *field);*field = val;&#125;count = scnprintf(buf, PAGE_SIZE, <span class="hljs-string">&quot;%d\n&quot;</span>, val);out:mutex_unlock(&amp;tsdata-&gt;mutex);<span class="hljs-keyword">return</span> error ?: count;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">edt_ft5x06_setting_store</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span><span class="hljs-params"><span class="hljs-keyword">struct</span> device_attribute *dattr,</span><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> count)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> to_i2c_client(dev);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> i2c_get_clientdata(client);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_attribute</span> *<span class="hljs-title">attr</span> =</span>container_of(dattr, <span class="hljs-keyword">struct</span> edt_ft5x06_attribute, dattr);u8 *field = (u8 *)tsdata + attr-&gt;field_offset;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val;<span class="hljs-type">int</span> error;u8 addr;mutex_lock(&amp;tsdata-&gt;mutex);<span class="hljs-keyword">if</span> (tsdata-&gt;factory_mode) &#123;error = -EIO;<span class="hljs-keyword">goto</span> out;&#125;error = kstrtouint(buf, <span class="hljs-number">0</span>, &amp;val);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">goto</span> out;<span class="hljs-keyword">if</span> (val &lt; attr-&gt;limit_low || val &gt; attr-&gt;limit_high) &#123;error = -ERANGE;<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;<span class="hljs-keyword">case</span> M06:addr = attr-&gt;addr_m06;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> M09:addr = attr-&gt;addr_m09;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:error = -ENODEV;<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-keyword">if</span> (addr != NO_REGISTER) &#123;error = edt_ft5x06_register_write(tsdata, addr, val);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;tsdata-&gt;client-&gt;dev,<span class="hljs-string">&quot;Failed to update attribute %s, error: %d\n&quot;</span>,dattr-&gt;attr.name, error);<span class="hljs-keyword">goto</span> out;&#125;&#125;*field = val;out:mutex_unlock(&amp;tsdata-&gt;mutex);<span class="hljs-keyword">return</span> error ?: count;&#125;<span class="hljs-type">static</span> <span class="hljs-title function_">EDT_ATTR</span><span class="hljs-params">(gain, S_IWUSR | S_IRUGO, WORK_REGISTER_GAIN,</span><span class="hljs-params">M09_REGISTER_GAIN, <span class="hljs-number">0</span>, <span class="hljs-number">31</span>)</span>;<span class="hljs-type">static</span> <span class="hljs-title function_">EDT_ATTR</span><span class="hljs-params">(offset, S_IWUSR | S_IRUGO, WORK_REGISTER_OFFSET,</span><span class="hljs-params">M09_REGISTER_OFFSET, <span class="hljs-number">0</span>, <span class="hljs-number">31</span>)</span>;<span class="hljs-type">static</span> <span class="hljs-title function_">EDT_ATTR</span><span class="hljs-params">(threshold, S_IWUSR | S_IRUGO, WORK_REGISTER_THRESHOLD,</span><span class="hljs-params">M09_REGISTER_THRESHOLD, <span class="hljs-number">20</span>, <span class="hljs-number">80</span>)</span>;<span class="hljs-type">static</span> <span class="hljs-title function_">EDT_ATTR</span><span class="hljs-params">(report_rate, S_IWUSR | S_IRUGO, WORK_REGISTER_REPORT_RATE,</span><span class="hljs-params">NO_REGISTER, <span class="hljs-number">3</span>, <span class="hljs-number">14</span>)</span>;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> *<span class="hljs-title">edt_ft5x06_attrs</span>[] =</span> &#123;&amp;edt_ft5x06_attr_gain.dattr.attr,&amp;edt_ft5x06_attr_offset.dattr.attr,&amp;edt_ft5x06_attr_threshold.dattr.attr,&amp;edt_ft5x06_attr_report_rate.dattr.attr,<span class="hljs-literal">NULL</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> <span class="hljs-title">edt_ft5x06_attr_group</span> =</span> &#123;.attrs = edt_ft5x06_attrs,&#125;;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_FS</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_factory_mode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> tsdata-&gt;client;<span class="hljs-type">int</span> retries = EDT_SWITCH_MODE_RETRIES;<span class="hljs-type">int</span> ret;<span class="hljs-type">int</span> error;disable_irq(client-&gt;irq);<span class="hljs-keyword">if</span> (!tsdata-&gt;raw_buffer) &#123;tsdata-&gt;raw_bufsize = tsdata-&gt;num_x * tsdata-&gt;num_y *      <span class="hljs-keyword">sizeof</span>(u16);tsdata-&gt;raw_buffer = kzalloc(tsdata-&gt;raw_bufsize, GFP_KERNEL);<span class="hljs-keyword">if</span> (!tsdata-&gt;raw_buffer) &#123;error = -ENOMEM;<span class="hljs-keyword">goto</span> err_out;&#125;&#125;<span class="hljs-comment">/* mode register is 0x3c when in the work mode */</span><span class="hljs-keyword">if</span> (tsdata-&gt;version == M09)<span class="hljs-keyword">goto</span> m09_out;error = edt_ft5x06_register_write(tsdata, WORK_REGISTER_OPMODE, <span class="hljs-number">0x03</span>);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;client-&gt;dev,<span class="hljs-string">&quot;failed to switch to factory mode, error %d\n&quot;</span>, error);<span class="hljs-keyword">goto</span> err_out;&#125;tsdata-&gt;factory_mode = <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> &#123;mdelay(EDT_SWITCH_MODE_DELAY);<span class="hljs-comment">/* mode register is 0x01 when in factory mode */</span>ret = edt_ft5x06_register_read(tsdata, FACTORY_REGISTER_OPMODE);<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0x03</span>)<span class="hljs-keyword">break</span>;&#125; <span class="hljs-keyword">while</span> (--retries &gt; <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (retries == <span class="hljs-number">0</span>) &#123;dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;not in factory mode after %dms.\n&quot;</span>,EDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);error = -EIO;<span class="hljs-keyword">goto</span> err_out;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;err_out:kfree(tsdata-&gt;raw_buffer);tsdata-&gt;raw_buffer = <span class="hljs-literal">NULL</span>;tsdata-&gt;factory_mode = <span class="hljs-literal">false</span>;enable_irq(client-&gt;irq);<span class="hljs-keyword">return</span> error;m09_out:dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;No factory mode support for M09\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_work_mode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> tsdata-&gt;client;<span class="hljs-type">int</span> retries = EDT_SWITCH_MODE_RETRIES;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;<span class="hljs-type">int</span> ret;<span class="hljs-type">int</span> error;<span class="hljs-comment">/* mode register is 0x01 when in the factory mode */</span>error = edt_ft5x06_register_write(tsdata, FACTORY_REGISTER_OPMODE, <span class="hljs-number">0x1</span>);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;client-&gt;dev,<span class="hljs-string">&quot;failed to switch to work mode, error: %d\n&quot;</span>, error);<span class="hljs-keyword">return</span> error;&#125;tsdata-&gt;factory_mode = <span class="hljs-literal">false</span>;<span class="hljs-keyword">do</span> &#123;mdelay(EDT_SWITCH_MODE_DELAY);<span class="hljs-comment">/* mode register is 0x01 when in factory mode */</span>ret = edt_ft5x06_register_read(tsdata, WORK_REGISTER_OPMODE);<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0x01</span>)<span class="hljs-keyword">break</span>;&#125; <span class="hljs-keyword">while</span> (--retries &gt; <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (retries == <span class="hljs-number">0</span>) &#123;dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;not in work mode after %dms.\n&quot;</span>,EDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);tsdata-&gt;factory_mode = <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> -EIO;&#125;kfree(tsdata-&gt;raw_buffer);tsdata-&gt;raw_buffer = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/* restore parameters */</span>edt_ft5x06_register_write(tsdata, reg_addr-&gt;reg_threshold,  tsdata-&gt;threshold);edt_ft5x06_register_write(tsdata, reg_addr-&gt;reg_gain,  tsdata-&gt;gain);edt_ft5x06_register_write(tsdata, reg_addr-&gt;reg_offset,  tsdata-&gt;offset);<span class="hljs-keyword">if</span> (reg_addr-&gt;reg_report_rate)edt_ft5x06_register_write(tsdata, reg_addr-&gt;reg_report_rate,  tsdata-&gt;report_rate);enable_irq(client-&gt;irq);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_debugfs_mode_get</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, u64 *mode)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> data;*mode = tsdata-&gt;factory_mode;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_debugfs_mode_set</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, u64 mode)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> data;<span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (mode &gt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -ERANGE;mutex_lock(&amp;tsdata-&gt;mutex);<span class="hljs-keyword">if</span> (mode != tsdata-&gt;factory_mode) &#123;retval = mode ? edt_ft5x06_factory_mode(tsdata) :edt_ft5x06_work_mode(tsdata);&#125;mutex_unlock(&amp;tsdata-&gt;mutex);<span class="hljs-keyword">return</span> retval;&#125;;DEFINE_SIMPLE_ATTRIBUTE(debugfs_mode_fops, edt_ft5x06_debugfs_mode_get,edt_ft5x06_debugfs_mode_set, <span class="hljs-string">&quot;%llu\n&quot;</span>);<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">edt_ft5x06_debugfs_raw_data_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file,</span><span class="hljs-params"><span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *off)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> file-&gt;private_data;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> tsdata-&gt;client;<span class="hljs-type">int</span> retries  = EDT_RAW_DATA_RETRIES;<span class="hljs-type">int</span> val, i, error;<span class="hljs-type">size_t</span> read = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> colbytes;<span class="hljs-type">char</span> wrbuf[<span class="hljs-number">3</span>];u8 *rdbuf;<span class="hljs-keyword">if</span> (*off &lt; <span class="hljs-number">0</span> || *off &gt;= tsdata-&gt;raw_bufsize)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;mutex_lock(&amp;tsdata-&gt;mutex);<span class="hljs-keyword">if</span> (!tsdata-&gt;factory_mode || !tsdata-&gt;raw_buffer) &#123;error = -EIO;<span class="hljs-keyword">goto</span> out;&#125;error = edt_ft5x06_register_write(tsdata, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x01</span>);<span class="hljs-keyword">if</span> (error) &#123;dev_dbg(&amp;client-&gt;dev,<span class="hljs-string">&quot;failed to write 0x08 register, error %d\n&quot;</span>, error);<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-keyword">do</span> &#123;msleep(EDT_RAW_DATA_DELAY);val = edt_ft5x06_register_read(tsdata, <span class="hljs-number">0x08</span>);<span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;&#125; <span class="hljs-keyword">while</span> (--retries &gt; <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) &#123;error = val;dev_dbg(&amp;client-&gt;dev,<span class="hljs-string">&quot;failed to read 0x08 register, error %d\n&quot;</span>, error);<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-keyword">if</span> (retries == <span class="hljs-number">0</span>) &#123;dev_dbg(&amp;client-&gt;dev,<span class="hljs-string">&quot;timed out waiting for register to settle\n&quot;</span>);error = -ETIMEDOUT;<span class="hljs-keyword">goto</span> out;&#125;rdbuf = tsdata-&gt;raw_buffer;colbytes = tsdata-&gt;num_y * <span class="hljs-keyword">sizeof</span>(u16);wrbuf[<span class="hljs-number">0</span>] = <span class="hljs-number">0xf5</span>;wrbuf[<span class="hljs-number">1</span>] = <span class="hljs-number">0x0e</span>;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tsdata-&gt;num_x; i++) &#123;wrbuf[<span class="hljs-number">2</span>] = i;  <span class="hljs-comment">/* column index */</span>error = edt_ft5x06_ts_readwrite(tsdata-&gt;client,<span class="hljs-keyword">sizeof</span>(wrbuf), wrbuf,colbytes, rdbuf);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">goto</span> out;rdbuf += colbytes;&#125;read = <span class="hljs-type">min_t</span>(<span class="hljs-type">size_t</span>, count, tsdata-&gt;raw_bufsize - *off);<span class="hljs-keyword">if</span> (copy_to_user(buf, tsdata-&gt;raw_buffer + *off, read)) &#123;error = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;*off += read;out:mutex_unlock(&amp;tsdata-&gt;mutex);<span class="hljs-keyword">return</span> error ?: read;&#125;;<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">debugfs_raw_data_fops</span> =</span> &#123;.open = simple_open,.read = edt_ft5x06_debugfs_raw_data_read,&#125;;<span class="hljs-type">static</span> <span class="hljs-type">void</span><span class="hljs-title function_">edt_ft5x06_ts_prepare_debugfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span><span class="hljs-params">      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *debugfs_name)</span>&#123;tsdata-&gt;debug_dir = debugfs_create_dir(debugfs_name, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (!tsdata-&gt;debug_dir)<span class="hljs-keyword">return</span>;debugfs_create_u16(<span class="hljs-string">&quot;num_x&quot;</span>, S_IRUSR, tsdata-&gt;debug_dir, &amp;tsdata-&gt;num_x);debugfs_create_u16(<span class="hljs-string">&quot;num_y&quot;</span>, S_IRUSR, tsdata-&gt;debug_dir, &amp;tsdata-&gt;num_y);debugfs_create_file(<span class="hljs-string">&quot;mode&quot;</span>, S_IRUSR | S_IWUSR,    tsdata-&gt;debug_dir, tsdata, &amp;debugfs_mode_fops);debugfs_create_file(<span class="hljs-string">&quot;raw_data&quot;</span>, S_IRUSR,    tsdata-&gt;debug_dir, tsdata, &amp;debugfs_raw_data_fops);&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span><span class="hljs-title function_">edt_ft5x06_ts_teardown_debugfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;debugfs_remove_recursive(tsdata-&gt;debug_dir);kfree(tsdata-&gt;raw_buffer);&#125;<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><span class="hljs-title function_">edt_ft5x06_ts_prepare_debugfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span><span class="hljs-params">      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *debugfs_name)</span>&#123;&#125;<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><span class="hljs-title function_">edt_ft5x06_ts_teardown_debugfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_DEBUGFS */</span></span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client,</span><span class="hljs-params"><span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;<span class="hljs-type">int</span> error;<span class="hljs-keyword">if</span> (gpio_is_valid(tsdata-&gt;wake_pin)) &#123;error = devm_gpio_request_one(&amp;client-&gt;dev,tsdata-&gt;wake_pin, GPIOF_OUT_INIT_LOW,<span class="hljs-string">&quot;edt-ft5x06 wake&quot;</span>);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;client-&gt;dev,<span class="hljs-string">&quot;Failed to request GPIO %d as wake pin, error %d\n&quot;</span>,tsdata-&gt;wake_pin, error);<span class="hljs-keyword">return</span> error;&#125;msleep(<span class="hljs-number">5</span>);gpio_set_value(tsdata-&gt;wake_pin, <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span> (gpio_is_valid(tsdata-&gt;reset_pin)) &#123;<span class="hljs-comment">/* this pulls reset down, enabling the low active reset */</span>error = devm_gpio_request_one(&amp;client-&gt;dev,tsdata-&gt;reset_pin, GPIOF_OUT_INIT_LOW,<span class="hljs-string">&quot;edt-ft5x06 reset&quot;</span>);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;client-&gt;dev,<span class="hljs-string">&quot;Failed to request GPIO %d as reset pin, error %d\n&quot;</span>,tsdata-&gt;reset_pin, error);<span class="hljs-keyword">return</span> error;&#125;msleep(<span class="hljs-number">5</span>);gpio_set_value(tsdata-&gt;reset_pin, <span class="hljs-number">1</span>);msleep(<span class="hljs-number">300</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_identify</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client,</span><span class="hljs-params"><span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span><span class="hljs-params"><span class="hljs-type">char</span> *fw_version)</span>&#123;u8 rdbuf[EDT_NAME_LEN];<span class="hljs-type">char</span> *p;<span class="hljs-type">int</span> error;<span class="hljs-type">char</span> *model_name = tsdata-&gt;name;<span class="hljs-comment">/* see what we find if we assume it is a M06 *</span><span class="hljs-comment"> * if we get less than EDT_NAME_LEN, we don&#x27;t want</span><span class="hljs-comment"> * to have garbage in there</span><span class="hljs-comment"> */</span><span class="hljs-built_in">memset</span>(rdbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(rdbuf));error = edt_ft5x06_ts_readwrite(client, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;\xbb&quot;</span>,EDT_NAME_LEN - <span class="hljs-number">1</span>, rdbuf);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">return</span> error;<span class="hljs-comment">/* if we find something consistent, stay with that assumption</span><span class="hljs-comment"> * at least M09 won&#x27;t send 3 bytes here</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span> (!(strncasecmp(rdbuf + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;EP0&quot;</span>, <span class="hljs-number">3</span>))) &#123;tsdata-&gt;version = M06;<span class="hljs-comment">/* remove last &#x27;$&#x27; end marker */</span>rdbuf[EDT_NAME_LEN - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-keyword">if</span> (rdbuf[EDT_NAME_LEN - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;$&#x27;</span>)rdbuf[EDT_NAME_LEN - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">/* look for Model/Version separator */</span>p = <span class="hljs-built_in">strchr</span>(rdbuf, <span class="hljs-string">&#x27;*&#x27;</span>);<span class="hljs-keyword">if</span> (p)*p++ = <span class="hljs-string">&#x27;\0&#x27;</span>;strlcpy(model_name, rdbuf + <span class="hljs-number">1</span>, EDT_NAME_LEN);strlcpy(fw_version, p ? p : <span class="hljs-string">&quot;&quot;</span>, EDT_NAME_LEN);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* since there are only two versions around (M06, M09) */</span>tsdata-&gt;version = M09;error = edt_ft5x06_ts_readwrite(client, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;\xA6&quot;</span>,<span class="hljs-number">2</span>, rdbuf);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">return</span> error;strlcpy(fw_version, rdbuf, <span class="hljs-number">2</span>);error = edt_ft5x06_ts_readwrite(client, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;\xA8&quot;</span>,<span class="hljs-number">1</span>, rdbuf);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">return</span> error;<span class="hljs-built_in">snprintf</span>(model_name, EDT_NAME_LEN, <span class="hljs-string">&quot;EP0%i%i0M09&quot;</span>,rdbuf[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">4</span>, rdbuf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x0F</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_ATTR_CHECKSET(name, reg) \</span><span class="hljs-meta">do &#123;\</span><span class="hljs-meta"><span class="hljs-keyword">if</span> (pdata-&gt;name &gt;= edt_ft5x06_attr_##name.limit_low &amp;&amp;\</span><span class="hljs-meta">    pdata-&gt;name &lt;= edt_ft5x06_attr_##name.limit_high)\</span><span class="hljs-meta">edt_ft5x06_register_write(tsdata, reg, pdata-&gt;name);\</span><span class="hljs-meta">&#125; while (0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDT_GET_PROP(name, reg) &#123;\</span><span class="hljs-meta">u32 val;\</span><span class="hljs-meta"><span class="hljs-keyword">if</span> (of_property_read_u32(np, #name, &amp;val) == 0)\</span><span class="hljs-meta">edt_ft5x06_register_write(tsdata, reg, val);\</span><span class="hljs-meta">&#125;</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">edt_ft5x06_ts_get_dt_defaults</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params"><span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;EDT_GET_PROP(threshold, reg_addr-&gt;reg_threshold);EDT_GET_PROP(gain, reg_addr-&gt;reg_gain);EDT_GET_PROP(offset, reg_addr-&gt;reg_offset);&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span><span class="hljs-title function_">edt_ft5x06_ts_get_defaults</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata,</span><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> edt_ft5x06_platform_data *pdata)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;<span class="hljs-keyword">if</span> (!pdata-&gt;use_parameters)<span class="hljs-keyword">return</span>;<span class="hljs-comment">/* pick up defaults from the platform data */</span>EDT_ATTR_CHECKSET(threshold, reg_addr-&gt;reg_threshold);EDT_ATTR_CHECKSET(gain, reg_addr-&gt;reg_gain);EDT_ATTR_CHECKSET(offset, reg_addr-&gt;reg_offset);<span class="hljs-keyword">if</span> (reg_addr-&gt;reg_report_rate != NO_REGISTER)EDT_ATTR_CHECKSET(report_rate, reg_addr-&gt;reg_report_rate);&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span><span class="hljs-title function_">edt_ft5x06_ts_get_parameters</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;tsdata-&gt;threshold = edt_ft5x06_register_read(tsdata,     reg_addr-&gt;reg_threshold);tsdata-&gt;gain = edt_ft5x06_register_read(tsdata, reg_addr-&gt;reg_gain);tsdata-&gt;offset = edt_ft5x06_register_read(tsdata, reg_addr-&gt;reg_offset);<span class="hljs-keyword">if</span> (reg_addr-&gt;reg_report_rate != NO_REGISTER)tsdata-&gt;report_rate = edt_ft5x06_register_read(tsdata,reg_addr-&gt;reg_report_rate);tsdata-&gt;num_x = edt_ft5x06_register_read(tsdata, reg_addr-&gt;reg_num_x);tsdata-&gt;num_y = edt_ft5x06_register_read(tsdata, reg_addr-&gt;reg_num_y);&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span><span class="hljs-title function_">edt_ft5x06_ts_set_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_reg_addr</span> *<span class="hljs-title">reg_addr</span> =</span> &amp;tsdata-&gt;reg_addr;<span class="hljs-keyword">switch</span> (tsdata-&gt;version) &#123;<span class="hljs-keyword">case</span> M06:reg_addr-&gt;reg_threshold = WORK_REGISTER_THRESHOLD;reg_addr-&gt;reg_report_rate = WORK_REGISTER_REPORT_RATE;reg_addr-&gt;reg_gain = WORK_REGISTER_GAIN;reg_addr-&gt;reg_offset = WORK_REGISTER_OFFSET;reg_addr-&gt;reg_num_x = WORK_REGISTER_NUM_X;reg_addr-&gt;reg_num_y = WORK_REGISTER_NUM_Y;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> M09:reg_addr-&gt;reg_threshold = M09_REGISTER_THRESHOLD;reg_addr-&gt;reg_gain = M09_REGISTER_GAIN;reg_addr-&gt;reg_offset = M09_REGISTER_OFFSET;reg_addr-&gt;reg_num_x = M09_REGISTER_NUM_X;reg_addr-&gt;reg_num_y = M09_REGISTER_NUM_Y;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_OF</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_i2c_ts_probe_dt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span><span class="hljs-params"><span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span> =</span> dev-&gt;of_node;<span class="hljs-comment">/*</span><span class="hljs-comment"> * irq_pin is not needed for DT setup.</span><span class="hljs-comment"> * irq is associated via &#x27;interrupts&#x27; property in DT</span><span class="hljs-comment"> */</span><span class="hljs-comment">//tsdata-&gt;irq_pin = -EINVAL;</span>tsdata-&gt;irq_pin = of_get_named_gpio(np, <span class="hljs-string">&quot;interrupt-gpios&quot;</span>, <span class="hljs-number">0</span>);tsdata-&gt;reset_pin = of_get_named_gpio(np, <span class="hljs-string">&quot;reset-gpios&quot;</span>, <span class="hljs-number">0</span>);tsdata-&gt;wake_pin = of_get_named_gpio(np, <span class="hljs-string">&quot;wake-gpios&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_i2c_ts_probe_dt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,</span><span class="hljs-params"><span class="hljs-keyword">struct</span> edt_ft5x06_ts_data *tsdata)</span>&#123;<span class="hljs-keyword">return</span> -ENODEV;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client,</span><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>&#123;<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_platform_data</span> *<span class="hljs-title">pdata</span> =</span>dev_get_platdata(&amp;client-&gt;dev);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input</span>;</span><span class="hljs-type">int</span> error;<span class="hljs-type">char</span> fw_version[EDT_NAME_LEN];dev_dbg(&amp;client-&gt;dev, <span class="hljs-string">&quot;probing for EDT FT5x06 I2C\n&quot;</span>);tsdata = devm_kzalloc(&amp;client-&gt;dev, <span class="hljs-keyword">sizeof</span>(*tsdata), GFP_KERNEL);<span class="hljs-keyword">if</span> (!tsdata) &#123;dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;failed to allocate driver data.\n&quot;</span>);<span class="hljs-keyword">return</span> -ENOMEM;&#125;<span class="hljs-keyword">if</span> (!pdata) &#123;error = edt_ft5x06_i2c_ts_probe_dt(&amp;client-&gt;dev, tsdata);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;client-&gt;dev,<span class="hljs-string">&quot;DT probe failed and no platform data present\n&quot;</span>);<span class="hljs-keyword">return</span> error;&#125;&#125; <span class="hljs-keyword">else</span> &#123;tsdata-&gt;reset_pin = pdata-&gt;reset_pin;tsdata-&gt;irq_pin = pdata-&gt;irq_pin;tsdata-&gt;wake_pin = -EINVAL;&#125;error = edt_ft5x06_ts_reset(client, tsdata);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">return</span> error;<span class="hljs-keyword">if</span> (gpio_is_valid(tsdata-&gt;irq_pin)) &#123;error = devm_gpio_request_one(&amp;client-&gt;dev, tsdata-&gt;irq_pin,GPIOF_IN, <span class="hljs-string">&quot;edt-ft5x06 irq&quot;</span>);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;client-&gt;dev,<span class="hljs-string">&quot;Failed to request GPIO %d, error %d\n&quot;</span>,tsdata-&gt;irq_pin, error);<span class="hljs-keyword">return</span> error;&#125;&#125;input = devm_input_allocate_device(&amp;client-&gt;dev);<span class="hljs-keyword">if</span> (!input) &#123;dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;failed to allocate input device.\n&quot;</span>);<span class="hljs-keyword">return</span> -ENOMEM;&#125;mutex_init(&amp;tsdata-&gt;mutex);tsdata-&gt;client = client;tsdata-&gt;input = input;tsdata-&gt;factory_mode = <span class="hljs-literal">false</span>;error = edt_ft5x06_ts_identify(client, tsdata, fw_version);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;touchscreen probe failed\n&quot;</span>);<span class="hljs-keyword">return</span> error;&#125;edt_ft5x06_ts_set_regs(tsdata);<span class="hljs-keyword">if</span> (!pdata)edt_ft5x06_ts_get_dt_defaults(client-&gt;dev.of_node, tsdata);<span class="hljs-keyword">else</span>edt_ft5x06_ts_get_defaults(tsdata, pdata);edt_ft5x06_ts_get_parameters(tsdata);dev_dbg(&amp;client-&gt;dev,<span class="hljs-string">&quot;Model \&quot;%s\&quot;, Rev. \&quot;%s\&quot;, %dx%d sensors\n&quot;</span>,tsdata-&gt;name, fw_version, tsdata-&gt;num_x, tsdata-&gt;num_y);input-&gt;name = tsdata-&gt;name;input-&gt;id.bustype = BUS_I2C;input-&gt;dev.parent = &amp;client-&gt;dev;<span class="hljs-comment">//__set_bit(EV_KEY, input-&gt;evbit);</span>__set_bit(EV_ABS, input-&gt;evbit);__set_bit(BTN_TOUCH, input-&gt;keybit);<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>input_set_abs_params(input, ABS_X, <span class="hljs-number">0</span>, tsdata-&gt;num_x * <span class="hljs-number">64</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);input_set_abs_params(input, ABS_Y, <span class="hljs-number">0</span>, tsdata-&gt;num_y * <span class="hljs-number">64</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);input_set_abs_params(input, ABS_MT_POSITION_X,     <span class="hljs-number">0</span>, tsdata-&gt;num_x * <span class="hljs-number">64</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);input_set_abs_params(input, ABS_MT_POSITION_Y,     <span class="hljs-number">0</span>, tsdata-&gt;num_y * <span class="hljs-number">64</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>input_set_abs_params(input, ABS_X, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);input_set_abs_params(input, ABS_Y, <span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);input_set_abs_params(input, ABS_MT_POSITION_X,<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);input_set_abs_params(input, ABS_MT_POSITION_Y,<span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     <span class="hljs-keyword">if</span> (!pdata)touchscreen_parse_of_params(input);error = input_mt_init_slots(input, MAX_SUPPORT_POINTS, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to init MT slots.\n&quot;</span>);<span class="hljs-keyword">return</span> error;&#125;input_set_drvdata(input, tsdata);i2c_set_clientdata(client, tsdata);<span class="hljs-comment">/* zuozhongkai 2019/1/30 */</span><span class="hljs-comment">//printk(&quot;tsdata-&gt;irq_pin=%d\r\n&quot;,tsdata-&gt;irq_pin);</span>gpio_request(tsdata-&gt;irq_pin, <span class="hljs-string">&quot;interrupt-gpios&quot;</span>);gpio_direction_input(tsdata-&gt;irq_pin);error = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="hljs-literal">NULL</span>,edt_ft5x06_ts_isr,IRQF_TRIGGER_FALLING | IRQF_ONESHOT,client-&gt;name, tsdata);<span class="hljs-keyword">if</span> (error) &#123;dev_err(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to request touchscreen IRQ.\n&quot;</span>);<span class="hljs-keyword">return</span> error;&#125;error = sysfs_create_group(&amp;client-&gt;dev.kobj, &amp;edt_ft5x06_attr_group);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">return</span> error;error = input_register_device(input);<span class="hljs-keyword">if</span> (error)<span class="hljs-keyword">goto</span> err_remove_attrs;edt_ft5x06_ts_prepare_debugfs(tsdata, dev_driver_string(&amp;client-&gt;dev));device_init_wakeup(&amp;client-&gt;dev, <span class="hljs-number">1</span>);dev_dbg(&amp;client-&gt;dev,<span class="hljs-string">&quot;EDT FT5x06 initialized: IRQ %d, WAKE pin %d, Reset pin %d.\n&quot;</span>,client-&gt;irq, tsdata-&gt;wake_pin, tsdata-&gt;reset_pin);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;err_remove_attrs:sysfs_remove_group(&amp;client-&gt;dev.kobj, &amp;edt_ft5x06_attr_group);<span class="hljs-keyword">return</span> error;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edt_ft5x06_ts_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edt_ft5x06_ts_data</span> *<span class="hljs-title">tsdata</span> =</span> i2c_get_clientdata(client);edt_ft5x06_ts_teardown_debugfs(tsdata);sysfs_remove_group(&amp;client-&gt;dev.kobj, &amp;edt_ft5x06_attr_group);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __maybe_unused <span class="hljs-title function_">edt_ft5x06_ts_suspend</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> to_i2c_client(dev);<span class="hljs-keyword">if</span> (device_may_wakeup(dev))enable_irq_wake(client-&gt;irq);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __maybe_unused <span class="hljs-title function_">edt_ft5x06_ts_resume</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> to_i2c_client(dev);<span class="hljs-keyword">if</span> (device_may_wakeup(dev))disable_irq_wake(client-&gt;irq);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-title function_">SIMPLE_DEV_PM_OPS</span><span class="hljs-params">(edt_ft5x06_ts_pm_ops,</span><span class="hljs-params"> edt_ft5x06_ts_suspend, edt_ft5x06_ts_resume)</span>;<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">edt_ft5x06_ts_id</span>[] =</span> &#123;&#123; <span class="hljs-string">&quot;edt-ft5x06&quot;</span>, <span class="hljs-number">0</span>, &#125;,&#123; <span class="hljs-comment">/* sentinel */</span> &#125;&#125;;MODULE_DEVICE_TABLE(i2c, edt_ft5x06_ts_id);<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_OF</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">edt_ft5x06_of_match</span>[] =</span> &#123;&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5206&quot;</span>, &#125;,&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5306&quot;</span>, &#125;,&#123; .compatible = <span class="hljs-string">&quot;edt,edt-ft5406&quot;</span>, &#125;,&#123; <span class="hljs-comment">/* sentinel */</span> &#125;&#125;;MODULE_DEVICE_TABLE(of, edt_ft5x06_of_match);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">edt_ft5x06_ts_driver</span> =</span> &#123;.driver = &#123;.owner = THIS_MODULE,.name = <span class="hljs-string">&quot;edt_ft5x06&quot;</span>,.of_match_table = of_match_ptr(edt_ft5x06_of_match),.pm = &amp;edt_ft5x06_ts_pm_ops,&#125;,.id_table = edt_ft5x06_ts_id,.probe    = edt_ft5x06_ts_probe,.remove   = edt_ft5x06_ts_remove,&#125;;module_i2c_driver(edt_ft5x06_ts_driver);MODULE_AUTHOR(<span class="hljs-string">&quot;Simon Budig &lt;simon.budig@kernelconcepts.de&gt;&quot;</span>);MODULE_DESCRIPTION(<span class="hljs-string">&quot;EDT FT5x06 I2C Touchscreen Driver&quot;</span>);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22| Linux 音频驱动</title>
    <link href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-音频驱动"><a href="#Linux-音频驱动" class="headerlink" title="Linux 音频驱动"></a>Linux 音频驱动</h1><h2 id="一、音频接口简介"><a href="#一、音频接口简介" class="headerlink" title="一、音频接口简介"></a>一、音频接口简介</h2><h3 id="1-为何需要音频编解码芯片？"><a href="#1-为何需要音频编解码芯片？" class="headerlink" title="1| 为何需要音频编解码芯片？"></a>1| 为何需要音频编解码芯片？</h3><p>处理器要想“听到”外界的声音必须要把外界的声音转化为自己能够理解的“语言”，处理器能理解的就是 0 和 1，也就是二进制数据。所以我们需要先把外界的声音转换为处理器能理解的 0 和 1，在信号处理领域，外界的声音是模拟信号，处理器能理解的是数字信号，因此这里就涉及到一个模拟信号转换为数字信号的过程，而完成这个功能的就是 ADC 芯片。</p><p>同理，如果处理器要向外界传达自己的“心声”，也就是放音，那么就涉及到将处理器能理解的 0 和 1 转化为外界能理解的连续变化的声音，这个过程就是将数字信号转化为模拟信号，而完成这个功能的是 DAC 芯片。</p><p>现在我们知道了，处理器如果既想“听到”外界的声音，又想向外界传达自己的“心声”，那么就需要同时用到 DAC 和 ADC 这两款芯片。那是不是买两颗 DAC 和 ADC 芯片就行了呢？答案肯定是可以的，但是音频不单单是能出声、能听到就行。我们往往需要听到的声音动听、录进去的语音贴近真实、可以调节音效、对声音能够进行一些处理(需要 DSP 单元)、拥有统一的标准接口，方便开发等等。将这些针对声音的各种要求全部叠加到 DAC 和 ADC 芯片上，那么就会得到一个专门用于音频的芯片，也就是音频编解码芯片，英文名字就是 Audio CODEC，所以我们在手机或者电脑的介绍中看到“CODEC”这个词语，一般说的都是音频编解码。</p><p>既然音频 CODEC 的本质是 ADC 和 DAC，那么采样率和采样位数就是衡量一款音频CODEC 最重要的指标。比如常见音频采样率有 8K、44.1K、48K、192K 甚至 384K 和 768K，采样位数常见的有 8 位、16 位、24 位、32 位。采样率和采样位数越高，那么音频 CODEC 越能真实的还原声音，也就是大家说的HIFI。因此大家会看到高端的音频播放器都会有很高的采样率和采样位数，同样的价格也会越高。当然了，实际的效果还与其他部分有关，采样率和采样位数只是其中重要的指标之一。</p><h3 id="2-WM8960简介"><a href="#2-WM8960简介" class="headerlink" title="2| WM8960简介"></a>2| WM8960简介</h3><p>前面我们已经分析了为何需要音频编解码芯片，那是因为专用的音频编解码芯片提供了很多针对音频的特性。我们就以正点原子 ALPHA 开发板所使用的 WM8960 这颗芯片为例，来看一下专用的音频编解码芯片都有哪些特性。</p><p>WM8960 是一颗由 wolfson(欧胜)公司出品的音频编解码芯片，是一颗低功耗、高质量的立体声音频 CODEC。集成 D 类喇叭功放，每个通道可以驱动一个 1W 喇叭(8Ω)。内部集成 3 个立体声输入源，可以灵活配置，拥有一路完整的麦克风接口。WM8960 内部 ADC 和 DAC 都为24 位，WM8960 主要特性如下所示：</p><ul><li>①、DAC 的 SNR(信噪比)为 98dB，3.3V、48KHz 下 THD(谐波失真)为-84dB。</li><li>②、ADC 的 SNR(信噪比)为 94dB，3.3V、48KHz 下 THD(谐波失真)为-82dB。</li><li>③、3D 增强。</li><li>④、立体声 D 类功放，可以直接外接喇叭，8Ω负载下每通道 1W。</li><li>⑤、集成耳机接口。</li><li>⑥、集成麦克风接口。</li><li>⑦、采样率支持 8K、11.025K、12K、16K、22.05K、24K、32K、44.1K 和 48K。</li><li>……</li></ul><p>WM8960 整体框图如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907161531045.png" alt="image-20200907161531045"></p><p>依次来看一下图中这四部分接口都是什么功能：</p><ul><li><p>①、此部分是 WM8960 提供的输入接口，作为立体声音频输入源，一共提供了三路，分别为 LINPUT1&#x2F;RINPUT1、LINPUT2&#x2F;RINPUT2、LINPUT3&#x2F;RINPUT3。麦克风或线路输入就连接到此接口上，这部分是需要硬件工程师重点关心的，因为音频选择从哪一路进入需要在画 PCB 的时候就应该定好。</p></li><li><p>②、此部分是 WM8960 的输出接口，比如输出给耳机或喇叭，SPK_LP&#x2F;SPK_LN 用于连接左声道的喇叭，支持 1W 的 8Ω喇叭。SPK_RP&#x2F;SPK_RN 用于连接右声道的喇叭，同样支持 1W的 8Ω喇叭，最后就是HP_L&#x2F;HP_R，用于连接耳机。</p></li><li><p>③、此部分是数字音频接口，用于和主控制器连接，有 5 根线，用于主控制器和 WM8960之间进行数据“沟通”。主控制器向 WM8960 的 DAC 发送的数据，WM8960 的 ADC 向主控制传递的数据都是通过此音频接口来完成的。这个接口非常重要，是我们驱动开发人员重点关注的，此接口支持 I2S 格式。此接口 5 根线的作用如下：</p><ul><li><p><strong>ADCDAT</strong>：ADC 数据输出引脚，采集到的音频数据转换为数字信号以后通过此引脚传输给主控制器。</p></li><li><p><strong>ADCLRC</strong>：ADC 数据对齐时钟，也就是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率就是采样率。此引脚可以配置为 GPIO 功能，配置为 GPIO 以后 ADC 就会使用 DACLRC引脚作为帧时钟。</p></li><li><p><strong>DACDAT</strong>：DAC 数据输入引脚，主控器通过此引脚将数字信号输入给 WM8960 的 DAC。</p></li><li><p><strong>DACLRC</strong> ：DAC 数据对齐时钟，功能和 ADCLRC 一样，都是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率等于采样率。</p></li><li><p><strong>BCLK</strong> ：位时钟，用于同步。</p></li><li><p><strong>MCLK</strong> ：主时钟，WM8960 工作的时候还需要一路主时钟，此时钟由 I.MX6ULL 提供，MCLK 频率等于采样率的 256 或 384 倍，因此大家在 WM8960 的数据手册里面常看到MCLK&#x3D;256fs 或 MCLK&#x3D;384fs。</p></li></ul></li><li><p>④、此部分为控制接口，是一个标准的 I2C 接口，WM8960 要想工作必须对其进行配置，这个 I2C 接口就是用于配置 WM8960 的。</p></li></ul><h3 id="3-I2S总线接口"><a href="#3-I2S总线接口" class="headerlink" title="3| I2S总线接口"></a>3| I2S总线接口</h3><p>I2S(Inter-IC Sound)总线有时候也写作 IIS，I2S 是飞利浦公司提出的一种<strong>用于数字音频设备之间进行音频数据传输的总线</strong>。和 I2C、SPI 这些常见的通信协议一样，I2S 总线用于主控制器和音频 CODEC 芯片之间传输音频数据。因此，要想使用 I2S 协议，主控制器和音频 CODEC 都得支持 I2S 协议，I.MX6ULL 的 SAI 外设就支持 I2S 协议，WM8960 同样也支持 I2S，所以本章实验就是使用 I2S 协议来完成的。I2S 接口需要 3 根信号线(如果需要实现收和发，那么就要 4根信号线，收和发分别使用一根信号线)：</p><ul><li><strong>SCK</strong> ：串行时钟信号，也叫做位时钟(BCLK)，音频数据的每一位数据都对应一个 SCK，立体声都是双声道的，因此 SCK&#x3D;2×采样率×采样位数。比如采样率为 44.1KHz、16 位的立体声音频，那么 SCK&#x3D;2×44100×16&#x3D;1411200Hz&#x3D;1.4112MHz。</li><li><strong>WS</strong> ：字段(声道)选择信号，也叫做 LRCK，也叫做帧时钟，用于切换左右声道数据，WS 为“1”表示正在传输左声道的数据，WS 为“0”表示正在传输右声道的数据。WS 的频率等于采样率，比如采样率为 44.1KHz 的音频，WS&#x3D;44.1KHz。</li><li><strong>SD</strong>： ：串行数据信号，也就是我们实际的音频数据，如果要同时实现放音和录音，那么就需要 2 根数据线，比如 WM8960 的 ADCDAT 和 DACDAT，就是分别用于录音和放音。不管音频数据是多少位的，数据的最高位都是最先传输的。数据的最高位总是出现在一帧开始后(LRCK变化)的第 2 个 SCK 脉冲处。</li></ul><p>另外，有时候为了使音频 CODEC 芯片与主控制器之间能够更好的同步，会引入另外一个叫做 MCLK 的信号，也叫做主时钟或系统时钟，一般是采样率的 256 倍或 384 倍。下图 就是一帧立体声音频时序图：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162620883.png" alt="image-20200907162620883"></p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162658396.png" alt="image-20200907162658396"></p><p>图 65.1.3.2 中通道 0 是 LRCK 时钟，通道 1 为 BCLK，通道 2 是 DACDATA，通道 3 是MCLK。随着技术的发展，在统一的 I2S 接口下，出现了不同的数据格式，根据 DATA 数据相对于 LRCK 和 SCLK 位置的不同，出现了 Left Justified(左对齐)和 Right Justified(右对齐)两种格式，这两种格式的时序图如下图所示</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162754213.png" alt="image-20200907162754213"></p><h3 id="4-I-MX6ULL-SAI-简介"><a href="#4-I-MX6ULL-SAI-简介" class="headerlink" title="4| I.MX6ULL SAI  简介"></a>4| I.MX6ULL SAI  简介</h3><p>音频 CODEC 支持 I2S 协议，那么主控制器也必须支持 I2S 协议，大家如果学过STM32F4&#x2F;F7&#x2F;H7 的话应该知道 SAI 接口，因为在 STM32 中就是通过 SAI 接口来连接音频CODEC。I.MX6ULL 也提供了一个叫做 SAI 的外设，全称为 Synchronous Audio Interface，翻译过来就是同步音频接口。</p><p>I.MX6ULL 的 SAI 是一个全双工、支持帧同步的串行接口，支持 I2S、AC97、TDM 和音频DSP，SAI 主要特性如下：</p><ul><li>①、帧最大为 32 个字。</li><li>②、字大小可选择 8bit 或 32bit。</li><li>③、每个接收和发送通道拥有 32×32bit 的 FIFO。</li><li>④、FIFO 错误以后支持平滑重启。</li></ul><p>I.MX6ULL 的 SAI 框图如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907162904361.png" alt="image-20200907162904361"></p><p>图中右侧“SAI_TX”和“SAI_RX”开头的就是 SAI 外设提供给外部连接音频CODEC 的信号线，具体连接方法查看下一节的原理图。</p><h2 id="二、硬件原理图分析"><a href="#二、硬件原理图分析" class="headerlink" title="二、硬件原理图分析"></a>二、硬件原理图分析</h2><p>正点原子 ALPHA 开发板音频原理图如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907163008088.png" alt="image-20200907163008088"></p><p>图中我们重点关注两个接口，SAI 和 I2C，我们依次来看一下这两个接口：</p><ul><li>①、SAI 接口一共用到了 6 根数据线，这 6 根数据线用于 I.MX6ULL 与 WM8960 之间的音频数据收发。</li><li>②、WM8960 在使用的时候需要进行配置，配置接口为 I2C，连接到了 I.MX6ULL 的 I2C2上。</li></ul><h2 id="三、Linux音频驱动使能"><a href="#三、Linux音频驱动使能" class="headerlink" title="三、Linux音频驱动使能"></a>三、Linux音频驱动使能</h2><p>NXP 官方已经写好了 WM8960 驱动，因此我们直接配置内核使能 WM8960 驱动即可，按照如下所示步骤使能 WM8960 驱动。</p><h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1| 修改设备树"></a>1| 修改设备树</h3><p>前面分析原理图的时候已经说过了，WM8960 与 I.MX6ULL 之间有两个通信接口：I2C 和SAI，因此设备树中会涉及到 I2C 和 SAI 两个设备节点。其中 I2C 用于配置 WM8960，SAI 接口用于音频数据传输，我们依次来配置一下这两个接口。</p><h4 id="1-、wm8960-i2c-接口设备树"><a href="#1-、wm8960-i2c-接口设备树" class="headerlink" title="1 、wm8960 i2c  接口设备树"></a>1 、wm8960 i2c  接口设备树</h4><p>首先配置一下 I2C 接口，根据原理图我们知道 WM8960 连接到了 I.MX6ULL 的 I2C2 接口上，因此在设备树中的“i2c2”节点下需要添加 wm8960 信息。如果去添加肯定是要看设备树的绑定手册，打开Documentation&#x2F;devicetree&#x2F;bindings&#x2F;sound&#x2F;wm8960.txt，此文件仅仅用于描述如何在 I2C 节点下添加 WM8960 相关信息，此文档适用于所有的主控，不局限于 I.MX6ULL。</p><p><strong>有 2 个必要的属性：</strong></p><ul><li><strong>compatible</strong>：兼容属性，属性值要设置为“wlf,wm8960”。所以大家在 linux 内核里面全局搜索“wlf,wm8960”的话就会找到WM8960的I2C驱动文件，此文件为sound&#x2F;soc&#x2F;codecs&#x2F;wm8960.c。</li><li><strong>reg</strong> ：设置 WM8960 的 I2C 地址，在正点原子的 ALPHA 开发板中 WM8960 的 I2C 地址为0X1A。</li></ul><p><strong>还要几个其他的可选属性：</strong></p><ul><li><strong>wlf,shared-lrclk</strong> ：这是一个 bool 类型的属性，如果添加了此属性，WM8960 的 R24 寄存器的 LRCM 位(bit2)就会置 1。当 LRCM 为 1 的时候只有当 ADC 和 DAC 全部关闭以后 ADCLRC和 DACLRC 时钟才会关闭。</li><li><strong>wlf,capless</strong> ：这也是一个 bool 类型的属性，如果添加了此属性，OUT3 引脚将会使能，并且为了响应耳机插入响应事件，HP_L 和 HP_R 这两个引脚都会关闭。</li></ul><p>绑定文档给出的参考节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">codec: wm8960@<span class="hljs-number">1</span>a &#123;    compatible = <span class="hljs-string">&quot;wlf,wm8960&quot;</span>;    reg = &lt;<span class="hljs-number">0x1a</span>&gt;;    wlf,shared-lrclk;&#125;;</code></pre></div><p>根据wm8960.txt 这份绑定文档我们就可以在任意一个主控的 I2C 节点下添加wm8960 相关信息了，NXP 官方 I.MX6ULL EVK 开发板使用的也是 WM8960，因此在设备树中添加设备节点这些工作 NXP 已经帮我们做了。打开 imx6ull-lxg-emmc.dts，找到名为“i2c2”的节点，此节点下都是连接到 I2C2 总线上的设备，其中就包括了 wm8960，wm8960 节点信息如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> codec: wm8960@<span class="hljs-number">1</span>a &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;wlf,wm8960&quot;</span>;<span class="hljs-number">3</span> reg = &lt;<span class="hljs-number">0x1a</span>&gt;;<span class="hljs-number">4</span> clocks = &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;<span class="hljs-number">5</span> clock-names = <span class="hljs-string">&quot;mclk&quot;</span>;<span class="hljs-number">6</span> wlf,shared-lrclk;<span class="hljs-number">7</span> &#125;;</code></pre></div><p>可以看出，示例代码中的内容基本和 wm8960.txt 这个绑定文档中的示例内容一致，只是多了第 4 和第 5 这两行，这两行用于描述时钟相关信息。第 4 行指定时钟源为 SAI2，第 5行指定时钟的名字为“mclk”。前面我们说过，为了更好的同步，一般都会额外提供一条 MCLK时钟。</p><p>至此，关于 wm8960 的 I2C 配置接口设备树就已经添加好了。</p><h4 id="2-、I-MX6ULL-SAI-音频接口设备树"><a href="#2-、I-MX6ULL-SAI-音频接口设备树" class="headerlink" title="2 、I.MX6ULL SAI 音频接口设备树"></a>2 、I.MX6ULL SAI 音频接口设备树</h4><p>接下来就是 I.MX6ULL 的 SAI 音频接口设备树相关内容的修改了，同样的，先查阅一下相应的绑定文档：Documentation&#x2F;devicetree&#x2F;bindings&#x2F;sound&#x2F;fsl-sai.txt。和我们前面讲过的 IIC 接口、ECSPI 等接口一样，在 imx6ull.dtsi 文件中会有关于 SAI 相关接口的描述，这部分是 NXP 原厂编写的，我们不需要做任何修改，SAI2 的设备子节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> sai2: sai@<span class="hljs-number">0202</span>c000 &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-sai&quot;</span>,<span class="hljs-number">3</span> <span class="hljs-string">&quot;fsl,imx6sx-sai&quot;</span>;<span class="hljs-number">4</span> reg = &lt;<span class="hljs-number">0x0202c000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">5</span> interrupts = &lt;GIC_SPI <span class="hljs-number">98</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-number">6</span> clocks = &lt;&amp;clks IMX6UL_CLK_SAI2_IPG&gt;,<span class="hljs-number">7</span>  &lt;&amp;clks IMX6UL_CLK_DUMMY&gt;,<span class="hljs-number">8</span>  &lt;&amp;clks IMX6UL_CLK_SAI2&gt;,<span class="hljs-number">9</span>  &lt;&amp;clks <span class="hljs-number">0</span>&gt;, &lt;&amp;clks <span class="hljs-number">0</span>&gt;;<span class="hljs-number">10</span> clock-names = <span class="hljs-string">&quot;bus&quot;</span>, <span class="hljs-string">&quot;mclk0&quot;</span>, <span class="hljs-string">&quot;mclk1&quot;</span>, <span class="hljs-string">&quot;mclk2&quot;</span>, <span class="hljs-string">&quot;mclk3&quot;</span>;<span class="hljs-number">11</span> dma-names = <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-string">&quot;tx&quot;</span>;<span class="hljs-number">12</span> dmas = &lt;&amp;sdma <span class="hljs-number">37</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>&gt;, &lt;&amp;sdma <span class="hljs-number">38</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>&gt;;<span class="hljs-number">13</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<span class="hljs-number">14</span> &#125;;</code></pre></div><p>直接搜索 compatible 属性中的两个兼容值，那么你就会找到 I.MX6ULL 的 SAI 接口驱动文件，路径为 sound&#x2F;soc&#x2F;fsl&#x2F;fsl_sai.c，此驱动文件不需要我们去研究，除非你在 NXP 上班，而你的工作恰好是给 NXP 的 I.MX 系列芯片编写 SAI 驱动的。</p><p>从第 13 行可以看出，SAI2 默认是关闭的，因此我们需要将其打开，也就是设置 status 属性的值为“okay”，这个工作肯定是在具体板子对应的.dts 文件中完成的，其实就是向 sai2 节点里面追加或者修改一些属性值。打开 imx6ull-lxg-emmc.dts 文件，找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;sai2 &#123;<span class="hljs-number">2</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">3</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_sai2<span class="hljs-number">4</span>  &amp;pinctrl_sai2_hp_det_b&gt;;<span class="hljs-number">5</span> assigned-clocks = &lt;&amp;clks IMX6UL_CLK_SAI2_SEL&gt;,<span class="hljs-number">6</span>   &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;<span class="hljs-number">7</span> assigned-clock-parents = &lt;&amp;clks IMX6UL_CLK_PLL4_AUDIO_DIV&gt;;<span class="hljs-number">8</span> assigned-clock-rates = &lt;<span class="hljs-number">0</span>&gt;, &lt;<span class="hljs-number">12288000</span>&gt;;<span class="hljs-number">9</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">10</span> &#125;;</code></pre></div><p>上述示例代码中的内容是 NXP 针对自己的 I.MX6ULL EVK 开发板而添加的，主要是对 sai2 节点做了三个方面的修改：SAI2 接口的 pinctrl、相应的时钟、修改 status 为“okay”。我们重点来看一下 pinctrl 的设置，因为关系到 SAI2 接口的 IO 设置，从 pinctrl-0 属性可以看出这里一共有两组 IO：pinctrl_sai2 和 pinctrl_sai2_hp_det_b，这两组 IO 内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_sai2: sai2grp &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6UL_PAD_JTAG_TDI__SAI2_TX_BCLK <span class="hljs-number">0x17088</span><span class="hljs-number">4</span> MX6UL_PAD_JTAG_TDO__SAI2_TX_SYNC <span class="hljs-number">0x17088</span><span class="hljs-number">5</span> MX6UL_PAD_JTAG_TRST_B__SAI2_TX_DATA <span class="hljs-number">0x11088</span><span class="hljs-number">6</span> MX6UL_PAD_JTAG_TCK__SAI2_RX_DATA <span class="hljs-number">0x11088</span><span class="hljs-number">7</span> MX6UL_PAD_JTAG_TMS__SAI2_MCLK <span class="hljs-number">0x17088</span><span class="hljs-number">8</span> &gt;;<span class="hljs-number">9</span> &#125;;<span class="hljs-number">10</span><span class="hljs-number">11</span> pinctrl_sai2_hp_det_b: sai2_hp_det_grp &#123;<span class="hljs-number">12</span> fsl,pins = &lt;<span class="hljs-number">13</span> MX6ULL_PAD_SNVS_TAMPER4__GPIO5_IO04 <span class="hljs-number">0x17059</span><span class="hljs-number">14</span> &gt;;<span class="hljs-number">15</span> &#125;;</code></pre></div><p>pinctrl_sai2 描述的是 SAI2 接口的 IO 配置，这个要根据自己板子的实际硬件情况修改，正点原子的 ALPHA 开发板上 SAI2 所使用的 IO 和 NXP 的 EVK 开发板一样，因此这里不需要做任何修改。</p><p>pinctrl_sai2_hp_det_b 描述的是耳机插入检测引脚，wm8960 支持耳机插入检测，这样当耳机插入以后就会通过耳机播放音乐，当耳机拔出来以后就会通过喇叭播放音乐。对于正点原子的 ALPHA 开发板，SAI 部分的设备树信息不需要做任何修改，直接使用 NXP官方写好的即可。</p><h4 id="3、I-MX6ULL-sound-节点"><a href="#3、I-MX6ULL-sound-节点" class="headerlink" title="3、I.MX6ULL sound 节点"></a>3、I.MX6ULL sound 节点</h4><p>最后我们需要在根节点“&#x2F;”下创建一个名为“sound”的子节点，笔者并没有在 linux 内核中找到此节点的绑定信息。只有一份在 I.MX 系列芯片中使用 WM8962 芯片的 sound 节点绑定文档，路径为：Documentation&#x2F;devicetree&#x2F;bindings&#x2F;sound&#x2F;imx-audio-wm8962.txt。虽然不是 wm8960的绑定文档，但是我们也可以参考 imx-audio-wm8962.txt。NXP 官方已经针对 EVK 开发板编写了 sound 节点，我们可以在此基础上针对我们所使用的平台来修改出对应的 sound 节点，修改完成以后的 sound 节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">sound &#123;compatible = <span class="hljs-string">&quot;fsl,imx6ul-evk-wm8960&quot;</span>,    <span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span>;model = <span class="hljs-string">&quot;wm8960-audio&quot;</span>;cpu-dai = &lt;&amp;sai2&gt;;audio-codec = &lt;&amp;codec&gt;;asrc-controller = &lt;&amp;asrc&gt;;codec-master;gpr = &lt;&amp;gpr <span class="hljs-number">4</span> <span class="hljs-number">0x100000</span> <span class="hljs-number">0x100000</span>&gt;;<span class="hljs-comment">/*</span><span class="hljs-comment">        * hp-det = &lt;hp-det-pin hp-det-polarity&gt;;</span><span class="hljs-comment"> * hp-det-pin: JD1 JD2  or JD3</span><span class="hljs-comment"> * hp-det-polarity = 0: hp detect high for headphone</span><span class="hljs-comment"> * hp-det-polarity = 1: hp detect high for speaker</span><span class="hljs-comment"> */</span>hp-det = &lt;<span class="hljs-number">3</span> <span class="hljs-number">0</span>&gt;;<span class="hljs-comment">/*hp-det-gpios = &lt;&amp;gpio5 4 0&gt;;</span><span class="hljs-comment">mic-det-gpios = &lt;&amp;gpio5 4 0&gt;;*/</span>audio-routing =<span class="hljs-string">&quot;Headphone Jack&quot;</span>, <span class="hljs-string">&quot;HP_L&quot;</span>,<span class="hljs-string">&quot;Headphone Jack&quot;</span>, <span class="hljs-string">&quot;HP_R&quot;</span>,<span class="hljs-string">&quot;Ext Spk&quot;</span>, <span class="hljs-string">&quot;SPK_LP&quot;</span>,<span class="hljs-string">&quot;Ext Spk&quot;</span>, <span class="hljs-string">&quot;SPK_LN&quot;</span>,<span class="hljs-string">&quot;Ext Spk&quot;</span>, <span class="hljs-string">&quot;SPK_RP&quot;</span>,<span class="hljs-string">&quot;Ext Spk&quot;</span>, <span class="hljs-string">&quot;SPK_RN&quot;</span>,<span class="hljs-string">&quot;LINPUT2&quot;</span>, <span class="hljs-string">&quot;Mic Jack&quot;</span>,<span class="hljs-string">&quot;LINPUT3&quot;</span>, <span class="hljs-string">&quot;Mic Jack&quot;</span>,<span class="hljs-string">&quot;RINPUT1&quot;</span>, <span class="hljs-string">&quot;Main MIC&quot;</span>,<span class="hljs-string">&quot;RINPUT2&quot;</span>, <span class="hljs-string">&quot;Main MIC&quot;</span>,<span class="hljs-string">&quot;Mic Jack&quot;</span>, <span class="hljs-string">&quot;MICB&quot;</span>,<span class="hljs-string">&quot;Main MIC&quot;</span>, <span class="hljs-string">&quot;MICB&quot;</span>,<span class="hljs-string">&quot;CPU-Playback&quot;</span>, <span class="hljs-string">&quot;ASRC-Playback&quot;</span>,<span class="hljs-string">&quot;Playback&quot;</span>, <span class="hljs-string">&quot;CPU-Playback&quot;</span>,<span class="hljs-string">&quot;ASRC-Capture&quot;</span>, <span class="hljs-string">&quot;CPU-Capture&quot;</span>,<span class="hljs-string">&quot;CPU-Capture&quot;</span>, <span class="hljs-string">&quot;Capture&quot;</span>;&#125;;</code></pre></div><p>简单看一下 sound 节点中几个重要的属性：</p><ul><li><p><strong>compatible</strong> ：非常重要，用于匹配相应的驱动文件，有两个属性值，在整个 linux 内核源码中搜索这两个属性值即可找到对应的驱动文件，这里找到的驱动文件为：sound&#x2F;soc&#x2F;fsl&#x2F;imx-wm8960.c。</p></li><li><p><strong>model</strong> ：最终用户看到的此声卡名字，这里设置为“wm8960-audio”。</p></li><li><p><strong>cpu-dai</strong>：CPU DAI(Digital Audio Interface)句柄，这里是 sai2 这个节点。</p></li><li><p><strong>audio-codec</strong>：音频解码芯片句柄，也就是 WM8960 芯片，这里为“codec”这个节点。</p></li><li><p><strong>asrc-controller</strong>：asrc 控制器，asrc 全称为 Asynchronous Sample Rate Converters，翻译过来就是异步采样频率转化器。</p></li><li><p><strong>hp-det</strong> ：耳机插入检测引脚设置，第一个参数为检测引脚，3 表示 JD3 为检测引脚。第二个参数设置检测电平，设置为 0 的时候，hp 检测到高电平表示耳机插入；设置为 1 的时候，hp 检测到高电平表示是喇叭，也就是耳机拔出了。</p></li><li><p><strong>audio-routing</strong>：音频器件一系列的连接设置，每个条目都是一对字符串，第一个字符串是连接的 sink，第二个是连接的 source(源)。</p></li></ul><h3 id="2-使能内核的-WM8960-驱动"><a href="#2-使能内核的-WM8960-驱动" class="headerlink" title="2| 使能内核的 WM8960  驱动"></a>2| 使能内核的 WM8960  驱动</h3><p>设备树配置完成以后就可以使能内核自带的 WM8960 驱动了，直接通过图形化界面配置即可，输入如下命令打开 linux 内核的图形化配置界面：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span></code></pre></div><h4 id="1-、取消-ALSA-模拟-OSS-API"><a href="#1-、取消-ALSA-模拟-OSS-API" class="headerlink" title="1 、取消 ALSA  模拟 OSS API"></a>1 、取消 ALSA  模拟 OSS API</h4><p>首先取消 ALSA 模拟 OSS，进入如下路径：</p><div class="hljs code-wrapper"><pre><code class="hljs clean">-&gt; Device Drivers    -&gt; Sound card support (SOUND [=y])        -&gt; Advanced Linux Sound Architecture (SND [=y])            -&gt; &lt;&gt; OSS Mixer API <span class="hljs-comment">//不选择</span>            -&gt; &lt;&gt; OSS PCM (digital audio) API <span class="hljs-comment">//不选择</span></code></pre></div><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907165744149.png" alt="image-20200907165744149"></p><h4 id="2-、使能-I-MX6ULL-的-的-WM8960-驱动"><a href="#2-、使能-I-MX6ULL-的-的-WM8960-驱动" class="headerlink" title="2 、使能 I.MX6ULL 的 的 WM8960 驱动"></a>2 、使能 I.MX6ULL 的 的 WM8960 驱动</h4><p>接下来使能 WM8960 驱动，进入如下路径：</p><div class="hljs code-wrapper"><pre><code class="hljs livescript">-&gt; Device Drivers    -&gt; Sound card support <span class="hljs-function"><span class="hljs-params">(SOUND [=y])</span></span><span class="hljs-function">        -&gt;</span> Advanced Linux Sound Architecture <span class="hljs-function"><span class="hljs-params">(SND [=y])</span></span><span class="hljs-function">            -&gt;</span> ALSA <span class="hljs-keyword">for</span> SoC audio support <span class="hljs-function"><span class="hljs-params">(SND_SOC [=y])</span></span><span class="hljs-function">            -&gt;</span> SoC Audio <span class="hljs-keyword">for</span> Freescale CPUs                    -&gt; &lt;*&gt; Asynchronous Sample Rate Converter (ASRC) module support <span class="hljs-regexp">//选中</span><span class="hljs-regexp">                    -&gt; &lt;*&gt; SoC Audio support for i.MX boards with wm8960 //</span>选中</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907165845744.png" alt="image-20200907165845744"></p><p>驱动使能以后重新编译 linux 内核，编译完成以后使用新的 zImage 和.dtb 文件启动，如果设备树和驱动都使能的话系统启动过程中就会如图所示的 log 信息：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170423473.png" alt="image-20200907170423473"></p><p>系统最终启动以后会打印出 ALSA 设备列表，现在的音频 CODEC 驱动基本都是 ALSA 架构的，本章的 WM8960 驱动也是根据 ALSA 架构编写的。因此在 ALSA 设备列表中就会找到“wm8960-audio”这个声卡，如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170550815.png" alt="image-20200907170550815"></p><p>进入系统以后查看一下&#x2F;dev&#x2F;snd 目录，看看有没有如图 所示文件：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170616116.png" alt="image-20200907170616116"></p><p>图中的这些文件就是ALSA音频驱动框架对应的设备文件，这些文件的作用如下：</p><ul><li>controlC0：用于声卡控制，C0 表示声卡 0。</li><li>pcmC0D0c 和 和 pcmC0D1c ：用于录音的 pcm 设备，其中的“COD0”和“C0D1”分别表示声卡 0 中的设备 0 和设备 1，最后面的“c”是 capture 的缩写，表示录音。</li><li>pcmC0D0p 和 和 pcmC0D1p：用于播放的 pcm 设备，其中的“COD0”和“C0D1”分别表示声卡 0 中的设备 0 和设备 1，最后面的“p”是 playback 的缩写，表示放音。</li><li>timer ：定时器。</li></ul><p>音频驱动使能以后还不能直接播放音乐或录音，我们还需要移植 alsa-lib 和 alsa-utils 这两个东西。</p><h2 id="四、alsa-lib-和-和-alsa-utils-移植"><a href="#四、alsa-lib-和-和-alsa-utils-移植" class="headerlink" title="四、alsa-lib 和 和 alsa-utils 移植"></a>四、alsa-lib 和 和 alsa-utils 移植</h2><p>首 选 下 载 alsa-lib 和 alsa-utils 源 码 ， 下 载 地 址 为 ： <a href="http://www.alsa-project.org/main/index.php/Main_Page%E3%80%82">http://www.alsa-project.org/main/index.php/Main_Page。</a></p><p>当前最新版本为 1.2.2，如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907170812231.png" alt="image-20200907170812231"></p><h3 id="1-alsa-lib-移植"><a href="#1-alsa-lib-移植" class="headerlink" title="1| alsa-lib 移植"></a>1| alsa-lib 移植</h3><p>注意 alsa-lib 编译过程中会生成一些配置文件，而这些配置信息的路径都是绝对路径，因此为了保证 ubuntu 和开发板根文件系统中的路径一致！我们需要在 ubuntu 和开发板中各创建一个路径和名字完全一样的目录，这里我们都创建一个&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录，ubuntu 中创建命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/share //进入 ubuntu 的/usr/share 目录sudo <span class="hljs-built_in">mkdir</span> arm-alsa  //创建 arm-alsa 目录</code></pre></div><p>最后在开发板根文件系统中也创建一个&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> .../nfs/rootfs///进入根文件系统根目录<span class="hljs-built_in">mkdir</span> ./usr/share/arm-alsa -p  //开发板根文件系统创建 arm-alsa 目录</code></pre></div><p>这样 ubuntu 和开发板根文件系统都有一个“&#x2F;usr&#x2F;share&#x2F;arm-alsa”目录，我们交叉编译的时候就不怕存在引用绝对路径了，因为 ubuntu 和开发板中的配置文件路径都是一模一样的。由于 alsa-utils 要用到 alsa-lib 库，因此要先编译 alsa-lib 库。alsa-lib 就是 ALSA 相关库文件，应用程序通过调用 ALSA 库来对 ALSA 框架下的声卡进行操作。先创建一个名为“alsa-lib”的目录用来保存 alsa-lib 的编译结果，然后将 alsa-lib-1.2.2.tar.bz2 拷贝到 ubuntu 中并解压，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">tar -vxjf alsa-lib-1.2.2.tar.bz2 //解压 alsa-lib</code></pre></div><p>解压完成以后就会得到一个名为“alsa-lib-1.2.2”的文件夹，这个就是 alsa-lib 的源码。进入alsa-lib-1.2.2 目录，然后配置并编译，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> alsa-lib-1.2.2/   //进入 alsa-lib 源码目录./configure --host=arm-linux-gnueabihf --prefix=/home/firestaradmin/linux/tools/alsa-lib --with-configdir=/usr/share/arm-alsa //配置</code></pre></div><p>注意， “–with-configdir”用于设置 alsa-lib 编译出来的配置文件存放位置，这里设置为前面创建的“&#x2F;usr&#x2F;share&#x2F;arm-alsa”目录。</p><p>配置完成以后就可以编译了，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">make  //编译sudo make install //安装</code></pre></div><p>可能会出现如图所示的错误提示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907171829579.png" alt="image-20200907171829579"></p><p>图中提示 libatopology.la 编译失败，这是因为 sudo 会切换到 root 用户下，但是此时 root用户下的环境变量中没有交叉编译器路径，因此会提示找不到“arm-linux-gnueabihf-gcc”，从而导致 libatopology.la 编译失败。解决方法就是先切换到 root 用户，重新执行一下&#x2F;etc&#x2F;profile文件，然后直接 make install 即可，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo -s  //切换到 root 用户<span class="hljs-built_in">source</span> /etc/profile //执行/etc/profilemake install  //安装，此时已经工作在 root 下，因此不需要加“sudo”su firestaradmin  //编译完成以后回原来的用户</code></pre></div><p>编译完成以后前面创建的“alsa-lib”目录就会保存相应的编译结果，如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907172030992.png" alt="image-20200907172030992"></p><p>ubuntu 中&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下的内容如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907172142141.png" alt="image-20200907172142141"></p><p>将上上图中alsa-lib&#x2F;lib 目录下的所有文件拷贝到开发板根文件系统的&#x2F;usr&#x2F;lib 目录下，再将上图中&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下的所有文件拷贝到开发板的&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> alsa-lib sudo <span class="hljs-built_in">cp</span> lib/* /home/firestardmin/linux/nfs/rootfs/lib/ -af<span class="hljs-built_in">cd</span> /usr/share/arm-alsasudo <span class="hljs-built_in">cp</span> * /home/firestardmin/linux/nfs/rootfs/usr/share/arm-alsa/ -raf</code></pre></div><h3 id="2-alsa-utils-移植"><a href="#2-alsa-utils-移植" class="headerlink" title="2| alsa-utils 移植"></a>2| alsa-utils 移植</h3><p>alsa-utils 是 ALSA 的一些小工具集合，我们可以通过这些小工具还测试我们的声卡。将 alsa-utils-1.2.2.tar.bz2 复制到 ubuntu 中并解压，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">tar -vxjf alsa-utils-1.2.2.tar.bz2  //解压</code></pre></div><p>解压成功以后会得到一个名为“alsa-utils-1.2.2”的文件夹，此文件夹就是 alsa-utils 源码。重新创建一个名为“alsa-utils”的目录用于存放 alsa-utils-1.2.2 的编译结果。按照如下命令编译alsa-utils：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> alsa-utils-1.2.2/ ./configure --host=arm-linux-gnueabihf --prefix=/home/firestaradmin/linux/tools/alsa-utils --with-alsa-inc-prefix=/home/firestaradmin/linux/tools/alsa-lib/include/ --with-alsa-prefix=/home/firestaradmin/linux/tools/alsa-lib/lib/ --disable-alsamixer --disable-xmltomake //编译sudo make install</code></pre></div><p>注意！上面在配置 alsa-utils 的时候使用了“–disable-alsamixer”来禁止编译 alsamixer 这个工具，但是这个工具确非常重要，它是一个图形化的声卡控制工具，需要 ncurses 库的支持。</p><p>ncurses 库笔者已经交叉编译成功了，但是尝试了很多次设置，就是无法编译alsa-utils 中的 alsamixer 工具。网上也没有找到有效的解决方法，大家都是禁止编译 alsamixer的。所以这里就没法使用 alsamixer 这个工具了，但是可以使用 alsa-utils 提供的另外一个工具：amixer，alsamixer 其实就是 amixer 的图形化版本。两者的功能都是一样的，只是 alsamixer 使用起来更人性化一点。</p><p>上面utils编译时可能会出现</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span>: 无法获取<span class="hljs-string">&quot;t-ja.gmo&quot;</span> 的文件状态(<span class="hljs-built_in">stat</span>): 没有那个文件或目录make[2]: *** [ja.gmo] 错误 1</code></pre></div><p>解决办法是自己创建一个空文件 ~&#x2F;alsa-utils-xxx&#x2F;alsaconf&#x2F;po&#x2F;t-ja.gmo 然后重新 make, 之后又提示另一个文件没有，用同样的办法创建空文件再次 make，就能成功了。</p><p>编译完成以后就会在前面创建的“alsa-utils”目录下生成 bin、sbin 和 share 三个文件夹，如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907174836127.png" alt="image-20200907174836127"></p><p>将图中 bin、sbin 和 share 这三个目录中的所有文件分别拷贝到开发板根目录下的&#x2F;bin、&#x2F;sbin 和&#x2F;usr&#x2F;share&#x2F;alsa 目录下，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> alsa-utilssudo <span class="hljs-built_in">cp</span> bin/* /home/firestaradmin/linux/nfs/rootfs/bin/ -rfasudo <span class="hljs-built_in">cp</span> sbin/* /home/firestaradmin/linux/nfs/rootfs/sbin/ -rfasudo <span class="hljs-built_in">cp</span> share/* /home/firestaradmin/linux/nfs/rootfs/usr/share/ -rfa</code></pre></div><p>打开开发板根文件系统中的&#x2F;etc&#x2F;profile 文件，在里面加入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">export ALSA_CONFIG_PATH=<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/arm-alsa/</span>alsa.conf</code></pre></div><p>ALSA_CONFIG_PATH 用于指定 alsa 的配置文件，这个配置文件是 alsa-lib 编译出来的。</p><h2 id="五、声卡设置与测试"><a href="#五、声卡设置与测试" class="headerlink" title="五、声卡设置与测试"></a>五、声卡设置与测试</h2><h3 id="1-amixer-使用方法"><a href="#1-amixer-使用方法" class="headerlink" title="1| amixer 使用方法"></a>1| amixer 使用方法</h3><h4 id="1-、查看帮助信息"><a href="#1-、查看帮助信息" class="headerlink" title="1 、查看帮助信息"></a>1 、查看帮助信息</h4><p>声卡相关选型默认都是关闭的，比如耳机和喇叭的左右声道输出等。因此我们在使用之前一定要先设置好声卡，alsa-utils 自带了 amixer 这个声卡设置工具。输入如下命令即可查看 amixer的帮助信息：</p><div class="hljs code-wrapper"><pre><code class="hljs ada">amixer <span class="hljs-comment">--help </span></code></pre></div><p>结果如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175325585.png" alt="image-20200907175325585"></p><p>从图 可以看出，amixer 软件命令分为两组，scontrols、scontents、sset 和 sget 为一组。controls、contents、cset 和 cget 为另一组。这两组的基本功能都是一样的，只不过“s”开头的是 simple(简单)组，这一组命令是简化版，本教程最终使用“s”开头的命令设置声卡，因为少输入很多字符。</p><h4 id="2-、查看设置项"><a href="#2-、查看设置项" class="headerlink" title="2 、查看设置项"></a>2 、查看设置项</h4><p>我们要先看一下都有哪些设置项，先来看一下 scontrols 对应的设置项，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">amixer scontrols  <span class="hljs-regexp">//</span>查看所有设置项</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175501178.png" alt="image-20200907175501178"></p><p>再来看一下 controls 对应的设置项，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">amixer controls  <span class="hljs-regexp">//</span>查看所有设置项</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175532792.png" alt="image-20200907175532792"></p><p>图 由于篇幅原因只列出了一部分设置项，整体设置项目还是比较多的，很多设置项目我们都不知道是啥意思，毕竟不是从事音频专业的。这里我们只关注一些最常用的设置即可，比如设置耳机和喇叭音量、设置左右声道音量、设置输入音量等等。</p><h4 id="3-、查看设置值-值"><a href="#3-、查看设置值-值" class="headerlink" title="3 、查看设置值 值"></a>3 、查看设置值 值</h4><p>不同的设置项对应的设置值类型不同，先查看一下scontents对应的设置值，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">amixer scontents  <span class="hljs-regexp">//</span>查看设置值</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907175630338.png" alt="image-20200907175630338"></p><p>从图 可以看出“Headphone”项目就是设置耳机音量的，音量范围为 0-127，当前音量为 0。有些设置项是 bool 类型，只有 on 和 off 两种状态。关于 controls 对应的设置值大家自行输入“amixer controls”命令查看即可。</p><h4 id="4、设置声卡"><a href="#4、设置声卡" class="headerlink" title="4、设置声卡"></a>4、设置声卡</h4><p>知道了设置项和设置值，那么设置声卡就很简单了，直接使用下面命令即可：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">amixer</span> sset 设置项目 设置值</code></pre></div><p>或：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">amixer</span> cset 设置项目 设置值</code></pre></div><h4 id="5-、获取声卡设置值"><a href="#5-、获取声卡设置值" class="headerlink" title="5 、获取声卡设置值"></a>5 、获取声卡设置值</h4><p>如果要读取当前声卡某项设置值的话使用如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs smali">amixer<span class="hljs-built_in"> sget </span>设置项目</code></pre></div><p>或：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">amixer</span> cget 设置项目</code></pre></div><h3 id="2-音乐播放测试"><a href="#2-音乐播放测试" class="headerlink" title="2| 音乐播放测试"></a>2| 音乐播放测试</h3><h4 id="1-、使用-amixer-设置声卡"><a href="#1-、使用-amixer-设置声卡" class="headerlink" title="1 、使用 amixer  设置声卡"></a>1 、使用 amixer  设置声卡</h4><p>第一次使用声卡之前一定要先使用 amixer 设置声卡，打开耳机和喇叭，并且设置喇叭和耳<br>机音量，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">amixer</span> sset Headphone <span class="hljs-number">100</span>,<span class="hljs-number">100</span><span class="hljs-attribute">amixer</span> sset Speaker <span class="hljs-number">120</span>,<span class="hljs-number">120</span><span class="hljs-attribute">amixer</span> sset &#x27;Right Output Mixer PCM&#x27; <span class="hljs-literal">on</span><span class="hljs-attribute">amixer</span> sset &#x27;Left Output Mixer PCM&#x27; <span class="hljs-literal">on</span></code></pre></div><h4 id="2-、使用-aplay-播放-WAV-格式音乐"><a href="#2-、使用-aplay-播放-WAV-格式音乐" class="headerlink" title="2 、使用 aplay  播放 WAV  格式音乐"></a>2 、使用 aplay  播放 WAV  格式音乐</h4><p>声卡设置好以后就可以使用 aplay 软件播放 wav 格式的音乐测试一下，aplay 也是 alsa-utils提供的。可以在开发板根文件系统下创建一个名为“music”的目录来存放音频文件，然后找一首 wav 格式的音乐放到开发板根文件系统中，然后输入如下命令播放：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">aplay test.wav <span class="hljs-regexp">//</span>播放歌曲</code></pre></div><p>如果一切设置正常的话就会开始播放音乐，因为 ALPHA 开发板支持喇叭和耳机自动切换，因此如果不插耳机的话默认从喇叭播放音乐。插上耳机以后喇叭就会停止播放音乐，改为耳机播放音乐。</p><h3 id="3-MIC-录音测试"><a href="#3-MIC-录音测试" class="headerlink" title="3| MIC  录音测试"></a>3| MIC  录音测试</h3><p>ALPHA 开发板上有一个麦克风，如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907180428743.png" alt="image-20200907180428743"></p><p>我们可以通过图 上的这个麦克风(MIC)来完成录音测试。</p><h4 id="1-、使用-amixer-设置声卡-1"><a href="#1-、使用-amixer-设置声卡-1" class="headerlink" title="1 、使用 amixer  设置声卡"></a>1 、使用 amixer  设置声卡</h4><p>同样的，第一次使用声卡录音之前要先使用 amixer 设置一下声卡，这里为了方便，我们在开发板根文件系统的&#x2F;music 目录下创建一个名为“mic_in_config.sh”的 shell 脚本，然后在里面输入声卡的设置命令。mic_in_config.sh 脚本内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><span class="hljs-comment">#设置捕获的音量</span>amixer cset name=<span class="hljs-string">&#x27;Capture Volume&#x27;</span> 90,90<span class="hljs-comment">#PCM</span>amixer sset <span class="hljs-string">&#x27;PCM Playback&#x27;</span> onamixer sset <span class="hljs-string">&#x27;Playback&#x27;</span> 256amixer sset <span class="hljs-string">&#x27;Right Output Mixer PCM&#x27;</span> onamixer sset <span class="hljs-string">&#x27;Left Output Mixer PCM&#x27;</span> on<span class="hljs-comment">#ADC PCM</span>amixer sset <span class="hljs-string">&#x27;ADC PCM&#x27;</span> 200<span class="hljs-comment">#耳机/喇叭（扬声器）设置播放音量，直流/交流</span><span class="hljs-comment">#Turn on Headphone</span>amixer sset <span class="hljs-string">&#x27;Headphone Playback ZC&#x27;</span> on<span class="hljs-comment">#Set the volume of your headphones(98% volume，127 is the MaxVolume)</span>amixer sset Headphone 125,125<span class="hljs-comment">#Turn on the speaker</span>amixer sset <span class="hljs-string">&#x27;Speaker Playback ZC&#x27;</span> on<span class="hljs-comment">#Set the volume of your Speaker(98% volume，127 is the MaxVolume)</span>amixer sset Speaker 125,125<span class="hljs-comment">#Set the volume of your Speaker AC(80% volume，100 is the MaxVolume)</span>amixer sset <span class="hljs-string">&#x27;Speaker AC&#x27;</span> 4<span class="hljs-comment">#Set the volume of your Speaker AC(80% volume，5 is the MaxVolume)</span>amixer sset <span class="hljs-string">&#x27;Speaker DC&#x27;</span> 4<span class="hljs-comment">#音频输入，左声道管理</span><span class="hljs-comment">#Turn on Left Input Mixer Boost</span>amixer sset <span class="hljs-string">&#x27;Left Input Mixer Boost&#x27;</span> offamixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT1&#x27;</span> offamixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT1&#x27;</span> 0amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT2&#x27;</span> onamixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT2&#x27;</span> 127<span class="hljs-comment">#Turn off Left Boost Mixer LINPUT3</span>amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT3&#x27;</span> offamixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT3&#x27;</span> 0<span class="hljs-comment">#音频输入，右声道管理，全部关闭</span><span class="hljs-comment">#Turn on Right Input Mixer Boost</span>amixer sset <span class="hljs-string">&#x27;Right Input Mixer Boost&#x27;</span> onamixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT1&#x27;</span> offamixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT2&#x27;</span> 0amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT2&#x27;</span> onamixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT2&#x27;</span> 127amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT3&#x27;</span> offamixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT3&#x27;</span> 0</code></pre></div><p>给予 mic_in_config.sh 可执行权限并运行，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 mic_in_config.sh ./mic_in_config.sh</code></pre></div><h4 id="2-、使用-arecord-录制音频"><a href="#2-、使用-arecord-录制音频" class="headerlink" title="2 、使用 arecord  录制音频"></a>2 、使用 arecord  录制音频</h4><p>使用 arecord 来录制一段 10 秒中的音频，arecord 也是 alsa-utils 编译出来的，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arecord -f <span class="hljs-built_in">cd</span> -d 10 record.wav</code></pre></div><p>-f 是设置录音质量，“-f cd”表示录音质量为 cd 级别。-d 是指定录音时间，单位是 s，这条指令就是录制一段 cd 级别 10s 的 wav 音频，音频名字为 record.wav。录制的时候大家就可以对着开发板上的 MIC 说话，直到录制完成。</p><p>录制完成以后使用 aplay 播放刚刚录制的 record.wav 音频，大家会发现只有左声道有声音，右声道没有任何声音，这是因为 ALPHA 开发板的 MIC 只接了左声道，因此录出来的音频只有左声道有数据。</p><h4 id="3-、单声道-MIC-录制立体声音频"><a href="#3-、单声道-MIC-录制立体声音频" class="headerlink" title="3 、单声道 MIC 录制立体声音频"></a>3 、单声道 MIC 录制立体声音频</h4><p>前面测出来 MIC 录出来的只有左声道有声音，那么我们能不能让只接到左声道的 MIC 录制出来的音频是双声道的呢？这个就要去看 WM8960 的数据手册了，看看能不能配置 WM8960的右声道 ADC 直接使用左声道的数据。这样左右声道就共同使用一个 MIC，录出来的音频就是双声道的，虽然两个声道的数据是一模一样的。打开 WM8960 数据手册，找到 R23 寄存器(地址为 0X17)，R23 寄存器的 bit3:2 是设置 ADC数据的，如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181151417.png" alt="image-20200907181151417"></p><p>从图  可以看出，R23 的 bit3:2 控制着左右声道数据来自哪里，可选设置如下：<br>00 ：左声道数据使用左 ADC，右声道数据使用右 ADC，这个是默认模式。<br>01 ：左声道数据使用左 ADC，右声道数据使用左 ADC。<br>10 ：左声道数据使用右 ADC，右声道数据使用右 ADC。<br>11：左声道数据使用右 ADC，右声道数据使用左 ADC。</p><p>由于 ALPHA 开发板 MIC 接在了左声道，因此 WM8960 的 R23 寄存器 bit3:2 应该设置为01，也就是左右声道的数据都使用左 ADC。</p><p>打开 linux 内核里面的 wm8960.c 这个文件，找到 wm8960_reg_defaults 数组，此数组保存着 wm8960 的默认配置值，为&lt;寄存器地址，值&gt;这样的形式。R23 寄存器地址为 0X17，因此找到 0x17 组，默认情况下 0x17 对应的值为 0X01C0，我们将 bit3:2 改为 01 以后 0x17 寄存器的值就变为了 0x01C4，修改后的 wm8960_reg_defaults 寄存器如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reg_default</span> <span class="hljs-title">wm8960_reg_defaults</span>[] =</span> &#123;<span class="hljs-number">2</span> &#123; <span class="hljs-number">0x0</span>, <span class="hljs-number">0x00a7</span> &#125;,......<span class="hljs-number">21</span> &#123; <span class="hljs-number">0x16</span>, <span class="hljs-number">0x00c3</span> &#125;,<span class="hljs-number">22</span> <span class="hljs-comment">/*&#123; 0x17, 0x01c0 &#125;,*/</span><span class="hljs-number">23</span> &#123; <span class="hljs-number">0x17</span>, <span class="hljs-number">0x01c4</span> &#125;,<span class="hljs-number">24</span> &#123; <span class="hljs-number">0x18</span>, <span class="hljs-number">0x0000</span> &#125;,......<span class="hljs-number">53</span> &#123; <span class="hljs-number">0x37</span>, <span class="hljs-number">0x00e9</span> &#125;,<span class="hljs-number">54</span> &#125;;</code></pre></div><p>第 23 行就是将 R23 寄存器的值改为 0x01c4。修改完成以后重新编译 linux 内核，然后使用新的内核启动开发板，重新测试 MIC 录音，这个时候录出来的就应该是立体音了。</p><h3 id="4-LINE-IN-录音测试"><a href="#4-LINE-IN-录音测试" class="headerlink" title="4| LINE IN  录音测试"></a>4| LINE IN  录音测试</h3><p>如果在 MIC 录音实验中将 R23 的寄存器改为了 0X01C4，那么在进行 LINE IN 录音测试之前先改回原来的 0X01C0，因为 ALPHA 开发板的 LINE IN 接了双声道，不需要共用左声道数据。当然了，不修改也是可以直接做测试的！最后进行一下 Line in 测试，也就是线路输入测试，ALPHA 开发板上 Line in 接口如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181517384.png" alt="image-20200907181517384"></p><p>注意，图  中的 Line in 不是用来连接话筒的！这里不能接话筒。使用一根 3.5mm 公对公音频线，一头连接到手机或者电脑，另外一头连接到图 中的 Line in 接口上。</p><h4 id="1-、使用-amixer-设置声卡-2"><a href="#1-、使用-amixer-设置声卡-2" class="headerlink" title="1 、使用 amixer  设置声卡"></a>1 、使用 amixer  设置声卡</h4><p>同样新建一个名为“line_in_config.sh”的 shell 脚本，在此脚本里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">1 <span class="hljs-comment">#!/bin/sh</span>2 <span class="hljs-comment">#正点原子@ALIENTEK</span>3 <span class="hljs-comment">#设置捕获的音量</span>4 amixer cset name=<span class="hljs-string">&#x27;Capture Volume&#x27;</span> 100,10056 <span class="hljs-comment">#PCM</span>7 amixer sset <span class="hljs-string">&#x27;PCM Playback&#x27;</span> on8 amixer sset <span class="hljs-string">&#x27;Playback&#x27;</span> 2569 amixer sset <span class="hljs-string">&#x27;Right Output Mixer PCM&#x27;</span> on10 amixer sset <span class="hljs-string">&#x27;Left Output Mixer PCM&#x27;</span> on1112 <span class="hljs-comment">#ADC PCM</span>13 amixer sset <span class="hljs-string">&#x27;ADC PCM&#x27;</span> 2001415 <span class="hljs-comment">#录音前应该设置耳机或者扬声器的音量为 0（下面并没有设置）防止干扰</span>16 <span class="hljs-comment">#耳机/喇叭（扬声器）设置播放音量，直流/交流</span>17 <span class="hljs-comment">#Turn on Headphone</span>18 amixer sset <span class="hljs-string">&#x27;Headphone Playback ZC&#x27;</span> on19 <span class="hljs-comment">#Set the volume of your headphones(98% volume，127 is the MaxVolume)</span>20 amixer sset Headphone 125,12521 <span class="hljs-comment">#Turn on the speaker</span>22 amixer sset <span class="hljs-string">&#x27;Speaker Playback ZC&#x27;</span> on23 <span class="hljs-comment">#Set the volume of your Speaker(98% volume，127 is the MaxVolume)</span>24 amixer sset Speaker 125,12525 <span class="hljs-comment">#Set the volume of your Speaker AC(80% volume，100 is the MaxVolume)</span>26 amixer sset <span class="hljs-string">&#x27;Speaker AC&#x27;</span> 427 <span class="hljs-comment">#Set the volume of your Speaker AC(80% volume，5 is the MaxVolume)</span>28 amixer sset <span class="hljs-string">&#x27;Speaker DC&#x27;</span> 42930 <span class="hljs-comment">#音频输入，左声道管理</span>31 <span class="hljs-comment">#Turn off Left Input Mixer Boost</span>32 amixer sset <span class="hljs-string">&#x27;Left Input Mixer Boost&#x27;</span> on33 <span class="hljs-comment">#关闭其他通道输入</span>34 amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT1&#x27;</span> off35 amixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT1&#x27;</span> 036 <span class="hljs-comment">#关闭麦克风左声道输入</span>37 amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT2&#x27;</span> on38 amixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT2&#x27;</span> 12739 <span class="hljs-comment">#Line_in 右声道输入关闭</span>40 amixer sset <span class="hljs-string">&#x27;Left Boost Mixer LINPUT3&#x27;</span> off41 amixer sset <span class="hljs-string">&#x27;Left Input Boost Mixer LINPUT3&#x27;</span> 0424344 <span class="hljs-comment">#音频输入，右声道管理</span>45 <span class="hljs-comment">#Turn on Right Input Mixer Boost</span>46 amixer sset <span class="hljs-string">&#x27;Right Input Mixer Boost&#x27;</span> on47 amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT1&#x27;</span> off48 amixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT1&#x27;</span> 049 amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT2&#x27;</span> off50 amixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT2&#x27;</span> 05152 <span class="hljs-comment">#要想设置成音频输入，请打开 RINPUT3,看原理图可知</span>53 <span class="hljs-comment">#其他的声道通过上面的配置可关闭，这样是为了避免干扰，需要的时候就打开</span>54 <span class="hljs-comment">#RINPUT3 打开（关键点）</span>55 amixer sset <span class="hljs-string">&#x27;Right Boost Mixer RINPUT3&#x27;</span> on56 amixer sset <span class="hljs-string">&#x27;Right Input Boost Mixer RINPUT3&#x27;</span> 127</code></pre></div><p>最后，给予 line_in_config.sh 可执行权限并运行，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs stata">chmod 777 line_in_config.<span class="hljs-keyword">sh</span> <span class="hljs-comment">//给予可执行权限</span>./line_in_config.<span class="hljs-keyword">sh</span> <span class="hljs-comment">//运行</span></code></pre></div><h4 id="2-、使用-arecord-录制音频-1"><a href="#2-、使用-arecord-录制音频-1" class="headerlink" title="2 、使用 arecord  录制音频"></a>2 、使用 arecord  录制音频</h4><p>使用 arecord 来录制一段 10 秒中的音频，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs powershell">arecord <span class="hljs-operator">-f</span> <span class="hljs-built_in">cd</span> <span class="hljs-literal">-d</span> <span class="hljs-number">10</span> record.wav</code></pre></div><p>录制完成以后使用 aplay 播放刚刚录制的音频，由于 ALPHA 开发板上 LINE IN 是接了左右双声道，因此录制出来的音频是立体声的，不像 MIC 录出来的只有左声道。</p><h2 id="六、开机自动配置声卡"><a href="#六、开机自动配置声卡" class="headerlink" title="六、开机自动配置声卡"></a>六、开机自动配置声卡</h2><p>大家在使用的时候应该应该会发现开发板重启以后声卡的所有设置都会消失，必须重新设置声卡。也就是说我们对声卡的设置不能保存，本小节我们就来学习一下如何保存声卡的设置。</p><h3 id="1-、使用-alsactl-保存声卡设置"><a href="#1-、使用-alsactl-保存声卡设置" class="headerlink" title="1 、使用 alsactl  保存声卡设置"></a>1 、使用 alsactl  保存声卡设置</h3><p>声卡设置的保存通过 alsactl 工具来完成，此工具也是 alsa-utils 编译出来的。因为 alsactl 默认将声卡配置文件保存在&#x2F;var&#x2F;lib&#x2F;alsa 目录下，因此首先在开发板根文件系统下创建&#x2F;var&#x2F;lib&#x2F;alsa目录，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/var/</span>lib/alsa -p</code></pre></div><p>首先使用 amixer 设置声卡，然后输入如下命令保存声卡设置</p><div class="hljs code-wrapper"><pre><code class="hljs awk">alsactl -f <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/alsa/</span>asound.state store <span class="hljs-regexp">//</span>保存声卡设置</code></pre></div><p>-f 指定声卡配置文件，store 表示保存。关于 alsactl 的详细使用方法，输入“alsactl -h”即可。保存成功以后就会生成&#x2F;var&#x2F;lib&#x2F;alsa&#x2F;asound.state 这个文件，asound.state 里面就是关于声卡的各种设置信息，大家可以打开此文件查看一下里面的内容，如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181757589.png" alt="image-20200907181757589"></p><p>如果要使用 asound.state 中的配置信息来配置声卡，执行如下命令即可：</p><div class="hljs code-wrapper"><pre><code class="hljs pf">alsactl -f /var/lib/alsa/asound.<span class="hljs-keyword">state</span> restore</code></pre></div><p>最后面的参数改为 restore 即可，也就是恢复的意思。</p><p>打开&#x2F;etc&#x2F;init.d&#x2F;rcS 文件，在最后面追加如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;/var/lib/alsa/asound.state&quot;</span> ]; then<span class="hljs-number">2</span> echo <span class="hljs-string">&quot;ALSA: Restoring mixer setting......&quot;</span><span class="hljs-number">3</span> /sbin/alsactl -f /var/lib/alsa/asound.state restore &amp;<span class="hljs-number">4</span> fi</code></pre></div><p>第 1 行判断&#x2F;var&#x2F;lib&#x2F;alsa&#x2F;asound.state 这个文件是否存在，存在的话就执行下面的。首先输出一行提示符：“ALSA: Restoring mixer setting……”，表示设置声卡，最后调用&#x2F;sbin&#x2F;alsactl 来执行声卡设置工作。<br>设置完成以后重启开发板，开发板开机就会自动设置声卡，会输入如图所示内容：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907181902945.png" alt="image-20200907181902945"></p><p>接使用 aplay 播放音乐测试声卡开机自动配置是否正确。</p><h2 id="七、mplayer-播放器移植与使用"><a href="#七、mplayer-播放器移植与使用" class="headerlink" title="七、mplayer  播放器移植与使用"></a>七、mplayer  播放器移植与使用</h2><p>至此，linux 下的 LCD 显示和音频都已经驱动起来了，那么肯定就会有朋友想播放视频。<br>本节我们就来学习一下如何移植 mplayer 这个强大的视频播放软件。mplayer 是一款开源的多媒<br>体播放器，可以用来播放音视频，mplayer 自带多种格式的解码器，不需要我们再另外安装。</p><h3 id="1-mplayer-移植"><a href="#1-mplayer-移植" class="headerlink" title="1| mplayer 移植"></a>1| mplayer 移植</h3><h4 id="1-、移植-zlib-库"><a href="#1-、移植-zlib-库" class="headerlink" title="1 、移植 zlib  库"></a>1 、移植 zlib  库</h4><p>mplayer 用到了 zlib 库，因此要先移植 zlib 库。zlib 源码下载地址为：<a href="http://zlib.net/%EF%BC%8C%E5%BD%93%E5%89%8D%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%BA">http://zlib.net/，当前最新版本为</a> 1.2.11。我们已经下载下来放到了开发板光盘中，</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">ar</span> -vxzf zlib-<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">11</span>.tar.gz  //解压</code></pre></div><p>解压完成以后得到一个名为“zlib-1.2.11”的 zlib 源码文件。另外新建一个名为“zlib”的文件夹来保存 zlib 的编译结果。进入 zlib 源码目录，然后配置并编译，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs groovy">cd zlib<span class="hljs-number">-1.2</span><span class="hljs-number">.11</span><span class="hljs-regexp">/ /</span>/进去 zlib 源码CC=arm-linux-gnueabihf-gcc  LD=arm-linux-gnueabihf-ld  AD=arm-linux-gnueabihf-<span class="hljs-keyword">as</span> .<span class="hljs-regexp">/configure --prefix=/</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/tools/</span>zlib <span class="hljs-comment">//配置</span>make  <span class="hljs-comment">//编译</span>make install</code></pre></div><p>编译完成以后的 zlib 目录内容如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182057667.png" alt="image-20200907182057667"></p><p>将图中的lib目录下的zlib库文件拷贝到开发板根文件系统的&#x2F;lib目录下，命令为：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo cp lib<span class="hljs-regexp">/* /</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/nfs/</span>rootfs<span class="hljs-regexp">/lib/</span> -rfa</code></pre></div><h4 id="2-、移植-mplayer"><a href="#2-、移植-mplayer" class="headerlink" title="2 、移植 mplayer"></a>2 、移植 mplayer</h4><p>mplayer 需要用到 alsa-lib 和 zlib，因此要先保证这两个已经交叉编译了。mplayer 源码下载地址为：<a href="http://www.mplayerhq.hu/MPlayer/releases/%EF%BC%8C%E5%BD%93%E5%89%8D%E6%9C%80%E6%96%B0%E7%9A%84%E4%B8%BA">http://www.mplayerhq.hu/MPlayer/releases/，当前最新的为</a> 1.4 版本。将 MPlayer-1.4.tar.gz 拷贝到 ubuntu 中并解压，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs stylus">tar -vxzf MPlayer-<span class="hljs-number">1.4</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> <span class="hljs-comment">//解压</span></code></pre></div><p>解压完成以后得到一个名为“MPlayer-1.4”的 mplayer 源码文件。另外新建一个名为“mplayer”的文件夹来保存 mplayer 的编译结果。进入 mplayer 源码目录，然后配置并编译，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">cd</span> <span class="hljs-comment">MPlayer</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">4/</span>  <span class="hljs-comment">//进去</span> <span class="hljs-comment">mplayer</span> <span class="hljs-comment">源码</span><span class="hljs-string">.</span><span class="hljs-comment">/configure</span> --<span class="hljs-comment">cc=arm</span><span class="hljs-literal">-</span><span class="hljs-comment">linux</span><span class="hljs-literal">-</span><span class="hljs-comment">gnueabihf</span><span class="hljs-literal">-</span><span class="hljs-comment">gcc</span> --<span class="hljs-comment">host</span><span class="hljs-literal">-</span><span class="hljs-comment">cc=gcc</span> --<span class="hljs-comment">target=arm</span><span class="hljs-literal">-</span><span class="hljs-comment">linux</span><span class="hljs-literal">-</span><span class="hljs-comment">gnueabihf</span> --<span class="hljs-comment">disable</span><span class="hljs-literal">-</span><span class="hljs-comment">ossaudio</span> --<span class="hljs-comment">enable</span><span class="hljs-literal">-</span><span class="hljs-comment">alsa</span> --<span class="hljs-comment">prefix=/home/zuozhongkai/linux/IMX6ULL/tool/mplayer</span> --<span class="hljs-comment">extra</span><span class="hljs-literal">-</span><span class="hljs-comment">cflags=&quot;</span><span class="hljs-literal">-</span><span class="hljs-comment">I/home/zuozhongkai/linux/IMX6ULL/tool/zlib/include</span>  <span class="hljs-literal">-</span><span class="hljs-comment">I/home/zuozhongkai/linux/IMX6ULL/tool/alsa</span><span class="hljs-literal">-</span><span class="hljs-comment">lib/include&quot;</span>  --<span class="hljs-comment">extra</span><span class="hljs-literal">-</span><span class="hljs-comment">ldflags=&quot;</span><span class="hljs-literal">-</span><span class="hljs-comment">L/home/zuozhongkai/linux/IMX6ULL/tool/zlib/lib</span>  <span class="hljs-literal">-</span><span class="hljs-comment">Iz</span>  <span class="hljs-literal">-</span><span class="hljs-comment">L/home/zuozhongkai/linux/IMX6ULL/tool/alsa</span><span class="hljs-literal">-</span><span class="hljs-comment">lib/lib</span> <span class="hljs-literal">-</span><span class="hljs-comment">lasound&quot;</span> --<span class="hljs-comment">enable</span><span class="hljs-literal">-</span><span class="hljs-comment">fbdev</span> --<span class="hljs-comment">disable</span><span class="hljs-literal">-</span><span class="hljs-comment">mencoder</span><span class="hljs-comment">make</span>  <span class="hljs-comment">//编译</span></code></pre></div><p>–extra-cflags 指定 zlib 和 alsa-lib 的头文件路径，–extra-ldflags 指定 zlib 和 alsa-lib 的库文件路径。编译完成以后打开 config.mak 文件，找到“INSTALLSTRIP &#x3D; -s”这一行，取消掉后面的“-s”，否则“make install”命令会失败！结果如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182313324.png" alt="image-20200907182313324"></p><p>修改完成以后使用“make install”安装，安装完成以后 mplayer 目录内容如图 所示</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182326254.png" alt="image-20200907182326254"></p><p>图 中的 bin 目录下有一个叫做“mplayer”的可执行文件，这就是我们需要的 mplayer播放器！将其拷贝到开发板根文件系统的&#x2F;bin 目录下，命令为：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo cp bin<span class="hljs-regexp">/mplayer /</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/nfs/</span>rootfs<span class="hljs-regexp">/bin/</span> -f</code></pre></div><p>至此，mplayer 移植就已经完成了，接下来就是使用 mplayer 播放音视频。</p><h3 id="2-mplayer-使用"><a href="#2-mplayer-使用" class="headerlink" title="2| mplayer  使用"></a>2| mplayer  使用</h3><h4 id="1-、mplayer-播放音频"><a href="#1-、mplayer-播放音频" class="headerlink" title="1 、mplayer  播放音频"></a>1 、mplayer  播放音频</h4><p>输入“mplayer -h”即可查看帮助信息。mplayer 播放歌曲很简单，不限歌曲格式，“mplayer+歌曲名”即可，比如：</p><div class="hljs code-wrapper"><pre><code class="hljs cmake">mplayer <span class="hljs-keyword">test</span>.flac</code></pre></div><p>播放过程如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182411920.png" alt="image-20200907182411920"></p><p>播放过程中我们可以通过键盘控制播放器，常用的控制方法如下：<br>9 ：增加音量。<br>0：减小音量。<br>左键：倒退 10 秒<br>右键：快进 10 秒<br>上键：倒退 1 分钟<br>下键：快进 1 分钟<br>空格：暂停和播放<br>如果 mplayer 音量已经调到最大了，但是耳机音量依旧很小的话请使用 amixer 调大声卡最<br>大音量。</p><h4 id="2-、视频播放测试"><a href="#2-、视频播放测试" class="headerlink" title="2 、视频播放测试"></a>2 、视频播放测试</h4><p>视频播放的方法和音频一样， “mplayer+视频名”即可，但是这样的话视频不是居中播放的，我们可以加入“-fs”参数让视频居中播放。注意！由于 I.MX6ULL 性能比较差，而且没有硬件视频解码，因此 6ULL 不能播放高分辨率、高码率和高帧率的视频，视频分辨率最好在 640*480 左右！输入如下命令播放视频：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">mplayer test.avi -fs <span class="hljs-regexp">//</span>居中播放视频</code></pre></div><p>如果你所使用的芯片性能比较差的话 mplayer 会给你提示，如图  所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182452001.png" alt="image-20200907182452001"></p><p>关于 mplayer 的更多使用请自行上网搜索，这里就不再赘述了。</p><h2 id="七、alsamixer-简介"><a href="#七、alsamixer-简介" class="headerlink" title="七、alsamixer  简介"></a>七、alsamixer  简介</h2><p>前面在移植 alsa-utils 的时候说过 alsamixer是一个图形化的声卡设置工具，但是由于 ncurses库依赖的原因笔者并没有在 alsa-utils 移植的时候编译出 alsamixer，不得已放弃编译 alsa-utils 中的 alsamixer。但是笔者用了一个投机取巧的方法，那就是使用 buildroot 编译出 alsamixer，然后将其拷贝到开发板根文件系统中。因此，如果还没了解过buildroot的朋友就不需要看本小节了，直接使用 amixer 来配置声卡。从这里也可以看出 buildroot 的强大，再一次建议大家做产品的时候使用 buidroot 或 yocto 来构建根文件系统！alsamixer 是基于图形化的，直接输入“alsamixer”命令即可打开声卡配置界面，如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/22%E3%80%81Linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200907182600316.png" alt="image-20200907182600316"></p><p>F1  键：查看帮助信息。<br>F2  键：查看系统信息。<br>F3  键：播放设置。<br>F4  键：录音设置。<br>F6  键：选择声卡，多声卡情况下。<br>Item ：设置项全名。</p><p>图  最下面一行就是具体的设置项，比如“Headphone”、“Headphone Playback ZC”等等，通过键盘上左右键选择设置项。按下上下键来调整大小，比如设置耳机音量大小等。有些项目会显示“MM”，表示静音，按下“M”键修改为“OO”状态打开，“M”键用于修改打开或关闭某些项目。关于 alsamixer 的介绍就到这里，用起来还是很简单的。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23| Linux USB驱动实验</title>
    <link href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-USB驱动实验"><a href="#Linux-USB驱动实验" class="headerlink" title="Linux USB驱动实验"></a>Linux USB驱动实验</h1><p>USB 是很常用的接口，目前大多数的设备都是 USB 接口的，比如鼠标、键盘、USB 摄像头等，我们在实际开发中也常常遇到 USB 接口的设备，本章我们就来学习一下如何使能 Linux内核自带的 USB 驱动。</p><p>注意！这里不讲解具体的 USB 开发，因为 USB 接口很复杂，不同的设备其协议也不同，这不是简简单单一章内容就能说完的，USB 驱动开发本身就是一门复杂的课程。</p><h2 id="一、USB接口简介"><a href="#一、USB接口简介" class="headerlink" title="一、USB接口简介"></a>一、USB接口简介</h2><h3 id="1-什么是-USB"><a href="#1-什么是-USB" class="headerlink" title="1| 什么是 USB"></a>1| 什么是 USB</h3><p>USB 全称为 Universal Serial Bus，翻译过来就是通用串行总线。由英特尔与众多电脑公司提出来，用于规范电脑与外部设备的连接与通讯。</p><p>目前 USB 接口已经得到了大范围的应用，已经是电脑、手机等终端设备的必配接口，甚至取代了大量的其他接口。比如最新的智能手机均采用 USB Typec 取到了传统的 3.5mm 耳机接口，苹果最新的 MacBook 只有 USB Typec 接口，至于其他的 HDMI、网口等均可以通过 USB Typec 扩展坞来扩展。</p><p>按照大版本划分，USB 目前可以划分为 USB1.0、USB2.0、USB3.0 以及正在即将到来的USB4.0。</p><ul><li><p>USB1.0 ：USB 规范于 1995 年第一次发布，由 Inter、IBM、Microsoft 等公司组成的 USB-IF(USB Implement Forum)组织提出。USB-IF 与 1996 年正式发布 USB1.0，理论速度为 1.5Mbps。</p></li><li><p>USB2.0 ：USB2.0 依旧由 Inter、IBM、Microsoft 等公司提出并发布，USB2.0 分为两个版本:Full-Speed 和 High-Speed，也就是全速(FS)和高速(HS)。USB2.0 FS 的速度为 12Mbps，USB2.0HS 速度为480Mbps。</p><p>目前大多数单片机以及低端 Cortex-A 芯片配置的都是 USB2.0 接口，比如 STM32 和 ALPHA 开发板所使用的 I.MX6ULL。USB2.0 全面兼容 USB1.0 标准。</p></li><li><p>USB3.0： ：USB3.0 同样有 Inter 等公司发起的，USB3.0 最大理论传输速度为 5.0Gbps，USB3.0引入了全双工数据传输，USB2.0 的 480Mbps 为半双工。USB3.0 中两根线用于发送数据，另外两根用于接收数据。在 USB3.0 的基础上又提出了 USB3.1、USB3.2 等规范，USB3.1 理论传输速度提升到了 10Gbps，USB3.2 理论传输速度为 20Gbps。为了规范 USB3.0 标准的命名，USB-IF 公布了最新的 USB 命名规范，原来的 USB3.0 和 USB3.1 命名将不会采用，所有的 3.0 版本的 USB 都命名为 USB3.2，以前的 USB3.0、USB3.1 和 USB3.2 分别叫做 USB3.2 Gen1、USB3.2Gen2、USB3.2 Gen 2X2。</p></li><li><p>USB4.0： ：目前还在标准定制中，目前还没有设备搭载，据说是在 Inter 的雷电 3 接口上改进而来。USB4.0 的速度将提升到了 40Gbps，最高支持 100W 的供电能力，只需要一根线就可以完成数据传输与供电，极大的简化了设备之间的链接线数，期待 USB4.0 设备上市。</p></li></ul><p>如果按照接口类型划分的话 USB 就要分为很多种了，最常见的就是 USB A 插头和插座，如图  所示：</p><h3 id="2-USB电气特性"><a href="#2-USB电气特性" class="headerlink" title="2| USB电气特性"></a>2| USB电气特性</h3><p>由于正点原子 I.MX6U-ALPHA 开发板使用的 Mini USB 接口，因此我们就以 Mini USB 为例讲解一下 USB 的基本电气属性。Mini USB 线一般都是一头为 USB A 插头，一头为 Mini USB插头。一共有四个触点，也就是 4 根线，这四根线的顺序如图  所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908113120868.png" alt="image-20200908113120868"></p><p>如图  所示，USB A 插头从左到右线序依次为 1,2,3,4，第 1 根线为 VBUS，电压为5V，第 2 根线为 D-，第 3 根线为 D+，第 4 根线为 GND。USB 采用差分信号来传输数据，因此有 D-和 D+两根差分信号线。大家仔细观察的话会发现 USB A 插头的 1 和 4 这两个触点比较长，2 和 3 这两个触点比较短。1 和 4 分别为VBUS 和 GND，也就是供电引脚，当插入 USB 的时候会先供电，然后再接通数据线。拔出的时候先断开数据线，然后再断开电源线。</p><p>大家再观察一下 Mini USB 插头，会发现 Mini USB 插头有 5 个触点，也就是 5 根线，线序从左往右依次是 1~5。第 1 根线为 VCC(5V)，第 2 根线为 D-，第 3 根线为 D+，第 4 根线为 ID，第 5 根线为 GND。可以看出 Mini USB 插头相比 USB A 插头多了一个 ID 线，这个 ID 线用于实现 OTG 功能，通过 ID 线来判断当前连接的是主设备(HOST)还是从设备(SLAVE)。</p><p>USB 是一种支持热插拔的总线接口，使用差分线(D-和 D+)来传输数据，USB 支持两种供电模式：总线供电和自供电，总线供电就是由 USB 接口为外部设备供电，在 USB2.0 下，总线供电最大可以提供 500mA 的电流。</p><h3 id="3-USB-拓扑结构"><a href="#3-USB-拓扑结构" class="headerlink" title="3| USB  拓扑结构"></a>3| USB  拓扑结构</h3><p>USB 是主从结构的，也就是分为主机和从机两部分，一般主机叫做 Host，从机叫做 Device。主机就是提供 USB A 插座来连接外部的设备，比如电脑作为主机，对外提供 USB A 插座，我们可以通过 USB 线来连接一些 USB 设备，比如声卡、手机等。因此电脑带的 USB A 插座数量就决定了你能外接多少个 USB 设备，如果不够用的话我们可以购买 USB 集线器来扩展电脑的USB 插口，USB 集线器也叫做 USB HUB，USB HUB如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908113341360.png" alt="image-20200908113341360"></p><p>图 是一个一拖四的 USB HUB，也就是将一个 USB 接口扩展为 4 个。主机一般会带几个原生的 USB 主控制器，比如 I.MX6ULL 就有两个原生的 USB 主控制器，因此 I.MX6ULL对外提供两个 USB 接口，这两个接口肯定不够用，正点原子的 ALPHA 开发板上有 4 个 HOST接口，其中一路是 USB1 的 OTG 接口，其他的三路就是 USB2 通过 USB HUB 芯片扩展出来的，稍后我们会讲解其原理图。</p><p>虽然我们可以对原生的 USB 口数量进行扩展，但是我们不能对原生 USB 口的带宽进行扩展，比如I.MX6ULL 的两个原生 USB 口都是 USB2.0 的，带宽最大为 480Mbps，因此接到下面的所有 USB 设备总带宽最大为 480Mbps。</p><p>USB 只能主机与设备之间进行数据通信，USB 主机与主机、设备与设备之间是不能通信的。因此两个正常通信的 USB 接口之间必定有一个主机，一个设备。为此使用了不同的插头和插座来区分主机与设备，比如主机提供 USB A 插座，从机提供 Mini USB、Micro USB 等插座。在一个 USB 系统中，仅有一个 USB 主机，但是可以有多个 USB 设备，包括 USB 功能设备和 USB HUB，最多支持 127 个设备。一个 USB 主控制器支持 128 个地址，地址 0 是默认地址，只有在设备枚举的时候才会使用，地址 0 不会分配给任何一个设备。所以一个 USB 主控制器最多可以分配 127 个地址。整个 USB 的拓扑结构就是一个分层的金字塔形，如图 所示(参考自USB2.0 协议中文版.pdf)：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908113538714.png" alt="image-20200908113538714"></p><p>图中可以看出从 Root Hub 开始，一共有 7 层，金字塔顶部是 Root Hub，这个是USB 控制器内部的。图中的 Hub 就是连接的 USB 集线器，Func 就是具体的 USB 设备。USB 主机和从机之间的通信通过管道(Pipe)来完成，管道是一个逻辑概念，任何一个 USB设备一旦上电就会存在一个管道，也就是默认管道，USB 主机通过管道来获取从机的描述符、配置等信息。在主机端管道其实就是一组缓冲区，用来存放主机数据，在设备端管道对应一个特定的端点。</p><h3 id="4-什么是-USB-OTG-？"><a href="#4-什么是-USB-OTG-？" class="headerlink" title="4| 什么是 USB OTG ？"></a>4| 什么是 USB OTG ？</h3><p>前面我们讲了，USB 分为 HOST(主机)和从机(或 DEVICE)，有些设备可能有时候需要做HOST，有时候又需要做 DEVICE，配两个 USB 口当然可以实现，但是太浪费资源了。如果一个 USB 接口既可以做 HOST 又可以做 DEVICE 那就太好了，使用起来就方便很多。为此，USB OTG 应运而生，OTG 是 On-The-Go 的缩写，支持 USB OTG 功能的 USB 接口既可以做 HOST，也可以做 DEVICE。那么问题来了，一个 USB 接口如何知道应该工作在 HOST 还是 DEVICE呢？这里就引入了 ID 线这个概念，前面讲解 USB 电气属性的时候已经说过了，Mini USB 插头有 5 根线，其中一条就是 ID 线。ID 线的高低电平表示 USB 口工作在 HOST 还是 DEVICE 模式：</p><p>ID&#x3D;1 ：OTG 设备工作在从机模式。<br>ID&#x3D;0：OTG 设备工作在主机模式。</p><p>支持 OTG 模式的 USB 接口一般都是 Mini USB 或 Micro USB 等这些带有 ID 线的接口，比如正点原子的 I.MX6ULL-ALPHA 开发板的 USB_OTG 接口就是支持 OTG 模式的，USB_OTG连接到了 I.MX6ULL 的 USB1 接口上。如果只有一个 Mini USB 或者 Micro USB 接口的话如果要使用 OTG 的主机模式，那么就需要一根 OTG 线，Mini USB 的 OTG 线如图  所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908114104439.png" alt="image-20200908114104439"></p><p>可以看出，Mini USB OTG 线一头是 USB A 插座，一头是 Mini USB 插头，将 Mini USB 插头插入机器的 Mini USB 口上，需要连接的 USB 设备插到另一端的 USB A 插座上，比如 U 盘啥的。USB OTG 线会将 ID 线拉低，这样机器就知道自己要做为一个主机，用来连接外部的从机设备(U 盘)。</p><h3 id="5-I-MX6ULL-USB-接口简介"><a href="#5-I-MX6ULL-USB-接口简介" class="headerlink" title="5| I.MX6ULL USB  接口简介"></a>5| I.MX6ULL USB  接口简介</h3><p>I.MX6ULL 内部集成了两个独立的 USB 控制器，这两个 USB 控制器都支持 OTG 功能。I.MX6ULL 内部 USB 控制器特性如下：</p><ul><li>①、有两个 USB2.0 控制器内核分别为 Core0 和 Core1，这两个 Core 分别连接到 OTG1 和OTG2。</li><li>②、两个 USB2.0 控制器都支持 HS、FS 和 LS 模式，不管是主机还是从机模式都支持HS&#x2F;FS&#x2F;LS，硬件支持 OTG 信号、会话请求协议和主机协商协议，支持 8 个双向端点。</li><li>③、支持低功耗模式，本地或远端可以唤醒。</li><li>④、每个控制器都有一个 DMA。</li></ul><p>每个 USB 控制器都有两个模式：正常模式(normal mode)和低功耗模式(low power mode)。</p><p>每个 USB OTG 控制器都可以运行在高速模式(HS 480Mbps)、全速模式(LS 12Mbps)和低速模式(1.5Mbps)。</p><p>正常模式下每个 OTG 控制器都可以工作在主机(HOST)或从机(DEVICE)模式下，每个 USB 控制器都有其对应的接口。低功耗模式顾名思义就是为了节省功耗，USB2.0 协议中要求，设备在上行端口检测到空闲状态以后就可以进入挂起状态。在从机(DEVICE)模式下，端口停止活动 3ms 以后 OTG 控制器内核进入挂起状态。</p><p>在主机(HOST)模式下，OTG 控制器内核不会自动进入挂起状态，但是可以通过软件设置。不管是本地还是远端的 USB 主从机都可以通过产生唤醒序列来重新开始 USB 通信。</p><p>两个 USB 控制器都兼容 EHCI，这里我们简单提一下 OHCI、UHCI、EHCI 和 xHCI，这三个是用来描述 USB 控制器规格的，区别如下：</p><ul><li><strong>OHCI</strong>： ：全称为 Open Host Controller Interface，这是一种 USB 控制器标准，厂商在设计 USB控制器的时候需要遵循此标准，用于 USB1.1 标准。OHCI 不仅仅用于 USB，也支持一些其他的接口，比如苹果的 Firewire 等，OHCI 由于硬件比较难，所以软件要求就降低了，软件相对来说比较简单。OHCI 主要用于非 X86 的 USB，比如扩展卡、嵌入式 USB 控制器。</li><li><strong>UHCI</strong>： ：全称是 Universal Host Controller Interface，UHCI 是 Inter 主导的一个用于 USB1.0&#x2F;1.1的标准，与 OHCI 不兼容。与 OHCI 相比 UHCI 硬件要求低，但是软件要求相应就高了，因此硬件成本上就比较低。</li><li><strong>EHCI</strong> ：全称是 Enhanced Host Controller Interface，是 Inter 主导的一个用于 USB2.0 的 USB控制器标准。I.MX6ULL 的两个 USB 控制器都是 2.0 的，因此兼容 EHCI 标准。EHCI 仅提供USB2.0 的高速功能，至于全速和低速功能就由 OHCI 或 UHCI 来提供。</li><li><strong>xHCI</strong> ：全称是 eXtensible Host Controller Interface，是目前最流行的 USB3.0 控制器标准，在速度、能效和虚拟化等方面比前三个都有较大的提高。xHCI 支持所有速度种类的 USB 设备，xHCI 出现的目的就是为了替换前面三个。</li></ul><p>关于 I.MX6ULL 的 USB 控制器就简单的讲解到这里，至于更详细的内容请参考 I.MX6ULL参考手册中的“Chapter 56 Universal Serial Bus Controller(USB)”章节。</p><h2 id="二、硬件原理图分析"><a href="#二、硬件原理图分析" class="headerlink" title="二、硬件原理图分析"></a>二、硬件原理图分析</h2><p>正点原子的 I.MX6ULL-ALPHA 开发板 USB 部分原理图可以分为两部分：USB HUB 以及USB OTG，我们依次来看一下这两部分的硬件原理图。</p><h3 id="USB-HUB-原理图分析"><a href="#USB-HUB-原理图分析" class="headerlink" title="USB HUB  原理图分析"></a>USB HUB  原理图分析</h3><p>首先来看一下 USB HUB 原理图，I.MX6ULL-ALPHA 使用 GL850G 这个 HUB 芯片将I.MX6ULL 的 USB OTG2 扩展成了 4 路 HOST 接口，其中一路供 4G 模块使用，因此就剩下了三个通用的 USB A 插座，原理图如图 所示：</p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908114506573.png" alt="image-20200908114506573" style="zoom:80%;"><p>图中 U10 就是 USB HUB 芯片 GL850G，GL850G 是一款符合 USB2.0 标准的 USBHUB 芯片，支持一拖四扩展，可以将一路 USB 扩展为 4 路 USB HOST 接口。这里我们将I.MX6ULL 的 USB OTG2 扩展出了 4 路 USB HOST 接口，分别为 HUB_DP1&#x2F;DM1、HUB_DP2&#x2F;DM2、HUB_DP3&#x2F;DM3 和 HUB_DP4&#x2F;DM4。其中 HUB_DP4&#x2F;DM4 用于 4G 模块，因此对外提供的只有三个 USB HOST 接口，这三个 USB HOST 接口如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908114621611.png" alt="image-20200908114621611"></p><p>注意，使用 GL850G 扩展出来的 4 路 USB 接口只能用作 HOST！</p><h3 id="USB-OTG-原理图分析"><a href="#USB-OTG-原理图分析" class="headerlink" title="USB OTG  原理图分析"></a>USB OTG  原理图分析</h3><p>I.MX6U-ALPHA 开发板上还有一路 USB OTG 接口，使用 I.MX6ULL 的 USB OTG1 接口。此路 USB OTG 既可以作为主机(HOST)，也可以作为从机(DEVICE)，从而实现完整的 OTG 功能，原理图如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908114743254.png" alt="image-20200908114743254"></p><p>图  中左侧的为 Mini USB 插座，当 OTG 作为从机(DEVICE)的时候 USB 线接入此接口。右侧为 USB A 插座，当 OTG 作为主机的时候将 USB 设备插入到此接口中。前面我们讲了，如果只有一个 Mini USB 插座的话如果要学习 OTG 那么就需要再购买一个 OTG 线，这样不方便我们使用。为此正点原子在开发板上集成了一个 USB HOST 接口，这样在做 OTG 实验的时候就不需要再另外单独购买一根 USB OTG 线了。这里就涉及到硬件对 USB ID 线的处理，图中 R111 和 R31 就是完成此功能的，我们分两部分来分析，既 OTG 分别工作在 HOST和 DEVICE 的时候硬件工作方式：</p><p>从机(DEVICE) 模式：图 中 USB_OTG_VBUS 是 Mini USB 的电源线，只有插入Mini USB 线以后 USB_OTG_VBUS 才有效(5V)。插入 Mini USB 线就表示开发板此时要做从机(此时不考虑接 OTG 线的情况)，USB_OTG_VBUS 就是电脑供的 5V 电压，由于分压电阻 R111和 R31 的作用，此时 USB_OTG1_ID 的电压就是 4.5V 左右，很明显这一个高电平。前面我们讲了，当 ID 线为高的时候就表示 OTG 工作在从机模式。</p><p>主机(HOST)： 模式：主机模式下必须将 Mini USB 线拔出来，将 USB 设备连接到对应的 USBHOST 接口上。Mini USB 线拔出来以后 USB_OTG_VBUS 就没有电压了，此时 USB_OTG1_ID线就被 R31 这个 100K 电阻下拉到地，因此 USB_OTG1_ID 线的电压就为 0，当 ID 线为 0 的时候就表示 OTG 工作在主机模式。</p><p>优点就是省去了购买一根 Mini USB OTG 线的麻烦，方便我们学习开发，但是在使用的时候要注意一下几点：</p><p>①、我们需要软件设置 USB_OTG1_ID 这个 IO 的电气属性，默认设置为下拉，也就是默认工作在主机(HOST)模式下。</p><p>②、由于我们修改了 OTG 硬件电路，因此就不能在 Mini USB 接口上接 OTG 线了，如果要使用 HOST 功能就将设备插到开发板板载的 USB HOST 接口上。I.MX6U-ALPHA 开发板上的 USB OTG 接口如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908115104725.png" alt="image-20200908115104725"></p><p>图中上面的就是主机(HOST)接口，下面的是从机(DEVICE)接口，两个不能同时使用！</p><h2 id="三、USB-协议简析"><a href="#三、USB-协议简析" class="headerlink" title="三、USB  协议简析"></a>三、USB  协议简析</h2><p>USB 协议中有很多的基础概念，本节就来看一下这些概念。</p><h3 id="1-USB-描述符"><a href="#1-USB-描述符" class="headerlink" title="1| USB  描述符"></a>1| USB  描述符</h3><p>顾名思义，USB 描述符就是用来描述 USB 信息的，描述符就是一串按照一定规则构建的字符串，USB 设备使用描述符来向主机报告自己的相关属性信息，常用的描述符如表 所示：</p><table><thead><tr><th align="center">描述符类型</th><th align="center">名字</th><th align="center">值</th></tr></thead><tbody><tr><td align="center">Device Descriptor</td><td align="center">设备描述符</td><td align="center">1</td></tr><tr><td align="center">Configuration Descriptor</td><td align="center">配置描述符</td><td align="center">2</td></tr><tr><td align="center">String Descriptor</td><td align="center">字符串描述符</td><td align="center">3</td></tr><tr><td align="center">Interface Descriptor</td><td align="center">接口字符串</td><td align="center">4</td></tr><tr><td align="center">Endpoint Descriptor</td><td align="center">端点描述符</td><td align="center">5</td></tr></tbody></table><p>我们依次来看一下表  中这 5 个描述符的含义：</p><h4 id="1-、设备描述符"><a href="#1-、设备描述符" class="headerlink" title="1 、设备描述符"></a>1 、设备描述符</h4><p>设备描述符用于描述 USB 设备的一般信息，USB 设备只有一个设备描述符。设备描述符里面记录了设备的 USB 版本号、设备类型、VID(厂商 ID)、PID(产品 ID)、设备序列号等。设备描述符结构如表 所示：</p><table><thead><tr><th align="center">偏移</th><th align="center">域</th><th align="center">大小(B)</th><th align="center">值类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">bLength</td><td align="center">1</td><td align="center">数字</td><td align="center">此设备描述符长度，18个字节</td></tr><tr><td align="center">1</td><td align="center">bDescriptorType</td><td align="center">1</td><td align="center">常量</td><td align="center">描述符类型，为0X01</td></tr><tr><td align="center">2</td><td align="center">bcdUSB</td><td align="center">2</td><td align="center">BCD码</td><td align="center">USB 版本号</td></tr><tr><td align="center">4</td><td align="center">bDeviceClass</td><td align="center">1</td><td align="center">类</td><td align="center">设备类</td></tr><tr><td align="center">5</td><td align="center">bDeviceSubClass</td><td align="center">1</td><td align="center">子类</td><td align="center">设备子类</td></tr><tr><td align="center">6</td><td align="center">bDevicePortocol</td><td align="center">1</td><td align="center">协议</td><td align="center">设备协议</td></tr><tr><td align="center">7</td><td align="center">bMaxPacketSize0</td><td align="center">1</td><td align="center">数字</td><td align="center">端点 0 的最大包长度</td></tr><tr><td align="center">8</td><td align="center">idVendor</td><td align="center">2</td><td align="center">ID</td><td align="center">厂商ID</td></tr><tr><td align="center">10</td><td align="center">idProduct</td><td align="center">2</td><td align="center">ID</td><td align="center">产品ID</td></tr><tr><td align="center">12</td><td align="center">bcdDevice</td><td align="center">2</td><td align="center">BCD码</td><td align="center">设备版本号</td></tr><tr><td align="center">14</td><td align="center">iManufacturer</td><td align="center">1</td><td align="center">索引</td><td align="center">厂商信息字符串描述符索引值</td></tr><tr><td align="center">15</td><td align="center">iProduct</td><td align="center">1</td><td align="center">索引</td><td align="center">产品信息字符串描述符索引值</td></tr><tr><td align="center">16</td><td align="center">iSerialNumber</td><td align="center">1</td><td align="center">索引</td><td align="center">产品序列号字符串描述符索引值</td></tr><tr><td align="center">17</td><td align="center">bNumConfigurations</td><td align="center">1</td><td align="center">索引</td><td align="center">可能的配置描述符数目</td></tr></tbody></table><h4 id="2-、配置描述符"><a href="#2-、配置描述符" class="headerlink" title="2 、配置描述符"></a>2 、配置描述符</h4><p>设备描述符的 bNumConfigurations 域定义了一个 USB 设备的配置描述符数量，一个 USB设备至少有一个配置描述符。配置描述符描述了设备可提供的接口(Interface)数量、配置编号、供电信息等，配置描述符结构如表 所示：</p><table><thead><tr><th>偏移</th><th>域</th><th>大小(B)</th><th>值类型</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>bLength</td><td>1</td><td>数字</td><td>此配置描述符长度，9个字节</td></tr><tr><td>1</td><td>bDescriptorType</td><td>1</td><td>常量</td><td>配置描述符类型，为 0X02</td></tr><tr><td>2</td><td>wTotalLength</td><td>2</td><td>数字</td><td>整个配置信息总长度(包括配置、接口、端点、设备类和厂家定义的描述符)</td></tr><tr><td>4</td><td>bNumInterfaces</td><td>1</td><td>数字</td><td>此配置所支持的接口数</td></tr><tr><td>5</td><td>bConfigurationValue</td><td>1</td><td>数字</td><td>该配置的值，一个设备支持多种配置，通过配置值来区分不同的配置。</td></tr><tr><td>6</td><td>bConfiguration</td><td>1</td><td>数字</td><td>描述此配置的字符串描述索引</td></tr><tr><td>7</td><td>bmAttributes</td><td>1</td><td>数字</td><td>该设备的属性：D7：保留 D6：自给电源   D5：远程唤醒 D4:0：保留</td></tr><tr><td>8</td><td>bMaxPower</td><td>1</td><td>数字</td><td>此配置下所需的总线电流(单位 2mA)</td></tr></tbody></table><h4 id="3-、字符串描述符"><a href="#3-、字符串描述符" class="headerlink" title="3 、字符串描述符"></a>3 、字符串描述符</h4><p>字符串描述符是可选的，字符串描述符用于描述一些方便人们阅读的信息，比如制造商、设备名称啥的。如果一个设备没有字符串描述符，那么其他描述符中和字符串有关的索引值都必须为 0，字符串描述符结构如表  所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908120331899.png" alt="image-20200908120331899"></p><p><strong>wLANGID[0]~wLANGID[x]</strong> 指明了设备支持的语言，具体含义要查阅文档《USB_LANGIDs.pdf》</p><p>主机会再次根据自己所需的语言向设备请求字符串描述符，这次会主机会指明要得到的字符串索引值和语言。设备返回 Unicode 编码的字符串描述符，结构如表 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908120439199.png" alt="image-20200908120439199"></p><h4 id="4-、接口描述符"><a href="#4-、接口描述符" class="headerlink" title="4 、接口描述符"></a>4 、接口描述符</h4><p>配置描述符中指定了该配置下的接口数量，配置可以提供一个或多个接口，接口描述符用于描述接口属性。接口描述符中一般记录接口编号、接口对应的端点数量、接口所述的类等，接口描述符结构如表所示：</p><table><thead><tr><th>偏移</th><th>域</th><th>大小(B)</th><th>值类型</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>bLength</td><td>1</td><td>数字</td><td>此接口描述符长度，9 个字节</td></tr><tr><td>1</td><td>bDescriptorType</td><td>1</td><td>常量</td><td>描述符类型，为0X04</td></tr><tr><td>2</td><td>bInterfaceNumber</td><td>1</td><td>数字</td><td>当前接口编号，从 0 开始</td></tr><tr><td>3</td><td>bAlternateSetting</td><td>1</td><td>数字</td><td>当前接口备用编号</td></tr><tr><td>4</td><td>bNumEndpoints</td><td>1</td><td>数字</td><td>当前接口的端点数量</td></tr><tr><td>5</td><td>bInterfaceClass</td><td>1</td><td>类</td><td>当前接口所属的类</td></tr><tr><td>6</td><td>bInterfaceSubClass</td><td>1</td><td>子类</td><td>当前接口所属的子类</td></tr><tr><td>7</td><td>bInterfaceProtocol</td><td>1</td><td>协议</td><td>当前接口所使用的协议</td></tr><tr><td>8</td><td>iInterface</td><td>1</td><td>索引</td><td>当前接口字符串的索引值</td></tr></tbody></table><h4 id="5-、端口描述符"><a href="#5-、端口描述符" class="headerlink" title="5 、端口描述符"></a>5 、端口描述符</h4><p>接口描述符定义了其端点数量，端点是设备与主机之间进行数据传输的逻辑接口，除了端点 0 是双向端口，其他的端口都是单向的。端点描述符描述了树传输类型、方向、数据包大小、端点号等信息，端点描述符结构如表所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908120732360.png" alt="image-20200908120732360"></p><h3 id="2-USB-数据包类型"><a href="#2-USB-数据包类型" class="headerlink" title="2| USB  数据包类型"></a>2| USB  数据包类型</h3><p>USB 是串行通信，需要一位一位的去传输数据， USB 传输的时候先将原始数据进行打包，所以 USB 中传输的基本单元就是数据包。根据用途的不同，USB 协议定义了 4 种不同的包结构：<strong>令牌(Token)包、数据(Data)包、握手(Handshake)包和特殊(Special)包</strong>。</p><p>这四种包通过包标识符 PID 来区分，PID 共有 8 位，USB 协议使用低 4 位 PID3<del>PID0，另外的高四位 PID7</del>PID4 是PID3<del>PID0 的取反，传输顺序是 PID0、PID1、PID2、PID3…PID7。令牌包的 PID1</del>0 为 01，数据包的 PID1<del>0 为 11，握手包的 PID1</del>0 为 10，特殊包的 PID1~0 为 00。每种类型的包又有多种具体的包，如表所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908121018454.png" alt="image-20200908121018454"></p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908121037706.png" alt="image-20200908121037706"></p><p>一个完整的包分为多个域，所有的数据包都是以同步域(SYNC)开始，后面紧跟着包标识符(PID)，最终都以包结束(EOP)信号结束。不同的数据包中间位域不同，一般有包目标地址(ADDR)、包目标端点(ENDP)、数据、帧索引、CRC 等，这个要具体数据包具体分析。接下来简单看一下这些数据包的结构。</p><h4 id="1-、令牌包"><a href="#1-、令牌包" class="headerlink" title="1 、令牌包"></a>1 、令牌包</h4><p>令牌包结构如下 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908121447983.png" alt="image-20200908121447983"></p><p>图是一个 SETUP 令牌包结构，首先是 SYNC 同步域，包同步域为 00000001，也就是连续 7 个 0，后面跟一个 1，如果是高速设备的话就是 31 个 0 后面跟一个 1。紧跟着是 PID，这里是 SETUP 包，为 0XB4，大家可能会好奇为什么不是 0X2D(00101101)，0XB4 的原因如下：</p><ul><li>①、SETUP 包的 PID3<del>PID0 为 1101，因此对应的 PID7</del>PID4 就是 0010。</li><li>②、PID 传输顺序为 PID0、PID1、PID2…PID7，因此按照传输顺序排列的话此处的 PID 就是 10110100&#x3D;0XB4，并不是 0X2D。</li></ul><p>PID 后面跟着地址域(ADDR)和端点域(ENDP)，为目标设备的地址和端点号。CRC5 域是 5位 CRC 值，是 ADDR 和 ENDP 这两个域的校验值。最后就是包结束域(EOP)，标记本数据包结束。其他令牌包的结构和 SETUP 基本类似，只是 SOF 令包中间没有 ADDR 和 ENDP 这两个域，而是只有一个 11 位的帧号域。</p><h4 id="2-、数据包"><a href="#2-、数据包" class="headerlink" title="2 、数据包"></a>2 、数据包</h4><p>数据包结构如图  所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908121426152.png" alt="image-20200908121426152"></p><p>数据包比较简单，同样的，数据包从 SYNC 同步域开始，然后紧跟着是 PID，这里就是DATA0，PID 值为 0XC3。接下来就是具体的数据，数据完了以后就是 16 位的 CRC 校验值，最后是 EOP。</p><h4 id="3-、握手包"><a href="#3-、握手包" class="headerlink" title="3 、握手包"></a>3 、握手包</h4><p>握手包结构如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908121515789.png" alt="image-20200908121515789"></p><p>图 是 ACK 握手包，很简单，首先是 SYNC 同步域，然后就是 ACK 包的 PID，为0X4B，最后就是 EOP。其他的 NAK、STALL、NYET 和 ERR 握手包结构都是一样的，只是其中的 PID 不同而已。</p><h3 id="3-USB-传输类型"><a href="#3-USB-传输类型" class="headerlink" title="3| USB  传输类型"></a>3| USB  传输类型</h3><p>在端点描述符中 bmAttributes 指定了端点的传输类型，一共有 4 种，本节我们来看一下这四种传输类型的区别。</p><h4 id="1、-控制-传输"><a href="#1、-控制-传输" class="headerlink" title="1、 控制 传输"></a>1、 控制 传输</h4><p>控制传输一般用于特定的请求，比如枚举过程就是全部由控制传输来完成的，比如获取描述符、设置地址、设置配置等。控制传输分为三个阶段：建立阶段(SETUP)、数据阶段(DATA)和状态阶段(STATUS)，其中数据阶段是可选的。建立阶段使用 SETUP 令牌包，SETUP 使用DATA0 包。数据阶段是 0 个、1 个或多个输入(IN)&#x2F;输出(OUT)事务，数据阶段的所有输入事务必须是同一个方向的，比如都为 IN 或都为 OUT。数据阶段的第一个数据包必须是 DATA1，每次正确传输以后就在 DATA0 和 DATA1 之间进行切换。数据阶段完成以后就是状态阶段，状态阶段的传输方向要和数据阶段相反，比如数据阶段为 IN 的话状态阶段就要为 OUT，状态阶段使用 DATA1 包。比如一个读控制传输格式如图  所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908121620734.png" alt="image-20200908121620734"></p><h4 id="2-、同步传输"><a href="#2-、同步传输" class="headerlink" title="2 、同步传输"></a>2 、同步传输</h4><p>同步传输用于周期性、低时延、数据量大的场合，比如音视频传输，这些场合对于时延要求很高，但是不要求数据 100%正确，允许有少量的错误。因此，同步传输没有握手阶段，即使数据传输出错了也不会重传。</p><h4 id="3-、批量传输"><a href="#3-、批量传输" class="headerlink" title="3 、批量传输"></a>3 、批量传输</h4><p>提起“批量”，我们第一反应就是“多”、“大”等，因此，批量传输就是用于大批量传输大块数据的，这些数据对实时性没有要求，比如 MSD 类设备(存储设备)，U 盘之类的。批量传输分为批量读(输入)和批量写(输出)，如果是批量读的话第一阶段的 IN 令牌包，如果是批量写那么第一阶段就是 OUT 令牌包。</p><p>我们就以批量写为例简单介绍一下批量传输过程：</p><ul><li>①、主机发出 OUT 令牌包，令牌包里面包含了设备地址、端点等信息。</li><li>②、如果 OUT 令牌包正确的话，也就是设备地址和端点号匹配，主机就会向设备发送一个数据(DATA)包，发送完成以后主机进入接收模式，等待设备返回握手包，一切都正确的话设备就会向主机返回一个 ACK 握手信号。</li></ul><p>批量读的过程刚好相反：</p><ul><li>①、主机发出 IN 令牌包，令牌包里面包含了设备地址、端点等信息。发送完成以后主机就进入到数据接收状态，等待设备返回数据。</li><li>②、如果 IN 令牌包正确的话，设备就会将一个 DATA 包放到总线上发送给主机。主机收到这个 DATA 包以后就会向设备发送一个 ACK 握手信号。</li></ul><h4 id="4-、中断传输"><a href="#4-、中断传输" class="headerlink" title="4 、中断传输"></a>4 、中断传输</h4><p>这里的中断传输并不是我们传统意义上的硬件中断，而是一种保持一定频率的传输，中断传输适用于传输数据量小、具有周期性并且要求响应速度快的数据，比如键盘、鼠标等。中断的端点会在端点描述符中报告自己的查询时间间隔，对于时间要求严格的设备可以采用中断传输。</p><h3 id="4-USB-枚举"><a href="#4-USB-枚举" class="headerlink" title="4| USB  枚举"></a>4| USB  枚举</h3><p>当 USB 设备与 USB 主机连接以后主机就会对 USB 设备进行枚举，通过枚举来获取设备的描述符信息，主机得到这些信息以后就知道该加载什么样的驱动、如何进行通信等。USB 枚举过程如下：</p><p>①、第一回合，当 USB 主机检测到 USB 设备插入以后机会发出总线复位信号来复位设备。USB 设备复位完成以后地址为 0，主机向地址 0 的端点 0 发送数据，请求设备的描述符。设备得到请求以后就会按照主机的要求将设备描述符发送给主机，主机得到设备发送过来的设备描述符以后，如果确认无误就会向设备返回一个确认数据包(ACK)。</p><p>②、第二回合，主机再次复位设备，进入地址设置阶段。主机向地址 0 的端点 0 发送设置地址请求数据包，新的设备地址就包含在这个数据包中，因此没有数据过程。设备进入状态过程，等待主机请求状态返回，收到以后设备就会向主机发送一个 0 字节状态数据包，表明设备已经设置好地址了，主机收到这个 0 字节状态数据包以后会返回一个确认包(ACK)。设备收到主机发送的 ACK 包以后就会使用这个新的设备地址，至此设备就得到了一个唯一的地址。</p><p>③、第三回合，主机向新的设备地址端点 0 发送请求设备描述符数据包，这一次主机要获取整个设备描述符，一共是 18 个字节。</p><p>④、和第③步类似，接下来依次获取配置描述符、配置集合、字符串描述符等等。</p><h2 id="四、Linux-内核自带-HOST-实验"><a href="#四、Linux-内核自带-HOST-实验" class="headerlink" title="四、Linux  内核自带 HOST  实验"></a>四、Linux  内核自带 HOST  实验</h2><h3 id="1-USB-鼠标键盘测试"><a href="#1-USB-鼠标键盘测试" class="headerlink" title="1| USB  鼠标键盘测试"></a>1| USB  鼠标键盘测试</h3><p>首先做一下 USB HOST 试验，也就是 I.MX6U-ALPHA 开发板做 USB 主机，然后外接 USB设备，比如 USB 鼠标键盘、USB 转 TTL 串口线、U 盘等设备。Linux 内核已经集成了大量的USB 设备驱动，尤其是我们常见的 USB 鼠标键盘、U 盘等，本节我们就来学习一下如何使能Linux 内核常见的 USB 设备驱动。</p><h4 id="1-、USB-鼠标键盘-驱动使能"><a href="#1-、USB-鼠标键盘-驱动使能" class="headerlink" title="1 、USB  鼠标键盘 驱动使能"></a>1 、USB  鼠标键盘 驱动使能</h4><p>注意，NXP 官方的 Linux 内核默认已经使能了 USB 键盘鼠标驱动！</p><p>USB 鼠标键盘属于 HID 设备，内核已经集成了相应的驱动，NXP 官方提供的 linux 内核默认已经使能了 USB 鼠标键盘驱动，但是我们还要学习一下如何手动使能这些驱动。输入<code>make menuconfig</code>打开 linux 内核配置界面，首先打开 HID 驱动，按照如下路径到相应的配置项目：</p><div class="hljs code-wrapper"><pre><code class="hljs elm">-&gt; <span class="hljs-type">Device</span> <span class="hljs-type">Drivers</span>    -&gt; <span class="hljs-type">HID</span> sup<span class="hljs-keyword">port</span>    -&gt; <span class="hljs-type">HID</span> bus sup<span class="hljs-keyword">port</span> (HID [=y])    -&gt; &lt;*&gt; <span class="hljs-type">Generic</span> <span class="hljs-type">HID</span> driver  //使能通用 <span class="hljs-type">HID</span> 驱动</code></pre></div><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908122624017.png" alt="image-20200908122624017"></p><p>接下来需要使能 USB 键盘和鼠标驱动，配置路径如下：</p><div class="hljs code-wrapper"><pre><code class="hljs elm">-&gt; <span class="hljs-type">Device</span> <span class="hljs-type">Drivers</span>    -&gt; <span class="hljs-type">HID</span> sup<span class="hljs-keyword">port</span>        -&gt; <span class="hljs-type">USB</span> <span class="hljs-type">HID</span> sup<span class="hljs-keyword">port</span>            -&gt; &lt;*&gt; <span class="hljs-type">USB</span> <span class="hljs-type">HID</span> trans<span class="hljs-keyword">port</span> layer //USB 键盘鼠标等 HID 设备驱动</code></pre></div><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908122641417.png" alt="image-20200908122641417"></p><p>大家可以将光标放到图 中“USB HID Transport layer”这一行，然后按下“?”键打开对应的帮助信息就可以看到对于这个配置项的描述，简单总结一下：</p><p>此选项对应配置项就是 CONFIG_USB_HID，也就是 USB 接口的 HID 设备。如果要使用USB 接口的 keyboards(键盘)、mice(鼠标)、joysticks(摇杆)、graphic tablets(绘图板)等其他的 HID设备，那么就需要选中“USB HID Transport layer”。</p><p>但是要注意一点，此驱动和 HIDBP(BootProtocol)键盘、鼠标的驱动不能一起使用！所以大家要是在网上查阅 linux 内核 USB 键盘鼠标驱动的时候，发现推荐使用“USB HIDBP Keyboard (simple Boot) support”和“USB HIDBP Mouse(simple Boot) support”这两个配置项的时候也不要觉得教程这里写错了。</p><h4 id="2-、测试-USB-鼠标和键盘-盘"><a href="#2-、测试-USB-鼠标和键盘-盘" class="headerlink" title="2 、测试 USB  鼠标和键盘 盘"></a>2 、测试 USB  鼠标和键盘 盘</h4><p>完成以后重新编译 linux 内核并且使用得到的 zImage 启动开发板。启动以后插入 USB 鼠标，会有如图 所示的提示信息：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908123217600.png" alt="image-20200908123217600"></p><p>从图可以看出，系统检测到了 USB 键盘，如果成功驱动的话就会在&#x2F;dev&#x2F;input目录下生成一个名为eventX(X&#x3D;0,1,2,3…)的文件，这个就是我们前面讲的输入子系统，鼠标和键盘都是作为输入子系统设备的。笔者这里对应的就是&#x2F;dev&#x2F;input&#x2F;event3 这个设备，使用如下命令查看鼠标的原始输入值，结果如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908123346643.png" alt="image-20200908123346643"></p><p>图就是键盘作为输入子系统设备的原始输入值，这里就不去分析了，我们在移植GUI 图形库以后就可以直接使用键盘鼠标，比如 QT 等。</p><p>最后再来测试一下 USB 键盘，屏幕已经驱动起来了，所以我们可以直接将屏幕作为终端，然后接上键盘直接输入命令来进行各种操作。首先将屏幕设置为控制台，打开开发板根文件系统中的&#x2F;etc&#x2F;inittab 文件，然后在里面加入下面这一行：</p><div class="hljs code-wrapper"><pre><code class="hljs arcade">tty1::askfirst:-<span class="hljs-regexp">/bin/</span>sh</code></pre></div><p>完成以后重启开发板，此时屏幕就会作为终端控制台，会有“Please press Enter to activatethis console.”这样提示，如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908123615570.png" alt="image-20200908123615570"></p><p>接上键盘，然后根据图  中的提示，按下键盘上的 Enter(回车)键即可使能 LCD 屏幕控制台，然后我们就可以输入各种命令来执行相应的操作。</p><h3 id="2-U-盘实验"><a href="#2-U-盘实验" class="headerlink" title="2| U  盘实验"></a>2| U  盘实验</h3><p>注意，NXP 官方的 Linux 内核默认已经使能了 U 盘！NXP 提供的 Linux 内核默认也已经是能了 U 盘驱动，因此我们可以直接插上去使用。但是我们还是需要学习一下如何手动配置 Linux 内核，使能 U 盘驱动。</p><h4 id="1-、使能-U-盘驱动"><a href="#1-、使能-U-盘驱动" class="headerlink" title="1 、使能 U  盘驱动"></a>1 、使能 U  盘驱动</h4><p>U 盘使用 SCSI 协议，因此要先使能 Linux 内核中的 SCSI 协议，配置路径如下：</p><div class="hljs code-wrapper"><pre><code class="hljs elm">-&gt; <span class="hljs-type">Device</span> <span class="hljs-type">Drivers</span>    -&gt; <span class="hljs-type">SCSI</span> device sup<span class="hljs-keyword">port</span>        -&gt; &lt;*&gt; <span class="hljs-type">SCSI</span> disk sup<span class="hljs-keyword">port</span> //选中此选项</code></pre></div><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908123706421.png" alt="image-20200908123706421"></p><p>我们还需要使能 USB Mass Storage，也就是 USB 接口的大容量存储设备，配置路径如下：</p><div class="hljs code-wrapper"><pre><code class="hljs elm">-&gt; <span class="hljs-type">Device</span> <span class="hljs-type">Drivers</span>    -&gt; <span class="hljs-type">USB</span> sup<span class="hljs-keyword">port</span> (USB_SUPPORT [=y])        -&gt; <span class="hljs-type">Support</span> for <span class="hljs-type">Host</span>-side <span class="hljs-type">USB</span> (<span class="hljs-type">USB</span> [=y])            -&gt; &lt;*&gt; <span class="hljs-type">USB</span> <span class="hljs-type">Mass</span> <span class="hljs-type">Storage</span> sup<span class="hljs-keyword">port</span> //USB 大容量存储设备</code></pre></div><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908123726925.png" alt="image-20200908123726925"></p><h4 id="2-、U-盘测试"><a href="#2-、U-盘测试" class="headerlink" title="2 、U 盘测试"></a>2 、U 盘测试</h4><p>准备好一个 U 盘，注意 U 盘要为 FAT32 格式的！NTFS 和 exFAT 由于版权问题所以在 Linux下支持的不完善，操作的话可能会有问题，比如只能读，不能写或者无法识别等。准备好以后将 U 盘插入到开发板 USB HUB 扩展出来的 HOST 接口上，此时会输出如图 所示信息：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908123912657.png" alt="image-20200908123912657"></p><p>从图可以看出，系统检测到 U 盘插入，大小为 16GB，对应的设备文件为&#x2F;dev&#x2F;sda和&#x2F;dev&#x2F;sda1，大家可以查看一下&#x2F;dev 目录下有没有 sda 和 sda1 这两个文件。</p><p>&#x2F;dev&#x2F;sda 是整个 U盘，&#x2F;dev&#x2F;sda1 是 U 盘的第一个分区，我们一般使用 U 盘的时候都是只有一个分区。要想访问 U盘我们需要先对 U 盘进行挂载，理论上挂载到任意一个目录下都可以，这里我创建一个&#x2F;mnt&#x2F;usb_disk 目录，然后将 U 盘挂载到&#x2F;mnt&#x2F;usb_disk 目录下，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/mnt/u</span>sb_disk -p <span class="hljs-regexp">//</span>创建目录mount <span class="hljs-regexp">/dev/</span>sda1 <span class="hljs-regexp">/mnt/u</span>sb_disk<span class="hljs-regexp">/ -t vfat -o iocharset=utf8  /</span><span class="hljs-regexp">/挂载</span></code></pre></div><p>-t 指定挂载所使用的文件系统类型，这里设置为 vfat，也就是 FAT 文件系统，“-o iocharset”设置硬盘编码格式为 utf8，否则的话 U 盘里面的中文会显示乱码！挂载成功以后进入到&#x2F;mnt&#x2F;usb_disk 目录下，输入 ls 命令查看 U 盘文件，如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908124337988.png" alt="image-20200908124337988"></p><p>至此 U 盘就能正常读写操作了，直接对&#x2F;mnt&#x2F;usb_disk 目录进行操作就行了。如果要拔出 U盘要执行一个 sync 命令进行同步，然后在使用 umount 进行 U 盘卸载，命令如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">sync <span class="hljs-regexp">//</span>同步cd <span class="hljs-regexp">/ /</span><span class="hljs-regexp">/如果处于/m</span>nt/usb_disk 目录的话先退出来，否则卸载的时候提示设备忙，导致卸载失败，切记！umount <span class="hljs-regexp">/mnt/u</span>sb_disk <span class="hljs-regexp">//</span>卸载</code></pre></div><h2 id="五、Linux-内核自带-USB-OTG-实验"><a href="#五、Linux-内核自带-USB-OTG-实验" class="headerlink" title="五、Linux  内核自带 USB OTG  实验"></a>五、Linux  内核自带 USB OTG  实验</h2><h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1| 修改设备树"></a>1| 修改设备树</h3><p>注意，如果使用的是正点原子 I.MX6U-ALPHA 开发板，那么就需要修改 OTG ID 引脚的电气属性，因为 ALPHA 开发板为了在板子上集成 OTG 的主机和从机接口对 ID 线做了修改，至于原因已经在前面小节讲过了。如果使用的其他 6ULL 开发板，就要去咨询一下厂商，看看需不需要修改 ID 引脚的电气属性。</p><p>查阅原理图可以知道，USB OTG1 的 ID 引脚连接到了 I.MX6ULL 的 GPIO1_IO00 这个引脚上，在 前面小节分析 ALPHA 开发板 USB OTG 原理图的时候已经说过了，USB OTG 默认工作在主机(HOST)模式下，因此 ID 线应该是低电平。这里需要修改设备树中 GPIO1_IO00 这个引脚的电气属性，将其设置为默认下拉。打开设备树 imx6ull-lxg-emmc.dts，在 iomuxc 节点的 pinctrl_hog_1 子节点下添加 GPIO1_IO00 引脚信息，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;iomuxc &#123;<span class="hljs-number">2</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">3</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;<span class="hljs-number">4</span> imx6ul-evk &#123;<span class="hljs-number">5</span> pinctrl_hog_1: hoggrp<span class="hljs-number">-1</span> &#123;<span class="hljs-number">6</span> fsl,pins = &lt;<span class="hljs-number">7</span> ......<span class="hljs-number">8</span> MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID <span class="hljs-number">0x13058</span> <span class="hljs-comment">/*OTG1 ID */</span><span class="hljs-number">9</span> &gt;;<span class="hljs-number">10</span> &#125;;<span class="hljs-number">11</span> ......<span class="hljs-number">12</span> &#125;;</code></pre></div><p>第 8 行就是将 GPIO1_IO00 复用为 OTG1 ID，并且设置电气属性为 0X13058，默认下拉，设备树修改好以后重新编译并用新的设备树启动系统</p><h3 id="2-OTG-主机实验"><a href="#2-OTG-主机实验" class="headerlink" title="2| OTG  主机实验"></a>2| OTG  主机实验</h3><p>系统重启成功以后就可以正常使用 USB OTG1 接口，OTG 既可以做主机，也可以做从机，做主机的话测试方法和上小节一模一样，直接在 ALPHA 的 OTG HOST 接口上插入 USB 鼠标键盘、U 盘等设备。</p><p>注意！如果使用正点原子的 ALPHA 开发板，切记不要使用 Mini OTG 线来外接 USB 设备，原因已经在前面小节说明了，只需要将USB 设备插入到开发板上的OTG HOST 接口上即可！</p><h3 id="3-OTG-从机实验"><a href="#3-OTG-从机实验" class="headerlink" title="3| OTG  从机实验"></a>3| OTG  从机实验</h3><p>OTG 从机就是将开发板作为一个 USB 设备连接到其他的主机上，这里我们来做两个 USB从机实验：模拟 U 盘以及 USB 声卡。</p><h4 id="1、-模拟-U-盘实验"><a href="#1、-模拟-U-盘实验" class="headerlink" title="1、 模拟 U  盘实验"></a>1、 模拟 U  盘实验</h4><p>模拟 U 盘实验就是将开发板当做一个 U 盘，可以将开发板上的 U 盘或者 TF 卡挂载到 PC上去，首先需要配置 Linux，配置路径如下：</p><div class="hljs code-wrapper"><pre><code class="hljs clean">-&gt; Device Drivers    -&gt; USB support (USB_SUPPORT [=y])        -&gt; USB Gadget Support (USB_GADGET [=y]            -&gt; [M]USB Gadget Drivers (&lt;choice&gt; [=m]) <span class="hljs-comment">//选中 USB Gadget 驱动</span>                -&gt;[M]Mass Storage Gadget <span class="hljs-comment">//大容量存储</span></code></pre></div><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908125107043.png" alt="image-20200908125107043"></p><p>这里我们需要将驱动编译为模块！使用的时候直接输入命令加载驱动模块即可。配置好以后重新编译 Linux 内核，会得到三个.ko 驱动模块(带路径)：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">drivers<span class="hljs-regexp">/usb/g</span>adget/libcomposite.kodrivers<span class="hljs-regexp">/usb/g</span>adget<span class="hljs-regexp">/function/u</span>sb_f_mass_storage.kodrivers<span class="hljs-regexp">/usb/g</span>adget<span class="hljs-regexp">/legacy/g</span>_mass_storage.ko</code></pre></div><p>将上述三个.ko 模块拷贝到开发板根文件系统中，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">cd drivers<span class="hljs-regexp">/usb/g</span>adget/ sudo cp libcomposite.ko <span class="hljs-regexp">/home/</span>firestaradmin<span class="hljs-regexp">/linux/</span>nfs<span class="hljs-regexp">/rootfs/</span>lib<span class="hljs-regexp">/modules/</span><span class="hljs-number">4.1</span>.<span class="hljs-number">15</span>/sudo cp <span class="hljs-keyword">function</span><span class="hljs-regexp">/usb_f_mass_storage.ko /</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/nfs/</span>rootfs<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.1.15/</span>sudo cp legacy<span class="hljs-regexp">/g_mass_storage.ko /</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/nfs/</span>rootfs<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.1.15/</span></code></pre></div><p>拷贝完成以后使用新编译出来的 zImage 启动开发板，在开发板上插入一个 U 盘，记住这个U盘对应的设备文件，比如我们这里是&#x2F;dev&#x2F;sda和&#x2F;dev&#x2F;sda1，以后要将&#x2F;dev&#x2F;sda1挂载到PC上，也就是把&#x2F;dev&#x2F;sda1 作为模拟 U 盘的存储区域。使用 Mini USB 线将开发板的 USB OTG Mini 接口与电脑连接起来，如图所示：</p><p>连接好以后依次加载 libcomposite.ko、usb_f_mass_storage.ko 和 g_mass_storage.ko 这三个驱动文件，顺序不能错了！命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">depmodmodprobe libcomposite.komodprobe usb_f_mass_storage.komodprobe g_mass_storage.ko <span class="hljs-attribute">file</span>=/dev/sda1 <span class="hljs-attribute">removable</span>=1</code></pre></div><p>加载 g_mass_storage.ko 的时候使用 file 参数指定使用的大容量存储设备，我这里使用 U 盘对应的&#x2F;dev&#x2F;sda1。如果加载成功的话电脑就会出现一个U盘，这个U盘就是我们开发板模拟的，如图 所示：</p><p>我们可以直接在电脑上对这个 U 盘进行读写操作，实际上操作的就是插在开发板上的 U盘。操作完成以后要退出的话执行如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">rmmod</span> g_mass_storage.ko</code></pre></div><p>注意！不要将开发板上的 EMMC 或者 NAND 作为模拟 U 盘的存储区域，因为 linux 下EMMC和NAND使用的文件系统一般都是EXT3&#x2F;EXT4和UBIFS，这些文件系统类型和windows下的不兼容，如果挂载的话就会在 windows 下提示要你格式化 U 盘！</p><h4 id="2-、USB-声卡实验"><a href="#2-、USB-声卡实验" class="headerlink" title="2 、USB  声卡实验"></a>2 、USB  声卡实验</h4><p>USB 声卡就是 USB 接口的外置声卡，一般电脑内部都自带了声卡，但是内部自带的声卡效果相对来说比较差，不能满足很多 HIFI 玩家的需求。USB 声卡通过 USB 接口来传递音频数据，具体的 ADC 和 DAC 过程由声卡完成，摆脱了电脑主板体积的限制，外置 USB 声卡就可以做的很好。ALPHA 开发板板载了音频解码芯片，因此可以将 ALPHA 开发板作为一个外置USB 声卡，配置 Linux 内核，配置路径如下：</p><div class="hljs code-wrapper"><pre><code class="hljs clean">-&gt; Device Drivers    -&gt; USB support (USB_SUPPORT [=y])        -&gt; USB Gadget Support (USB_GADGET [=y]            -&gt; [M]USB Gadget Drivers <span class="hljs-comment">//选中 USB Gadget 驱动</span>                -&gt;[M] Audio Gadget <span class="hljs-comment">//选中音频</span>                    -&gt;UAC <span class="hljs-number">1.0</span> (Legacy) <span class="hljs-comment">//选中 UAC</span></code></pre></div><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908125942445.png" alt="image-20200908125942445"></p><p>注意，这里也是编译为驱动模块，配置完成以后重新编译内核，得到新的 zImage 和三个.ko驱动模块文件：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">drivers<span class="hljs-regexp">/usb/g</span>adget/libcomposite.kodrivers<span class="hljs-regexp">/usb/g</span>adget<span class="hljs-regexp">/function/u</span>sb_f_uac1.kodrivers<span class="hljs-regexp">/usb/g</span>adget<span class="hljs-regexp">/legacy/g</span>_audio.ko</code></pre></div><p>将上述三个.ko 模块拷贝到开发板根文件系统中，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">cd drivers<span class="hljs-regexp">/usb/g</span>adget/sudo cp libcomposite.ko <span class="hljs-regexp">/home/</span>firestaradmin<span class="hljs-regexp">/linux/</span>nfs<span class="hljs-regexp">/rootfs/</span>lib<span class="hljs-regexp">/modules/</span><span class="hljs-number">4.1</span>.<span class="hljs-number">15</span>/sudo cp <span class="hljs-keyword">function</span><span class="hljs-regexp">/usb_f_uac1.ko /</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/nfs/</span>rootfs<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.1.15/</span>sudo cp legacy<span class="hljs-regexp">/g_audio.ko /</span>home<span class="hljs-regexp">/firestaradmin/</span>linux<span class="hljs-regexp">/nfs/</span>rootfs<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.1.15/</span></code></pre></div><p>拷贝完成以后使用新编译出来的 zImage 启动开发板，首先按照 音频驱动实验讲解的方法配置ALPHA 的声卡，保证声卡播放正常！使用 Mini USB 线将开发板与电脑连接起来，最后依次加载 libcomposite.ko、usb_f_uac1.ko 和 g_audio.ko 这三个驱动模块，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs stylus">depmodmodprobe libcomposite<span class="hljs-selector-class">.ko</span>modprobe usb_f_uac1<span class="hljs-selector-class">.ko</span>modprobe g_audio.ko</code></pre></div><p>加载完成以后稍等一会虚拟出一个 USB 声卡，打开电脑的设备管理器，选择“声音、视频和游戏控制器”，会发现有一个名为“AC Interface”设备，如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908130127061.png" alt="image-20200908130127061"></p><p>图 中的“AC Interface”就是开发板模拟出来的 USB 声卡，设置 windows，选择音频输出使用“AC Interface”，Windows10 设置如图  所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/23%E3%80%81Linux_USB%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200908130142916.png" alt="image-20200908130142916"></p><p>一切设置好以后就可以从开发板上听到电脑输出的声音，此时开发板就完全是一个 USB 声卡设备了。</p><p>关于 USB 驱动就讲解到这里，本章并没有深入到 USB 驱动具体编写方式，只是对 USB 的协议做了简单的介绍，后面讲解了一下 Linux 内核自带的 USB HOST 和 DEVICE 驱动的使用，Linux 内核已经集成了大量的 USB 设备驱动，至于其他特殊的就需要具体情况具体分析了，比如本教程后面讲解的 USB WIFI 和 4G 模块驱动。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24| Linux 块设备驱动实验</title>
    <link href="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-块设备驱动实验"><a href="#Linux-块设备驱动实验" class="headerlink" title="Linux 块设备驱动实验"></a>Linux 块设备驱动实验</h1><p>块设备驱动是Linux 三大驱动类型之一。块设备驱动要远比字符设备驱动复杂得多，不同类型的存储设备又对应不同的驱动子系统，本章我们重点学习一下块设备相关驱动概念，不涉及到具体的存储设备。最后，我们使用 ALPHA 开发板板载 RAM 模拟一个块设备，学习块设备驱动框架的使用。</p><h2 id="一、什么是块设备？"><a href="#一、什么是块设备？" class="headerlink" title="一、什么是块设备？"></a>一、什么是块设备？</h2><p>块设备是针对存储设备的，比如 SD 卡、EMMC、NAND Flash、Nor Flash、SPI Flash、机械硬盘、固态硬盘等。因此块设备驱动其实就是这些存储设备驱动，块设备驱动相比字符设备驱动的主要区别如下：</p><ul><li>①、块设备只能以块为单位进行读写访问，块是 linux 虚拟文件系统(VFS)基本的数据传输单位。字符设备是以字节为单位进行数据传输的，不需要缓冲。</li><li>②、块设备在结构上是可以进行随机访问的，对于这些设备的读写都是按块进行的，块设备使用缓冲区来暂时存放数据，等到条件成熟以后在一次性将缓冲区中的数据写入块设备中。这么做的目的为了提高块设备寿命，大家如果仔细观察的话就会发现有些硬盘或者 NAND Flash就会标明擦除次数(flash 的特性，写之前要先擦除)，比如擦除 100000 次等。因此，为了提高块设备寿命而引入了缓冲区，数据先写入到缓冲区中，等满足一定条件后再一次性写入到真正的物理存储设备中，这样就减少了对块设备的擦除次数，提高了块设备寿命。</li></ul><p>字符设备是顺序的数据流设备，字符设备是按照字节进行读写访问的。字符设备不需要缓冲区，对于字符设备的访问都是实时的，而且也不需要按照固定的块大小进行访问。</p><p>块设备结构的不同其 I&#x2F;O 算法也会不同，比如对于 EMMC、SD 卡、NAND Flash 这类没有任何机械设备的存储设备就可以任意读写任何的扇区(块设备物理存储单元)。但是对于机械硬盘这样带有磁头的设备，读取不同的盘面或者磁道里面的数据，磁头都需要进行移动，因此对于机械硬盘而言，将那些杂乱的访问按照一定的顺序进行排列可以有效提高磁盘性能，linux 里面针对不同的存储设备实现了不同的 I&#x2F;O 调度算法。</p><h2 id="二、块设备驱动框架"><a href="#二、块设备驱动框架" class="headerlink" title="二、块设备驱动框架"></a>二、块设备驱动框架</h2><h3 id="1-block-device-结构体"><a href="#1-block-device-结构体" class="headerlink" title="1| block_device  结构体"></a>1| block_device  结构体</h3><p>linux 内核使用 block_device 表示块设备，block_device 为一个结构体，定义在include&#x2F;linux&#x2F;fs.h 文件中，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-type">dev_t</span> bd_dev; <span class="hljs-comment">/* not a kdev_t - it&#x27;s a search key */</span><span class="hljs-number">3</span> <span class="hljs-type">int</span> bd_openers;<span class="hljs-number">4</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">bd_inode</span>;</span> <span class="hljs-comment">/* will die */</span><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">bd_super</span>;</span><span class="hljs-number">6</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">bd_mutex</span>;</span> <span class="hljs-comment">/* open/close mutex */</span><span class="hljs-number">7</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">bd_inodes</span>;</span><span class="hljs-number">8</span> <span class="hljs-type">void</span> * bd_claiming;<span class="hljs-number">9</span> <span class="hljs-type">void</span> * bd_holder;<span class="hljs-number">10</span> <span class="hljs-type">int</span> bd_holders;<span class="hljs-number">11</span> <span class="hljs-type">bool</span> bd_write_holder;<span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSFS</span><span class="hljs-number">13</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">bd_holder_disks</span>;</span><span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-number">15</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> *<span class="hljs-title">bd_contains</span>;</span><span class="hljs-number">16</span> <span class="hljs-type">unsigned</span> bd_block_size;<span class="hljs-number">15</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_struct</span> *<span class="hljs-title">bd_part</span>;</span><span class="hljs-number">18</span> <span class="hljs-comment">/*number of times partitions within this device have been opened.*/</span><span class="hljs-number">19</span> <span class="hljs-type">unsigned</span> bd_part_count;<span class="hljs-number">20</span> <span class="hljs-type">int</span> bd_invalidated;<span class="hljs-number">21</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> *<span class="hljs-title">bd_disk</span>;</span><span class="hljs-number">22</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">bd_queue</span>;</span><span class="hljs-number">23</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">bd_list</span>;</span><span class="hljs-number">24</span> <span class="hljs-comment">/*</span><span class="hljs-comment">25 * Private data. You must have bd_claim&#x27;ed the block_device</span><span class="hljs-comment">26 * to use this. <span class="hljs-doctag">NOTE:</span> bd_claim allows an owner to claim</span><span class="hljs-comment">27 * the same device multiple times, the owner must take special</span><span class="hljs-comment">28 * care to not mess up bd_private for that case.</span><span class="hljs-comment">29 */</span><span class="hljs-number">30</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bd_private;<span class="hljs-number">31</span><span class="hljs-number">32</span> <span class="hljs-comment">/* The counter of freeze processes */</span><span class="hljs-number">33</span> <span class="hljs-type">int</span> bd_fsfreeze_count;<span class="hljs-number">34</span> <span class="hljs-comment">/* Mutex for freeze */</span><span class="hljs-number">35</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">bd_fsfreeze_mutex</span>;</span><span class="hljs-number">36</span> &#125;;</code></pre></div><p>对于 block_device 结构体，我们重点关注一下第 21 行的 bd_disk 成员变量，此成员变量为gendisk 结构体指针类型。内核使用 block_device 来表示一个具体的块设备对象，比如一个硬盘或者分区，如果是硬盘的话 bd_disk 就指向通用磁盘结构 gendisk。</p><h4 id="注册块设备"><a href="#注册块设备" class="headerlink" title="注册块设备"></a>注册块设备</h4><p>和字符设备驱动一样，我们需要向内核注册新的块设备、申请设备号，块设备注册函数为register_blkdev，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">register_blkdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>major</strong> ：主设备号。<br><strong>name</strong> ：块设备名字。<br><strong>返回值</strong>：如果参数 major 在 1<del>255 之间的话表示自定义主设备号，那么返回 0 表示注册成功，如果返回负值的话表示注册失败。如果 major 为 0 的话表示由系统自动分配主设备号，那么返回值就是系统分配的主设备号(1</del>255)，如果返回负值那就表示注册失败。</p><h4 id="注销块设备"><a href="#注销块设备" class="headerlink" title="注销块设备"></a>注销块设备</h4><p>和字符设备驱动一样，如果不使用某个块设备了，那么就需要注销掉，函数为unregister_blkdev，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_blkdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>major</strong> ：要注销的块设备主设备号。<br><strong>name</strong>： ： 要注销的块设备名字。<br><strong>返回值</strong>：无。</p><h3 id="2-gendisk-结构体"><a href="#2-gendisk-结构体" class="headerlink" title="2| gendisk  结构体"></a>2| gendisk  结构体</h3><p>linux 内核使用 gendisk 来描述一个磁盘设备，这是一个结构体，定义在 include&#x2F;linux&#x2F;genhd.h中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-comment">/* major, first_minor and minors are input parameters only,</span><span class="hljs-comment">3 * don&#x27;t use directly. Use disk_devt() and disk_max_parts().</span><span class="hljs-comment">4 */</span><span class="hljs-number">5</span> <span class="hljs-type">int</span> major; <span class="hljs-comment">/* major number of driver */</span><span class="hljs-number">6</span> <span class="hljs-type">int</span> first_minor;<span class="hljs-number">7</span> <span class="hljs-type">int</span> minors; <span class="hljs-comment">/* maximum number of minors, =1 for</span><span class="hljs-comment">8 * disks that can&#x27;t be partitioned. */</span><span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-type">char</span> disk_name[DISK_NAME_LEN]; <span class="hljs-comment">/* name of major driver */</span><span class="hljs-number">11</span> <span class="hljs-type">char</span> *(*devnode)(<span class="hljs-keyword">struct</span> gendisk *gd, <span class="hljs-type">umode_t</span> *mode);<span class="hljs-number">12</span><span class="hljs-number">13</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> events; <span class="hljs-comment">/* supported events */</span><span class="hljs-number">14</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> async_events; <span class="hljs-comment">/* async events, subset of all */</span><span class="hljs-number">15</span><span class="hljs-number">16</span> <span class="hljs-comment">/* Array of pointers to partitions indexed by partno.</span><span class="hljs-comment">17 * Protected with matching bdev lock but stat and other</span><span class="hljs-comment">18 * non-critical accesses use RCU. Always access through</span><span class="hljs-comment">19 * helpers.</span><span class="hljs-comment">20 */</span><span class="hljs-number">21</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk_part_tbl</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">part_tbl</span>;</span><span class="hljs-number">22</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_struct</span> <span class="hljs-title">part0</span>;</span><span class="hljs-number">23</span><span class="hljs-number">24</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device_operations</span> *<span class="hljs-title">fops</span>;</span><span class="hljs-number">25</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">queue</span>;</span><span class="hljs-number">26</span> <span class="hljs-type">void</span> *private_data;<span class="hljs-number">27</span><span class="hljs-number">28</span> <span class="hljs-type">int</span> flags;<span class="hljs-number">29</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">driverfs_dev</span>;</span> <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> remove</span><span class="hljs-number">30</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">slave_dir</span>;</span><span class="hljs-number">31</span><span class="hljs-number">32</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_rand_state</span> *<span class="hljs-title">random</span>;</span><span class="hljs-number">33</span> <span class="hljs-type">atomic_t</span> sync_io; <span class="hljs-comment">/* RAID */</span><span class="hljs-number">34</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk_events</span> *<span class="hljs-title">ev</span>;</span><span class="hljs-number">35</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEV_INTEGRITY</span><span class="hljs-number">36</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_integrity</span> *<span class="hljs-title">integrity</span>;</span><span class="hljs-number">37</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-number">38</span> <span class="hljs-type">int</span> node_id;<span class="hljs-number">39</span> &#125;;</code></pre></div><p>我们简单看一下 gendisk 结构体中比较重要的几个成员变量：</p><ul><li>第 5 行，major 为磁盘设备的主设备号。</li><li>第 6 行，first_minor 为磁盘的第一个次设备号。</li><li>第 7 行，minors 为磁盘的此设备号数量，也就是磁盘的分区数量，这些分区的主设备号一样，此设备号不同。</li><li>第 21 行，part_tbl 为磁盘对应的分区表，为结构体 disk_part_tbl 类型，disk_part_tbl 的核心是一个 hd_struct 结构体指针数组，此数组每一项都对应一个分区信息。</li><li>第 24 行，fops 为块设备操作集，为 block_device_operations 结构体类型。和字符设备操作集 file_operations 一样，是块设备驱动中的重点！</li><li>第 25 行，queue 为磁盘对应的请求队列，所以针对该磁盘设备的请求都放到此队列中，驱动程序需要处理此队列中的所有请求。</li></ul><p>编写块的设备驱动的时候需要分配并初始化一个 gendisk，linux 内核提供了一组 gendisk 操<br>作函数，我们来看一下一些常用的 API 函数。</p><h4 id="1、-申请-gendisk"><a href="#1、-申请-gendisk" class="headerlink" title="1、 申请 gendisk"></a>1、 申请 gendisk</h4><p>使用 gendisk 之前要先申请，allo_disk 函数用于申请一个 gendisk，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> gendisk *<span class="hljs-title function_">alloc_disk</span><span class="hljs-params">(<span class="hljs-type">int</span> minors)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>minors</strong> ：次设备号数量，也就是 gendisk 对应的分区数量。<br><strong>返回值</strong>：成功：返回申请到的 gendisk，失败：NULL。</p><h4 id="2-、删除-gendisk"><a href="#2-、删除-gendisk" class="headerlink" title="2 、删除 gendisk"></a>2 、删除 gendisk</h4><p>如果要删除 gendisk 的话可以使用函数 del_gendisk，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">del_gendisk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *gp)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>gp</strong> ：要删除的 gendisk。<br><strong>返回值</strong>：无。</p><h4 id="3-、将-gendisk-添加到内核"><a href="#3-、将-gendisk-添加到内核" class="headerlink" title="3 、将 gendisk  添加到内核"></a>3 、将 gendisk  添加到内核</h4><p>使用 alloc_disk 申请到 gendisk 以后系统还不能使用，必须使用 add_disk 函数将申请到的gendisk 添加到内核中，add_disk 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">add_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>disk</strong> ：要添加到内核的 gendisk。<br><strong>返回值</strong>：无。</p><h4 id="4-、设置-gendisk-容量"><a href="#4-、设置-gendisk-容量" class="headerlink" title="4 、设置 gendisk  容量"></a>4 、设置 gendisk  容量</h4><p>每一个磁盘都有容量，所以在初始化 gendisk 的时候也需要设置其容量，使用函数set_capacity，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">set_capacity</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk, <span class="hljs-type">sector_t</span> size)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>disk</strong> ：要设置容量的 gendisk。<br><strong>size</strong>： ：磁盘容量大小，注意这里是扇区数量。块设备中最小的可寻址单元是扇区，一个扇区一般是 512 字节，有些设备的物理扇区可能不是 512 字节。不管物理扇区是多少，内核和块设备驱动之间的扇区都是 512 字节。所以 set_capacity 函数设置的大小就是块设备实际容量除以512 字节得到的扇区数量。比如一个 2MB 的磁盘，其扇区数量就是(2<em>1024</em>1024)&#x2F;512&#x3D;4096。<br><strong>返回值</strong>：无。</p><h4 id="5-、调整-gendisk-引用计数"><a href="#5-、调整-gendisk-引用计数" class="headerlink" title="5 、调整 gendisk  引用计数"></a>5 、调整 gendisk  引用计数</h4><p>内核会通过 get_disk 和 put_disk 这两个函数来调整 gendisk 的引用计数，根据名字就可以知道，get_disk 是增加 gendisk 的引用计数，put_disk 是减少 gendisk 的引用计数，这两个函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">truct kobject *<span class="hljs-title function_">get_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk)</span><span class="hljs-type">void</span> <span class="hljs-title function_">put_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk)</span></code></pre></div><h3 id="3-block-device-operations-结构体"><a href="#3-block-device-operations-结构体" class="headerlink" title="3| block_device_operations  结构体"></a>3| block_device_operations  结构体</h3><p>和字符设备的 file _operations 一样，块设备也有操作集，为结构体 block_device_operations，此结构体定义在 include&#x2F;linux&#x2F;blkdev.h 中，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device_operations</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">fmode_t</span>);<span class="hljs-number">3</span> <span class="hljs-type">void</span> (*release) (<span class="hljs-keyword">struct</span> gendisk *, <span class="hljs-type">fmode_t</span>);<span class="hljs-number">4</span> <span class="hljs-type">int</span> (*rw_page)(<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">sector_t</span>, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span> rw);<span class="hljs-number">5</span> <span class="hljs-type">int</span> (*ioctl) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">fmode_t</span>, <span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<span class="hljs-number">6</span> <span class="hljs-type">int</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">fmode_t</span>, <span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<span class="hljs-number">7</span> <span class="hljs-type">long</span> (*direct_access)(<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">sector_t</span>,<span class="hljs-number">8</span> <span class="hljs-type">void</span> **, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *pfn, <span class="hljs-type">long</span> size);<span class="hljs-number">9</span> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*check_events)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk,</span><span class="hljs-params"><span class="hljs-number">10</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> clearing)</span>;<span class="hljs-number">11</span> <span class="hljs-comment">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span><span class="hljs-number">12</span> <span class="hljs-type">int</span> (*media_changed) (<span class="hljs-keyword">struct</span> gendisk *);<span class="hljs-number">13</span> <span class="hljs-type">void</span> (*unlock_native_capacity) (<span class="hljs-keyword">struct</span> gendisk *);<span class="hljs-number">14</span> <span class="hljs-type">int</span> (*revalidate_disk) (<span class="hljs-keyword">struct</span> gendisk *);<span class="hljs-number">15</span> <span class="hljs-type">int</span> (*getgeo)(<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-keyword">struct</span> hd_geometry *);<span class="hljs-number">16</span> <span class="hljs-comment">/* this callback is with swap_lock and sometimes page table lock held */</span><span class="hljs-number">17</span> <span class="hljs-type">void</span> (*swap_slot_free_notify) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<span class="hljs-number">18</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><span class="hljs-number">19</span> &#125;;</code></pre></div><p>可以看出，block_device_operations 结构体里面的操作集函数和字符设备的 file_operations操作集基本类似，但是块设备的操作集函数比较少，我们来看一下其中比较重要的几个成员函数：</p><ul><li>第 2 行，open 函数用于打开指定的块设备。</li><li>第 3 行，release 函数用于关闭(释放)指定的块设备。</li><li>第 4 行，rw_page 函数用于读写指定的页。</li><li>第 5 行，ioctl 函数用于块设备的 I&#x2F;O 控制。</li><li>第 6 行，compat_ioctl 函数和 ioctl 函数一样，都是用于块设备的 I&#x2F;O 控制。区别在于在 64位系统上，32 位应用程序的 ioctl 会调用 compat_iotl 函数。在 32 位系统上运行的 32 位应用程序调用的就是 ioctl 函数。</li><li>第 15 行，getgeo 函数用于获取磁盘信息，包括磁头、柱面和扇区等信息。</li><li>第 18 行，owner 表示此结构体属于哪个模块，一般直接设置为 THIS_MODULE。</li></ul><h3 id="4-块设备-I-x2F-O-请求过程"><a href="#4-块设备-I-x2F-O-请求过程" class="headerlink" title="4| 块设备 I&#x2F;O  请求过程"></a>4| 块设备 I&#x2F;O  请求过程</h3><p>大家如果仔细观察的话会在 block_device_operations 结构体中并没有找到 read和 write 这样<br>的读写函数，那么块设备是怎么从物理块设备中读写数据？这里就引处理块设备驱动中非常重<br>要的 request_queue、request 和 bio。</p><h4 id="1、请求队列-request-queue"><a href="#1、请求队列-request-queue" class="headerlink" title="1、请求队列 request_queue"></a>1、请求队列 request_queue</h4><p>内核将对块设备的读写都发送到请求队列 request_queue 中，request_queue 中是大量的request(请求结构体)，而 request 又包含了 bio，bio 保存了读写相关数据，比如从块设备的哪个地址开始读取、读取的数据长度，读取到哪里，如果是写的话还包括要写入的数据等。我们先来看一下 request_queue，这是一个结构体，定义在文件 include&#x2F;linux&#x2F;blkdev.h 中，由于request_queue 结构体比较长，这里就不列出来了。大家回过头看一下示例代码的 gendisk结构体就会发现里面有一个 request_queue 结构体指针类型成员变量 queue，也就说在编写块设备驱动的时候，每个磁盘(gendisk)都要分配一个 request_queue。</p><h5 id="①、初始化请求队列"><a href="#①、初始化请求队列" class="headerlink" title="①、初始化请求队列"></a>①、初始化请求队列</h5><p>我们首先需要申请并初始化一个 request_queue，然后在初始化 gendisk 的时候将这个request_queue 地址赋值给 gendisk 的 queue 成员变量。使用 blk_init_queue 函数来完成request_queue 的申请与初始化，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">request_queue *<span class="hljs-title function_">blk_init_queue</span><span class="hljs-params">(request_fn_proc *rfn, <span class="hljs-type">spinlock_t</span> *lock)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><p><strong>rfn</strong> ：请求处理函数指针，每个 request_queue 都要有一个请求处理函数，请求处理函数request_fn_proc 原型如下：</p>  <div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> (request_fn_proc) (<span class="hljs-keyword">struct</span> request_queue *q)</code></pre></div><p>  请求处理函数需要驱动编写人员自行实现。</p></li><li><p><strong>lock</strong>： ：自旋锁指针，需要驱动编写人员定义一个自旋锁，然后传递进来。，请求队列会使用这个自旋锁。</p></li><li><p><strong>返回值</strong>：如果为 NULL 的话表示失败，成功的话就返回申请到的 request_queue 地址。</p></li></ul><h5 id="②、删除请求队列"><a href="#②、删除请求队列" class="headerlink" title="②、删除请求队列"></a>②、删除请求队列</h5><p>当卸载块设备驱动的时候我们还需要删除掉前面申请到的 request_queue，删除请求队列使用函数 blk_cleanup_queue，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">void blk<span class="hljs-constructor">_cleanup_queue(<span class="hljs-params">struct</span> <span class="hljs-params">request_queue</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><strong>q</strong> ：需要删除的请求队列。</li><li><strong>返回值</strong>：无。</li></ul><h5 id="③、分配请求队列-并绑定制造请求函数"><a href="#③、分配请求队列-并绑定制造请求函数" class="headerlink" title="③、分配请求队列 并绑定制造请求函数"></a>③、分配请求队列 并绑定制造请求函数</h5><p>blk_init_queue 函数完成了请求队列的申请已经请求处理函数的绑定，这个一般用于像机械硬盘这样的存储设备，需要 I&#x2F;O 调度器来优化数据读写过程。但是对于 EMMC、SD 卡这样的非机械设备，可以进行完全随机访问，所以就不需要复杂的 I&#x2F;O 调度器了。对于非机械设备我们可以先申请 request_queue，然后将申请到的 request_queue 与“制造请求”函数绑定在一起。</p><p>先来看一下 request_queue 申请函数 blk_alloc_queue，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> request_queue *<span class="hljs-title function_">blk_alloc_queue</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><strong>gfp_mask</strong>：内存分配掩码，具体可选择的掩码值请参考 include&#x2F;linux&#x2F;gfp.h 中的相关宏定义，一般为 GFP_KERNEL。</li><li><strong>返回 值</strong>：申请到的无 I&#x2F;O 调度的 request_queue。</li></ul><p>我们需要为 blk_alloc_queue 函数申请到的请求队列绑定一个“制造请求”函数(其他参考资料将其直接翻译为“制造请求”函数)。这里我们需要用到函数 blk_queue_make_request，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">blk_queue_make_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, make_request_fn *mfn)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><p><strong>q</strong> ：需要绑定的请求队列，也就是 blk_alloc_queue 申请到的请求队列。</p></li><li><p><strong>mfn</strong>：需要绑定的“制造”请求函数，函数原型如下：</p><ul><li>&#96;&#96;&#96;c<br>  void (make_request_fn) (struct request_queue *q, struct bio *bio)  <div class="hljs code-wrapper"><pre><code class="hljs clean">    “制造请求”函数需要驱动编写人员实现。- **返回值**：无。一般 blk_alloc_queue 和 blk_queue_make_request 是搭配在一起使用的，用于那么非机械的存储设备、无需 I/O 调度器，比如 EMMC、SD 卡等。blk_init_queue 函数会给请求队列分配一个 I/O 调度器，用于机械存储设备，比如机械硬盘等。### <span class="hljs-number">2</span>、请求 request请求队列(request_queue)里面包含的就是一系列的请求(request)，request 是一个结构体，定义在 include/linux/blkdev.h 里面，这里就不展开 request 结构体了，太长了。request 里面有一个名为“bio”的成员变量，类型为 bio 结构体指针。前面说了，真正的数据就保存在 bio 里面，所以我们需要从 request_queue 中取出一个一个的 request，然后再从每个 request 里面取出 bio，最后根据 bio 的描述讲数据写入到块设备，或者从块设备中读取数据。#### ①、 获取请求我们需要从request_queue中依次获取每个request，使用blk_peek_request函数完成此操作，函数原型如下：```crequest *blk_peek_request(struct request_queue *q)</code></pre></div></li></ul></li></ul><p>函数参数和返回值含义如下：<br><strong>q</strong> ：指定 request_queue。<br><strong>返回值</strong>：request_queue 中下一个要处理的请求(request)，如果没有要处理的请求就返回 NULL。</p><h4 id="②、开启请求"><a href="#②、开启请求" class="headerlink" title="②、开启请求"></a>②、开启请求</h4><p>使用 blk_peek_request 函数获取到下一个要处理的请求以后就要开始处理这个请求，这里要用到 blk_start_request 函数，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">blk_start_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *req)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>req</strong> ：要开始处理的请求。<br><strong>返回值</strong>：无。</p><h4 id="③、一步到位处理请求"><a href="#③、一步到位处理请求" class="headerlink" title="③、一步到位处理请求"></a>③、一步到位处理请求</h4><p>我们也可以使用 blk_fetch_request 函数来一次性完成请求的获取和开启，blk_fetch_request函数很简单，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-keyword">struct</span> request *<span class="hljs-title function_">blk_fetch_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span>2 &#123;<span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span><span class="hljs-number">4</span><span class="hljs-number">5</span> rq = blk_peek_request(q);<span class="hljs-number">6</span> <span class="hljs-keyword">if</span> (rq)<span class="hljs-number">7</span> blk_start_request(rq);<span class="hljs-number">8</span> <span class="hljs-keyword">return</span> rq;<span class="hljs-number">9</span> &#125;</code></pre></div><p>可以看出，blk_fetch_request 就是直接调用了 blk_peek_request 和 blk_start_request 这两个函 数。</p><h4 id="④、其他和请求有关的函数"><a href="#④、其他和请求有关的函数" class="headerlink" title="④、其他和请求有关的函数"></a>④、其他和请求有关的函数</h4><p>关于请求的 API 还有很多，常见的见表 ： </p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909164818191.png" alt="image-20200909164818191"></p><h3 id="3-、bio-结构"><a href="#3-、bio-结构" class="headerlink" title="3 、bio  结构"></a>3 、bio  结构</h3><p>每个 request 里面里面会有多个 bio，bio 保存着最终要读写的数据、地址等信息。上层应用程序对于块设备的都写会被构造成一个或多个 bio 结构，bio 结构描述了要读写的起始扇区、要读写的扇区数量、是读取还是写入、页便宜、数据长度等等信息。上层会讲 bio 提交给 I&#x2F;O 调度器，I&#x2F;O 调度器会将这些 bio 构造成 request 结构，而一个物理存储设备对应一个 request_queue，request_queue 里面顺序存放着一系列的 request。新产生的 bio 可能被合并到 request_queue 里现有的 request 中，也可能产生新的 request，然后插入到 request_queue 中合适的位置，这一切都是由 I&#x2F;O 调度器来完成的。request_queue、request 和 bio 之间的关系如图所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909164843110.png" alt="image-20200909164843110"></p><p>bio 是个结构体，定义在 include&#x2F;linux&#x2F;blk_types.h 中，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">bi_next</span>;</span> <span class="hljs-comment">/* 请求队列的下一个 bio */</span><span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> *<span class="hljs-title">bi_bdev</span>;</span> <span class="hljs-comment">/* 指向块设备  */</span><span class="hljs-number">4</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bi_flags; <span class="hljs-comment">/* bio 状态等信息  */</span><span class="hljs-number">5</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bi_rw; <span class="hljs-comment">/* I/O 操作,读或写 */</span><span class="hljs-number">6</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bvec_iter</span> <span class="hljs-title">bi_iter</span>;</span>  <span class="hljs-comment">/* I/O 操作,读或写 */</span><span class="hljs-number">7</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_phys_segments;<span class="hljs-number">8</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_seg_front_size;<span class="hljs-number">9</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_seg_back_size;<span class="hljs-number">10</span> <span class="hljs-type">atomic_t</span> bi_remaining;<span class="hljs-number">11</span> <span class="hljs-type">bio_end_io_t</span> *bi_end_io;<span class="hljs-number">12</span> <span class="hljs-type">void</span> *bi_private;<span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_CGROUP</span><span class="hljs-number">14</span> <span class="hljs-comment">/*</span><span class="hljs-comment">15 * Optional ioc and css associated with this bio. Put on bio</span><span class="hljs-comment">16 * release. Read comment on top of bio_associate_current().</span><span class="hljs-comment">17 */</span><span class="hljs-number">18</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_context</span> *<span class="hljs-title">bi_ioc</span>;</span><span class="hljs-number">19</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cgroup_subsys_state</span> *<span class="hljs-title">bi_css</span>;</span><span class="hljs-number">20</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-number">21</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><span class="hljs-number">22</span> <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span><span class="hljs-number">23</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_integrity_payload</span> *<span class="hljs-title">bi_integrity</span>;</span><span class="hljs-number">24</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-number">25</span> &#125;;<span class="hljs-number">26</span><span class="hljs-number">27</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> bi_vcnt; <span class="hljs-comment">/* bio_vec 列表中元素数量  */</span><span class="hljs-number">28</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> bi_max_vecs; <span class="hljs-comment">/* bio_vec 列表长度 */</span><span class="hljs-number">29</span> <span class="hljs-type">atomic_t</span> bi_cnt; <span class="hljs-comment">/* pin count */</span><span class="hljs-number">30</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> *<span class="hljs-title">bi_io_vec</span>;</span> <span class="hljs-comment">/* bio_vec  列表 */</span><span class="hljs-number">31</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_set</span> *<span class="hljs-title">bi_pool</span>;</span><span class="hljs-number">32</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> <span class="hljs-title">bi_inline_vecs</span>[0];</span><span class="hljs-number">33</span> &#125;;</code></pre></div><p>重点来看一下第 6 行和第 30 行，第 6 行为 bvec_iter 结构体类型的成员变量，第 30 行为bio_vec 结构体指针类型的成员变量。</p><p>bvec_iter 结构体描述了要操作的设备扇区等信息，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bvec_iter</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-type">sector_t</span> bi_sector; <span class="hljs-comment">/* I/O 请求的设备起始扇区(512 字节) */</span><span class="hljs-number">3</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_size; <span class="hljs-comment">/* 剩余的 I/O 数量 */</span><span class="hljs-number">4</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_idx; <span class="hljs-comment">/* blv_vec 中当前索引 */</span><span class="hljs-number">5</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bi_bvec_done; <span class="hljs-comment">/* 当前 bvec 中已经处理完成的字节数 */</span><span class="hljs-number">6</span> &#125;;</code></pre></div><p>bio_vec 结构体描述了内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">bv_page</span>;</span> <span class="hljs-comment">/* 页 */</span><span class="hljs-number">3</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bv_len;  <span class="hljs-comment">/* 长度 */</span><span class="hljs-number">4</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bv_offset; <span class="hljs-comment">/* 偏移 */</span><span class="hljs-number">5</span> &#125;;</code></pre></div><p>可以看出 bio_vec 就是“page,offset,len”组合，page 指定了所在的物理页，offset 表示所处页的偏移地址，len 就是数据长度。</p><p>我们对于物理存储设备的操作不外乎就是将 RAM 中的数据写入到物理存储设备中，或者将物理设备中的数据读取到 RAM 中去处理。数据传输三个要求：数据源、数据长度以及数据目的地，也就是你要从物理存储设备的哪个地址开始读取、读取到 RAM 中的哪个地址处、读取的数据长度是多少。既然 bio 是块设备最小的数据传输单元，那么 bio 就有必要描述清楚这些信息，其中 bi_iter 这个结构体成员变量就用于描述物理存储设备地址信息，比如要操作的扇区地址。bi_io_vec 指向 bio_vec 数组首地址，bio_vec 数组就是 RAM 信息，比如页地址、页偏移以及长度，“页地址”是 linux 内核里面内存管理相关的概念，这里我们不深究 linux 内存管理，我们只需要知道对于 RAM 的操作最终会转换为页相关操作。</p><p>bio、bvec_iter 以及 bio_vec 这三个机构体之间的关系如图 所示：</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909165121668.png" alt="image-20200909165121668"></p><h4 id="①、遍历请求中的-bio"><a href="#①、遍历请求中的-bio" class="headerlink" title="①、遍历请求中的 bio"></a>①、遍历请求中的 bio</h4><p>前面说了，请求中包含有大量的 bio，因此就涉及到遍历请求中所有 bio 并进行处理。遍历请求中的 bio 使用函数__rq_for_each_bio，这是一个宏，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __rq_for_each_bio(_bio, rq) \</span><span class="hljs-meta"><span class="hljs-keyword">if</span> ((rq-&gt;bio)) \</span><span class="hljs-meta">for (_bio = (rq)-&gt;bio; _bio; _bio = _bio-&gt;bi_next)_</span></code></pre></div><p>__bio 就是遍历出来的每个 bio，rq 是要进行遍历操作的请求，_bio 参数为 bio 结构体指针类 型，rq 参数为 request 结构体指针类型。</p><h4 id="②、遍历-bio-中的所有段"><a href="#②、遍历-bio-中的所有段" class="headerlink" title="②、遍历 bio  中的所有段"></a>②、遍历 bio  中的所有段</h4><p>bio 包含了最终要操作的数据，因此还需要遍历 bio 中的所有段，这里要用到 bio_for_each_segment 函数，此函数也是一个宏，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> bio_for_each_segment(bvl, bio, iter) \</span><span class="hljs-meta">__bio_for_each_segment(bvl, bio, iter, (bio)-&gt;bi_iter)</span></code></pre></div><p>第一个 bvl 参数就是遍历出来的每个 bio_vec，第二个 bio 参数就是要遍历的 bio，类型为bio 结构体指针，第三个 iter 参数保存要遍历的 bio 中 bi_iter 成员变量。</p><h4 id="③、通知-bio-处理结束"><a href="#③、通知-bio-处理结束" class="headerlink" title="③、通知 bio  处理结束"></a>③、通知 bio  处理结束</h4><p>如果使用“制造请求”，也就是抛开 I&#x2F;O 调度器直接处理 bio 的话，在 bio 处理完成以后要通过内核 bio 处理完成，使用 bio_endio 函数，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">bvoid <span class="hljs-title function_">bio_endio</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bio *bio, <span class="hljs-type">int</span> error)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><p><strong>bio</strong> ：要结束的 bio。</p></li><li><p><strong>error</strong> ：如果 bio 处理成功的话就直接填 0，如果失败的话就填个负值，比如-EIO。</p></li><li><p><strong>返回值</strong>：无</p></li></ul><h2 id="三、使用请求队列实验"><a href="#三、使用请求队列实验" class="headerlink" title="三、使用请求队列实验"></a>三、使用请求队列实验</h2><p>关于块设备架构就讲解这些，接下来我们使用开发板上的 RAM 模拟一段块设备，也就是ramdisk，然后编写块设备驱动。</p><h3 id="1-实验程序编写"><a href="#1-实验程序编写" class="headerlink" title="1| 实验程序编写"></a>1| 实验程序编写</h3><p>首先是传统的使用请求队列的时候，也就是针对机械硬盘的时候如何编写驱动。由于实验程序稍微有点长，因此我们就分步骤来讲解一下，本实验参考自 linux 内核 drivers&#x2F;block&#x2F;z2ram.c。打开实验源码，我们先来看一下一相关的宏定义和结构体，代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span>......<span class="hljs-number">21</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span>......<span class="hljs-number">33</span><span class="hljs-number">34</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> RAMDISK_SIZE (2 * 1024 * 1024) <span class="hljs-comment">/* 容量大小为 2MB */</span></span><span class="hljs-number">35</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> RAMDISK_NAME <span class="hljs-string">&quot;ramdisk&quot;</span> <span class="hljs-comment">/* 名字 */</span></span><span class="hljs-number">36</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> RADMISK_MINOR 3 <span class="hljs-comment">/* 表示三个磁盘分区！不是次设备号为 3！ */</span></span><span class="hljs-number">37</span><span class="hljs-number">38</span> <span class="hljs-comment">/* ramdisk 设备结构体 */</span><span class="hljs-number">39</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ramdisk_dev</span>&#123;</span><span class="hljs-number">40</span> <span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><span class="hljs-number">41</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ramdiskbuf; <span class="hljs-comment">/* ramdisk 内存空间,用于模拟块设备 */</span><span class="hljs-number">42</span> <span class="hljs-type">spinlock_t</span> lock; <span class="hljs-comment">/* 自旋锁 */</span><span class="hljs-number">43</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> *<span class="hljs-title">gendisk</span>;</span> <span class="hljs-comment">/* gendisk */</span><span class="hljs-number">44</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">queue</span>;</span><span class="hljs-comment">/* 请求队列 */</span><span class="hljs-number">45</span> &#125;;<span class="hljs-number">46</span><span class="hljs-number">47</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ramdisk_dev</span> <span class="hljs-title">ramdisk</span>;</span> <span class="hljs-comment">/* ramdisk 设备 */</span></code></pre></div><ul><li><strong>第34~36行</strong>，实验相关宏定义，RAMDISK_SIZE就是模拟块设备的大小，这里设置为2MB，也就是说本实验中的虚拟块设备大小为 2MB。RAMDISK_NAME 为本实验名字，RADMISK_MINOR 是本实验此设备号数量，注意不是次设备号！此设备号数量决定了本块设备的磁盘分区数量。</li><li><strong>第 39~45 行</strong>，ramdisk 的设备结构体。</li><li><strong>第 47 行</strong>，定义一个 ramdisk 示例。</li></ul><p>接下来看一下驱动模块的加载与卸载，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*</span><span class="hljs-comment">2 * @description : 驱动出口函数</span><span class="hljs-comment">3 * @param : 无</span><span class="hljs-comment">4 * @return : 无</span><span class="hljs-comment">5 */</span><span class="hljs-number">6</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ramdisk_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>7 &#123;<span class="hljs-number">8</span> <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-comment">/* 1、申请用于 ramdisk 内存 */</span><span class="hljs-number">11</span> ramdisk.ramdiskbuf = kzalloc(RAMDISK_SIZE, GFP_KERNEL);<span class="hljs-number">12</span> <span class="hljs-keyword">if</span>(ramdisk.ramdiskbuf == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-number">13</span> ret = -EINVAL;<span class="hljs-number">14</span> <span class="hljs-keyword">goto</span> ram_fail;<span class="hljs-number">15</span> &#125;<span class="hljs-number">16</span><span class="hljs-number">17</span> <span class="hljs-comment">/* 2、初始化自旋锁 */</span><span class="hljs-number">18</span> spin_lock_init(&amp;ramdisk.lock);<span class="hljs-number">19</span><span class="hljs-number">20</span> <span class="hljs-comment">/* 3、注册块设备 */</span><span class="hljs-number">21</span> ramdisk.major = register_blkdev(<span class="hljs-number">0</span>, RAMDISK_NAME); <span class="hljs-comment">/* 自动分配 */</span><span class="hljs-number">22</span> <span class="hljs-keyword">if</span>(ramdisk.major &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-number">23</span> <span class="hljs-keyword">goto</span> register_blkdev_fail;<span class="hljs-number">24</span> &#125;<span class="hljs-number">25</span>printk(<span class="hljs-string">&quot;ramdisk major = %d\r\n&quot;</span>, ramdisk.major);<span class="hljs-number">26</span><span class="hljs-number">27</span> <span class="hljs-comment">/* 4、分配并初始化 gendisk */</span><span class="hljs-number">28</span> ramdisk.gendisk = alloc_disk(RADMISK_MINOR);<span class="hljs-number">29</span> <span class="hljs-keyword">if</span>(!ramdisk.gendisk) &#123;<span class="hljs-number">30</span> ret = -EINVAL;<span class="hljs-number">31</span> <span class="hljs-keyword">goto</span> gendisk_alloc_fail;<span class="hljs-number">32</span> &#125;<span class="hljs-number">33</span><span class="hljs-number">34</span> <span class="hljs-comment">/* 5、分配并初始化请求队列 */</span><span class="hljs-number">35</span> ramdisk.<span class="hljs-built_in">queue</span> = blk_init_queue(ramdisk_request_fn,&amp;ramdisk.lock);<span class="hljs-number">36</span> <span class="hljs-keyword">if</span>(!ramdisk.<span class="hljs-built_in">queue</span>) &#123;<span class="hljs-number">37</span> ret = EINVAL;<span class="hljs-number">38</span> <span class="hljs-keyword">goto</span> blk_init_fail;<span class="hljs-number">39</span> &#125;<span class="hljs-number">40</span><span class="hljs-number">41</span> <span class="hljs-comment">/* 6、添加(注册)disk */</span><span class="hljs-number">42</span> ramdisk.gendisk-&gt;major = ramdisk.major;  <span class="hljs-comment">/* 主设备号 */</span><span class="hljs-number">43</span> ramdisk.gendisk-&gt;first_minor = <span class="hljs-number">0</span>; <span class="hljs-comment">/*起始次设备号) */</span><span class="hljs-number">44</span> ramdisk.gendisk-&gt;fops = &amp;ramdisk_fops; <span class="hljs-comment">/* 操作函数 */</span><span class="hljs-number">45</span> ramdisk.gendisk-&gt;private_data = &amp;ramdisk; <span class="hljs-comment">/* 私有数据 */</span><span class="hljs-number">46</span> ramdisk.gendisk-&gt;<span class="hljs-built_in">queue</span> = ramdisk.<span class="hljs-built_in">queue</span>; <span class="hljs-comment">/* 请求队列 */</span><span class="hljs-number">47</span> <span class="hljs-built_in">sprintf</span>(ramdisk.gendisk-&gt;disk_name, RAMDISK_NAME);<span class="hljs-comment">/* 名字 */</span><span class="hljs-number">48</span> set_capacity(ramdisk.gendisk, RAMDISK_SIZE/<span class="hljs-number">512</span>); <span class="hljs-comment">/* 设备容量(单位 为扇区)*/</span><span class="hljs-number">49</span> add_disk(ramdisk.gendisk);<span class="hljs-number">50</span><span class="hljs-number">51</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">52</span><span class="hljs-number">53</span> blk_init_fail:<span class="hljs-number">54</span> put_disk(ramdisk.gendisk);<span class="hljs-number">55</span> gendisk_alloc_fail:<span class="hljs-number">56</span> unregister_blkdev(ramdisk.major, RAMDISK_NAME);<span class="hljs-number">57</span> register_blkdev_fail:<span class="hljs-number">58</span> kfree(ramdisk.ramdiskbuf); <span class="hljs-comment">/* 释放内存 */</span><span class="hljs-number">59</span> ram_fail:<span class="hljs-number">60</span> <span class="hljs-keyword">return</span> ret;<span class="hljs-number">61</span> &#125;<span class="hljs-number">62</span><span class="hljs-number">63</span> <span class="hljs-comment">/*</span><span class="hljs-comment">64 * @description : 驱动出口函数</span><span class="hljs-comment">65 * @param : 无</span><span class="hljs-comment">66 * @return : 无</span><span class="hljs-comment">67 */</span><span class="hljs-number">68</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">ramdisk_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>69 &#123;<span class="hljs-number">70</span> <span class="hljs-comment">/* 释放 gendisk */</span><span class="hljs-number">71</span> put_disk(ramdisk.gendisk);<span class="hljs-number">72</span> del_gendisk(ramdisk.gendisk);<span class="hljs-number">73</span><span class="hljs-number">74</span> <span class="hljs-comment">/* 清除请求队列 */</span><span class="hljs-number">75</span> blk_cleanup_queue(ramdisk.<span class="hljs-built_in">queue</span>);<span class="hljs-number">76</span><span class="hljs-number">77</span> <span class="hljs-comment">/* 注销块设备 */</span><span class="hljs-number">78</span> unregister_blkdev(ramdisk.major, RAMDISK_NAME);<span class="hljs-number">79</span><span class="hljs-number">80</span> <span class="hljs-comment">/* 释放内存 */</span><span class="hljs-number">81</span> kfree(ramdisk.ramdiskbuf);<span class="hljs-number">82</span> &#125;<span class="hljs-number">83</span><span class="hljs-number">84</span> module_init(ramdisk_init);<span class="hljs-number">85</span> module_exit(ramdisk_exit);<span class="hljs-number">86</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-number">87</span> MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>ramdisk_init 和 ramdisk_exit 这两个函数分别为驱动入口以及出口函数，我们依次来看一下这两个函数。</p><ul><li>第 11 行，因为本实验是使用一块内存模拟真实的块设备，因此这里先使用 kzalloc 函数申请用于 ramdisk 实验的内存，大小为 2MB。</li><li>第 18 行，初始化一个自旋锁，blk_init_queue 函数在分配并初始化请求队列的时候需要用到一次自旋锁。</li><li>第 21 行，使用 register_blkdev 函数向内核注册一个块设备，返回值就是注册成功的块设备主设备号。这里我们让内核自动分配一个主设备号，因此 register_blkdev 函数的第一个参数为0。</li><li>第 28 行，使用 alloc_disk 分配一个 gendisk。</li><li>第 35 行，使用 blk_init_queue 函数分配并初始化一个请求队列，请求处理函数为ramdisk_request_fn，具体的块设备读写操作就在此函数中完成，这个需要驱动开发人员去编写，稍后讲解。</li><li>第 42~47 行，初始化第 28 行申请到的 gendisk，重点是第 44 行设置 gendisk 的 fops 成员变量，也就是设置块设备的操作集。这里设置为 ramdisk_fops，需要驱动开发人员自行编写实现，稍后讲解。</li><li>第 48 行，使用 set_capacity 函数设置本块设备容量大小，注意这里的大小是扇区数，不是字节数，一个扇区是 512 字节。</li><li>第 48 行，gendisk 初始化完成以后就可以使用 add_disk 函数将 gendisk 添加到内核中，也就是向内核添加一个磁盘设备。</li><li>ramdisk_exit 函数就比较简单了，在卸载块设备驱动的时候需要将前面申请的内容都释放掉。第 71 和 72 行使用 put_disk 和 del_gendis 函数释放前面申请的 gendisk，第 75 行使用blk_cleanup_queue 函数消除前面申请的请求队列，第 78 行使用 unregister_blkdev 函数注销前面注册的块设备，最后调用 kfree 来释放掉申请的内存。</li></ul><p>在 ramdisk_init 函数中设置了 gendisk 的 fops 成员变量，也就是块设备的操作集，具体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*</span><span class="hljs-comment">2 * @description : 打开块设备</span><span class="hljs-comment">3 * @param - dev : 块设备</span><span class="hljs-comment">4 * @param - mode : 打开模式</span><span class="hljs-comment">5 * @return : 0 成功;其他 失败</span><span class="hljs-comment">6 */</span><span class="hljs-number">7</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ramdisk_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> block_device *dev, <span class="hljs-type">fmode_t</span> mode)</span>8 &#123;<span class="hljs-number">9</span> printk(<span class="hljs-string">&quot;ramdisk open\r\n&quot;</span>);<span class="hljs-number">10</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">11</span> &#125;<span class="hljs-number">12</span><span class="hljs-number">13</span> <span class="hljs-comment">/*</span><span class="hljs-comment">14 * @description : 释放块设备</span><span class="hljs-comment">15 * @param - disk : gendisk</span><span class="hljs-comment">16 * @param - mode : 模式</span><span class="hljs-comment">17 * @return : 0 成功;其他 失败</span><span class="hljs-comment">18 */</span><span class="hljs-number">19</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ramdisk_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk, <span class="hljs-type">fmode_t</span> mode)</span>20 &#123;<span class="hljs-number">21</span> printk(<span class="hljs-string">&quot;ramdisk release\r\n&quot;</span>);<span class="hljs-number">22</span> &#125;<span class="hljs-number">23</span><span class="hljs-number">24</span> <span class="hljs-comment">/*</span><span class="hljs-comment">25 * @description  : 获取磁盘信息</span><span class="hljs-comment">26 * @param - dev : 块设备</span><span class="hljs-comment">27 * @param - geo : 模式</span><span class="hljs-comment">28 * @return : 0 成功;其他 失败</span><span class="hljs-comment">29 */</span><span class="hljs-number">30</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ramdisk_getgeo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> block_device *dev, <span class="hljs-keyword">struct</span> hd_geometry *geo)</span>31 &#123;<span class="hljs-number">32</span> <span class="hljs-comment">/* 这是相对于机械硬盘的概念 */</span><span class="hljs-number">33</span> geo-&gt;heads = <span class="hljs-number">2</span>; <span class="hljs-comment">/* 磁头 */</span><span class="hljs-number">34</span> geo-&gt;cylinders = <span class="hljs-number">32</span>; <span class="hljs-comment">/* 柱面 */</span><span class="hljs-number">35</span> geo-&gt;sectors = RAMDISK_SIZE / (<span class="hljs-number">2</span> * <span class="hljs-number">32</span> *<span class="hljs-number">512</span>); <span class="hljs-comment">/* 磁道上的扇区数量 */</span><span class="hljs-number">36</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">37</span> &#125;<span class="hljs-number">38</span><span class="hljs-number">39</span> <span class="hljs-comment">/*</span><span class="hljs-comment">40 * 块设备操作函数</span><span class="hljs-comment">41 */</span><span class="hljs-number">42</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device_operations</span> <span class="hljs-title">ramdisk_fops</span> =</span><span class="hljs-number">43</span> &#123;<span class="hljs-number">44</span> .owner = THIS_MODULE,<span class="hljs-number">45</span> .open = ramdisk_open,<span class="hljs-number">46</span> .release = ramdisk_release,<span class="hljs-number">47</span> .getgeo = ramdisk_getgeo,<span class="hljs-number">48</span> &#125;;</code></pre></div><p>第 42<del>48 行就是块设备的操作集 block_device_operations，本例程实现的比较简单，仅仅实现了 open、release 和 getgeo，其中 open 和 release 函数都是空函数。重点是 getgeo 函数，第30</del>37 行就是 getgeo 的具体实现，此函数用户获取磁盘信息，信息保存在参数 geo 中，为结构体 hd_geometry 类型，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_geometry</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> heads; <span class="hljs-comment">/* 磁头 */</span><span class="hljs-number">3</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sectors; <span class="hljs-comment">/*一个磁道上的扇区数量 */</span><span class="hljs-number">4</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cylinders; <span class="hljs-comment">/* 柱面 */</span><span class="hljs-number">5</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start;<span class="hljs-number">6</span> &#125;;</code></pre></div><p>本例程中设置 ramdisk 有 2 个磁头(head)、一共有 32 个柱面(cylinderr)。知道磁盘总容量、磁头数、柱面数以后我们就可以计算出一个磁道上有多少个扇区了，也就是 hd_geometry 中的sectors 成员变量。</p><p>最后就是非常重要的请求处理函数，使用 blk_init_queue 函数初始化队列的时候需要指定一个请求处理函数，本例程中注册的请求处理函数如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*</span><span class="hljs-comment">2 * @description : 处理传输过程</span><span class="hljs-comment">3 * @param-req : 请求</span><span class="hljs-comment">4 * @return : 无</span><span class="hljs-comment">5 */</span><span class="hljs-number">6</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ramdisk_transfer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *req)</span>7 &#123;<span class="hljs-number">8</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start = blk_rq_pos(req) &lt;&lt; <span class="hljs-number">9</span>; <span class="hljs-comment">/* blk_rq_pos 获取到的是扇区地址，左移 9 位转换为字节地址 */</span><span class="hljs-number">9</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len = blk_rq_cur_bytes(req); <span class="hljs-comment">/* 大小 */</span><span class="hljs-number">10</span><span class="hljs-number">11</span> <span class="hljs-comment">/* bio 中的数据缓冲区</span><span class="hljs-comment">12 * 读：从磁盘读取到的数据存放到 buffer 中</span><span class="hljs-comment">13 * 写：buffer 保存这要写入磁盘的数据</span><span class="hljs-comment">14 */</span><span class="hljs-number">15</span> <span class="hljs-type">void</span> *buffer = bio_data(req-&gt;bio);<span class="hljs-number">16</span><span class="hljs-number">17</span> <span class="hljs-keyword">if</span>(rq_data_dir(req) == READ) <span class="hljs-comment">/* 读数据 */</span><span class="hljs-number">18</span> <span class="hljs-built_in">memcpy</span>(buffer, ramdisk.ramdiskbuf + start, len);<span class="hljs-number">19</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rq_data_dir(req) == WRITE) <span class="hljs-comment">/* 写数据 */</span><span class="hljs-number">20</span> <span class="hljs-built_in">memcpy</span>(ramdisk.ramdiskbuf + start, buffer, len);<span class="hljs-number">21</span><span class="hljs-number">22</span> &#125;<span class="hljs-number">23</span><span class="hljs-number">24</span> <span class="hljs-comment">/*</span><span class="hljs-comment">25 * @description : 请求处理函数</span><span class="hljs-comment">26 * @param-q : 请求队列</span><span class="hljs-comment">27 * @return : 无</span><span class="hljs-comment">28 */</span><span class="hljs-number">29</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ramdisk_request_fn</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span>30 &#123;<span class="hljs-number">31</span> <span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<span class="hljs-number">32</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">req</span>;</span><span class="hljs-number">33</span><span class="hljs-number">34</span> <span class="hljs-comment">/* 循环处理请求队列中的每个请求 */</span><span class="hljs-number">35</span> req = blk_fetch_request(q);<span class="hljs-number">36</span> <span class="hljs-keyword">while</span>(req != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-number">37</span><span class="hljs-number">38</span> <span class="hljs-comment">/* 针对请求做具体的传输处理 */</span><span class="hljs-number">39</span> ramdisk_transfer(req);<span class="hljs-number">40</span><span class="hljs-number">41</span> <span class="hljs-comment">/* 判断是否为最后一个请求，如果不是的话就获取下一个请求</span><span class="hljs-comment">42 * 循环处理完请求队列中的所有请求。</span><span class="hljs-comment">43 */</span><span class="hljs-number">44</span> <span class="hljs-keyword">if</span> (!__blk_end_request_cur(req, err))<span class="hljs-number">45</span> req = blk_fetch_request(q);<span class="hljs-number">46</span> &#125;<span class="hljs-number">47</span> &#125;</code></pre></div><p>请求处理函数的重要内容就是完成从块设备中读取数据，或者向块设备中写入数据。首先c来看一下 29~47 行的 ramdisk_request_fn 函数，这个就是请求处理函数。此函数只要一个参数q，为 request_queue 结构体指针类型，也就是要处理的请求队列，因此 ramdisk_request_fn 函数的主要工作就是依次处理请求队列中的所有请求。第 35 行，首先使用 blk_fetch_request 函数获取请求队列中第一个请求，如果请求不为空的话就调用 ramdisk_transfer 函数进行对请求做进一步的处理，然后就是 while 循环依次处理完请求队列中的每个请求。第 44 行使用__blk_end_request_cur 函数检查是否为最后一个请求，如果不是的话就继续获取下一个，直至整个请求队列处理完成。</p><p>ramdisk_transfer 函数完成清楚中的数据处理，第 8 行调用 blk_rq_pos 函数从请求中获取要操作的块设备扇区地址，第 9 行使用 blk_rq_cur_bytes 函数获取请求要操作的数据长度，第 15行使用 bio_data 函数获取请求中 bio 保存的数据。第 17 ~20 行调用 rq_data_dir 函数判断当前是读还是写，如果是写的话就将 bio 中的数据拷贝到 ramdisk 指定地址(扇区)，如果是读的话就从ramdisk 中的指定地址(扇区)读取数据放到 bio 中。</p><h3 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2| 运行测试"></a>2| 运行测试</h3><p>编译上一小节的驱动，得到 ramdisk.ko 驱动模块，然后拷贝到 rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15 目录中，重启开发板，进入到目录 lib&#x2F;modules&#x2F;4.1.15 中。输入如下命令加载 ramdisk.ko 这个驱动模块。</p><div class="hljs code-wrapper"><pre><code class="hljs sh">depmod //第一次加载驱动的时候需要运行此命令modprobe ramdisk.ko  //加载驱动模块</code></pre></div><h4 id="1-、查看-ramdisk-磁盘"><a href="#1-、查看-ramdisk-磁盘" class="headerlink" title="1 、查看 ramdisk  磁盘"></a>1 、查看 ramdisk  磁盘</h4><p>驱动加载成功以后就会在&#x2F;dev&#x2F;目录下生成一个名为“ramdisk”的设备， 输入如下命令查看ramdisk 磁盘信息：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">fdisk -l  //查看磁盘信息</code></pre></div><p>上述命令会将当前系统中所有的磁盘信息都打印出来，其中就包括了 ramdisk 设备，如图 所示</p><p><img src="/2020/09/14/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/24%E3%80%81Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200909170421873.png" alt="image-20200909170421873"></p><p>从图可以看出，ramdisk已经识别出来了，大小为2MB，但是同时也提示&#x2F;dev&#x2F;ramdisk没有分区表，因为我们还没有格式化&#x2F;dev&#x2F;ramdisk。</p><h4 id="2-、格式化-x2F-dev-x2F-ramdisk"><a href="#2-、格式化-x2F-dev-x2F-ramdisk" class="headerlink" title="2 、格式化&#x2F;dev&#x2F;ramdisk"></a>2 、格式化&#x2F;dev&#x2F;ramdisk</h4><p>使用 mkfs.vfat 命令格式化&#x2F;dev&#x2F;ramdisk，将其格式化成 vfat 格式，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">mkfs.vfat /dev/ramdisk</code></pre></div><p>格式化完成以后就可以挂载&#x2F;dev&#x2F;ramdisk 来访问了，挂载点可以自定义，这里笔者就将其挂载到&#x2F;tmp 目录下，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">mount /dev/ramdisk /tmp</code></pre></div><p>挂载成功以后就可以通过&#x2F;tmp 来访问 ramdisk 这个磁盘了，进入到&#x2F;tmp 目录中，可以通过 vi 命令新建一个 txt 文件来测试磁盘访问是否正常。</p><h2 id="四、不使用请求队列实验"><a href="#四、不使用请求队列实验" class="headerlink" title="四、不使用请求队列实验"></a>四、不使用请求队列实验</h2><h3 id="1-实验程序编写-1"><a href="#1-实验程序编写-1" class="headerlink" title="1| 实验程序编写"></a>1| 实验程序编写</h3><p>本实验对应的例程路径为：开发板光盘-&gt; 2、Linux 驱动例程-&gt; 25_ramdisk_norequest。</p><p>前面我们学习了如何使用请求队列，请求队列会用到 I&#x2F;O 调度器，适合机械硬盘这种存储设备。对于 EMMC、SD、ramdisk 这样没有机械结构的存储设备，我们可以直接访问任意一个扇区，因此可以不需要 I&#x2F;O 调度器，也就不需要请求队列了，这个我们前面已经说过了。本实验就来学习一下如何使用“制造请求”方法，本实验在上一个实验的基础上修改而来，参考了linux 内核 drivers&#x2F;block&#x2F;zram&#x2F;zram_drv.c。重点来看一下与上一个实验不同的地方，首先是驱动入口函数 ramdisk_init，ramdisk_init 函数大部分和上一个实验相同，只是本实验中改为使用blk_queue_make_request 函数设置“制造请求”函数，修改后的 ramdisk_init 函数内容如下(有省略)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ramdisk_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>2 &#123;......<span class="hljs-number">29</span><span class="hljs-number">30</span> <span class="hljs-comment">/* 5、分配请求队列 */</span><span class="hljs-number">31</span> ramdisk.<span class="hljs-built_in">queue</span> = blk_alloc_queue(GFP_KERNEL);<span class="hljs-number">32</span> <span class="hljs-keyword">if</span>(!ramdisk.<span class="hljs-built_in">queue</span>)&#123;<span class="hljs-number">33</span> ret = -EINVAL;<span class="hljs-number">34</span> <span class="hljs-keyword">goto</span> blk_allo_fail;<span class="hljs-number">35</span> &#125;<span class="hljs-number">36</span><span class="hljs-number">37</span> <span class="hljs-comment">/* 6 、设置“ 制造请求” 函数 */</span><span class="hljs-number">38</span> blk_queue_make_request(ramdisk.<span class="hljs-built_in">queue</span>, ramdisk_make_request_fn);<span class="hljs-number">39</span><span class="hljs-number">40</span> <span class="hljs-comment">/* 7、添加(注册)disk */</span><span class="hljs-number">41</span> ramdisk.gendisk-&gt;major = ramdisk.major; <span class="hljs-comment">/* 主设备号 */</span><span class="hljs-number">42</span> ramdisk.gendisk-&gt;first_minor = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 起始次设备号 */</span><span class="hljs-number">43</span> ramdisk.gendisk-&gt;fops = &amp;ramdisk_fops; <span class="hljs-comment">/*  操作函数 */</span><span class="hljs-number">44</span> ramdisk.gendisk-&gt;private_data = &amp;ramdisk; <span class="hljs-comment">/* 私有数据 */</span><span class="hljs-number">45</span> ramdisk.gendisk-&gt;<span class="hljs-built_in">queue</span> = ramdisk.<span class="hljs-built_in">queue</span>; <span class="hljs-comment">/* 请求队列 */</span><span class="hljs-number">46</span> <span class="hljs-built_in">sprintf</span>(ramdisk.gendisk-&gt;disk_name, RAMDISK_NAME); <span class="hljs-comment">/* 名字 */</span><span class="hljs-number">47</span> set_capacity(ramdisk.gendisk, RAMDISK_SIZE/<span class="hljs-number">512</span>); <span class="hljs-comment">/* 设备容量*/</span><span class="hljs-number">48</span> add_disk(ramdisk.gendisk);<span class="hljs-number">49</span>......<span class="hljs-number">60</span> <span class="hljs-keyword">return</span> ret;<span class="hljs-number">61</span> &#125;</code></pre></div><p>amdisk_init 函数中第 31~38 行就是与上一个实验不同的地方，这里使用 blk_alloc_queue和 blk_queue_make_request 这两个函数取代了上一个实验的 blk_init_queue 函数。</p><p>第 31 行，使用 blk_alloc_queue 函数申请一个请求队列。</p><p>第 38 行，使用 blk_queue_make_request 函数设置“制造请求”函数，这里设置的制造请求函数为 ramdisk_make_request_fn，这个需要驱动编写人员去实现，稍后讲解。</p><p>第 43 行，设置块设备操作集为 ramdisk_fops，和上一个实验一模一样，这里就不讲解了。</p><p>接下来重点看一下“制造请求”函数 ramdisk_make_request_fn，函数内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*</span><span class="hljs-comment">2 * @description : “制造请求”函数</span><span class="hljs-comment">3 * @param-q : 请求队列</span><span class="hljs-comment">4 * @return : 无</span><span class="hljs-comment">5 */</span><span class="hljs-number">6</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ramdisk_make_request_fn</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> bio *bio)</span>7 &#123;<span class="hljs-number">8</span> <span class="hljs-type">int</span> offset;<span class="hljs-number">9</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> <span class="hljs-title">bvec</span>;</span><span class="hljs-number">10</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bvec_iter</span> <span class="hljs-title">iter</span>;</span><span class="hljs-number">11</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len = <span class="hljs-number">0</span>;<span class="hljs-number">12</span><span class="hljs-number">13</span> offset = (bio-&gt;bi_iter.bi_sector) &lt;&lt; <span class="hljs-number">9</span>; <span class="hljs-comment">/* 获取设备的偏移地址 */</span><span class="hljs-number">14</span><span class="hljs-number">15</span> <span class="hljs-comment">/* 处理 bio 中的每个段 */</span><span class="hljs-number">16</span> bio_for_each_segment(bvec, bio, iter)&#123;<span class="hljs-number">17</span> <span class="hljs-type">char</span> *ptr = page_address(bvec.bv_page) + bvec.bv_offset;<span class="hljs-number">18</span> len = bvec.bv_len;<span class="hljs-number">19</span><span class="hljs-number">20</span> <span class="hljs-keyword">if</span>(bio_data_dir(bio) == READ) <span class="hljs-comment">/* 读数据 */</span><span class="hljs-number">21</span> <span class="hljs-built_in">memcpy</span>(ptr, ramdisk.ramdiskbuf + offset, len);<span class="hljs-number">22</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bio_data_dir(bio) == WRITE) <span class="hljs-comment">/* 写数据 */</span><span class="hljs-number">23</span> <span class="hljs-built_in">memcpy</span>(ramdisk.ramdiskbuf + offset, ptr, len);<span class="hljs-number">24</span> offset += len;<span class="hljs-number">25</span> &#125;<span class="hljs-number">26</span> set_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags);<span class="hljs-number">27</span> bio_endio(bio, <span class="hljs-number">0</span>);<span class="hljs-number">28</span> &#125;</code></pre></div><p>虽然 ramdisk_make_request_fn 函数第一个参数依旧是请求队列，但是实际上这个请求队列不包含真正的请求，所有的处理内容都在第二个 bio 参数里面，所以 ramdisk_make_request_fn 函数里面是全部是对 bio 的操作。</p><p>第 13 行，直接读取 bio 的 bi_iter 成员变量的 bi_sector 来获取要操作的设备地址(扇区)。</p><p>第 16~25 行，使用 bio_for_each_segment 函数循环获取 bio 中的每个段，然后对其每个段进行处理。</p><p>第 17 行，根据 bio_vec 中页地址以及偏移地址转换为真正的数据起始地址。</p><p>第 18 行，获取要出来的数据长度，也就是 bio_vec 的 bv_len 成员变量。</p><p>第 20~23 行，和上一个实验一样，要操作的块设备起始地址知道了，数据的存放地址以及长度也知道，接下来就是根据读写操作将数据从块设备中读出来，或者将数据写入到块设备中。</p><p>第 27 行，调用 bio_endio 函数，结束 bio。</p><h3 id="2-运行测试-1"><a href="#2-运行测试-1" class="headerlink" title="2| 运行测试"></a>2| 运行测试</h3><p>测试方法和上一个实验一样，参考前面小节即可。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13| Linux自带的LED灯驱动</title>
    <link href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/13%E3%80%81Linux%E8%87%AA%E5%B8%A6%E7%9A%84LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/13%E3%80%81Linux%E8%87%AA%E5%B8%A6%E7%9A%84LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux自带的LED灯驱动"><a href="#Linux自带的LED灯驱动" class="headerlink" title="Linux自带的LED灯驱动"></a>Linux自带的LED灯驱动</h1><p>前面我们都是自己编写 LED 灯驱动，其实像 LED 灯这样非常基础的设备驱动，Linux 内核已经集成了。Linux 内核的 LED 灯驱动采用 platform 框架，因此我们只需要按照要求在设备树文件中添加相应的 LED 节点即可，本章我们就来学习如何使用 Linux 内核自带的 LED 驱动来驱动 I.MX6U-ALPHA 开发板上的 LED0。</p><h2 id="1-Linux-内核自带-LED-驱动使能"><a href="#1-Linux-内核自带-LED-驱动使能" class="headerlink" title="1| Linux  内核自带 LED  驱动使能"></a>1| Linux  内核自带 LED  驱动使能</h2><p>上一章节我们编写基于设备树的 platform LED 灯驱动，其实 Linux 内核已经自带了 LED 灯驱动，要使用 Linux 内核自带的 LED 灯驱动首先得先配置 Linux 内核，使能自带的 LED 灯驱动，输入如下命令打开 Linux 配置菜单：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span></code></pre></div><p>按照如下路径打开 LED 驱动配置项：</p><div class="hljs code-wrapper"><pre><code class="hljs livescript">-&gt; Device Drivers-&gt; LED Support <span class="hljs-function"><span class="hljs-params">(NEW_LEDS [=y])</span></span><span class="hljs-function">-&gt;</span>LED Support <span class="hljs-keyword">for</span> GPIO connected LEDs</code></pre></div><p>按照上述路径，选择“LED Support for GPIO connected LEDs”，将其编译进 Linux 内核，也即是在此选项上按下“Y”键，使此选项前面变为“&lt;*&gt;”，如图  所示</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/13%E3%80%81Linux%E8%87%AA%E5%B8%A6%E7%9A%84LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828193602935.png" alt="image-20200828193602935"></p><p>在“LED Support for GPIO connected LEDs”上按下可以打开此选项的帮助信息，如图 所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/13%E3%80%81Linux%E8%87%AA%E5%B8%A6%E7%9A%84LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828193709178.png" alt="image-20200828193709178"></p><p>从图可以看出， 把 Linux 内部自带的 LED 灯 驱动编 译进内 核以后 ，<strong>CONFIG_LEDS_GPIO</strong> 就会等于‘y’，Linux 会根据 CONFIG_LEDS_GPIO 的值来选择如何编译LED 灯驱动，如果为‘y’就将其编译进 Linux 内核。</p><p>重新编译 Linux 内核，然后使用新编译出来的 zImage 镜像启动开发板。</p><h2 id="2-Linux-内核自带-LED-驱动简介"><a href="#2-Linux-内核自带-LED-驱动简介" class="headerlink" title="2|  Linux  内核自带 LED  驱动简介"></a>2|  Linux  内核自带 LED  驱动简介</h2><h3 id="1、LED-灯驱动框架分析"><a href="#1、LED-灯驱动框架分析" class="headerlink" title="1、LED 灯驱动框架分析"></a>1、LED 灯驱动框架分析</h3><p>LED 灯驱动文件为&#x2F;drivers&#x2F;leds&#x2F;leds-gpio.c，大家可以打开&#x2F;drivers&#x2F;leds&#x2F;Makefile 这个文件，找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">2 <span class="hljs-comment"># LED Core</span>3 obj-<span class="hljs-variable">$(CONFIG_NEW_LEDS)</span> += led-core.o.....23 obj-<span class="hljs-variable">$(CONFIG_LEDS_GPIO_REGISTER)</span> += leds-gpio-register.o24 obj-<span class="hljs-variable">$(CONFIG_LEDS_GPIO)</span> += leds-gpio.o25 obj-<span class="hljs-variable">$(CONFIG_LEDS_LP3944)</span> += leds-lp3944.o......</code></pre></div><p>第 24 行，如果定义了 <strong>CONFIG_LEDS_GPIO</strong> 的话就会编译 leds-gpio.c 这个文件，在上一小节我们选择将 LED 驱动编译进 Linux 内核，在.config 文件中就会有“CONFIG_LEDS_GPIO&#x3D;y”这一行，因此 leds-gpio.c 驱动文件就会被编译。</p><p>接下来我们看一下 leds-gpio.c 这个驱动文件，找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">236</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">of_gpio_leds_match</span>[] =</span> &#123;<span class="hljs-number">237</span> &#123; .compatible = <span class="hljs-string">&quot;gpio-leds&quot;</span>, &#125;,<span class="hljs-number">238</span> &#123;&#125;,<span class="hljs-number">239</span> &#125;;......<span class="hljs-number">290</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">gpio_led_driver</span> =</span> &#123;<span class="hljs-number">291</span> .probe = gpio_led_probe,<span class="hljs-number">292</span> .remove = gpio_led_remove,<span class="hljs-number">293</span> .driver = &#123;<span class="hljs-number">294</span> .name = <span class="hljs-string">&quot;leds-gpio&quot;</span>,<span class="hljs-number">295</span> .of_match_table = of_gpio_leds_match,<span class="hljs-number">296</span> &#125;,<span class="hljs-number">297</span> &#125;;<span class="hljs-number">298</span><span class="hljs-number">299</span> module_platform_driver(gpio_led_driver);</code></pre></div><p>第 236~239 行，LED 驱动的匹配表，此表只有一个匹配项，compatible 内容为“gpio-leds”，因此设备树中的 LED 灯设备节点的 compatible 属性值也要为“gpio-leds”，否则设备和驱动匹配不成功，驱动就没法工作。</p><p>第 290~296 行，platform_driver 驱动结构体变量，可以看出，Linux 内核自带的 LED 驱动采用了 platform 框架。第 291 行可以看出 probe 函数为 gpio_led_probe，因此当驱动和设备匹配成功以后 gpio_led_probe 函数就会执行。从 294 行可以看出，驱动名字为“leds-gpio”，因此会在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers 目录下存在一个名为“leds-gpio”的文件，如图 所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/13%E3%80%81Linux%E8%87%AA%E5%B8%A6%E7%9A%84LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828201703810.png" alt="image-20200828201703810"></p><p>第 299 行通过 module_platform_driver 函数向 Linux 内核注册 gpio_led_driver 这个platform<br>驱动。</p><h3 id="2、module-platform-driver-函数简析"><a href="#2、module-platform-driver-函数简析" class="headerlink" title="2、module_platform_driver 函数简析"></a>2、module_platform_driver 函数简析</h3><p>在上一小节中我们知道 LED 驱动会采用 module_platform_driver 函数向 Linux 内核注册platform 驱动，其实在 Linux 内核中会大量采用 module_platform_driver 来完成向 Linux 内核注册 platform 驱动的操作。module_platform_driver 定义在include&#x2F;linux&#x2F;platform_device.h 文件中，为一个宏，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">221</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> module_platform_driver(__platform_driver) \</span><span class="hljs-meta">222 module_driver(__platform_driver, platform_driver_register, \</span><span class="hljs-meta">223 platform_driver_unregister)</span></code></pre></div><p>可以看出，module_platform_driver 依赖 module_driver，module_driver 也是一个宏，定义在include&#x2F;linux&#x2F;device.h 文件中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1260</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span><span class="hljs-meta">1261 static int __init __driver##_init(void) \</span><span class="hljs-meta">1262 &#123; \</span><span class="hljs-meta">1263 return __register(&amp;(__driver) , ##__VA_ARGS__); \</span><span class="hljs-meta">1264 &#125; \</span><span class="hljs-meta">1265 module_init(__driver##_init); \</span><span class="hljs-meta">1266 static void __exit __driver##_exit(void) \</span><span class="hljs-meta">1267 &#123; \</span><span class="hljs-meta">1268 __unregister(&amp;(__driver) , ##__VA_ARGS__); \</span><span class="hljs-meta">1269 &#125; \</span><span class="hljs-meta">1270 module_exit(__driver##_exit);</span></code></pre></div><p>借助示例代码将：</p><div class="hljs code-wrapper"><pre><code class="hljs c">module_platform_driver(gpio_led_driver)</code></pre></div><p>展开以后就是：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpio_led_driver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-keyword">return</span> platform_driver_register (&amp;(gpio_led_driver));&#125;module_init(gpio_led_driver_init);<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpio_led_driver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;platform_driver_unregister (&amp;(gpio_led_driver) );&#125;module_exit(gpio_led_driver_exit);</code></pre></div><p>上面的代码不就是标准的注册和删除platform驱动吗？因此module_platform_driver函数的功能就是完成 platform 驱动的注册和删除。</p><h3 id="3、gpio-led-probe-函数简析"><a href="#3、gpio-led-probe-函数简析" class="headerlink" title="3、gpio_led_probe  函数简析"></a>3、gpio_led_probe  函数简析</h3><p>当驱动和设备匹配以后 gpio_led_probe 函数就会执行，此函数主要是从设备树中获取 LED灯的 GPIO 信息，缩减后的函数内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">243</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span>244 &#123;<span class="hljs-number">245</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_led_platform_data</span> *<span class="hljs-title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);<span class="hljs-number">246</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_leds_priv</span> *<span class="hljs-title">priv</span>;</span><span class="hljs-number">247</span> <span class="hljs-type">int</span> i, ret = <span class="hljs-number">0</span>;<span class="hljs-number">248</span><span class="hljs-number">249</span> <span class="hljs-keyword">if</span> (pdata &amp;&amp; pdata-&gt;num_leds) &#123; <span class="hljs-comment">/* 非设备树方式 */</span><span class="hljs-comment">/* 获取 platform_device 信息 */</span>......<span class="hljs-number">268</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 采用设备树 */</span><span class="hljs-number">269</span> priv = gpio_leds_create(pdev);<span class="hljs-number">270</span> <span class="hljs-keyword">if</span> (IS_ERR(priv))<span class="hljs-number">271</span> <span class="hljs-keyword">return</span> PTR_ERR(priv);<span class="hljs-number">272</span> &#125;<span class="hljs-number">273</span><span class="hljs-number">274</span> platform_set_drvdata(pdev, priv);<span class="hljs-number">275</span><span class="hljs-number">276</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">277</span> &#125;</code></pre></div><p>第 269~271 行，如果使用设备树的话，使用 gpio_leds_create 函数从设备树中提取设备信息，获取到的 LED 灯 GPIO 信息保存在返回值中，gpio_leds_create 函数内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">167</span> <span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> gpio_leds_priv *<span class="hljs-title function_">gpio_leds_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span>168 &#123;<span class="hljs-number">169</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;pdev-&gt;dev;<span class="hljs-number">170</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fwnode_handle</span> *<span class="hljs-title">child</span>;</span><span class="hljs-number">171</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_leds_priv</span> *<span class="hljs-title">priv</span>;</span><span class="hljs-number">172</span> <span class="hljs-type">int</span> count, ret;<span class="hljs-number">173</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span><span class="hljs-number">174</span><span class="hljs-number">175</span> count = device_get_child_node_count(dev);<span class="hljs-number">176</span> <span class="hljs-keyword">if</span> (!count)<span class="hljs-number">177</span> <span class="hljs-keyword">return</span> ERR_PTR(-ENODEV);<span class="hljs-number">178</span><span class="hljs-number">179</span> priv = devm_kzalloc(dev, sizeof_gpio_leds_priv(count), GFP_KERNEL);<span class="hljs-number">180</span> <span class="hljs-keyword">if</span> (!priv)<span class="hljs-number">181</span> <span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<span class="hljs-number">182</span><span class="hljs-number">183</span> device_for_each_child_node(dev, child) &#123;<span class="hljs-number">184</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_led</span> <span class="hljs-title">led</span> =</span> &#123;&#125;;<span class="hljs-number">185</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *state = <span class="hljs-literal">NULL</span>;<span class="hljs-number">186</span><span class="hljs-number">187</span> led.gpiod = devm_get_gpiod_from_child(dev, <span class="hljs-literal">NULL</span>, child);<span class="hljs-number">188</span> <span class="hljs-keyword">if</span> (IS_ERR(led.gpiod)) &#123;<span class="hljs-number">189</span> fwnode_handle_put(child);<span class="hljs-number">190</span> ret = PTR_ERR(led.gpiod);<span class="hljs-number">191</span> <span class="hljs-keyword">goto</span> err;<span class="hljs-number">192</span> &#125;<span class="hljs-number">193</span><span class="hljs-number">194</span> np = of_node(child);<span class="hljs-number">195</span><span class="hljs-number">196</span> <span class="hljs-keyword">if</span> (fwnode_property_present(child, <span class="hljs-string">&quot;label&quot;</span>)) &#123;<span class="hljs-number">197</span> fwnode_property_read_string(child, <span class="hljs-string">&quot;label&quot;</span>, &amp;led.name);<span class="hljs-number">198</span> &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-number">199</span> <span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_OF) &amp;&amp; !led.name &amp;&amp; np)<span class="hljs-number">200</span> led.name = np-&gt;name;<span class="hljs-number">201</span> <span class="hljs-keyword">if</span> (!led.name)<span class="hljs-number">202</span> <span class="hljs-keyword">return</span> ERR_PTR(-EINVAL);<span class="hljs-number">203</span> &#125;<span class="hljs-number">204</span> fwnode_property_read_string(child, <span class="hljs-string">&quot;linux,default-trigger&quot;</span>,<span class="hljs-number">205</span> &amp;led.default_trigger);<span class="hljs-number">206</span><span class="hljs-number">207</span> <span class="hljs-keyword">if</span> (!fwnode_property_read_string(child, <span class="hljs-string">&quot;default-state&quot;</span>,<span class="hljs-number">208</span> &amp;state)) &#123;<span class="hljs-number">209</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(state, <span class="hljs-string">&quot;keep&quot;</span>))<span class="hljs-number">210</span> led.default_state = LEDS_GPIO_DEFSTATE_KEEP;<span class="hljs-number">211</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(state, <span class="hljs-string">&quot;on&quot;</span>))<span class="hljs-number">212</span> led.default_state = LEDS_GPIO_DEFSTATE_ON;<span class="hljs-number">213</span> <span class="hljs-keyword">else</span><span class="hljs-number">214</span> led.default_state = LEDS_GPIO_DEFSTATE_OFF;<span class="hljs-number">215</span> &#125;<span class="hljs-number">216</span><span class="hljs-number">217</span> <span class="hljs-keyword">if</span> (fwnode_property_present(child, <span class="hljs-string">&quot;retain-state-suspended&quot;</span>))<span class="hljs-number">218</span> led.retain_state_suspended = <span class="hljs-number">1</span>;<span class="hljs-number">219</span><span class="hljs-number">220</span> ret = create_gpio_led(&amp;led, &amp;priv-&gt;leds[priv-&gt;num_leds++],<span class="hljs-number">221</span> dev, <span class="hljs-literal">NULL</span>);<span class="hljs-number">222</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-number">223</span> fwnode_handle_put(child);<span class="hljs-number">224</span> <span class="hljs-keyword">goto</span> err;<span class="hljs-number">225</span> &#125;<span class="hljs-number">226</span> &#125;<span class="hljs-number">227</span><span class="hljs-number">228</span> <span class="hljs-keyword">return</span> priv;<span class="hljs-number">229</span><span class="hljs-number">230</span> err:<span class="hljs-number">231</span> <span class="hljs-keyword">for</span> (count = priv-&gt;num_leds - <span class="hljs-number">2</span>; count &gt;= <span class="hljs-number">0</span>; count--)<span class="hljs-number">232</span> delete_gpio_led(&amp;priv-&gt;leds[count]);<span class="hljs-number">233</span> <span class="hljs-keyword">return</span> ERR_PTR(ret);<span class="hljs-number">234</span> &#125;</code></pre></div><ul><li>第 175 行，调用 device_get_child_node_count 函数统计子节点数量，一般在在设备树中创建一个节点表示 LED 灯，然后在这个节点下面为每个 LED 灯创建一个子节点。因此子节点数量也是 LED 灯的数量。</li><li>第 183 行，遍历每个子节点，获取每个子节点的信息。</li><li>第 187 行，获取 LED 灯所使用的 GPIO 信息。</li><li>第 196~197 行，读取子节点 label 属性值，因为使用 label 属性作为 LED 的名字。</li><li>第 204~205 行，获取“linux,default-trigger”属性值，可以通过此属性设置某个 LED 灯在Linux 系统中的默认功能，比如作为系统心跳指示灯等等。</li><li>第 207~215 行，获取“default-state”属性值，也就是 LED 灯的默认状态属性。</li><li>第 220 行，调用 create_gpio_led 函数创建 LED 相关的 io，其实就是设置 LED 所使用的 io为输出之类的。create_gpio_led 函数主要是初始化 led_dat 这个 gpio_led_data 结构体类型变量，led_dat 保存了 LED 的操作函数等内容。</li></ul><p>关于 gpio_led_probe 函数就分析到这里，gpio_led_probe 函数主要功能就是获取 LED 灯的<br>设备信息，然后根据这些信息来初始化对应的 IO，设置为输出等。</p><h2 id="3-设备树节点编写"><a href="#3-设备树节点编写" class="headerlink" title="3| 设备树节点编写"></a>3| 设备树节点编写</h2><p>打开文档 Documentation&#x2F;devicetree&#x2F;bindings&#x2F;leds&#x2F;leds-gpio.txt，此文档详细的讲解了Linux 自带驱动对应的设备树节点该如何编写，我们在编写设备节点的时候要注意以下几点：</p><ul><li>①、创建一个节点表示 LED 灯设备，比如 dtsleds，如果板子上有多个 LED 灯的话每个 LED灯都作为 dtsleds 的子节点。</li><li>②、dtsleds 节点的 compatible 属性值一定要为“gpio-leds”。</li><li>③、设置 label 属性，此属性为可选，每个子节点都有一个 label 属性，label 属性一般表示LED 灯的名字，比如以颜色区分的话就是 red、green 等等。</li><li>④、每个子节点必须要设置 gpios 属性值，表示此 LED 所使用的 GPIO 引脚！</li><li>⑤、可以设置“linux,default-trigger”属性值，也就是设置 LED 灯的默认功能，可以查阅Documentation&#x2F;devicetree&#x2F;bindings&#x2F;leds&#x2F;common.txt 这个文档来查看可选功能，比如：backlight ：LED 灯作为背光。<ul><li>default-on：LED 灯打开</li><li>heartbeat ：LED 灯作为心跳指示灯，可以作为系统运行提示灯。</li><li>ide-disk ：LED 灯作为硬盘活动指示灯。</li><li>timer ：LED 灯周期性闪烁，由定时器驱动，闪烁频率可以修改</li></ul></li><li>⑥、可以设置“default-state”属性值，可以设置为 on、off 或 keep，为 on 的时候 LED 灯默认打开，为 off 的话 LED 灯默认关闭，为 keep 的话 LED 灯保持当前模式。</li></ul><p>根据上述几条要求在 imx6ull-lxg-emmc.dts 中添加如下所示 LED 灯设备节点：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> dtsleds &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;gpio-leds&quot;</span>;<span class="hljs-number">3</span><span class="hljs-number">4</span> led0 &#123;<span class="hljs-number">5</span> label = <span class="hljs-string">&quot;red&quot;</span>;<span class="hljs-number">6</span> gpios = &lt;&amp;gpio1 <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">7</span> <span class="hljs-keyword">default</span>-state = <span class="hljs-string">&quot;off&quot;</span>;<span class="hljs-number">8</span> &#125;;<span class="hljs-number">9</span> &#125;;</code></pre></div><p>因为 I.MX6U-ALPHA 开发板只有一个 LED0，因此在 dtsleds 这个节点下只有一个子节点led0，LED0 名字为 red，默认关闭。修改完成以后保存并重新编译设备树，然后用新的设备树启动开发板。</p><h2 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4| 运行测试"></a>4| 运行测试</h2><p>用 新 的 zImage 和 imx6ull-lxg-emmc.dtb 启 动 开 发 板 ， 启 动 以 后 查 看&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices&#x2F;dtsleds 这个目录是否存在，如果存在的话就如到此目录中，如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/13%E3%80%81Linux%E8%87%AA%E5%B8%A6%E7%9A%84LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828203725010.png" alt="image-20200828203725010"></p><p>进入到 leds 目录中，此目录中的内容如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/13%E3%80%81Linux%E8%87%AA%E5%B8%A6%E7%9A%84LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828203747024.png" alt="image-20200828203747024"></p><p>从图 可以看出，在 leds 目录下有一个名为“red”子目录，这个子目录的名字就是我们在设备树中第 5 行设置的 label 属性值。</p><p>我们的设置究竟有没有用，最终是要通过测试才能知道的，首先查看一下系统中有没有“sys&#x2F;class&#x2F;leds&#x2F;red&#x2F;brightness”这个文件，如果有的话就输入如下命令打开 RED 这个 LED 灯：</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/leds/</span>red<span class="hljs-regexp">/brightness /</span><span class="hljs-regexp">/打开 LED0</span></code></pre></div><p>关闭 RED 这个 LED 灯的命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">echo <span class="hljs-number">0</span> &gt; <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/leds/</span>red<span class="hljs-regexp">/brightness /</span><span class="hljs-regexp">/关闭 LED0</span></code></pre></div><p>如果能正常的打开和关闭 LED 灯话就说明我们 Linux 内核自带的 LED 灯驱动工作正常。我们一般会使用一个 LED 灯作为系统指示灯，系统运行正常的话这个 LED 指示灯就会一闪一闪的。里我们设置 LED0 作为系统指示灯，在 dtsleds 这个设备节点中加入“linux,default-trigger”属性信息即可，属性值为“heartbeat”，修改完以后的 dtsleds 节点内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> dtsleds &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;gpio-leds&quot;</span>;<span class="hljs-number">3</span><span class="hljs-number">4</span> led0 &#123;<span class="hljs-number">5</span> label = <span class="hljs-string">&quot;red&quot;</span>;<span class="hljs-number">6</span> gpios = &lt;&amp;gpio1 <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">7</span> linux,<span class="hljs-keyword">default</span>-trigger = <span class="hljs-string">&quot;heartbeat&quot;</span>;<span class="hljs-number">8</span> <span class="hljs-keyword">default</span>-state = <span class="hljs-string">&quot;on&quot;</span>;<span class="hljs-number">9</span> &#125;;<span class="hljs-number">10</span> &#125;;</code></pre></div><p>第 7 行，设置 LED0 为 heartbeat。<br>第 8 行，默认打开 LED0。</p><p>重新编译设备树并且使用新的设备树启动 Linux 系统，启动以后 LED0 就会闪烁，作为系统心跳指示灯，表示系统正在运行。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14| Linux MISC驱动实验</title>
    <link href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/14%E3%80%81Linux_MISC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/14%E3%80%81Linux_MISC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-MISC驱动实验"><a href="#Linux-MISC驱动实验" class="headerlink" title="Linux MISC驱动实验"></a>Linux MISC驱动实验</h1><p><strong>misc 的意思是混合、杂项的，因此 MISC 驱动也叫做杂项驱动</strong>，也就是当我们板子上的某些外设无法进行分类的时候就可以使用 MISC 驱动。</p><p>MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动，本章我们就来学习一下 MISC 驱动的编写。</p><h2 id="一、MISC-设备驱动简介"><a href="#一、MISC-设备驱动简介" class="headerlink" title="一、MISC 设备驱动简介"></a>一、MISC 设备驱动简介</h2><p>所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。随着 Linux字符设备驱动的不断增加，设备号变得越来越紧张，尤其是主设备号，MISC 设备驱动就用于解决此问题。<strong>MISC 设备会自动创建 cdev，不需要像我们以前那样手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写。</strong></p><p>我们需要向 Linux 注册一个 miscdevice 设备，miscdevice是一个结构体，定义在文件include&#x2F;linux&#x2F;miscdevice.h 中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">57</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscdevice</span> &#123;</span><span class="hljs-number">58</span> <span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 子设备号 */</span><span class="hljs-number">59</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">/* 设备名字 */</span><span class="hljs-number">60</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">fops</span>;</span> <span class="hljs-comment">/* 设备操作集 */</span><span class="hljs-number">61</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><span class="hljs-number">62</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">parent</span>;</span><span class="hljs-number">63</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">this_device</span>;</span><span class="hljs-number">64</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span><span class="hljs-number">65</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *nodename;<span class="hljs-number">66</span> <span class="hljs-type">umode_t</span> mode;<span class="hljs-number">67</span> &#125;;</code></pre></div><p>定义一个 MISC 设备(miscdevice 类型)以后我们需要设置 minor、name 和 fops 这三个成员变量。</p><p><strong>minor 表示子设备号</strong>，MISC 设备的主设备号为 10，这个是固定的，需要用户指定子设备号，Linux 系统已经预定义了一些 MISC 设备的子设备号，这些预定义的子设备号定义在include&#x2F;linux&#x2F;miscdevice.h 文件中，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PSMOUSE_MINOR 1</span><span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BUSMOUSE_MINOR 2 <span class="hljs-comment">/* unused */</span></span><span class="hljs-number">15</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ATIXL_BUSMOUSE_MINOR 3 <span class="hljs-comment">/* unused */</span></span><span class="hljs-number">16</span> <span class="hljs-comment">/*#define AMIGAMOUSE_MINOR 4 FIXME OBSOLETE */</span><span class="hljs-number">17</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ATARIMOUSE_MINOR 5 <span class="hljs-comment">/* unused */</span></span><span class="hljs-number">18</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SUN_MOUSE_MINOR 6 <span class="hljs-comment">/* unused */</span></span>......<span class="hljs-number">52</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MISC_DYNAMIC_MINOR 255</span></code></pre></div><p>我们在使用的时候可以从这些预定义的子设备号中挑选一个，当然也可以自己定义，只要这个子设备号没有被其他设备使用接口。</p><p><strong>name 就是此 MISC 设备名字</strong>，当此设备注册成功以后就会在&#x2F;dev 目录下生成一个名为name的设备文件。</p><p><strong>fops 就是字符设备的操作集合</strong>，MISC 设备驱动最终是需要使用用户提供的 fops操作集合。</p><hr><p>当设置好 miscdevice 以后就需要使用 misc_register 函数向系统中注册一个 MISC 设备，此函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">misc_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> miscdevice * misc)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>misc</strong>：要注册的 MISC 设备。<br><strong>返回值</strong>：负数，失败；0，成功。</p><p>以前我们需要自己调用一堆的函数去创建设备，比如在以前的字符设备驱动中我们会使用如下几个函数完成设备创建过程：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> alloc_chrdev_region(); <span class="hljs-comment">/* 申请设备号 */</span><span class="hljs-number">2</span> cdev_init(); <span class="hljs-comment">/* 初始化 cdev */</span><span class="hljs-number">3</span> cdev_add(); <span class="hljs-comment">/* 添加 cdev */</span><span class="hljs-number">4</span> class_create(); <span class="hljs-comment">/* 创建类 */</span><span class="hljs-number">5</span> device_create(); <span class="hljs-comment">/* 创建设备 */</span></code></pre></div><p>现在我们可以直接使用 misc_register 一个函数来完成示例代码中的这些步骤。</p><hr><p>当我们卸载设备驱动模块的时候需要调用misc_deregister函数来注销掉MISC设备，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">misc_deregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> miscdevice *misc)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>misc</strong>：要注销的 MISC 设备。<br><strong>返回值</strong>：负数，失败；0，成功。</p><p>以前注销设备驱动的时候，我们需要调用一堆的函数去删除此前创建的 cdev、设备等等内<br>容，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> cdev_del(); <span class="hljs-comment">/* 删除 cdev */</span><span class="hljs-number">2</span> unregister_chrdev_region(); <span class="hljs-comment">/* 注销设备号 */</span><span class="hljs-number">3</span> device_destroy(); <span class="hljs-comment">/* 删除设备 */</span><span class="hljs-number">4</span> class_destroy(); <span class="hljs-comment">/* 删除类 */</span></code></pre></div><p>现在我们只需要一个 misc_deregister 函数即可完成示例代码 57.1.4 中的这些工作。关于MISC 设备驱动就讲解到这里，接下来我们就使用 platform 加 MISC 驱动框架来编写 beep 蜂鸣器驱动。</p><h2 id="二、硬件原理分析"><a href="#二、硬件原理分析" class="headerlink" title="二、硬件原理分析"></a>二、硬件原理分析</h2><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/14%E3%80%81Linux_MISC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829105616026.png" alt="image-20200829105616026"></p><p>通过一个 PNP 型的三极管 8550 来驱动蜂鸣器，通过 SNVS_TAMPER1 这个 IO来控制三极管 Q1 的导通，当 SNVS_TAMPER1 输出低电平的时候 Q1 导通，相当于蜂鸣器的正极连接到 DCDC_3V3，蜂鸣器形成一个通路，因此蜂鸣器会鸣叫。</p><h2 id="三、实验程序编写"><a href="#三、实验程序编写" class="headerlink" title="三、实验程序编写"></a>三、实验程序编写</h2><h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1| 修改设备树"></a>1| 修改设备树</h3><p>本章实验我们需要用到蜂鸣器，因此需要在 imx6ull-lxg-emmc.dts 文件中创建蜂鸣器设<br>备节点.</p><h3 id="2-beep-驱动程序编写"><a href="#2-beep-驱动程序编写" class="headerlink" title="2| beep 驱动程序编写"></a>2| beep 驱动程序编写</h3><p>新建名为“19_miscbeep”的文件夹，然后在 19_miscbeep 文件夹里面创建 vscode 工程，工作区命名为“miscbeep。新建名为 miscbeep.c 的驱动文件，在 miscbeep.c 中输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/miscdevice.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MISCBEEP_NAME<span class="hljs-string">&quot;miscbeep&quot;</span><span class="hljs-comment">/* 名字 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MISCBEEP_MINOR144<span class="hljs-comment">/* 子设备号 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEEPOFF 0<span class="hljs-comment">/* 关蜂鸣器 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEEPON 1<span class="hljs-comment">/* 开蜂鸣器 */</span></span><span class="hljs-comment">/* miscbeep设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscbeep_dev</span>&#123;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-comment">/* 设备号  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-comment">/* cdev */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-comment">/* 类 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-comment">/* 设备  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>*<span class="hljs-title">nd</span>;</span> <span class="hljs-comment">/* 设备节点 */</span><span class="hljs-type">int</span> beep_gpio;<span class="hljs-comment">/* beep所使用的GPIO编号*/</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscbeep_dev</span> <span class="hljs-title">miscbeep</span>;</span><span class="hljs-comment">/* beep设备 */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 打开设备</span><span class="hljs-comment"> * @param - inode : 传递给驱动的inode</span><span class="hljs-comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><span class="hljs-comment"> *   一般在open的时候将private_data指向设备结构体。</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">miscbeep_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;miscbeep; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向设备写数据 </span><span class="hljs-comment"> * @param - filp : 设备文件，表示打开的文件描述符</span><span class="hljs-comment"> * @param - buf : 要写给设备写入的数据</span><span class="hljs-comment"> * @param - cnt : 要写入的数据长度</span><span class="hljs-comment"> * @param - offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">miscbeep_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> retvalue;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">1</span>];<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> beepstat;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscbeep_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;retvalue = copy_from_user(databuf, buf, cnt);<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;printk(<span class="hljs-string">&quot;kernel write failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EFAULT;&#125;beepstat = databuf[<span class="hljs-number">0</span>];<span class="hljs-comment">/* 获取状态值 */</span><span class="hljs-keyword">if</span>(beepstat == BEEPON) &#123;gpio_set_value(dev-&gt;beep_gpio, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 打开蜂鸣器 */</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(beepstat == BEEPOFF) &#123;gpio_set_value(dev-&gt;beep_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 关闭蜂鸣器 */</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作函数 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">miscbeep_fops</span> =</span> &#123;.owner = THIS_MODULE,.open = miscbeep_open,.write = miscbeep_write,&#125;;<span class="hljs-comment">/* MISC设备结构体 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscdevice</span> <span class="hljs-title">beep_miscdev</span> =</span> &#123;.minor = MISCBEEP_MINOR,.name = MISCBEEP_NAME,.fops = &amp;miscbeep_fops,&#125;; <span class="hljs-comment">/*</span><span class="hljs-comment">  * @description     : platform驱动的probe函数，当驱动与</span><span class="hljs-comment">  *                    设备匹配以后此函数就会执行</span><span class="hljs-comment">  * @param - dev     : platform设备</span><span class="hljs-comment">  * @return          : 0，成功;其他负值,失败</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">miscbeep_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;printk(<span class="hljs-string">&quot;k:beep driver and device was matched!\r\n&quot;</span>);<span class="hljs-comment">/* 设置BEEP所使用的GPIO */</span><span class="hljs-comment">/* 1、获取设备节点：beep */</span>miscbeep.nd = of_find_node_by_path(<span class="hljs-string">&quot;/beep&quot;</span>);<span class="hljs-keyword">if</span>(miscbeep.nd == <span class="hljs-literal">NULL</span>) &#123;printk(<span class="hljs-string">&quot;k:beep node not find!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125; <span class="hljs-comment">/* 2、 获取设备树中的gpio属性，得到BEEP所使用的BEEP编号 */</span>miscbeep.beep_gpio = of_get_named_gpio(miscbeep.nd, <span class="hljs-string">&quot;beep-gpios&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(miscbeep.beep_gpio &lt; <span class="hljs-number">0</span>) &#123;printk(<span class="hljs-string">&quot;k:can&#x27;t get beep-gpio&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-comment">/* 3、设置GPIO5_IO01为输出，并且输出高电平，默认关闭BEEP */</span>ret = gpio_direction_output(miscbeep.beep_gpio, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;printk(<span class="hljs-string">&quot;k:can&#x27;t set gpio!\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 一般情况下会注册对应的字符设备，但是这里我们使用MISC设备</span><span class="hljs-comment">   * 所以我们不需要自己注册字符设备驱动，只需要注册misc设备驱动即可</span><span class="hljs-comment"> */</span>ret = misc_register(&amp;beep_miscdev);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:misc device register failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EFAULT;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description     : platform驱动的remove函数，移除platform驱动的时候此函数会执行</span><span class="hljs-comment"> * @param - dev     : platform设备</span><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">miscbeep_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>&#123;<span class="hljs-comment">/* 注销设备的时候关闭LED灯 */</span>gpio_set_value(miscbeep.beep_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 注销misc设备 */</span>misc_deregister(&amp;beep_miscdev);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 匹配列表 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">beep_of_match</span>[] =</span> &#123;&#123; .compatible = <span class="hljs-string">&quot;lxg,beep&quot;</span> &#125;,&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;&#125;; <span class="hljs-comment">/* platform驱动结构体 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">beep_driver</span> =</span> &#123;     .driver     = &#123;         .name   = <span class="hljs-string">&quot;imx6ul-beep&quot;</span>,         <span class="hljs-comment">/* 驱动名字，用于和设备匹配 */</span>         .of_match_table = beep_of_match, <span class="hljs-comment">/* 设备树匹配表          */</span>     &#125;,     .probe      = miscbeep_probe,     .remove     = miscbeep_remove,&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动出口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">miscbeep_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-keyword">return</span> platform_driver_register(&amp;beep_driver);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动出口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">miscbeep_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;platform_driver_unregister(&amp;beep_driver);&#125;module_init(miscbeep_init);module_exit(miscbeep_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><h3 id="3-编写测试APP"><a href="#3-编写测试APP" class="headerlink" title="3| 编写测试APP"></a>3| 编写测试APP</h3><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEEPOFF 0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEEPON 1</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: main主程序</span><span class="hljs-comment"> * @param - argc : argv数组元素个数</span><span class="hljs-comment"> * @param - argv : 具体参数</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<span class="hljs-type">int</span> fd, retvalue;<span class="hljs-type">char</span> *filename;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;filename = argv[<span class="hljs-number">1</span>];<span class="hljs-comment">/* 打开led驱动 */</span>fd = open(filename, O_RDWR);<span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s open failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;databuf[<span class="hljs-number">0</span>] = atoi(argv[<span class="hljs-number">2</span>]);<span class="hljs-comment">/* 要执行的操作：打开或关闭 */</span>retvalue = write(fd, databuf, <span class="hljs-keyword">sizeof</span>(databuf));<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;BEEP Control Failed!\r\n&quot;</span>);close(fd);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;retvalue = close(fd); <span class="hljs-comment">/* 关闭文件 */</span><span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s close failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="四、运行测试"><a href="#四、运行测试" class="headerlink" title="四、运行测试"></a>四、运行测试</h2><p>编译运行。</p><p>当驱动模块加载成功以后我们可以在&#x2F;sys&#x2F;class&#x2F;misc 这个目录下看到一个名为“miscbeep”的子目录，如图  所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/14%E3%80%81Linux_MISC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829113754481.png" alt="image-20200829113754481"></p><p>所有的 misc 设备都属于同一个类，&#x2F;sys&#x2F;class&#x2F;misc 目录下就是 misc 这个类的所有设备，每个设备对应一个子目录。</p><p>驱动与设备匹配成功以后就会生成&#x2F;dev&#x2F;miscbeep 这个设备驱动文件，<strong>输入如下命令查看这个文件的主次设备号：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span> /dev/miscbeep -l</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/14%E3%80%81Linux_MISC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829113851138.png" alt="image-20200829113851138"></p><p>从图 可以看出，&#x2F;dev&#x2F;miscbeep 这个设备的主设备号为 10，次设备号为 144，和我们驱动程序里面设置的一致。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15| Linux INPUT子系统实验</title>
    <link href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-INPUT子系统实验"><a href="#Linux-INPUT子系统实验" class="headerlink" title="Linux INPUT子系统实验"></a>Linux INPUT子系统实验</h1><p>按键、鼠标、键盘、触摸屏等都属于输入(input)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。</p><p>输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息，input 核心层负责处理这些事件。本章我们就来学习一下 Linux 内核中的 input 子系统。</p><h2 id="一、INPUT子系统"><a href="#一、INPUT子系统" class="headerlink" title="一、INPUT子系统"></a>一、INPUT子系统</h2><h3 id="1-input-子系统简介"><a href="#1-input-子系统简介" class="headerlink" title="1| input  子系统简介"></a>1| input  子系统简介</h3><p>input 就是输入的意思，因此 input 子系统就是管理输入的子系统，和 pinctrl 和 gpio 子系统一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，不同的输入设备所代表的含义不同，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同，对于驱动编写者而言不需要去关心应用层的事情，我们只需要按照要求上报这些输入事件即可。为此 input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点，input 子系统框架如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829114244477.png" alt="image-20200829114244477"></p><p>图中左边就是最底层的具体设备，比如按键、USB 键盘&#x2F;鼠标等，中间部分属于Linux 内核空间，分为驱动层、核心层和事件层，最右边的就是用户空间，所有的输入设备以文件的形式供用户应用程序使用。</p><p>可以看出 input 子系统用到了我们前面讲解的驱动分层模型，我们编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层，这三个层的分工如下：</p><ul><li><strong>驱动层</strong>：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。</li><li><strong>核心层</strong>：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。</li><li><strong>事件层</strong>：主要和用户空间进行交互。</li></ul><h3 id="2-input-驱动编写流程"><a href="#2-input-驱动编写流程" class="headerlink" title="2| input  驱动编写流程"></a>2| input  驱动编写流程</h3><p>input 核心层会向 Linux 内核注册一个字符设备，大家找到 drivers&#x2F;input&#x2F;input.c 这个文件，input.c 就是 input 输入子系统的核心层，此文件里面有如下所示代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1767</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> <span class="hljs-title">input_class</span> =</span> &#123;<span class="hljs-number">1768</span> .name = <span class="hljs-string">&quot;input&quot;</span>,<span class="hljs-number">1769</span> .devnode = input_devnode,<span class="hljs-number">1770</span> &#125;;......<span class="hljs-number">2414</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">input_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>2415 &#123;<span class="hljs-number">2416</span> <span class="hljs-type">int</span> err;<span class="hljs-number">2417</span><span class="hljs-number">2418</span> err = class_register(&amp;input_class);<span class="hljs-number">2419</span> <span class="hljs-keyword">if</span> (err) &#123;<span class="hljs-number">2420</span> pr_err(<span class="hljs-string">&quot;unable to register input_dev class\n&quot;</span>);<span class="hljs-number">2421</span> <span class="hljs-keyword">return</span> err;<span class="hljs-number">2422</span> &#125;<span class="hljs-number">2423</span><span class="hljs-number">2424</span> err = input_proc_init();<span class="hljs-number">2425</span> <span class="hljs-keyword">if</span> (err)<span class="hljs-number">2426</span> <span class="hljs-keyword">goto</span> fail1;<span class="hljs-number">2427</span><span class="hljs-number">2428</span> err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="hljs-number">0</span>),<span class="hljs-number">2429</span> INPUT_MAX_CHAR_DEVICES, <span class="hljs-string">&quot;input&quot;</span>);<span class="hljs-number">2430</span> <span class="hljs-keyword">if</span> (err) &#123;<span class="hljs-number">2431</span> pr_err(<span class="hljs-string">&quot;unable to register char major %d&quot;</span>, INPUT_MAJOR);<span class="hljs-number">2432</span> <span class="hljs-keyword">goto</span> fail2;<span class="hljs-number">2433</span> &#125;<span class="hljs-number">2434</span><span class="hljs-number">2435</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">2436</span><span class="hljs-number">2437</span> fail2: input_proc_exit();<span class="hljs-number">2438</span> fail1: class_unregister(&amp;input_class);<span class="hljs-number">2439</span> <span class="hljs-keyword">return</span> err;<span class="hljs-number">2440</span> &#125;</code></pre></div><p>第 2418 行，注册一个 input 类，这样系统启动以后就会在&#x2F;sys&#x2F;class 目录下有一个 input 子目录，如图 所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829114745845.png" alt="image-20200829114745845"></p><p>第 2428~2429 行，注册一个字符设备，主设备号为 INPUT_MAJOR，INPUT_MAJOR 定义在 include&#x2F;uapi&#x2F;linux&#x2F;major.h 文件中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_MAJOR  13</span></code></pre></div><p>因此，input 子系统的所有设备主设备号都为 13，我们在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，我们只需要向系统注册一个 input_device 即可。</p><h4 id="1-、注册-input-dev"><a href="#1-、注册-input-dev" class="headerlink" title="1 、注册 input_dev"></a>1 、注册 input_dev</h4><p>在使用 input 子系统的时候我们只需要注册一个 input 设备即可，input_dev 结构体表示 input设备，此结构体定义在 include&#x2F;linux&#x2F;input.h 文件中，定义如下(有省略)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">121</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> &#123;</span><span class="hljs-number">122</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-number">123</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *phys;<span class="hljs-number">124</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *uniq;<span class="hljs-number">125</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_id</span> <span class="hljs-title">id</span>;</span><span class="hljs-number">126</span><span class="hljs-number">127</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];<span class="hljs-number">128</span><span class="hljs-number">129</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="hljs-comment">/* 事件类型的位图 */</span><span class="hljs-number">130</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="hljs-comment">/* 按键值的位图 */</span><span class="hljs-number">131</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="hljs-comment">/* 相对坐标的位图 */</span><span class="hljs-number">132</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="hljs-comment">/* 绝对坐标的位图 */</span><span class="hljs-number">133</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="hljs-comment">/* 杂项事件的位图 */</span><span class="hljs-number">134</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="hljs-comment">/*LED 相关的位图 */</span><span class="hljs-number">135</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="hljs-comment">/* sound 有关的位图 */</span><span class="hljs-number">136</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="hljs-comment">/* 压力反馈的位图 */</span><span class="hljs-number">137</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="hljs-comment">/*开关状态的位图 */</span>......<span class="hljs-number">189</span> <span class="hljs-type">bool</span> devres_managed;<span class="hljs-number">190</span> &#125;;</code></pre></div><p>第 129 行，evbit 表示输入事件类型，可选的事件类型定义在 include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，事件类型如下：</p><ul><li>&#96;&#96;&#96;c<br>#define EV_SYN     0x00 &#x2F;* 同步事件 <em>&#x2F;<br>#define EV_KEY     0x01 &#x2F;</em> 按键事件 <em>&#x2F;<br>#define EV_REL     0x02 &#x2F;</em> 相对坐标事件 <em>&#x2F;<br>#define EV_ABS     0x03 &#x2F;</em> 绝对坐标事件 <em>&#x2F;<br>#define EV_MSC     0x04 &#x2F;</em> 杂项(其他)事件 <em>&#x2F;<br>#define EV_SW     0x05 &#x2F;</em> 开关事件 <em>&#x2F;<br>#define EV_LED     0x11 &#x2F;</em> LED <em>&#x2F;<br>#define EV_SND     0x12 &#x2F;</em> sound(声音) <em>&#x2F;<br>#define EV_REP     0x14 &#x2F;</em> 重复事件 <em>&#x2F;<br>#define EV_FF     0x15 &#x2F;</em> 压力事件 <em>&#x2F;<br>#define EV_PWR     0x16 &#x2F;</em> 电源事件 <em>&#x2F;<br>#define EV_FF_STATUS 0x17 &#x2F;</em> 压力状态事件 *&#x2F;<div class="hljs code-wrapper"><pre><code class="hljs dts">比如本章我们要使用到按键，那么就需要注册 EV_KEY 事件，如果要使用连按功能的话还需要注册 EV_REP 事件。继续回到示例代码中，第 <span class="hljs-number">129</span> 行~<span class="hljs-number">137</span> 行的 evbit、keybit、relbit 等等都是存放不同事件对应的值。比如我们本章要使用按键事件，因此要用到 keybit，keybit 就是按键事件使用的位图，Linux 内核定义了很多按键值，这些按键值定义在 include<span class="hljs-keyword">/uapi/</span>linux/input.h 文件中，按键值如下：```c<span class="hljs-number">215</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_RESERVED 0</span><span class="hljs-number">216</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_ESC 1</span><span class="hljs-number">217</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_1 2</span><span class="hljs-number">218</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_2 3</span><span class="hljs-number">219</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_3 4</span><span class="hljs-number">220</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_4 5</span><span class="hljs-number">221</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_5 6</span><span class="hljs-number">222</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_6 7</span><span class="hljs-number">223</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_7 8</span><span class="hljs-number">224</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_8 9</span><span class="hljs-number">225</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_9 10</span><span class="hljs-number">226</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_0 11</span>......<span class="hljs-number">794</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> BTN_TRIGGER_HAPPY39 0x2e6</span><span class="hljs-number">795</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> BTN_TRIGGER_HAPPY40 0x2e7</span></code></pre></div></li></ul><p>我们可以将开发板上的按键值设置为示例代码 中的任意一个，比如我们本章实验会将 I.MX6U-ALPHA 开发板上的 KEY 按键值设置为 KEY_0。</p><hr><p>在编写 input 设备驱动的时候我们需要先<strong>申请一个 input_dev 结构体变量</strong>，使用input_allocate_device 函数来申请一个 input_dev，此函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> input_dev *<span class="hljs-title function_">input_allocate_device</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>参数</strong>：无。<br><strong>返回值</strong>：申请到的 input_dev。</p><hr><p>如果要注销的 input 设备的话需要使用 input_free_device 函数来<strong>释放掉前面申请到的input_dev</strong>，input_free_device 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_free_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong>：需要释放的 input_dev。<br><strong>返回值</strong>：无。</p><hr><p>申请好一个 input_dev 以后就需要<strong>初始化这个 input_dev</strong>，需要初始化的内容主要为事件类型(evbit)和事件值(keybit)这两种。input_dev 初始化完成以后就需要向 Linux 内核注册input_dev<br>了，需要用到 input_register_device 函数，此函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">input_register_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong>：要注册的 input_dev 。<br><strong>返回值</strong>：0，input_dev 注册成功；负值，input_dev 注册失败。</p><hr><p>同样的，注销 input 驱动的时候也需要使用 input_unregister_device 函数来<strong>注销掉前面注册的 input_dev</strong>，input_unregister_device 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_unregister_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong>：要注销的 input_dev 。<br><strong>返回值</strong>：无。</p><hr><p>综上所述，input_dev 注册过程如下：</p><p>①、使用 input_allocate_device 函数申请一个 input_dev。<br>②、初始化 input_dev 的事件类型以及事件值。<br>③、使用 input_register_device 函数向 Linux 系统注册前面初始化好的 input_dev。<br>④、卸载input驱动的时候需要先使用input_unregister_device函数注销掉注册的input_dev, 然后使用 input_free_device 函数释放掉前面申请的 input_dev。</p><p>input_dev 注册过程示例代码如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">inputdev</span>;</span> <span class="hljs-comment">/* input 结构体变量 */</span><span class="hljs-number">2</span><span class="hljs-number">3</span> <span class="hljs-comment">/* 驱动入口函数 */</span><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>5 &#123;<span class="hljs-number">6</span> ......<span class="hljs-number">7</span> inputdev = input_allocate_device(); <span class="hljs-comment">/* 申请 input_dev */</span><span class="hljs-number">8</span> inputdev-&gt;name = <span class="hljs-string">&quot;test_inputdev&quot;</span>; <span class="hljs-comment">/* 设置 input_dev 名字 */</span><span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-comment">/*********第一种设置事件和事件值的方法***********/</span><span class="hljs-number">11</span> __set_bit(EV_KEY, inputdev-&gt;evbit); <span class="hljs-comment">/* 设置产生按键事件 */</span><span class="hljs-number">12</span> __set_bit(EV_REP, inputdev-&gt;evbit); <span class="hljs-comment">/* 重复事件 */</span><span class="hljs-number">13</span> __set_bit(KEY_0, inputdev-&gt;keybit); <span class="hljs-comment">/*设置产生哪些按键值 */</span><span class="hljs-number">14</span> <span class="hljs-comment">/************************************************/</span><span class="hljs-number">15</span><span class="hljs-number">16</span> <span class="hljs-comment">/*********第二种设置事件和事件值的方法***********/</span><span class="hljs-number">17</span> keyinputdev.inputdev-&gt;evbit[<span class="hljs-number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);<span class="hljs-number">18</span> keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);<span class="hljs-number">19</span> <span class="hljs-comment">/************************************************/</span><span class="hljs-number">20</span><span class="hljs-number">21</span> <span class="hljs-comment">/*********第三种设置事件和事件值的方法***********/</span><span class="hljs-number">22</span> keyinputdev.inputdev-&gt;evbit[<span class="hljs-number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);<span class="hljs-number">23</span> input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);<span class="hljs-number">24</span> <span class="hljs-comment">/************************************************/</span><span class="hljs-number">25</span><span class="hljs-number">26</span> <span class="hljs-comment">/* 注册 input_dev */</span><span class="hljs-number">27</span>input_register_device(inputdev);<span class="hljs-number">28</span> ......<span class="hljs-number">29</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">30</span> &#125;<span class="hljs-number">31</span><span class="hljs-number">32</span> <span class="hljs-comment">/* 驱动出口函数 */</span><span class="hljs-number">33</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>34 &#123;<span class="hljs-number">35</span> input_unregister_device(inputdev); <span class="hljs-comment">/* 注销 input_dev */</span><span class="hljs-number">36</span> input_free_device(inputdev); <span class="hljs-comment">/* 删除 input_dev */</span><span class="hljs-number">37</span> &#125;</code></pre></div><p>第 1 行，定义一个 input_dev 结构体指针变量。</p><p>第 4<del>30 行，驱动入口函数，在此函数中完成 input_dev 的申请、设置、注册等工作。第 7行调用 input_allocate_device 函数申请一个 input_dev。第 10</del>23 行都是设置 input 设备事件和按键值，这里用了三种方法来设置事件和按键值。第 27 行调用 input_register_device 函数向Linux内核注册 inputdev。</p><p>第 33~37 行，驱动出口函数，第 35 行调用 input_unregister_device 函数注销前面注册的input_dev，第 36 行调用 input_free_device 函数删除前面申请的 input_dev。 </p><h4 id="2-、上报输入事件"><a href="#2-、上报输入事件" class="headerlink" title="2 、上报输入事件"></a>2 、上报输入事件</h4><p>当我们向 Linux 内核注册好 input_dev 以后还不能高枕无忧的使用 input 设备，input 设备都是具有输入功能的，但是具体是什么样的输入值 Linux 内核是不知道的，我们需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。</p><p>比如按键，我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。</p><p>不同的事件，其上报事件的 API 函数不同，我们依次来看一下一些常用的事件上报 API 函数。首先是 input_event 函数，此函数用于上报指定的事件以及对应的值，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_event</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev,</span><span class="hljs-params">                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type,</span><span class="hljs-params">                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code,</span><span class="hljs-params">                 <span class="hljs-type">int</span> value)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong>：    需要上报的 input_dev。<br><strong>type</strong>:     上报的事件类型，比如 EV_KEY。<br><strong>code</strong> ： 事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等。<br><strong>value</strong>： 事件值，比如 1 表示按键按下，0 表示按键松开。<br><strong>返回值</strong>：无。</p><hr><p>input_event 函数可以上报所有的事件类型和事件值，Linux 内核也提供了其他的针对具体事件的上报函数，这些函数其实都用到了 input_event 函数。比如上报按键所使用的input_report_key 函数，此函数内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">input_report_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span>&#123;input_event(dev, EV_KEY, code, !!value);&#125;</code></pre></div><p>从示例代码  可以看出，input_report_key 函数的本质就是 input_event 函数，如果要上报按键事件的话还是建议大家使用 input_report_key 函数。</p><hr><p>同样的还有一些其他的事件上报函数，这些函数如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_report_rel</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span><span class="hljs-type">void</span> <span class="hljs-title function_">input_report_abs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span><span class="hljs-type">void</span> <span class="hljs-title function_">input_report_ff_status</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span><span class="hljs-type">void</span> <span class="hljs-title function_">input_report_switch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code, <span class="hljs-type">int</span> value)</span><span class="hljs-type">void</span> <span class="hljs-title function_">input_mt_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div><hr><p>当我们上报事件以后还需要使用 input_sync 函数来告诉 Linux 内核 input 子系统上报结束，input_sync 函数本质是上报一个同步事件，此函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">input_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong>：需要上报同步事件的 input_dev。<br><strong>返回值</strong>：无。</p><p>综上所述，按键的上报事件的参考代码如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 用于按键消抖的定时器服务函数 */</span><span class="hljs-number">2</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>3 &#123;<span class="hljs-number">4</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;<span class="hljs-number">5</span><span class="hljs-number">6</span> value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/*  读取 IO  值 */</span><span class="hljs-number">7</span> <span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span><span class="hljs-number">8</span> <span class="hljs-comment">/*  上报按键值 */</span><span class="hljs-number">9</span> input_report_key(inputdev, KEY_0, <span class="hljs-number">1</span>); <span class="hljs-comment">/*  最后一个参数 1 ， 按下 */</span><span class="hljs-number">10</span> input_sync(inputdev); <span class="hljs-comment">/* 同步事件 */</span><span class="hljs-number">11</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 按键松开 */</span><span class="hljs-number">12</span> input_report_key(inputdev, KEY_0, <span class="hljs-number">0</span>); <span class="hljs-comment">/*  最后一个参数 0 ， 松开 */</span><span class="hljs-number">13</span> input_sync(inputdev); <span class="hljs-comment">/* 同步事件 */</span><span class="hljs-number">14</span> &#125;<span class="hljs-number">15</span> &#125;</code></pre></div><h4 id="3、input-event-结构体"><a href="#3、input-event-结构体" class="headerlink" title="3、input_event  结构体"></a>3、input_event  结构体</h4><p>Linux 内核使用 input_event 这个结构体来表示所有的输入事件，input_envent 结构体定义在include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">24</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_event</span> &#123;</span><span class="hljs-number">25</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">time</span>;</span><span class="hljs-number">26</span> __u16 type;<span class="hljs-number">27</span> __u16 code;<span class="hljs-number">28</span> __s32 value;<span class="hljs-number">29</span> &#125;;</code></pre></div><p>我们依次来看一下 input_event 结构体中的各个成员变量：</p><ul><li><p><strong>time</strong>：时间，也就是此事件发生的时间，为 timeval 结构体类型，timeval 结构体定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">__kernel_long_t</span>;<span class="hljs-number">2</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">__kernel_long_t</span> <span class="hljs-type">__kernel_time_t</span>;<span class="hljs-number">3</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">__kernel_long_t</span> <span class="hljs-type">__kernel_suseconds_t</span>;<span class="hljs-number">4</span><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span><span class="hljs-number">6</span> <span class="hljs-type">__kernel_time_t</span> tv_sec; <span class="hljs-comment">/* 秒  */</span><span class="hljs-number">7</span> <span class="hljs-type">__kernel_suseconds_t</span> tv_usec; <span class="hljs-comment">/* 微秒 */</span><span class="hljs-number">8</span> &#125;;</code></pre></div><p>从示例代码 可以看出，tv_sec 和 tv_usec 这两个成员变量都为 long 类型，也就是 32位，这个一定要记住，后面我们分析 event 事件上报数据的时候要用到。</p></li><li><p><strong>type</strong> ：事件类型，比如 EV_KEY，表示此次事件为按键事件，此成员变量为 16 位。</p></li><li><p><strong>code</strong> ：事件码，比如在 EV_KEY 事件中 code 就表示具体的按键码，如：KEY_0、KEY_1等等这些按键。此成员变量为 16 位。</p></li><li><p><strong>value</strong> ：值，比如 EV_KEY 事件中 value 就是按键值，表示按键有没有被按下，如果为 1 的话说明按键按下，如果为 0 的话说明按键没有被按下或者按键松开了。</p></li></ul><p>input_envent 这个结构体非常重要，因为所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过 input_event 来获取到具体的输入事件或相关的值，比如按键值等。关于 input 子系统就讲解到这里，接下来我们就以开发板上的 KEY0 按键为例，讲解一下如何编写 input 驱动。</p><h2 id="二、硬件原理图分析"><a href="#二、硬件原理图分析" class="headerlink" title="二、硬件原理图分析"></a>二、硬件原理图分析</h2><p>参考之前按键的实验。</p><h2 id="三、实验程序编写"><a href="#三、实验程序编写" class="headerlink" title="三、实验程序编写"></a>三、实验程序编写</h2><h3 id="1-修改设备树文件"><a href="#1-修改设备树文件" class="headerlink" title="1| 修改设备树文件"></a>1| 修改设备树文件</h3><p>直接使用上次的key节点即可。</p><h3 id="2-按键-input-驱动程序编写"><a href="#2-按键-input-驱动程序编写" class="headerlink" title="2| 按键 input  驱动程序编写"></a>2| 按键 input  驱动程序编写</h3><p>新建名为“20_input”的文件夹，然后在 20_input 文件夹里面创建 vscode 工程，工作区命名为“keyinput”。工程创建好以后新建 keyinput.c 文件，在 keyinput.c 里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYINPUT_CNT1<span class="hljs-comment">/* 设备号个数 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYINPUT_NAME<span class="hljs-string">&quot;keyinput&quot;</span><span class="hljs-comment">/* 名字 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE0X01<span class="hljs-comment">/* KEY0按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY0XFF<span class="hljs-comment">/* 无效的按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_NUM1<span class="hljs-comment">/* 按键数量 */</span></span><span class="hljs-comment">/* 中断IO描述结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> &#123;</span><span class="hljs-type">int</span> gpio;<span class="hljs-comment">/* gpio */</span><span class="hljs-type">int</span> irqnum;<span class="hljs-comment">/* 中断号     */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;<span class="hljs-comment">/* 按键对应的键值 */</span><span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<span class="hljs-comment">/* 名字 */</span><span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *);<span class="hljs-comment">/* 中断服务函数 */</span>&#125;;<span class="hljs-comment">/* keyinput设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyinput_dev</span>&#123;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-comment">/* 设备号  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-comment">/* cdev */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-comment">/* 类 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-comment">/* 设备  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>*<span class="hljs-title">nd</span>;</span> <span class="hljs-comment">/* 设备节点 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span><span class="hljs-comment">/* 定义一个定时器*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> <span class="hljs-title">irqkeydesc</span>[<span class="hljs-title">KEY_NUM</span>];</span><span class="hljs-comment">/* 按键描述数组 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> curkeynum;<span class="hljs-comment">/* 当前的按键号 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">inputdev</span>;</span><span class="hljs-comment">/* input结构体 */</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyinput_dev</span> <span class="hljs-title">keyinputdev</span>;</span><span class="hljs-comment">/* key input设备 */</span><span class="hljs-comment">/* @description: 中断服务函数，开启定时器，延时10ms，</span><span class="hljs-comment"> *    定时器用于按键消抖。</span><span class="hljs-comment"> * @param - irq : 中断号 </span><span class="hljs-comment"> * @param - dev_id: 设备结构。</span><span class="hljs-comment"> * @return : 中断执行结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">key0_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyinput_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> keyinput_dev *)dev_id;dev-&gt;curkeynum = <span class="hljs-number">0</span>;dev-&gt;timer.data = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span>)dev_id;mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="hljs-number">10</span>));<span class="hljs-comment">/* 10ms定时 */</span><span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);&#125;<span class="hljs-comment">/* @description: 定时器服务函数，用于按键消抖，定时器到了以后</span><span class="hljs-comment"> *  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><span class="hljs-comment"> * @param - arg: 设备结构变量</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> *<span class="hljs-title">keydesc</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyinput_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> keyinput_dev *)arg;num = dev-&gt;curkeynum;keydesc = &amp;dev-&gt;irqkeydesc[num];value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/* 读取IO值 */</span><span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span><span class="hljs-comment">/* 上报按键值 */</span><span class="hljs-comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 1);</span>input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 最后一个参数表示按下还是松开，1为按下，0为松开 */</span>input_sync(dev-&gt;inputdev);&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 按键松开 */</span><span class="hljs-comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 0);</span>input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="hljs-number">0</span>);input_sync(dev-&gt;inputdev);&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 按键IO初始化</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;<span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;keyinputdev.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);<span class="hljs-keyword">if</span> (keyinputdev.nd== <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;k:key node not find!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125; <span class="hljs-comment">/* 提取GPIO */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_NUM; i++) &#123;keyinputdev.irqkeydesc[i].gpio = of_get_named_gpio(keyinputdev.nd ,<span class="hljs-string">&quot;key-gpios&quot;</span>, i);<span class="hljs-keyword">if</span> (keyinputdev.irqkeydesc[i].gpio &lt; <span class="hljs-number">0</span>) &#123;printk(<span class="hljs-string">&quot;k:can&#x27;t get key%d\r\n&quot;</span>, i);&#125;&#125;<span class="hljs-comment">/* 初始化key所使用的IO，并且设置成中断模式 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_NUM; i++) &#123;<span class="hljs-built_in">memset</span>(keyinputdev.irqkeydesc[i].name, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(name));<span class="hljs-comment">/* 缓冲区清零 */</span><span class="hljs-built_in">sprintf</span>(keyinputdev.irqkeydesc[i].name, <span class="hljs-string">&quot;KEY%d&quot;</span>, i);<span class="hljs-comment">/* 组合名字 */</span>gpio_request(keyinputdev.irqkeydesc[i].gpio, name);gpio_direction_input(keyinputdev.irqkeydesc[i].gpio);keyinputdev.irqkeydesc[i].irqnum = irq_of_parse_and_map(keyinputdev.nd, i);&#125;<span class="hljs-comment">/* 申请中断 */</span>keyinputdev.irqkeydesc[<span class="hljs-number">0</span>].handler = key0_handler;keyinputdev.irqkeydesc[<span class="hljs-number">0</span>].value = KEY_0;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_NUM; i++) &#123;ret = request_irq(keyinputdev.irqkeydesc[i].irqnum, keyinputdev.irqkeydesc[i].handler,                  IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, keyinputdev.irqkeydesc[i].name, &amp;keyinputdev);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:irq %d request failed!\r\n&quot;</span>, keyinputdev.irqkeydesc[i].irqnum);<span class="hljs-keyword">return</span> -EFAULT;&#125;&#125;<span class="hljs-comment">/* 创建定时器 */</span>init_timer(&amp;keyinputdev.timer);keyinputdev.timer.function = timer_function;<span class="hljs-comment">/* 申请input_dev */</span>keyinputdev.inputdev = input_allocate_device();keyinputdev.inputdev-&gt;name = KEYINPUT_NAME;<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><span class="hljs-comment">/* 初始化input_dev，设置产生哪些事件 */</span>__set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit);<span class="hljs-comment">/* 设置产生按键事件          */</span>__set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit);<span class="hljs-comment">/* 重复事件，比如按下去不放开，就会一直输出信息  */</span><span class="hljs-comment">/* 初始化input_dev，设置产生哪些按键 */</span>__set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>keyinputdev.inputdev-&gt;evbit[<span class="hljs-number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>keyinputdev.inputdev-&gt;evbit[<span class="hljs-number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);<span class="hljs-comment">/* 注册输入设备 */</span>ret = input_register_device(keyinputdev.inputdev);<span class="hljs-keyword">if</span> (ret) &#123;printk(<span class="hljs-string">&quot;k:register input device failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动入口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">keyinput_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;keyio_init();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动出口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">keyinput_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 删除定时器 */</span>del_timer_sync(&amp;keyinputdev.timer);<span class="hljs-comment">/* 删除定时器 */</span><span class="hljs-comment">/* 释放中断 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_NUM; i++) &#123;free_irq(keyinputdev.irqkeydesc[i].irqnum, &amp;keyinputdev);&#125;<span class="hljs-comment">/* 释放input_dev */</span>input_unregister_device(keyinputdev.inputdev);input_free_device(keyinputdev.inputdev);&#125;module_init(keyinput_init);module_exit(keyinput_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>keyinput.c 文件内容其实就是实验“irq”中的 imx6uirq.c 文件中修改而来的，只是将其中与字符设备有关的内容进行了删除，加入了 input_dev 相关的内容，我们简单来分析一下示例代码中的程序。</p><ul><li>第 57 行，在设备结构体中定义一个 input_dev 指针变量。</li><li>第 93~102 行，在按键消抖定时器处理函数中上报输入事件，也就是使用 input_report_key函数上报按键事件以及按键值，最后使用 input_sync 函数上报一个同步事件，这一步一定得做！</li><li>第 156~180 行，使用 input_allocate_device 函数申请 input_dev，然后设置相应的事件以及事件码(也就是 KEY 模拟成那个按键，这里我们设置为 KEY_0)。最后使用 input_register_device函数向 Linux 内核注册 input_dev。</li><li>第 211~212 行，当注销 input 设备驱动的时候使用 input_unregister_device 函数注销掉前面注册的 input_dev，最后使用 input_free_device 函数释放掉前面申请的 input_dev。</li></ul><h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3| 编写测试 APP"></a>3| 编写测试 APP</h3><p>新建 keyinputApp.c 文件，然后在里面输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/ioctl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span><span class="hljs-comment">/* 定义一个input_event变量，存放输入事件信息 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_event</span> <span class="hljs-title">inputevent</span>;</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: main主程序</span><span class="hljs-comment"> * @param - argc : argv数组元素个数</span><span class="hljs-comment"> * @param - argv : 具体参数</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<span class="hljs-type">int</span> fd;<span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<span class="hljs-type">char</span> *filename;<span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;filename = argv[<span class="hljs-number">1</span>];fd = open(filename, O_RDWR);<span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;err = read(fd, &amp;inputevent, <span class="hljs-keyword">sizeof</span>(inputevent));<span class="hljs-keyword">if</span> (err &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 读取数据成功 */</span><span class="hljs-keyword">switch</span> (inputevent.type) &#123;<span class="hljs-keyword">case</span> EV_KEY:<span class="hljs-keyword">if</span> (inputevent.code &lt; BTN_MISC) &#123; <span class="hljs-comment">/* 键盘键值 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key %d %s\r\n&quot;</span>, inputevent.code, inputevent.value ? <span class="hljs-string">&quot;press&quot;</span> : <span class="hljs-string">&quot;release&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;button %d %s\r\n&quot;</span>, inputevent.code, inputevent.value ? <span class="hljs-string">&quot;press&quot;</span> : <span class="hljs-string">&quot;release&quot;</span>);&#125;<span class="hljs-keyword">break</span>;<span class="hljs-comment">/* 其他类型的事件，自行处理 */</span><span class="hljs-keyword">case</span> EV_REL:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> EV_ABS:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> EV_MSC:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> EV_SW:<span class="hljs-keyword">break</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;读取数据失败\r\n&quot;</span>);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>前面已经说过了，Linux 内核会使用 input_event 结构体来表示输入事件，所以我们要获取按键输入信息，那么必须借助于 input_event 结构体。定义了一个 inputevent 变量，此变量为 input_event 结构体类型。</p><p>当我们向 Linux 内核成功注册 input_dev 设备以后，会在&#x2F;dev&#x2F;input 目录下生成一个名为“eventX(X&#x3D;0….n)”的文件，这个&#x2F;dev&#x2F;input&#x2F;eventX 就是对应的 input 设备文件。我们读取这个文件就可以获取到输入事件信息，比如按键值什么的。使用read函数读取输入设备文件，也就是&#x2F;dev&#x2F;input&#x2F;eventX，读取到的数据按照 input_event 结构体组织起来。获取到输入事件以后(input_event 结构体类型)使用 switch case 语句来判断事件类型，本章实验我们设置的事件类型为 EV_KEY，因此只需要处理 EV_KEY 事件即可。比如获取按键编号(KEY_0 的编号为 11)、获取按键状态，按下还是松开的？</p><h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4| 运行测试"></a>4| 运行测试</h3><p>编译运行。</p><p>将编译出来keyinput.ko和keyinputApp这两个文件拷贝到rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15目录中，在加载 keyinput.ko 驱动模块之前，先看一下&#x2F;dev&#x2F;input 目录下都有哪些文件，结果如图 所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122445514.png" alt="image-20200829122445514"></p><p>从图 可以看出，当前&#x2F;dev&#x2F;input 目录只有 event0 和 mice 这两个文件。接下来输入如下命令加载 keyinput.ko 这个驱动模块。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">depmod <span class="hljs-regexp">//</span>第一次加载驱动的时候需要运行此命令modprobe keyinput.ko <span class="hljs-regexp">//</span>加载驱动模块</code></pre></div><p>当驱动模块加载成功以后再来看一下&#x2F;dev&#x2F;input 目录下有哪些文件，结果如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122604797.png" alt="image-20200829122604797"></p><p>从图可以看出，多了一个 event1 文件，因此&#x2F;dev&#x2F;input&#x2F;event1 就是我们注册的驱动所对应的设备文件。keyinputApp 就是通过读取&#x2F;dev&#x2F;input&#x2F;event1 这个文件来获取输入事件信息的，输入如下测试命令：</p><div class="hljs code-wrapper"><pre><code class="hljs c">./keyinputApp /dev/input/event1</code></pre></div><p>然后按下开发板上的 KEY 按键，结果如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122743481.png" alt="image-20200829122743481"></p><p>从图可以看出，当我们按下或者释放开发板上的按键以后都会在终端上输出相应的内容，提示我们哪个按键按下或释放了，在 Linux 内核中 KEY_0 为 11。</p><p>另外，我们也可以不用 keyinputApp 来测试驱动，可以直接使用 hexdump 命令来查看&#x2F;dev&#x2F;input&#x2F;event1 文件内容，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">hexdump /dev/input/event1</code></pre></div><p>然后按下按键，终端输出如图 所示信息：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829122902349.png" alt="image-20200829122902349"></p><p>图就是 input_event 类型的原始事件数据值，采用十六进制表示，这些原始数据的含义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*  编号 */</span>  <span class="hljs-comment">/* tv_sec */</span>   <span class="hljs-comment">/* tv_usec */</span> <span class="hljs-comment">/* type */</span>  <span class="hljs-comment">/* code */</span> <span class="hljs-comment">/* value */</span><span class="hljs-number">0000000</span> <span class="hljs-number">106</span>a <span class="hljs-number">0000</span> d395 <span class="hljs-number">0001</span>     <span class="hljs-number">0001</span>       <span class="hljs-number">000b</span> <span class="hljs-number">0001</span> <span class="hljs-number">0000</span><span class="hljs-number">0000010</span> <span class="hljs-number">106</span>a <span class="hljs-number">0000</span> d395 <span class="hljs-number">0001</span>     <span class="hljs-number">0000</span>   <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><span class="hljs-number">0000020</span> <span class="hljs-number">106</span>a <span class="hljs-number">0000</span> <span class="hljs-number">3328</span> <span class="hljs-number">0003</span>     <span class="hljs-number">0001</span>   <span class="hljs-number">000b</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><span class="hljs-number">0000030</span> <span class="hljs-number">106</span>a <span class="hljs-number">0000</span> <span class="hljs-number">3328</span> <span class="hljs-number">0003</span>   <span class="hljs-number">0000</span>   <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><span class="hljs-number">0000040</span> <span class="hljs-number">106</span>a <span class="hljs-number">0000</span> <span class="hljs-number">2f</span>af <span class="hljs-number">000</span>e   <span class="hljs-number">0001</span>   <span class="hljs-number">000b</span> <span class="hljs-number">0001</span> <span class="hljs-number">0000</span><span class="hljs-number">0000050</span> <span class="hljs-number">106</span>a <span class="hljs-number">0000</span> <span class="hljs-number">2f</span>af <span class="hljs-number">000</span>e   <span class="hljs-number">0000</span>   <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><span class="hljs-number">0000060</span> <span class="hljs-number">106b</span> <span class="hljs-number">0000</span> <span class="hljs-number">4</span>ce6 <span class="hljs-number">0000</span>   <span class="hljs-number">0001</span>      <span class="hljs-number">000b</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><span class="hljs-number">0000070</span> <span class="hljs-number">106b</span> <span class="hljs-number">0000</span> <span class="hljs-number">4</span>ce6 <span class="hljs-number">0000</span>   <span class="hljs-number">0000</span>   <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span></code></pre></div><p>type 为事件类型，查看示例代码 可知，EV_KEY 事件值为 1，EV_SYN 事件值为0。因此第 1 行表示 EV_KEY 事件，第 2 行表示 EV_SYN 事件。code 为事件编码，也就是按键号，查看示例代码可以，KEY_0 这个按键编号为 11，对应的十六进制为 0xb，因此第1 行表示 KEY_0 这个按键事件，最后的 value 就是按键值，为 1 表示按下，为 0 的话表示松开。</p><p>综上所述，示例代码中的原始事件值含义如下：</p><ul><li>第 1 行，按键(KEY_0)按下事件。<br>第 2 行，EV_SYN 同步事件，因为每次上报按键事件以后都要同步的上报一个 EV_SYN 事件。<br>第 3 行，按键(KEY_0)松开事件。<br>第 4 行，EV_SYN 同步事件，和第 2 行一样。</li></ul><h2 id="四、Linux-自带按键驱动程序的使用"><a href="#四、Linux-自带按键驱动程序的使用" class="headerlink" title="四、Linux  自带按键驱动程序的使用"></a>四、Linux  自带按键驱动程序的使用</h2><h3 id="1-自带按键驱动程序源码简析"><a href="#1-自带按键驱动程序源码简析" class="headerlink" title="1| 自带按键驱动程序源码简析"></a>1| 自带按键驱动程序源码简析</h3><p>Linux 内核也自带了 KEY 驱动，如果要使用内核自带的 KEY 驱动的话需要配置 Linux 内核，不过 Linux 内核一般默认已经使能了 KEY 驱动，但是我们还是要检查一下。按照如下路径找到相应的配置选项：</p><div class="hljs code-wrapper"><pre><code class="hljs livescript">-&gt; Device Drivers    -&gt; Input device support        -&gt; Generic input layer <span class="hljs-function"><span class="hljs-params">(needed <span class="hljs-keyword">for</span> keyboard, mouse, ...)</span> <span class="hljs-params">(INPUT [=y])</span></span><span class="hljs-function">            -&gt;</span> Keyboards <span class="hljs-function"><span class="hljs-params">(INPUT_KEYBOARD [=y])</span></span><span class="hljs-function">                 -&gt;</span> GPIO Buttons</code></pre></div><p>选中“GPIO Buttons”选项，将其编译进 Linux 内核中，如图  所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829123547978.png" alt="image-20200829123547978"></p><p>选中以后就会在.config 文件中出现“CONFIG_KEYBOARD_GPIO&#x3D;y”这一行，Linux 内核就会根据这一行来将 KEY 驱动文件编译进 Linux 内核。Linux 内核自带的 KEY 驱动文件为drivers&#x2F;input&#x2F;keyboard&#x2F;gpio_keys.c</p><p>具体详情参考正点原子IMX6UL驱动开发手册 58.5.1节</p><h3 id="2-自带按键驱动的使用"><a href="#2-自带按键驱动的使用" class="headerlink" title="2| 自带按键驱动的使用"></a>2| 自带按键驱动的使用</h3><p>要使用Linux内核自带的按键驱动程序很简单，只需要根据Documentation&#x2F;devicetree&#x2F;bindings&#x2F;input&#x2F;gpio-keys.txt 这个文件在设备树中添加指定的设备节点即可，节点要求如下：</p><ul><li>①、节点名字为“gpio-keys”。</li><li>②、gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。</li><li>③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己：<ul><li>gpios ：KEY 所连接的 GPIO 信息。</li><li>interrupts ：KEY 所使用 GPIO 中断信息，不是必须的，可以不写。</li><li>label：KEY 名字</li><li>linux,code：KEY 要模拟的按键</li></ul></li><li>④、如果按键要支持连按的话要加入 autorepeat。</li></ul><p>打开 imx6ull-lxg-emmc.dts，根据上面的要求创建对应的设备节点，设备节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> gpio-keys &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;gpio-keys&quot;</span>;<span class="hljs-number">3</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">4</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><span class="hljs-number">5</span> autorepeat;<span class="hljs-number">6</span> key0 &#123;<span class="hljs-number">7</span> label = <span class="hljs-string">&quot;GPIO Key Enter&quot;</span>;<span class="hljs-number">8</span> linux,code = &lt;KEY_ENTER&gt;;<span class="hljs-number">9</span> gpios = &lt;&amp;gpio1 <span class="hljs-number">18</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">10</span> &#125;;<span class="hljs-number">11</span> &#125;;</code></pre></div><p>第 5 行，autorepeat 表示按键支持连按。<br>第 6~10 行，ALPHA 开发板 KEY 按键信息，名字设置为“GPIO Key Enter”，这里我们将开发板上的 KEY 按键设置为“EKY_ENTER”这个按键，也就是回车键，效果和键盘上的回车键一样。后面学习 LCD 驱动的时候需要用到此按键，因为 Linux 内核设计的 10 分钟以后 LCD关闭，也就是黑屏，就跟我们用电脑或者手机一样，一定时间以后关闭屏幕。这里将开发板上的 KEY 按键注册为回车键，当 LCD 黑屏以后直接按一下 KEY 按键即可唤醒屏幕，就跟当电脑熄屏以后按下回车键即可重新打开屏幕一样。</p><p>最后设置 KEY 所使用的 IO 为 GPIO1_IO18，一定要检查一下设备树看看此 GPIO 有没有被用到其他外设上，如果有的话要删除掉相关代码！重新编译设备树，然后用新编译出来的 imx6ull-lxg-emmc.dtb 启动 Linux 系统，系统启动以后查看&#x2F;dev&#x2F;input 目录，看看都有哪些文件，结果如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829124758907.png" alt="image-20200829124758907"></p><p>从图 可以看出存在 event1 这个文件，这个文件就是 KEY 对应的设备文件，使用hexdump 命令来查看&#x2F;dev&#x2F;input&#x2F;event1 文件，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">hexdump <span class="hljs-regexp">/dev/i</span>nput/event1</code></pre></div><p>然后按下 ALPHA 开发板上的按键，终端输出图 所示内容：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/15%E3%80%81Linux_INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20200829124848591.png" alt="image-20200829124848591"></p><p>如果按下 KEY 按键以后会在终端上输出图 所示的信息那么就表示 Linux 内核的按键驱动工作正常。至于图 中内容的含义大家就自行分析，这个已经在前面 小节详细的分析过了，这里就不再讲解了。</p><p>大家如果发现按下 KEY 按键以后没有反应，那么请检查一下三方面：<br>①、是否使能 Linux 内核 KEY 驱动。<br>②、设备树中 gpio-keys 节点是否创建成功。<br>③、在设备树中是否有其他外设也使用了 KEY 按键对应的 GPIO，但是我们并没有删除掉这些外设信息。检查 Linux 启动 log 信息，看看是否有类似下面这条信息：</p><div class="hljs code-wrapper"><pre><code class="hljs c">gpio-keys gpio_keys：Failed to request GPIO <span class="hljs-number">18</span>, error <span class="hljs-number">-16</span></code></pre></div><p>上述信息表示 GPIO 18 申请失败，失败的原因就是有其他的外设正在使用此 GPIO。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16| Linux LCD驱动实验</title>
    <link href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-LCD驱动实验"><a href="#Linux-LCD驱动实验" class="headerlink" title="Linux LCD驱动实验"></a>Linux LCD驱动实验</h1><p>LCD 是很常用的一个外设，在裸机篇中我们讲解了如何编写 LCD 裸机驱动，在 Linux 下LCD 的使用更加广泛，在搭配 QT 这样的 GUI 库下可以制作出非常精美的 UI 界面。本章我们就来学习一下如何在 Linux 下驱动 LCD 屏幕。</p><h2 id="一、Linux-下-LCD-驱动简析"><a href="#一、Linux-下-LCD-驱动简析" class="headerlink" title="一、Linux 下 LCD  驱动简析"></a>一、Linux 下 LCD  驱动简析</h2><h3 id="1-Framebuffer-设备"><a href="#1-Framebuffer-设备" class="headerlink" title="1| Framebuffer 设备"></a>1| Framebuffer 设备</h3><p>先来回顾一下裸机的时候 LCD 驱动是怎么编写的，裸机 LCD 驱动编写流程如下：</p><p>①、初始化 I.MX6U 的 eLCDIF 控制器，重点是 LCD 屏幕宽(width)、高(height)、hspw、hbp、hfp、vspw、vbp 和 vfp 等信息。<br>②、初始化 LCD 像素时钟。<br>③、设置 RGBLCD 显存。<br>④、应用程序直接通过操作显存来操作 LCD，实现在 LCD 上显示字符、图片等信息。</p><p>在 Linux 中应用程序最终也是通过操作 RGB LCD 的显存来实现在 LCD 上显示字符、图片等信息。在裸机中我们可以随意的分配显存，但是在 Linux 系统中内存的管理很严格，显存是需要申请的，不是你想用就能用的。而且因为虚拟内存的存在，驱动程序设置的显存和应用程序访问的显存要是同一片物理内存。</p><p>为了解决上述问题，Framebuffer 诞生了， Framebuffer 翻译过来就是帧缓冲，简称 fb，因此大家在以后的 Linux 学习中见到“Framebuffer”或者“fb”的话第一反应应该想到 RGBLCD或者显示设备。</p><p>fb 是一种机制，将系统中所有跟显示有关的硬件以及软件集合起来，虚拟出一个 fb 设备，当我们编写好 LCD 驱动以后会生成一个名为&#x2F;dev&#x2F;fbX(X&#x3D;0~n)的设备，应用程序通过访问&#x2F;dev&#x2F;fbX 这个设备就可以访问 LCD。</p><p>NXP 官方的 Linux 内核默认已经开启了 LCD 驱动，因此我们是可以看到&#x2F;dev&#x2F;fb0 这样一个设备，如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829171727766.png" alt="image-20200829171727766"></p><p>图中的&#x2F;dev&#x2F;fb0 就是 LCD 对应的设备文件，&#x2F;dev&#x2F;fb0 是个字符设备，因此肯定有file_operations 操作集，fb 的 file_operations 操作集定义在 drivers&#x2F;video&#x2F;fbdev&#x2F;core&#x2F;fbmem.c 文件中，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1495</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">fb_fops</span> =</span> &#123;<span class="hljs-number">1496</span> .owner = THIS_MODULE,<span class="hljs-number">1497</span> .read = fb_read,<span class="hljs-number">1498</span> .write = fb_write,<span class="hljs-number">1499</span> .unlocked_ioctl = fb_ioctl,<span class="hljs-number">1500</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><span class="hljs-number">1501</span> .compat_ioctl = fb_compat_ioctl,<span class="hljs-number">1502</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-number">1503</span> .mmap = fb_mmap,<span class="hljs-number">1504</span> .open = fb_open,<span class="hljs-number">1505</span> .release = fb_release,<span class="hljs-number">1506</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_ARCH_FB_UNMAPPED_AREA</span><span class="hljs-number">1507</span> .get_unmapped_area = get_fb_unmapped_area,<span class="hljs-number">1508</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-number">1509</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FB_DEFERRED_IO</span><span class="hljs-number">1510</span> .fsync = fb_deferred_io_fsync,<span class="hljs-number">1511</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-number">1512</span> .llseek = default_llseek,<span class="hljs-number">1513</span> &#125;;</code></pre></div><p>关于 fb 的详细处理过程就不去深究了，本章我们的重点是驱动起来 ALPHA 开发板上的LCD。</p><h3 id="2-LCD-驱动简析"><a href="#2-LCD-驱动简析" class="headerlink" title="2| LCD  驱动简析"></a>2| LCD  驱动简析</h3><p>LCD 裸机例程主要分两部分：<br>①、获取 LCD 的屏幕参数。<br>②、根据屏幕参数信息来初始化 eLCDIF 接口控制器。</p><p>不同分辨率的 LCD 屏幕其 eLCDIF 控制器驱动代码都是一样的，只需要修改好对应的屏幕参数即可。屏幕参数信息属于屏幕设备信息内容，这些肯定是要放到设备树中的，因此我们本章实验的主要工作就是修改设备树，NXP 官方的设备树已经添加了 LCD 设备节点，只是此节点的 LCD 屏幕信息是针对 NXP 官方 EVK 开发板所使用的 4.3 寸 480*272 编写的，我们需要将其改为我们所使用的屏幕参数。</p><p>我们简单看一下 NXP 官方编写的 Linux 下的 LCD 驱动，打开 imx6ull.dtsi，然后找到 lcdif节点内容，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> lcdif: lcdif@<span class="hljs-number">021</span>c8000 &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-lcdif&quot;</span>, <span class="hljs-string">&quot;fsl,imx28-lcdif&quot;</span>;<span class="hljs-number">3</span> reg = &lt;<span class="hljs-number">0x021c8000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">4</span> interrupts = &lt;GIC_SPI <span class="hljs-number">5</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-number">5</span> clocks = &lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;,<span class="hljs-number">6</span>  &lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;,<span class="hljs-number">7</span>  &lt;&amp;clks IMX6UL_CLK_DUMMY&gt;;<span class="hljs-number">8</span> clock-names = <span class="hljs-string">&quot;pix&quot;</span>, <span class="hljs-string">&quot;axi&quot;</span>, <span class="hljs-string">&quot;disp_axi&quot;</span>;<span class="hljs-number">9</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<span class="hljs-number">10</span> &#125;;</code></pre></div><p>示例代码中的 lcdif 节点信息是所有使用 I.MX6ULL 芯片的板子所共有的，并不是完整的 lcdif 节点信息。</p><p>像屏幕参数这些需要根据不同的硬件平台去添加，比如向 imx6ull-lxg-emmc.dts 中的 lcdif 节点添加其他的属性信息。从示例代码可以看出 lcdif 节点的 compatible 属性值为“fsl,imx6ul-lcdif”和“fsl,imx28-lcdi”，因此在 Linux 源码中搜索这两个字符串即可找到 I.MX6ULL 的 LCD 驱动文件，这个文件为 drivers&#x2F;video&#x2F;fbdev&#x2F;mxsfb.c，mxsfb.c就是 I.MX6ULL 的 LCD 驱动文件，在此文件中找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1362</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">mxsfb_dt_ids</span>[] =</span> &#123;<span class="hljs-number">1363</span> &#123; .compatible = <span class="hljs-string">&quot;fsl,imx23-lcdif&quot;</span>, .data = &amp;mxsfb_devtype[<span class="hljs-number">0</span>], &#125;,<span class="hljs-number">1364</span> &#123; .compatible = <span class="hljs-string">&quot;fsl,imx28-lcdif&quot;</span>, .data = &amp;mxsfb_devtype[<span class="hljs-number">1</span>], &#125;,<span class="hljs-number">1365</span> &#123; <span class="hljs-comment">/* sentinel */</span> &#125;<span class="hljs-number">1366</span> &#125;;......<span class="hljs-number">1625</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">mxsfb_driver</span> =</span> &#123;<span class="hljs-number">1626</span> .probe = mxsfb_probe,<span class="hljs-number">1627</span> .remove = mxsfb_remove,<span class="hljs-number">1628</span> .shutdown = mxsfb_shutdown,<span class="hljs-number">1629</span> .id_table = mxsfb_devtype,<span class="hljs-number">1630</span> .driver = &#123;<span class="hljs-number">1631</span> .name = DRIVER_NAME,<span class="hljs-number">1632</span> .of_match_table = mxsfb_dt_ids,<span class="hljs-number">1633</span> .pm = &amp;mxsfb_pm_ops,<span class="hljs-number">1634</span> &#125;,<span class="hljs-number">1635</span> &#125;;<span class="hljs-number">1636</span><span class="hljs-number">1637</span> module_platform_driver(mxsfb_driver);</code></pre></div><p>从示例代码 可以看出，这是一个标准的 platform 驱动，当驱动和设备匹配以后mxsfb_probe 函数就会执行。在看 mxsfb_probe 函数之前我们先简单了解一下 Linux 下Framebuffer 驱动的编写流程，Linux 内核将所有的 Framebuffer 抽象为一个叫做 fb_info 的结构体，fb_info 结构体包含了 Framebuffer 设备的完整属性和操作集合，因此每一个 Framebuffer 设备都必须有一个 fb_info。换言之就是，LCD 的驱动就是构建 fb_info，并且向系统注册 fb_info的过程。fb_info 结构体定义在 include&#x2F;linux&#x2F;fb.h 文件里面，内容如下(省略掉条件编译)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">448</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_info</span> &#123;</span><span class="hljs-number">449</span> <span class="hljs-type">atomic_t</span> count;<span class="hljs-number">450</span> <span class="hljs-type">int</span> node;<span class="hljs-number">451</span> <span class="hljs-type">int</span> flags;<span class="hljs-number">452</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">/* 互斥锁 */</span><span class="hljs-number">453</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mm_lock</span>;</span> <span class="hljs-comment">/* 互斥锁，用于 fb_mmap 和 smem_*域*/</span><span class="hljs-number">454</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_var_screeninfo</span> <span class="hljs-title">var</span>;</span> <span class="hljs-comment">/* 当前可变参数 */</span><span class="hljs-number">455</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_fix_screeninfo</span> <span class="hljs-title">fix</span>;</span> <span class="hljs-comment">/* 当前固定参数 */</span><span class="hljs-number">456</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_monspecs</span> <span class="hljs-title">monspecs</span>;</span>  <span class="hljs-comment">/* 当前显示器特性 */</span><span class="hljs-number">457</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">queue</span>;</span> <span class="hljs-comment">/* 帧缓冲事件队列 */</span><span class="hljs-number">458</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_pixmap</span> <span class="hljs-title">pixmap</span>;</span> <span class="hljs-comment">/* 图像硬件映射 */</span><span class="hljs-number">459</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_pixmap</span> <span class="hljs-title">sprite</span>;</span> <span class="hljs-comment">/* 光标硬件映射 */</span><span class="hljs-number">460</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_cmap</span> <span class="hljs-title">cmap</span>;</span> <span class="hljs-comment">/* 当前调色板 */</span><span class="hljs-number">461</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">modelist</span>;</span> <span class="hljs-comment">/* 当前模式列表 */</span><span class="hljs-number">462</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_videomode</span> *<span class="hljs-title">mode</span>;</span> <span class="hljs-comment">/* 当前视频模式 */</span><span class="hljs-number">463</span><span class="hljs-number">464</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FB_BACKLIGHT <span class="hljs-comment">/* 如果 LCD 支持背光的话 */</span></span><span class="hljs-number">465</span> <span class="hljs-comment">/* assigned backlight device */</span><span class="hljs-number">466</span> <span class="hljs-comment">/* set before framebuffer registration,</span><span class="hljs-comment">467    remove after unregister */</span><span class="hljs-number">468</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">backlight_device</span> *<span class="hljs-title">bl_dev</span>;</span>  <span class="hljs-comment">/* 背光设备 */</span><span class="hljs-number">469</span><span class="hljs-number">470</span> <span class="hljs-comment">/* Backlight level curve */</span><span class="hljs-number">471</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">bl_curve_mutex</span>;</span><span class="hljs-number">472</span> u8 bl_curve[FB_BACKLIGHT_LEVELS];<span class="hljs-number">473</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>......<span class="hljs-number">479</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_ops</span> *<span class="hljs-title">fbops</span>;</span> <span class="hljs-comment">/* 帧缓冲操作函数集 */</span><span class="hljs-number">480</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 父设备 */</span><span class="hljs-number">481</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span> <span class="hljs-comment">/* 当前 fb 设备 */</span><span class="hljs-number">482</span> <span class="hljs-type">int</span> class_flag; <span class="hljs-comment">/* 私有 sysfs 标志 */</span>......<span class="hljs-number">486</span> <span class="hljs-type">char</span> __iomem *screen_base; <span class="hljs-comment">/* 虚拟内存基地址(屏幕显存) */</span><span class="hljs-number">487</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> screen_size; <span class="hljs-comment">/* 虚拟内存大小(屏幕显存大小) */</span><span class="hljs-number">488</span> <span class="hljs-type">void</span> *pseudo_palette; <span class="hljs-comment">/* 伪 16 位调色板 */</span>......<span class="hljs-number">507</span> &#125;;</code></pre></div><p>fb_info 结构体的成员变量很多，我们重点关注 var、fix、fbops、screen_base、screen_size和 pseudo_palette。</p><p>mxsfb_probe 函数的主要工作内容为：</p><p>①、申请 fb_info。<br>②、初始化 fb_info 结构体中的各个成员变量。<br>③、初始化 eLCDIF 控制器。<br>④、使用 register_framebuffer 函数向 Linux 内核注册初始化好的 fb_info。</p><p>register_framebuffer函数原型如下：</p><ul><li><div class="hljs code-wrapper"><pre><code class="hljs">int register_framebuffer(struct fb_info *fb_info)<pre><code class="hljs yaml">  <span class="hljs-string">函数参数和返回值含义如下：</span>  <span class="hljs-string">**fb_info**：需要上报的</span> <span class="hljs-string">fb_info。</span>  <span class="hljs-string">**返回值**：0，成功；负值，失败。</span><span class="hljs-meta">---</span><span class="hljs-meta"></span><span class="hljs-string">接下来我们简单看一下</span> <span class="hljs-string">mxsfb_probe</span> <span class="hljs-string">函数，函数内容如下(有缩减)：</span><span class="hljs-string">```c</span><span class="hljs-number">1369 </span><span class="hljs-string">static</span> <span class="hljs-string">int</span> <span class="hljs-string">mxsfb_probe(struct</span> <span class="hljs-string">platform_device</span> <span class="hljs-string">*pdev)</span><span class="hljs-number">1370</span> &#123;<span class="hljs-number">1371 </span><span class="hljs-string">const</span> <span class="hljs-string">struct</span> <span class="hljs-string">of_device_id</span> <span class="hljs-string">*of_id</span> <span class="hljs-string">=</span><span class="hljs-number">1372 </span><span class="hljs-string">of_match_device(mxsfb_dt_ids</span>, <span class="hljs-string">&amp;pdev-&gt;dev);</span><span class="hljs-number">1373 </span><span class="hljs-string">struct</span> <span class="hljs-string">resource</span> <span class="hljs-string">*res;</span><span class="hljs-number">1374 </span><span class="hljs-string">struct</span> <span class="hljs-string">mxsfb_info</span> <span class="hljs-string">*host;</span><span class="hljs-number">1375 </span><span class="hljs-string">struct</span> <span class="hljs-string">fb_info</span> <span class="hljs-string">*fb_info;</span><span class="hljs-number">1376 </span><span class="hljs-string">struct</span> <span class="hljs-string">pinctrl</span> <span class="hljs-string">*pinctrl;</span><span class="hljs-number">1377 </span><span class="hljs-string">int</span> <span class="hljs-string">irq</span> <span class="hljs-string">=</span> <span class="hljs-string">platform_get_irq(pdev</span>, <span class="hljs-number">0</span><span class="hljs-string">);</span><span class="hljs-number">1378 </span><span class="hljs-string">int</span> <span class="hljs-string">gpio</span>, <span class="hljs-string">ret;</span><span class="hljs-number">1379</span><span class="hljs-string">......</span><span class="hljs-number">1394</span><span class="hljs-number">1395 </span><span class="hljs-string">res</span> <span class="hljs-string">=</span> <span class="hljs-string">platform_get_resource(pdev</span>, <span class="hljs-string">IORESOURCE_MEM</span>, <span class="hljs-number">0</span><span class="hljs-string">);</span><span class="hljs-number">1396 </span><span class="hljs-string">if</span> <span class="hljs-string">(!res)</span> &#123;<span class="hljs-number">1397 </span><span class="hljs-string">dev_err(&amp;pdev-&gt;dev</span>, <span class="hljs-string">&quot;Cannot get memory IO resource\n&quot;</span><span class="hljs-string">);</span><span class="hljs-number">1398 </span><span class="hljs-string">return</span> <span class="hljs-string">-ENODEV;</span><span class="hljs-number">1399</span> &#125;<span class="hljs-number">1400</span><span class="hljs-number">1401 </span><span class="hljs-string">host</span> <span class="hljs-string">=</span> <span class="hljs-string">devm_kzalloc(&amp;pdev-&gt;dev</span>, <span class="hljs-string">sizeof(struct</span> <span class="hljs-string">mxsfb_info)</span>, <span class="hljs-string">GFP_KERNEL);</span><span class="hljs-number">1402 </span><span class="hljs-string">if</span> <span class="hljs-string">(!host)</span> &#123;<span class="hljs-number">1403 </span><span class="hljs-string">dev_err(&amp;pdev-&gt;dev</span>, <span class="hljs-string">&quot;Failed to allocate IO resource\n&quot;</span><span class="hljs-string">);</span><span class="hljs-number">1404 </span><span class="hljs-string">return</span> <span class="hljs-string">-ENOMEM;</span><span class="hljs-number">1405</span> &#125;<span class="hljs-number">1406</span><span class="hljs-number">1407 </span><span class="hljs-string">fb_info</span> <span class="hljs-string">=</span> <span class="hljs-string">framebuffer_alloc(sizeof(struct</span> <span class="hljs-string">fb_info)</span>, <span class="hljs-string">&amp;pdev-&gt;dev);</span><span class="hljs-number">1408 </span><span class="hljs-string">if</span> <span class="hljs-string">(!fb_info)</span> &#123;<span class="hljs-number">1409 </span><span class="hljs-string">dev_err(&amp;pdev-&gt;dev</span>, <span class="hljs-string">&quot;Failed to allocate fbdev\n&quot;</span><span class="hljs-string">);</span><span class="hljs-number">1410 </span><span class="hljs-string">devm_kfree(&amp;pdev-&gt;dev</span>, <span class="hljs-string">host);</span><span class="hljs-number">1411 </span><span class="hljs-string">return</span> <span class="hljs-string">-ENOMEM;</span><span class="hljs-number">1412</span> &#125;<span class="hljs-number">1413 </span><span class="hljs-string">host-&gt;fb_info</span> <span class="hljs-string">=</span> <span class="hljs-string">fb_info;</span><span class="hljs-number">1414 </span><span class="hljs-string">fb_info-&gt;par</span> <span class="hljs-string">=</span> <span class="hljs-string">host;</span><span class="hljs-number">1415</span><span class="hljs-number">1416 </span><span class="hljs-string">ret</span> <span class="hljs-string">=</span> <span class="hljs-string">devm_request_irq(&amp;pdev-&gt;dev</span>, <span class="hljs-string">irq</span>, <span class="hljs-string">mxsfb_irq_handler</span>, <span class="hljs-number">0</span>,<span class="hljs-number">1417 </span><span class="hljs-string">dev_name(&amp;pdev-&gt;dev)</span>, <span class="hljs-string">host);</span><span class="hljs-number">1418 </span><span class="hljs-string">if</span> <span class="hljs-string">(ret)</span> &#123;<span class="hljs-number">1419 </span><span class="hljs-string">dev_err(&amp;pdev-&gt;dev</span>, <span class="hljs-string">&quot;request_irq (%d) failed with</span><span class="hljs-string">1420 error %d\n&quot;</span>, <span class="hljs-string">irq</span>, <span class="hljs-string">ret);</span><span class="hljs-number">1421 </span><span class="hljs-string">ret</span> <span class="hljs-string">=</span> <span class="hljs-string">-ENODEV;</span><span class="hljs-number">1422 </span><span class="hljs-string">goto</span> <span class="hljs-string">fb_release;</span><span class="hljs-number">1423</span> &#125;<span class="hljs-number">1424</span><span class="hljs-number">1425 </span><span class="hljs-string">host-&gt;base</span> <span class="hljs-string">=</span> <span class="hljs-string">devm_ioremap_resource(&amp;pdev-&gt;dev</span>, <span class="hljs-string">res);</span><span class="hljs-number">1426 </span><span class="hljs-string">if</span> <span class="hljs-string">(IS_ERR(host-&gt;base))</span> &#123;<span class="hljs-number">1427 </span><span class="hljs-string">dev_err(&amp;pdev-&gt;dev</span>, <span class="hljs-string">&quot;ioremap failed\n&quot;</span><span class="hljs-string">);</span><span class="hljs-number">1428 </span><span class="hljs-string">ret</span> <span class="hljs-string">=</span> <span class="hljs-string">PTR_ERR(host-&gt;base);</span><span class="hljs-number">1429 </span><span class="hljs-string">goto</span> <span class="hljs-string">fb_release;</span><span class="hljs-number">1430</span> &#125;<span class="hljs-string">......</span><span class="hljs-number">1461</span><span class="hljs-number">1462 </span><span class="hljs-string">fb_info-&gt;pseudo_palette</span> <span class="hljs-string">=</span> <span class="hljs-string">devm_kzalloc(&amp;pdev-&gt;dev</span>, <span class="hljs-string">sizeof(u32)</span> <span class="hljs-string">*</span><span class="hljs-number">1463 </span><span class="hljs-number">16</span>, <span class="hljs-string">GFP_KERNEL);</span><span class="hljs-number">1464 </span><span class="hljs-string">if</span> <span class="hljs-string">(!fb_info-&gt;pseudo_palette)</span> &#123;<span class="hljs-number">1465 </span><span class="hljs-string">ret</span> <span class="hljs-string">=</span> <span class="hljs-string">-ENOMEM;</span><span class="hljs-number">1466 </span><span class="hljs-string">goto</span> <span class="hljs-string">fb_release;</span><span class="hljs-number">1467</span> &#125;<span class="hljs-number">1468</span><span class="hljs-number">1469 </span><span class="hljs-string">INIT_LIST_HEAD(&amp;fb_info-&gt;modelist);</span><span class="hljs-number">1470</span><span class="hljs-number">1473 </span><span class="hljs-string">ret</span> <span class="hljs-string">=</span> <span class="hljs-string">mxsfb_init_fbinfo(host);</span><span class="hljs-number">1474 </span><span class="hljs-string">if</span> <span class="hljs-string">(ret</span> <span class="hljs-type">!=</span> <span class="hljs-number">0</span><span class="hljs-string">)</span><span class="hljs-number">1475 </span><span class="hljs-string">goto</span> <span class="hljs-string">fb_pm_runtime_disable;</span><span class="hljs-number">1476</span><span class="hljs-number">1477 </span><span class="hljs-string">mxsfb_dispdrv_init(pdev</span>, <span class="hljs-string">fb_info);</span><span class="hljs-number">1478</span><span class="hljs-number">1479 </span><span class="hljs-string">if</span> <span class="hljs-string">(!host-&gt;dispdrv)</span> &#123;<span class="hljs-number">1480 </span><span class="hljs-string">pinctrl</span> <span class="hljs-string">=</span> <span class="hljs-string">devm_pinctrl_get_select_default(&amp;pdev-&gt;dev);</span><span class="hljs-number">1481 </span><span class="hljs-string">if</span> <span class="hljs-string">(IS_ERR(pinctrl))</span> &#123;<span class="hljs-number">1482 </span><span class="hljs-string">ret</span> <span class="hljs-string">=</span> <span class="hljs-string">PTR_ERR(pinctrl);</span><span class="hljs-number">1483 </span><span class="hljs-string">goto</span> <span class="hljs-string">fb_pm_runtime_disable;</span><span class="hljs-number">1484</span> &#125;<span class="hljs-number">1485</span> &#125;<span class="hljs-number">1486</span><span class="hljs-number">1487 </span><span class="hljs-string">if</span> <span class="hljs-string">(!host-&gt;enabled)</span> &#123;<span class="hljs-number">1488 </span><span class="hljs-string">writel(0</span>, <span class="hljs-string">host-&gt;base</span> <span class="hljs-string">+</span> <span class="hljs-string">LCDC_CTRL);</span><span class="hljs-number">1489 </span><span class="hljs-string">mxsfb_set_par(fb_info);</span><span class="hljs-number">1490 </span><span class="hljs-string">mxsfb_enable_controller(fb_info);</span><span class="hljs-number">1491 </span><span class="hljs-string">pm_runtime_get_sync(&amp;host-&gt;pdev-&gt;dev);</span><span class="hljs-number">1492</span> &#125;<span class="hljs-number">1493</span><span class="hljs-number">1494 </span><span class="hljs-string">ret</span> <span class="hljs-string">=</span> <span class="hljs-string">register_framebuffer(fb_info);</span><span class="hljs-number">1495 </span><span class="hljs-string">if</span> <span class="hljs-string">(ret</span> <span class="hljs-type">!=</span> <span class="hljs-number">0</span><span class="hljs-string">)</span> &#123;<span class="hljs-number">1496 </span><span class="hljs-string">dev_err(&amp;pdev-&gt;dev</span>, <span class="hljs-string">&quot;Failed to register framebuffer\n&quot;</span><span class="hljs-string">);</span><span class="hljs-number">1497 </span><span class="hljs-string">goto</span> <span class="hljs-string">fb_destroy;</span><span class="hljs-number">1498</span> &#125;<span class="hljs-string">......</span><span class="hljs-number">1525 </span><span class="hljs-string">return</span> <span class="hljs-string">ret;</span><span class="hljs-number">1526</span> &#125;</code></pre></div></code></pre></li><li><p><strong>第 1374 行</strong>，host 结构体指针变量，表示 I.MX6ULL 的 LCD 的主控接口，mxsfb_info 结构体是 NXP 定义的针对 I.MX 系列 SOC 的 Framebuffer 设备结构体。也就是我们前面一直说的设备结构体，此结构体包含了 I.MX 系列 SOC 的 Framebuffer 设备详细信息，比如时钟、eLCDIF控制器寄存器基地址、fb_info 等。</p></li><li><p><strong>第 1395 行</strong>，从设备树中获取 eLCDIF 接口控制器的寄存器首地址，设备树中 lcdif 节点已经设置了 eLCDIF 寄存器首地址为 0X021C8000，因此 res&#x3D;0X021C8000。</p></li><li><p><strong>第 1401 行</strong>，给 host 申请内存，host 为 mxsfb_info 类型结构体指针。</p></li><li><p><strong>第 1407 行</strong>，给 fb_info 申请内存，也就是申请 fb_info。</p></li><li><p><strong>第 1413~1414 行</strong>，设置 host 的 fb_info 成员变量为 fb_info，设置 fb_info 的 par 成员变量为host。通过这一步就将前面申请的 host 和 fb_info 联系在了一起。</p></li><li><p><strong>第 1416 行</strong>，申请中断，中断服务函数为 mxsfb_irq_handler。</p></li><li><p><strong>第 1425 行</strong>，对从设备树中获取到的寄存器首地址(res)进行内存映射，得到虚拟地址，并保存到host 的 base 成员变量。因此通过访问 host 的 base 成员即可访问 I.MX6ULL 的整个 eLCDIF寄存器。其实在 mxsfb.c 中已经定义了 eLCDIF 各个寄存器相比于基地址的偏移值，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">67</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LCDC_CTRL 0x00</span><span class="hljs-number">68</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LCDC_CTRL1 0x10</span><span class="hljs-number">69</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LCDC_V4_CTRL2 0x20</span><span class="hljs-number">70</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LCDC_V3_TRANSFER_COUNT 0x20</span><span class="hljs-number">71</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LCDC_V4_TRANSFER_COUNT 0x30</span>......<span class="hljs-number">89</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LCDC_V4_DEBUG0 0x1d0</span><span class="hljs-number">90</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LCDC_V3_DEBUG0 0x1f0</span></code></pre></div><p>大家可以对比着《I.MX6ULL 参考手册》中的 eLCDIF 章节检查一下上述示例代码中的这些寄存器有没有错误。</p></li><li><p><strong>第1462行</strong>，给fb_info中的pseudo_palette申请内存。</p></li><li><p><strong>第 1473 行</strong>，调用 mxsfb_init_fbinfo 函数初始化 fb_info，重点是 fb_info 的 var、fix、fbops，screen_base 和 screen_size。其中 fbops 是 Framebuffer 设备的操作集，NXP 提供的 fbops 为mxsfb_ops，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">987</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_ops</span> <span class="hljs-title">mxsfb_ops</span> =</span> &#123;<span class="hljs-number">988</span> .owner = THIS_MODULE,<span class="hljs-number">989</span> .fb_check_var = mxsfb_check_var,<span class="hljs-number">990</span> .fb_set_par = mxsfb_set_par,<span class="hljs-number">991</span> .fb_setcolreg = mxsfb_setcolreg,<span class="hljs-number">992</span> .fb_ioctl = mxsfb_ioctl,<span class="hljs-number">993</span> .fb_blank = mxsfb_blank,<span class="hljs-number">994</span> .fb_pan_display = mxsfb_pan_display,<span class="hljs-number">995</span> .fb_mmap = mxsfb_mmap,<span class="hljs-number">996</span> .fb_fillrect = cfb_fillrect,<span class="hljs-number">997</span> .fb_copyarea = cfb_copyarea,<span class="hljs-number">998</span> .fb_imageblit = cfb_imageblit,<span class="hljs-number">999</span> &#125;;</code></pre></div><p>关于 mxsfb_ops 里面的各个操作函数这里就不去详解的介绍了。mxsfb_init_fbinfo 函数通过调用 mxsfb_init_fbinfo_dt 函数从设备树中获取到 LCD 的各个参数信息。最后，mxsfb_init_fbinfo函数会调用 mxsfb_map_videomem 函数申请 LCD 的帧缓冲内存(也就是显存)。</p></li><li><p><strong>第 1489~1490 行</strong>，设置 eLCDIF 控制器的相应寄存器。</p></li><li><p><strong>第 1494 行</strong>，最后调用 register_framebuffer 函数向 Linux 内核注册 fb_info。<br>mxsfb.c 文件很大，还有一些其他的重要函数，比如 mxsfb_remove、mxsfb_shutdown 等，<br>这里我们就简单的介绍了一下 mxsfb_probe 函数，至于其他的函数大家自行查阅。</p></li></ul><h2 id="二、硬件原理图分析"><a href="#二、硬件原理图分析" class="headerlink" title="二、硬件原理图分析"></a>二、硬件原理图分析</h2><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829173052061.png" alt="image-20200829173052061"></p><h2 id="三、-LCD-驱动程序编写"><a href="#三、-LCD-驱动程序编写" class="headerlink" title="三、 LCD  驱动程序编写"></a>三、 LCD  驱动程序编写</h2><p>前面已经说了，6ULL 的 eLCDIF 接口驱动程序 NXP 已经编写好了，因此 LCD 驱动部分我们不需要去修改。我们需要做的就是按照所使用的 LCD 来修改设备树。重点要注意三个地方：<br>①、LCD 所使用的 IO 配置。<br>②、LCD 屏幕节点修改，修改相应的属性值，换成我们所使用的 LCD 屏幕参数。<br>③、LCD 背光节点信息修改，要根据实际所使用的背光 IO 来修改相应的设备节点信息。</p><p>接下来我们依次来看一下上面这两个节点改如何去修改：</p><h3 id="1-LCD-屏幕-IO-配置"><a href="#1-LCD-屏幕-IO-配置" class="headerlink" title="1| LCD  屏幕 IO  配置"></a>1| LCD  屏幕 IO  配置</h3><p>首先要检查一下设备树中 LCD 所使用的 IO 配置，这个其实 NXP 都已经给我们写好了，不需要修改，不过我们还是要看一下。打开 imx6ull-lxg-emmc.dts 文件，在 iomuxc 节点中找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_lcdif_dat: lcdifdatgrp &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6UL_PAD_LCD_DATA00__LCDIF_DATA00 <span class="hljs-number">0x79</span><span class="hljs-number">4</span> MX6UL_PAD_LCD_DATA01__LCDIF_DATA01 <span class="hljs-number">0x79</span><span class="hljs-number">5</span> MX6UL_PAD_LCD_DATA02__LCDIF_DATA02 <span class="hljs-number">0x79</span><span class="hljs-number">6</span> MX6UL_PAD_LCD_DATA03__LCDIF_DATA03 <span class="hljs-number">0x79</span><span class="hljs-number">7</span> MX6UL_PAD_LCD_DATA04__LCDIF_DATA04 <span class="hljs-number">0x79</span><span class="hljs-number">8</span> MX6UL_PAD_LCD_DATA05__LCDIF_DATA05 <span class="hljs-number">0x79</span><span class="hljs-number">9</span> MX6UL_PAD_LCD_DATA06__LCDIF_DATA06 <span class="hljs-number">0x79</span><span class="hljs-number">10</span> MX6UL_PAD_LCD_DATA07__LCDIF_DATA07 <span class="hljs-number">0x79</span><span class="hljs-number">11</span> MX6UL_PAD_LCD_DATA08__LCDIF_DATA08 <span class="hljs-number">0x79</span><span class="hljs-number">12</span> MX6UL_PAD_LCD_DATA09__LCDIF_DATA09 <span class="hljs-number">0x79</span><span class="hljs-number">13</span> MX6UL_PAD_LCD_DATA10__LCDIF_DATA10 <span class="hljs-number">0x79</span><span class="hljs-number">14</span> MX6UL_PAD_LCD_DATA11__LCDIF_DATA11 <span class="hljs-number">0x79</span><span class="hljs-number">15</span> MX6UL_PAD_LCD_DATA12__LCDIF_DATA12 <span class="hljs-number">0x79</span><span class="hljs-number">16</span> MX6UL_PAD_LCD_DATA13__LCDIF_DATA13 <span class="hljs-number">0x79</span><span class="hljs-number">17</span> MX6UL_PAD_LCD_DATA14__LCDIF_DATA14 <span class="hljs-number">0x79</span><span class="hljs-number">18</span> MX6UL_PAD_LCD_DATA15__LCDIF_DATA15 <span class="hljs-number">0x79</span><span class="hljs-number">19</span> MX6UL_PAD_LCD_DATA16__LCDIF_DATA16 <span class="hljs-number">0x79</span><span class="hljs-number">20</span> MX6UL_PAD_LCD_DATA17__LCDIF_DATA17 <span class="hljs-number">0x79</span><span class="hljs-number">21</span> MX6UL_PAD_LCD_DATA18__LCDIF_DATA18 <span class="hljs-number">0x79</span><span class="hljs-number">22</span> MX6UL_PAD_LCD_DATA19__LCDIF_DATA19 <span class="hljs-number">0x79</span><span class="hljs-number">23</span> MX6UL_PAD_LCD_DATA20__LCDIF_DATA20 <span class="hljs-number">0x79</span><span class="hljs-number">24</span> MX6UL_PAD_LCD_DATA21__LCDIF_DATA21 <span class="hljs-number">0x79</span><span class="hljs-number">25</span> MX6UL_PAD_LCD_DATA22__LCDIF_DATA22 <span class="hljs-number">0x79</span><span class="hljs-number">26</span> MX6UL_PAD_LCD_DATA23__LCDIF_DATA23 <span class="hljs-number">0x79</span><span class="hljs-number">27</span> &gt;;<span class="hljs-number">28</span> &#125;;<span class="hljs-number">29</span><span class="hljs-number">30</span> pinctrl_lcdif_ctrl: lcdifctrlgrp &#123;<span class="hljs-number">31</span> fsl,pins = &lt;<span class="hljs-number">32</span> MX6UL_PAD_LCD_CLK__LCDIF_CLK <span class="hljs-number">0x79</span><span class="hljs-number">33</span> MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE <span class="hljs-number">0x79</span><span class="hljs-number">34</span> MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC <span class="hljs-number">0x79</span><span class="hljs-number">35</span> MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC <span class="hljs-number">0x79</span><span class="hljs-number">36</span> &gt;;<span class="hljs-number">37</span> pinctrl_pwm1: pwm1grp &#123;<span class="hljs-number">38</span> fsl,pins = &lt;<span class="hljs-number">39</span> MX6UL_PAD_GPIO1_IO08__PWM1_OUT <span class="hljs-number">0x110b0</span><span class="hljs-number">40</span> &gt;;<span class="hljs-number">41</span> &#125;;</code></pre></div><p>第 2~27 行，子节点 pinctrl_lcdif_dat，为 RGB LCD 的 24 根数据线配置项。</p><p>第 30~36 行，子节点 pinctrl_lcdif_ctrl，RGB LCD 的 4 根控制线配置项，包括 CLK、ENABLE、VSYNC 和 HSYNC。</p><p>第 37~40 行，子节点 pinctrl_pwm1，LCD 背光 PWM 引脚配置项。这个引脚要根据实际情况设置，这里我们建议大家在以后的学习或工作中，LCD 的背光 IO 尽量和半导体厂商的官方开发板一致。</p><h3 id="2-LCD-屏幕参数节点信息修改"><a href="#2-LCD-屏幕参数节点信息修改" class="headerlink" title="2| LCD  屏幕参数节点信息修改"></a>2| LCD  屏幕参数节点信息修改</h3><p>继续在 imx6ull-lxg-emmc.dts 文件中找到 lcdif 节点，节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;lcdif &#123;<span class="hljs-number">2</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">3</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_lcdif_dat <span class="hljs-comment">/* 使用到的 IO */</span><span class="hljs-number">4</span> &amp;pinctrl_lcdif_ctrl<span class="hljs-number">5</span> &amp;pinctrl_lcdif_reset&gt;;<span class="hljs-number">6</span> display = &lt;&amp;display0&gt;;<span class="hljs-number">7</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">8</span><span class="hljs-number">9</span> display0: display &#123; <span class="hljs-comment">/* LCD 属性信息 */</span><span class="hljs-number">10</span> bits-per-pixel = &lt;<span class="hljs-number">16</span>&gt;; <span class="hljs-comment">/* 一个像素占用几个 bit */</span><span class="hljs-number">11</span> bus-width = &lt;<span class="hljs-number">24</span>&gt;; <span class="hljs-comment">/* 总线宽度 */</span><span class="hljs-number">12</span><span class="hljs-number">13</span> display-timings &#123;<span class="hljs-number">14</span> native-mode = &lt;&amp;timing0&gt;; <span class="hljs-comment">/* 时序信息 */</span><span class="hljs-number">15</span> timing0: timing0 &#123;<span class="hljs-number">16</span> clock-frequency = &lt;<span class="hljs-number">9200000</span>&gt;; <span class="hljs-comment">/* LCD 像素时钟，单位 Hz */</span><span class="hljs-number">17</span> hactive = &lt;<span class="hljs-number">480</span>&gt;; <span class="hljs-comment">/* LCD X 轴像素个数 */</span><span class="hljs-number">18</span> vactive = &lt;<span class="hljs-number">272</span>&gt;; <span class="hljs-comment">/* LCD Y 轴像素个数 */</span><span class="hljs-number">19</span> hfront-porch = &lt;<span class="hljs-number">8</span>&gt;; <span class="hljs-comment">/* LCD hfp 参数 */</span><span class="hljs-number">20</span> hback-porch = &lt;<span class="hljs-number">4</span>&gt;; <span class="hljs-comment">/* LCD hbp 参数 */</span><span class="hljs-number">21</span> hsync-len = &lt;<span class="hljs-number">41</span>&gt;; <span class="hljs-comment">/* LCD hspw 参数 */</span><span class="hljs-number">22</span> vback-porch = &lt;<span class="hljs-number">2</span>&gt;; <span class="hljs-comment">/* LCD vbp 参数 */</span><span class="hljs-number">23</span> vfront-porch = &lt;<span class="hljs-number">4</span>&gt;; <span class="hljs-comment">/* LCD vfp 参数 */</span><span class="hljs-number">24</span> vsync-len = &lt;<span class="hljs-number">10</span>&gt;; <span class="hljs-comment">/* LCD vspw 参数 */</span><span class="hljs-number">25</span><span class="hljs-number">26</span> hsync-active = &lt;<span class="hljs-number">0</span>&gt;; <span class="hljs-comment">/* hsync 数据线极性 */</span><span class="hljs-number">27</span> vsync-active = &lt;<span class="hljs-number">0</span>&gt;; <span class="hljs-comment">/* vsync 数据线极性 */</span><span class="hljs-number">28</span> de-active = &lt;<span class="hljs-number">1</span>&gt;; <span class="hljs-comment">/* de 数据线极性 */</span><span class="hljs-number">29</span> pixelclk-active = &lt;<span class="hljs-number">0</span>&gt;; <span class="hljs-comment">/* clk 数据线先极性 */</span><span class="hljs-number">30</span> &#125;;<span class="hljs-number">31</span> &#125;;<span class="hljs-number">32</span> &#125;;<span class="hljs-number">33</span> &#125;;</code></pre></div><p>上述示例代码 就是向 imx6ull.dtsi 文件中的 lcdif 节点追加的内容，我们依次来看一下示例代码 中的这些属性都是写什么含义。</p><p><strong>第 3 行</strong>，pinctrl-0 属性，LCD 所使用的 IO 信息，这里用到了 <strong>pinctrl_lcdif_dat、pinctrl_lcdif_ctrl和 pinctrl_lcdif_reset</strong> 这三个 IO 相关的节点，pinctrl_lcdif_reset 是 LCD 复位 IO 信息节点，正点原子的 I.MX6U-ALPHA 开发板的 LCD 没有用到复位 IO，因此pinctrl_lcdif_reset 可以删除掉。</p><p><strong>第 6 行</strong>，display 属性，指定 LCD 属性信息所在的子节点，这里为 display0，下面就是display0子节点内容。</p><p><strong>第 9~32 行</strong>，display0 子节点，描述 LCD 的参数信息，第 10 行的 bits-per-pixel 属性用于指明一个像素占用的 bit 数，默认为 16bit。本教程我们将 LCD 配置为 RGB888 模式，因此一个像素点占用 24bit，bits-per-pixel 属性要改为 24。第 11 行的 bus-width 属性用于设置数据线宽度，因为要配置为 RGB888 模式，因此 bus-width 也要设置为 24。</p><p><strong>第 13~30 行</strong>，这几行非常重要！因为这几行设置了 LCD 的时序参数信息，NXP 官方的 EVK开发板使用了一个 4.3 寸的 480*272 屏幕，因此这里默认是按照 NXP 官方的那个屏幕参数设置的。每一个属性的含义后面的注释已经写的很详细了，大家自己去看就行了，这些时序参数就是我们重点要修改的，需要根据自己所使用的屏幕去修改。</p><p>这里以正点原子的 ATK7016(7 寸 1024*600)屏幕为例，将 imx6ull-lxg-emmc.dts 文件中的 lcdif 节点改为如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;lcdif &#123;<span class="hljs-number">2</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">3</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_lcdif_dat <span class="hljs-comment">/*  使用到的 IO */</span><span class="hljs-number">4</span> &amp;pinctrl_lcdif_ctrl&gt;;<span class="hljs-number">5</span> display = &lt;&amp;display0&gt;;<span class="hljs-number">6</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">7</span><span class="hljs-number">8</span> display0: display &#123; <span class="hljs-comment">/* LCD 属性信息 */</span><span class="hljs-number">9</span> bits-per-pixel = &lt;<span class="hljs-number">24</span>&gt;; <span class="hljs-comment">/*  一个像素占用 24bit  */</span><span class="hljs-number">10</span> bus-width = &lt;<span class="hljs-number">24</span>&gt;; <span class="hljs-comment">/* 总线宽度 */</span><span class="hljs-number">11</span><span class="hljs-number">12</span> display-timings &#123;<span class="hljs-number">13</span> native-mode = &lt;&amp;timing0&gt;; <span class="hljs-comment">/* 时序信息 */</span><span class="hljs-number">14</span> timing0: timing0 &#123;<span class="hljs-number">15</span> clock-frequency = &lt;<span class="hljs-number">51200000</span>&gt;; <span class="hljs-comment">/* LCD  像素时钟，单位 Hz */</span><span class="hljs-number">16</span> hactive = &lt;<span class="hljs-number">1024</span>&gt;; <span class="hljs-comment">/* LCD X  轴像素个数 */</span><span class="hljs-number">17</span> vactive = &lt;<span class="hljs-number">600</span>&gt;; <span class="hljs-comment">/* LCD Y  轴像素个数 */</span><span class="hljs-number">18</span> hfront-porch = &lt;<span class="hljs-number">160</span>&gt;; <span class="hljs-comment">/* LCD hfp  参数 */</span><span class="hljs-number">19</span> hback-porch = &lt;<span class="hljs-number">140</span>&gt;; <span class="hljs-comment">/* LCD hbp  参数 */</span><span class="hljs-number">20</span> hsync-len = &lt;<span class="hljs-number">20</span>&gt;; <span class="hljs-comment">/* LCD hspw  参数 */</span><span class="hljs-number">21</span> vback-porch = &lt;<span class="hljs-number">20</span>&gt;; <span class="hljs-comment">/* LCD vbp  参数 */</span><span class="hljs-number">22</span> vfront-porch = &lt;<span class="hljs-number">12</span>&gt;; <span class="hljs-comment">/* LCD vfp  参数 */</span><span class="hljs-number">23</span> vsync-len = &lt;<span class="hljs-number">3</span>&gt;; <span class="hljs-comment">/* LCD vspw  参数 */</span><span class="hljs-number">24</span><span class="hljs-number">25</span> hsync-active = &lt;<span class="hljs-number">0</span>&gt;; <span class="hljs-comment">/* hsync 数据线极性 */</span><span class="hljs-number">26</span> vsync-active = &lt;<span class="hljs-number">0</span>&gt;; <span class="hljs-comment">/* vsync 数据线极性 */</span><span class="hljs-number">27</span> de-active = &lt;<span class="hljs-number">1</span>&gt;; <span class="hljs-comment">/* de 数据线极性 */</span><span class="hljs-number">28</span> pixelclk-active = &lt;<span class="hljs-number">0</span>&gt;; <span class="hljs-comment">/* clk 数据线先极性 */</span><span class="hljs-number">29</span> &#125;;<span class="hljs-number">30</span> &#125;;<span class="hljs-number">31</span> &#125;;<span class="hljs-number">32</span> &#125;;</code></pre></div><p>第 3 行，设置 LCD 屏幕所使用的 IO，删除掉原来的 pinctrl_lcdif_reset，因为没有用到屏幕复位 IO，其他的 IO 不变。</p><p>第 9 行，使用 RGB888 模式，所以一个像素点是 24bit。</p><p>第 15~23 行，ATK7016 屏幕时序参数，根据自己所使用的屏幕修改即可。</p><h3 id="3-LCD-屏幕背光节点信息"><a href="#3-LCD-屏幕背光节点信息" class="headerlink" title="3| LCD  屏幕背光节点信息"></a>3| LCD  屏幕背光节点信息</h3><p>正点原子的 LCD 接口背光控制 IO 连接到了 I.MX6U 的 GPIO1_IO08 引脚上，GPIO1_IO08复用为 PWM1_OUT，通过 PWM 信号来控制 LCD 屏幕背光的亮度。正点原子 I.MX6U-ALPHA 开发板的 LCD 背光引脚和 NXP 官方 EVK 开发板的背光引脚一样，因此背光的设备树节点是不需要修改的，但是考虑到其他同学可能使用别的开发板或者屏幕，LCD 背光引脚和 NXP 官方 EVK 开发板可能不同，因此我们还是来看一下如何在设备树中添加背光节点信息。</p><p>先是 GPIO1_IO08 这个 IO 的配置，在 imx6ull-lxg-emmc.dts 中找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_pwm1: pwm1grp &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6UL_PAD_GPIO1_IO08__PWM1_OUT <span class="hljs-number">0x110b0</span><span class="hljs-number">4</span> &gt;;<span class="hljs-number">5</span> &#125;;</code></pre></div><p>pinctrl_pwm1 节点就是 GPIO1_IO08 的配置节点，从第 3 行可以看出，设置 GPIO1_IO08这个 IO 复用为 PWM1_OUT，并且设置电气属性值为 0x110b0。LCD 背光要用到 PWM1，因此也要设置 PWM1 节点，在 imx6ull.dtsi 文件中找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pwm1: pwm@<span class="hljs-number">02080000</span> &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-pwm&quot;</span>, <span class="hljs-string">&quot;fsl,imx27-pwm&quot;</span>;<span class="hljs-number">3</span> reg = &lt;<span class="hljs-number">0x02080000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">4</span> interrupts = &lt;GIC_SPI <span class="hljs-number">83</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-number">5</span> clocks = &lt;&amp;clks IMX6UL_CLK_PWM1&gt;,<span class="hljs-number">6</span>  &lt;&amp;clks IMX6UL_CLK_PWM1&gt;;<span class="hljs-number">7</span> clock-names = <span class="hljs-string">&quot;ipg&quot;</span>, <span class="hljs-string">&quot;per&quot;</span>;<span class="hljs-number">8</span> <span class="hljs-meta">#pwm-cells = <span class="hljs-string">&lt;2&gt;</span>;</span><span class="hljs-number">9</span> &#125;;</code></pre></div><p>imx6ull.dtsi 文件中的 pwm1 节点信息大家不要修改，如果要修改 pwm1 节点内容的话请在imx6ull-lxg-emmc.dts 文件中修改。</p><p>在整个 Linux 源码文件中搜索 compatible 属性的这两个值即可找到 imx6ull 的 pwm 驱动文件，imx6ull 的 PWM 驱动文件为 drivers&#x2F;pwm&#x2F;pwm-imx.c，这里我们就不详细的去分析这个文件了。</p><p>继续在 imx6ull-lxg-emmc.dts 文件中找到向 pwm1追加的内容，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;pwm1 &#123;<span class="hljs-number">2</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">3</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_pwm1&gt;;<span class="hljs-number">4</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">5</span> &#125;;</code></pre></div><p>第 3 行，设置 pwm1 所使用的 IO 为 pinctrl_pwm1，也就是示例代码所定义的GPIO1_IO08 这个 IO。<br>第 4 行，将 status 设置为 okay。</p><p>如果背光用的其他 pwm 通道，比如 pwm2，那么就需要仿照示例代码的内容，向pwm2 节点追加相应的内容。</p><p>pwm 和相关的 IO 已经准备好了，但是 Linux 系统怎么知道PWM1_OUT就是控制LCD背光的呢？因此我们还需要一个节点来将LCD背光和PWM1_OUT连接起来。这个节点就是 backlight，<strong>backlight节点描述</strong>可以参考<strong>Documentation&#x2F;devicetree&#x2F;indings&#x2F;video&#x2F;backlight&#x2F;pwm-backlight.txt</strong> 这个文档，此文档详细讲解了backlight 节点该如何去创建，这里大概总结一下：</p><ul><li>①、<strong>节点名称</strong>要为“backlight”。</li><li>②、节点的 <strong>compatible 属性</strong>值要为“pwm-backlight”，因此可以通过在 Linux 内核中搜索“ pwm-backlight ” 来查找PWM背光控制驱动程序，这个驱动程序文件为drivers&#x2F;video&#x2F;backlight&#x2F;pwm_bl.c，感兴趣的可以去看一下这个驱动程序。</li><li>③、<strong>pwms属性</strong>用于描述背光所使用的PWM以及PWM频率，比如本章我们要使用的pwm1，pwm 频率设置为 5KHz(NXP 官方推荐设置)。</li><li>④、<strong>brightness-levels 属性描述亮度级别</strong>，范围为 0~255，0 表示 PWM 占空比为 0%，也就是亮度最低，255 表示 100%占空比，也就是亮度最高。至于设置几级亮度，大家可以自行填写此属性。</li><li>⑤、default-brightness-level 属性为默认亮度级别。</li></ul><p>根据上述 5 点设置 backlight 节点，这个 NXP 已经给我们设置好了，大家在 imx6ull-lxg-emmc.dts 文件中找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> backlight &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;pwm-backlight&quot;</span>;<span class="hljs-number">3</span> pwms = &lt;&amp;pwm1 <span class="hljs-number">0</span> <span class="hljs-number">5000000</span>&gt;;<span class="hljs-number">4</span> brightness-levels = &lt;<span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span> <span class="hljs-number">128</span> <span class="hljs-number">255</span>&gt;;<span class="hljs-number">5</span> <span class="hljs-keyword">default</span>-brightness-level = &lt;<span class="hljs-number">6</span>&gt;;<span class="hljs-number">6</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">7</span> &#125;;</code></pre></div><ul><li>第 3 行，设置背光使用 pwm1，PWM 频率为 5KHz。</li><li>第 4 行，设置背 8 级背光(0~7)，分别为 0、4、8、16、32、64、128、255，对应占空比为0%、1.57%、3.13%、6.27%、12.55%、25.1%、50.19%、100%，如果嫌少的话可以自行添加一些其他的背光等级值。</li><li>第 5 行，设置默认背光等级为 6，也就是 50.19%的亮度。关于背光的设备树节点信息就讲到这里，整个的 LCD 设备树节点内容我们就讲完了，按照这些节点内容配置自己的开发板即可。</li></ul><h2 id="四、运行测试"><a href="#四、运行测试" class="headerlink" title="四、运行测试"></a>四、运行测试</h2><h3 id="1-LCD屏幕基本测试"><a href="#1-LCD屏幕基本测试" class="headerlink" title="1| LCD屏幕基本测试"></a>1| LCD屏幕基本测试</h3><h4 id="1-编译新的设备树"><a href="#1-编译新的设备树" class="headerlink" title="1.编译新的设备树"></a>1.编译新的设备树</h4><p>上一小节我们已经配置好了设备树，所以需要输入如下命令重新编译一下设备树：<br><code>make dtbs</code><br>等待编译生成新的 imx6ull-alientek-emmc.dtb 设备树文件，一会要使用新的设备树启动Linux 内核</p><h4 id="2-使能-Linux-logo-显示"><a href="#2-使能-Linux-logo-显示" class="headerlink" title="2.使能 Linux logo  显示"></a>2.使能 Linux logo  显示</h4><p>Linux 内核启动的时候可以选择显示小企鹅 logo，只要这个小企鹅 logo 显示没问题那么我们的 LCD 驱动基本就工作正常了。这个 logo 显示是要配置的，不过 Linux 内核一般都会默认开启 logo 显示，但是奔着学习的目的，我们还是来看一下如何使能 Linux logo 显示。打开 Linux内核图形化配置界面，按下路径找到对应的配置项：</p><div class="hljs code-wrapper"><pre><code class="hljs elm">-&gt; <span class="hljs-type">Device</span> <span class="hljs-type">Drivers</span>    -&gt; <span class="hljs-type">Graphics</span> sup<span class="hljs-keyword">port</span>        -&gt; <span class="hljs-type">Bootup</span> logo (<span class="hljs-type">LOGO</span> [=y])            -&gt; <span class="hljs-type">Standard</span> black and white <span class="hljs-type">Linux</span> logo            -&gt; <span class="hljs-type">Standard</span> <span class="hljs-number">16</span>-color <span class="hljs-type">Linux</span> logo            -&gt; <span class="hljs-type">Standard</span> <span class="hljs-number">224</span>-color <span class="hljs-type">Linux</span> logo</code></pre></div><p>如图 所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829175456646.png" alt="image-20200829175456646"></p><p>图 中这三个选项分别对应黑白、16 位、24 位色彩格式的 logo，我们把这三个都选中，都编译进 Linux 内核里面。设置好以后保存退出，重新编译 Linux 内核，编译完成以后使用新编译出来的 imx6ull-lxg-emmc.dtb 和 zImage 镜像启动系统，如果 LCD 驱动工作正常的话就会在 LCD 屏幕左上角出现一个彩色的小企鹅 logo，屏幕背景色为黑色，如图 所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829175529252.png" alt="image-20200829175529252"></p><h3 id="2-设置-LCD-作为终端控制台"><a href="#2-设置-LCD-作为终端控制台" class="headerlink" title="2| 设置 LCD  作为终端控制台"></a>2| 设置 LCD  作为终端控制台</h3><p>我们一直使用SecureCRT作为Linux开发板终端，开发板通过串口和SecureCRT进行通信。现在我们已经驱动起来 LCD 了，所以可以设置 LCD 作为终端，也就是开发板使用自己的显示设备作为自己的终端，然后接上键盘就可以直接在开发板上敲命令了(前提是USB驱动设置好)，将 LCD 设置为终端控制台的方法如下：</p><h4 id="1-、设置-uboot-中的-bootargs"><a href="#1-、设置-uboot-中的-bootargs" class="headerlink" title="1 、设置 uboot  中的 bootargs"></a>1 、设置 uboot  中的 bootargs</h4><p>重启开发板，进入 Linux 命令行，重新设置 bootargs 参数的 console 内容，命令如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> bootargs &#x27;console=tty1 console=ttymxc0,<span class="hljs-number">115200</span> root=/dev/nfs nfsroot=<span class="hljs-number">192.168.0.200</span>:/home/firestaradmin/linux/nfs/rootfs,proto=tcp rw ip=<span class="hljs-number">192.168.0.210:192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">200</span>:<span class="hljs-number">192.168.0.1:255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span>::eth0:<span class="hljs-literal">off</span>&#x27;</code></pre></div><p>注意分设置 console，这里我们设置了两遍 console，第一次设置 console&#x3D;tty1，也就是设置 LCD 屏幕为控制台，第二遍又设置 console&#x3D;ttymxc0,115200，也就是设置串口也作为控制台。相当于我们打开了两个 console，一个是 LCD，一个是串口，大家重启开发板就会发现 LCD 和串口都会显示 Linux 启动 log 信息。但是此时我们还不能使用 LCD 作为终端进行交互，因为我们的设置还未完成。</p><h4 id="2、修改-x2F-etc-x2F-inittab-文件"><a href="#2、修改-x2F-etc-x2F-inittab-文件" class="headerlink" title="2、修改&#x2F;etc&#x2F;inittab  文件"></a>2、修改&#x2F;etc&#x2F;inittab  文件</h4><p>打开开发板根文件系统中的&#x2F;etc&#x2F;inittab 文件，在里面加入下面这一行：</p><div class="hljs code-wrapper"><pre><code class="hljs arcade">tty1::askfirst:-<span class="hljs-regexp">/bin/</span>sh</code></pre></div><p>添加完成以后的&#x2F;etc&#x2F;inittab 文件内容如图  所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829180715010.png" alt="image-20200829180715010"></p><p>修改完成以后保存&#x2F;etc&#x2F;inittab 并退出，然后重启开发板，重启以后开发板 LCD 屏幕最后一行会显示下面一行语句：</p><div class="hljs code-wrapper"><pre><code class="hljs applescript">Please press Enter <span class="hljs-keyword">to</span> <span class="hljs-built_in">activate</span> this console.</code></pre></div><p>上述提示语句说的是：按下回车键使能当前终端，我们之前已经将 I.MX6U-ALPHA 开发板上的 KEY 按键注册为了回车键，因此按下开发板上的 KEY 按键即可使能 LCD这个终端。当然了，大家也可以接上一个 USB 键盘，Linux 内核默认已经使能了 USB 键盘驱动了，因此可以直接使用 USB 键盘。</p><p>至此，我们就拥有了两套终端，一个是基于串口的 SecureCRT，一个就是我们开发板的 LCD屏幕，但是为了方便调试，我们以后还是以 SecureCRT 为主。</p><p>我们可以通过下面这一行命令向LCD 屏幕输出“hello linux！”</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> hello linux &gt; /dev/tty1</code></pre></div><h3 id="3-LCD-背光调节"><a href="#3-LCD-背光调节" class="headerlink" title="3| LCD  背光调节"></a>3| LCD  背光调节</h3><p>背光设备树节点设置了 8 个等级的背光调节，可以设置为 0~7，我们可以通过设置背光等级来实现 LCD 背光亮度的调节，进入如下目录：</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/platform/</span>backlight<span class="hljs-regexp">/backlight/</span>backlight</code></pre></div><p>此目录下的文件如图 所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829181040258.png" alt="image-20200829181040258"></p><p>图中的 brightness 表示当前亮度等级，max_bgigntness 表示最大亮度等级。当前这两个文件内容如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/16%E3%80%81Linux_LCD%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200829181118422.png" alt="image-20200829181118422"></p><p>从图可以看出，当前屏幕亮度等级为 6，根据前面的分析可以，这个是 50%亮度。屏幕最大亮度等级为 7。如果我们要修改屏幕亮度，只需要向 brightness 写入需要设置的屏幕亮度等级即可。比如设置屏幕亮度等级为 7，那么可以使用如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> <span class="hljs-number">7</span> &gt; brightness</code></pre></div><p>输入上述命令以后就会发现屏幕亮度增大了，如果设置 brightness 为 0 的话就会关闭 LCD背光，屏幕就会熄灭。</p><h3 id="4-LCD-自动关闭解决方法"><a href="#4-LCD-自动关闭解决方法" class="headerlink" title="4| LCD  自动关闭解决方法"></a>4| LCD  自动关闭解决方法</h3><p>默认情况下 10 分钟以后 LCD 就会熄屏，这个并不是代码有问题，而是 Linux 内核设置的，就和我们用手机或者电脑一样，一段时间不操作的话屏幕就会熄灭，以节省电能。解决这个问题有多种方法，我们依次来看一下：</p><h4 id="1-按键盘唤醒"><a href="#1-按键盘唤醒" class="headerlink" title="1.按键盘唤醒"></a>1.按键盘唤醒</h4><p>最简单的就是按下回车键唤醒屏幕，我们在前面将 I.MX6U-ALPHA 开发板上的 KEY按键注册为了回车键，因此按下开发板上的 KEY 按键即可唤醒屏幕。如果开发板上没有按键的话可以外接 USB 键盘，然后按下 USB 键盘上的回车键唤醒屏幕。</p><h4 id="2-关闭-10-分钟熄屏功能"><a href="#2-关闭-10-分钟熄屏功能" class="headerlink" title="2.关闭 10  分钟熄屏功能"></a>2.关闭 10  分钟熄屏功能</h4><p>在 Linux 源码中找到 drivers&#x2F;tty&#x2F;vt&#x2F;vt.c 这个文件，在此文件中找到 blankinterval 变量，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">179</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> vesa_blank_mode;<span class="hljs-number">180</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> vesa_off_interval;<span class="hljs-number">181</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> blankinterval = <span class="hljs-number">10</span>*<span class="hljs-number">60</span>;</code></pre></div><p>blankinterval 变量控制着 LCD 关闭时间，默认是 10*60，也就是 10 分钟。将 blankinterval的值改为 0 即可关闭 10 分钟熄屏的功能，修改完成以后需要重新编译 Linux 内核，得到新的zImage，然后用新的 zImage 启动开发板。</p><h4 id="3-编写一个-APP-来关闭熄屏功能"><a href="#3-编写一个-APP-来关闭熄屏功能" class="headerlink" title="3.编写一个 APP  来关闭熄屏功能"></a>3.编写一个 APP  来关闭熄屏功能</h4><p>在 ubuntu 中新建一个名为 lcd_always_on.c 的文件，然后在里面输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><span class="hljs-number">4</span><span class="hljs-number">5</span><span class="hljs-number">6</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>7 &#123;<span class="hljs-number">8</span> <span class="hljs-type">int</span> fd;<span class="hljs-number">9</span> fd = open(<span class="hljs-string">&quot;/dev/tty1&quot;</span>, O_RDWR);<span class="hljs-number">10</span> write(fd, <span class="hljs-string">&quot;\033[9;0]&quot;</span>, <span class="hljs-number">8</span>);<span class="hljs-number">11</span> close(fd);<span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">13</span> &#125;</code></pre></div><p>使用如下命令编译 lcd_always_on.c 这个文件：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-gcc lcd_always_on.c -o lcd_always_on</code></pre></div><p>编译生成 lcd_always_on 以后将此可执行文件拷贝到开发板根文件系统的&#x2F;usr&#x2F;bin 目录中，然后给予可执行权限。设置 lcd_always_on 这个软件为开机自启动，打开&#x2F;etc&#x2F;init.d&#x2F;rcS，在此文件最后面加入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> cd /usr/bin<span class="hljs-number">2</span> ./lcd_always_on<span class="hljs-number">3</span> cd ..</code></pre></div><p>修改完成以后保存&#x2F;etc&#x2F;init.d&#x2F;rcS 文件，然后重启开发板即可。关于 Linux 下的 LCD 驱动我们就讲到这里。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17| Linux RTC驱动</title>
    <link href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/17%E3%80%81Linux_RTC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/17%E3%80%81Linux_RTC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-RTC驱动"><a href="#Linux-RTC驱动" class="headerlink" title="Linux RTC驱动"></a>Linux RTC驱动</h1><p>RTC 也就是实时时钟，用于记录当前系统时间，对于 Linux 系统而言时间是非常重要的，就和我们使用 Windows 电脑或手机查看时间一样，我们在使用 Linux 设备的时候也需要查看时间。本章我们就来学习一下如何编写 Linux 下的 RTC 驱动程序。</p><h2 id="1-Linux-内核-RTC-驱动简介"><a href="#1-Linux-内核-RTC-驱动简介" class="headerlink" title="1| Linux  内核 RTC  驱动简介"></a>1| Linux  内核 RTC  驱动简介</h2><p>RTC 设备驱动是一个标准的字符设备驱动，应用程序通过 open、release、read、write 和 ioctl等函数完成对 RTC 设备的操作，Linux 内核将 RTC 设备抽象为 rtc_device 结构体，因此 RTC 设备驱动就是申请并初始化 rtc_device，最后将 rtc_device 注册到 Linux 内核里面，这样 Linux 内核就有一个 RTC 设备的。</p><p>至于 RTC 设备的操作肯定是用一个操作集合(结构体)来表示的，我们先来看一下 rtc_device 结构体，此结构体定义在 include&#x2F;linux&#x2F;rtc.h 文件中，结构体内容如下(删除条件编译)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">104</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_device</span></span><span class="hljs-class">105 &#123;</span><span class="hljs-number">106</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span> <span class="hljs-comment">/* 设备 */</span><span class="hljs-number">107</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><span class="hljs-number">108</span><span class="hljs-number">109</span> <span class="hljs-type">int</span> id; <span class="hljs-comment">/* ID */</span><span class="hljs-number">110</span> <span class="hljs-type">char</span> name[RTC_DEVICE_NAME_SIZE]; <span class="hljs-comment">/* 名字 */</span><span class="hljs-number">111</span><span class="hljs-number">112</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_class_ops</span> *<span class="hljs-title">ops</span>;</span> <span class="hljs-comment">/* RTC 设备底层操作函数 */</span><span class="hljs-number">113</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">ops_lock</span>;</span><span class="hljs-number">114</span><span class="hljs-number">115</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">char_dev</span>;</span> <span class="hljs-comment">/* 字符设备 */</span><span class="hljs-number">116</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<span class="hljs-number">117</span><span class="hljs-number">118</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> irq_data;<span class="hljs-number">119</span> <span class="hljs-type">spinlock_t</span> irq_lock;<span class="hljs-number">120</span> <span class="hljs-type">wait_queue_head_t</span> irq_queue;<span class="hljs-number">121</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">async_queue</span>;</span><span class="hljs-number">122</span><span class="hljs-number">123</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_task</span> *<span class="hljs-title">irq_task</span>;</span><span class="hljs-number">124</span> <span class="hljs-type">spinlock_t</span> irq_task_lock;<span class="hljs-number">125</span> <span class="hljs-type">int</span> irq_freq;<span class="hljs-number">126</span> <span class="hljs-type">int</span> max_user_freq;<span class="hljs-number">127</span><span class="hljs-number">128</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerqueue_head</span> <span class="hljs-title">timerqueue</span>;</span><span class="hljs-number">129</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_timer</span> <span class="hljs-title">aie_timer</span>;</span><span class="hljs-number">130</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_timer</span> <span class="hljs-title">uie_rtctimer</span>;</span><span class="hljs-number">131</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hrtimer</span> <span class="hljs-title">pie_timer</span>;</span> <span class="hljs-comment">/* sub second exp, so needs hrtimer */</span><span class="hljs-number">132</span> <span class="hljs-type">int</span> pie_enabled;<span class="hljs-number">133</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">irqwork</span>;</span><span class="hljs-number">134</span> <span class="hljs-comment">/* Some hardware can&#x27;t support UIE mode */</span><span class="hljs-number">135</span> <span class="hljs-type">int</span> uie_unsupported;......<span class="hljs-number">147</span> &#125;;</code></pre></div><p>我们需要重点关注的是 ops 成员变量，这是一个 rtc_class_ops 类型的指针变量，rtc_class_ops为 RTC 设备的最底层操作函数集合，包括从 RTC 设备中读取时间、向 RTC 设备写入新的时间值等。因此，rtc_class_ops 是需要用户根据所使用的 RTC 设备编写的，此结构体定义在include&#x2F;linux&#x2F;rtc.h 文件中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">71</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_class_ops</span> &#123;</span><span class="hljs-number">72</span> <span class="hljs-type">int</span> (*open)(<span class="hljs-keyword">struct</span> device *);<span class="hljs-number">73</span> <span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> device *);<span class="hljs-number">74</span> <span class="hljs-type">int</span> (*ioctl)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<span class="hljs-number">75</span> <span class="hljs-type">int</span> (*read_time)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-keyword">struct</span> rtc_time *);<span class="hljs-number">76</span> <span class="hljs-type">int</span> (*set_time)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-keyword">struct</span> rtc_time *);<span class="hljs-number">77</span> <span class="hljs-type">int</span> (*read_alarm)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-keyword">struct</span> rtc_wkalrm *);<span class="hljs-number">78</span> <span class="hljs-type">int</span> (*set_alarm)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-keyword">struct</span> rtc_wkalrm *);<span class="hljs-number">79</span> <span class="hljs-type">int</span> (*proc)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-keyword">struct</span> seq_file *);<span class="hljs-number">80</span> <span class="hljs-type">int</span> (*set_mmss64)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-type">time64_t</span> secs);<span class="hljs-number">81</span> <span class="hljs-type">int</span> (*set_mmss)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> secs);<span class="hljs-number">82</span> <span class="hljs-type">int</span> (*read_callback)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-type">int</span> data);<span class="hljs-number">83</span> <span class="hljs-type">int</span> (*alarm_irq_enable)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> enabled);<span class="hljs-number">84</span> &#125;;</code></pre></div><p>看名字就知道 rtc_class_ops 操作集合中的这些函数是做什么的了，但是我们要注意，rtc_class_ops 中的这些函数只是最底层的 RTC 设备操作函数，并不是提供给应用层的file_operations 函数操作集。RTC 是个字符设备，那么肯定有字符设备的 file_operations 函数操作集，Linux 内核提供了一个 RTC 通用字符设备驱动文件，文件名为 drivers&#x2F;rtc&#x2F;rtc-dev.c，rtc-dev.c 文件提供了所有 RTC 设备共用的 file_operations 函数操作集，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">448</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">rtc_dev_fops</span> =</span> &#123;<span class="hljs-number">449</span> .owner = THIS_MODULE,<span class="hljs-number">450</span> .llseek = no_llseek,<span class="hljs-number">451</span> .read = rtc_dev_read,<span class="hljs-number">452</span> .poll = rtc_dev_poll,<span class="hljs-number">453</span> .unlocked_ioctl = rtc_dev_ioctl,<span class="hljs-number">454</span> .open = rtc_dev_open,<span class="hljs-number">455</span> .release = rtc_dev_release,<span class="hljs-number">456</span> .fasync = rtc_dev_fasync,<span class="hljs-number">457</span> &#125;;</code></pre></div><p>看到示例代码是不是很熟悉了，标准的字符设备操作集。应用程序可以通过 ioctl 函数来设置&#x2F;读取时间、设置&#x2F;读取闹钟的操作，那么对应的 rtc_dev_ioctl 函数就会执行，rtc_dev_ioctl 最终会通过操作 rtc_class_ops 中的 read_time、set_time 等函数来对具体 RTC 设备的读写操作。我们简单来看一下 rtc_dev_ioctl 函数，函数内容如下(有省略)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">218</span> <span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">rtc_dev_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file,</span><span class="hljs-params"><span class="hljs-number">219</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>220 &#123;<span class="hljs-number">221</span> <span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<span class="hljs-number">222</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_device</span> *<span class="hljs-title">rtc</span> =</span> file-&gt;private_data;<span class="hljs-number">223</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_class_ops</span> *<span class="hljs-title">ops</span> =</span> rtc-&gt;ops;<span class="hljs-number">224</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_time</span> <span class="hljs-title">tm</span>;</span><span class="hljs-number">225</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_wkalrm</span> <span class="hljs-title">alarm</span>;</span><span class="hljs-number">226</span> <span class="hljs-type">void</span> __user *uarg = (<span class="hljs-type">void</span> __user *) arg;<span class="hljs-number">227</span><span class="hljs-number">228</span> err = mutex_lock_interruptible(&amp;rtc-&gt;ops_lock);<span class="hljs-number">229</span> <span class="hljs-keyword">if</span> (err)<span class="hljs-number">230</span> <span class="hljs-keyword">return</span> err;......<span class="hljs-number">269</span> <span class="hljs-keyword">switch</span> (cmd) &#123;......<span class="hljs-number">333</span> <span class="hljs-keyword">case</span> RTC_RD_TIME: <span class="hljs-comment">/*  读取时间 */</span><span class="hljs-number">334</span> mutex_unlock(&amp;rtc-&gt;ops_lock);<span class="hljs-number">335</span><span class="hljs-number">336</span> err = rtc_read_time(rtc, &amp;tm);<span class="hljs-number">337</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<span class="hljs-number">338</span> <span class="hljs-keyword">return</span> err;<span class="hljs-number">339</span><span class="hljs-number">340</span> <span class="hljs-keyword">if</span> (copy_to_user(uarg, &amp;tm, <span class="hljs-keyword">sizeof</span>(tm)))<span class="hljs-number">341</span> err = -EFAULT;<span class="hljs-number">342</span> <span class="hljs-keyword">return</span> err;<span class="hljs-number">343</span><span class="hljs-number">344</span> <span class="hljs-keyword">case</span> RTC_SET_TIME: <span class="hljs-comment">/* 设置时间 */</span><span class="hljs-number">345</span> mutex_unlock(&amp;rtc-&gt;ops_lock);<span class="hljs-number">346</span><span class="hljs-number">347</span> <span class="hljs-keyword">if</span> (copy_from_user(&amp;tm, uarg, <span class="hljs-keyword">sizeof</span>(tm)))<span class="hljs-number">348</span> <span class="hljs-keyword">return</span> -EFAULT;<span class="hljs-number">349</span><span class="hljs-number">350</span> <span class="hljs-keyword">return</span> rtc_set_time(rtc, &amp;tm);......<span class="hljs-number">401</span> <span class="hljs-keyword">default</span>:<span class="hljs-number">402</span> <span class="hljs-comment">/* Finally try the driver&#x27;s ioctl interface */</span><span class="hljs-number">403</span> <span class="hljs-keyword">if</span> (ops-&gt;ioctl) &#123;<span class="hljs-number">404</span> err = ops-&gt;ioctl(rtc-&gt;dev.parent, cmd, arg);<span class="hljs-number">405</span> <span class="hljs-keyword">if</span> (err == -ENOIOCTLCMD)<span class="hljs-number">406</span> err = -ENOTTY;<span class="hljs-number">407</span> &#125; <span class="hljs-keyword">else</span><span class="hljs-number">408</span> err = -ENOTTY;<span class="hljs-number">409</span> <span class="hljs-keyword">break</span>;<span class="hljs-number">410</span> &#125;<span class="hljs-number">411</span><span class="hljs-number">412</span> done:<span class="hljs-number">413</span> mutex_unlock(&amp;rtc-&gt;ops_lock);<span class="hljs-number">414</span> <span class="hljs-keyword">return</span> err;<span class="hljs-number">415</span> &#125;</code></pre></div><p>第 333 行，RTC_RD_TIME 为时间读取命令。</p><p>第 336 行，如果是读取时间命令的话就调用 rtc_read_time 函数获取当前 RTC 时钟，rtc_read_time 函数，rtc_read_time 会调用__rtc_read_time 函数，__rtc_read_time 函数内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">23</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __rtc_read_time(<span class="hljs-keyword">struct</span> rtc_device *rtc, <span class="hljs-keyword">struct</span> rtc_time *tm)<span class="hljs-number">24</span> &#123;<span class="hljs-number">25</span> <span class="hljs-type">int</span> err;<span class="hljs-number">26</span> <span class="hljs-keyword">if</span> (!rtc-&gt;ops)<span class="hljs-number">27</span> err = -ENODEV;<span class="hljs-number">28</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!rtc-&gt;ops-&gt;read_time)<span class="hljs-number">29</span> err = -EINVAL;<span class="hljs-number">30</span> <span class="hljs-keyword">else</span> &#123;<span class="hljs-number">31</span> <span class="hljs-built_in">memset</span>(tm, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> rtc_time));<span class="hljs-number">32</span> err = rtc-&gt;ops-&gt;read_time(rtc-&gt;dev.parent, tm);<span class="hljs-number">33</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-number">34</span> dev_dbg(&amp;rtc-&gt;dev, <span class="hljs-string">&quot;read_time: fail to read: %d\n&quot;</span>,<span class="hljs-number">35</span> err);<span class="hljs-number">36</span> <span class="hljs-keyword">return</span> err;<span class="hljs-number">37</span> &#125;<span class="hljs-number">38</span><span class="hljs-number">39</span> err = rtc_valid_tm(tm);<span class="hljs-number">40</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<span class="hljs-number">41</span> dev_dbg(&amp;rtc-&gt;dev, <span class="hljs-string">&quot;read_time: rtc_time isn&#x27;t valid\n&quot;</span>);<span class="hljs-number">42</span> &#125;<span class="hljs-number">43</span> <span class="hljs-keyword">return</span> err;<span class="hljs-number">44</span> &#125;</code></pre></div><p>从示例代码 中的 32 行可以看出，__rtc_read_time 函数会通过调用 rtc_class_ops 中的read_time 来从 RTC 设备中获取当前时间。rtc_dev_ioctl 函数对其他的命令处理都是类似的，比如 RTC_ALM_READ 命令会通过 rtc_read_alarm 函数获取到闹钟值，而 rtc_read_alarm 函数经过层层调用，最终会调用rtc_class_ops 中的 read_alarm 函数来获取闹钟值。</p><p>至此，Linux 内核中 RTC 驱动调用流程就很清晰了，如图  所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/17%E3%80%81Linux_RTC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830121424825.png" alt="image-20200830121424825"></p><hr><p>当 rtc_class_ops 准备好以后需要将其<strong>注册到 Linux 内核</strong>中，这里我们可以使用rtc_device_register函数完成注册工作。此函数会申请一个rtc_device并且初始化这个rtc_device，最后向调用者返回这个rtc_device，此函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> rtc_device *<span class="hljs-title function_">rtc_device_register</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><span class="hljs-params">                                       <span class="hljs-keyword">struct</span> device *dev,</span><span class="hljs-params">                                       <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> rtc_class_ops *ops,</span><span class="hljs-params">                                       <span class="hljs-keyword">struct</span> module *owner)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>name</strong>：设备名字。<br><strong>dev</strong> ：设备。<br><strong>ops</strong> ：RTC 底层驱动函数集。<br><strong>owner</strong>：驱动模块拥有者。<br><strong>返回值</strong>：注册成功的话就返回 rtc_device，错误的话会返回一个负值。</p><hr><p>当<strong>卸载 RTC 驱动</strong>的时候需要调用 rtc_device_unregister 函数来注销注册的 rtc_device，函数型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rtc_device_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rtc_device *rtc)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>rtc</strong>：要删除的 rtc_device。<br><strong>返回值</strong>：无。</p><hr><p>还有另外一对 rtc_device 注册函数 devm_rtc_device_register 和 devm_rtc_device_unregister，分别为注册和注销 rtc_device。</p><hr><h2 id="2-I-MX6U-内部-RTC-驱动分析"><a href="#2-I-MX6U-内部-RTC-驱动分析" class="headerlink" title="2| I.MX6U  内部 RTC 驱动分析"></a>2| I.MX6U  内部 RTC 驱动分析</h2><p>先直接告诉大家，I.MX6U 的 RTC 驱动我们不用自己编写，因为 NXP 已经写好了。其实对于大多数的 SOC 来讲，内部 RTC 驱动都不需要我们去编写，半导体厂商会编写好。但是这不代表我们就偷懒了，虽然不用编写 RTC 驱动，但是我们得看一下这些原厂是怎么编写 RTC 驱动的。</p><p><strong>具体参考正点原子IMX6UL驱动开发手册 60.2节</strong></p><h2 id="3-RTC-时间查看与设置"><a href="#3-RTC-时间查看与设置" class="headerlink" title="3| RTC  时间查看与设置"></a>3| RTC  时间查看与设置</h2><h3 id="1-、时间-RTC-查看"><a href="#1-、时间-RTC-查看" class="headerlink" title="1 、时间 RTC 查看"></a>1 、时间 RTC 查看</h3><p>RTC 是用来计时的，因此最基本的就是查看时间，Linux 内核启动的时候可以看到系统时钟设置信息，如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/17%E3%80%81Linux_RTC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830141549858.png" alt="image-20200830141549858"></p><p>从图中可以看出，Linux 内核在启动的时候将 snvs_rtc 设置为 rtc0，大家的启动信息可能会和图中的不同，但是内容基本上都是一样的。如果要查看时间的话输入“date”命令即可，结果如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/17%E3%80%81Linux_RTC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830141816507.png" alt="image-20200830141816507"></p><p>从图可以看出，当前时间为 1970 年 1 月 1 日 00:01:19，很明显是时间不对，我们需要重新设置 RTC 时间。</p><h3 id="2-、设置-RTC-时间"><a href="#2-、设置-RTC-时间" class="headerlink" title="2 、设置 RTC  时间"></a>2 、设置 RTC  时间</h3><p>RTC 时间设置也是使用的 date 命令，输入“date –help”命令即可查看 date 命令如何设置系统时间，结果如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/17%E3%80%81Linux_RTC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830141914426.png" alt="image-20200830141914426"></p><p>现在我要设置当前时间为 2020年8月30日14:19:30，因此输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">date</span> -s <span class="hljs-string">&quot;2020-08-30 14:20:00&quot;</span></code></pre></div><p>设置完成以后再次使用 date 命令查看一下当前时间就会发现时间改过来了，如图 所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/17%E3%80%81Linux_RTC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830142017580.png" alt="image-20200830142017580"></p><p>大家注意我们使用“date -s”命令仅仅是将当前系统时间设置了，此时间还没有写入到I.MX6U 内部 RTC 里面或其他的 RTC 芯片里面，因此系统重启以后时间又会丢失。我们需要将当前的时间写入到 RTC 里面，这里要用到 hwclock 命令，输入如下命令将系统时间写入到 RTC里面：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">hwclock -w  //将当前系统时间写入到 RTC 里面</code></pre></div><p>时间写入到 RTC 里面以后就不怕系统重启以后时间丢失了，如果 I.MX6U-ALPHA 开发板底板接了纽扣电池，那么开发板即使断电了时间也不会丢失。大家可以尝试一下不断电重启和断电重启这两种情况下开发板时间会不会丢失。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18| Linux I2C驱动实验</title>
    <link href="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-I2C驱动实验"><a href="#Linux-I2C驱动实验" class="headerlink" title="Linux I2C驱动实验"></a>Linux I2C驱动实验</h1><p>I2C 是很常用的一个串行通信接口，用于连接各种外设、传感器等器件。本章我们来学习一下如何在 Linux 下开发 I2C 接口器件驱动，重点是学习 Linux 下的 I2C 驱动框架，按照指定的框架去编写 I2C 设备驱动。本章同样以 I.MX6U-ALPHA 开发板上的 AP3216C 这个三合一环境光传感器为例，通过 AP3216C 讲解一下如何编写 Linux 下的 I2C 设备驱动程序。</p><h2 id="1-Linux-I2C-驱动框架简介"><a href="#1-Linux-I2C-驱动框架简介" class="headerlink" title="1| Linux I2C  驱动框架简介"></a>1| Linux I2C  驱动框架简介</h2><p>想一下我们在裸机中是怎么编写 AP3216C 驱动的，我们编写了四个文件：bsp_i2c.c、bsp_i2c.h、bsp_ap3216c.c 和 bsp_ap3216c.h。</p><p>其中前两个是 I.MX6U 的 IIC 接口驱动，后两个文件是 AP3216C 这个 I2C 设备驱动文件。相当于有两部分驱动：<br>①、I2C 主机驱动。<br>②、I2C 设备驱动。</p><p>对于 I2C 主机驱动，一旦编写完成就不需要再做修改，其他的 I2C 设备直接调用主机驱动提供的 API 函数完成读写操作即可。这个正好符合 Linux 的驱动分离与分层的思想，因此 Linux内核也将 I2C 驱动分为两部分：</p><p>①、I2C 总线驱动，I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。<br>②、I2C 设备驱动，I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。</p><hr><h3 id="I2C-总线驱动"><a href="#I2C-总线驱动" class="headerlink" title="I2C  总线驱动"></a>I2C  总线驱动</h3><p>首先来看一下 I2C 总线，在讲 platform 的时候就说过，platform 是虚拟出来的一条总线，目的是为了实现总线、设备、驱动框架。</p><p>对于 I2C 而言，不需要虚拟出一条总线，直接使用 I2C总线即可。I2C 总线驱动重点是 I2C 适配器(也就是 SOC 的 I2C 接口控制器)驱动，这里要用到两个重要的数据结构：i2c_adapter 和 i2c_algorithm，Linux 内核将 SOC 的 I2C 适配器(控制器)抽象成 i2c_adapter，i2c_adapter 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">498</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> &#123;</span><span class="hljs-number">499</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><span class="hljs-number">500</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* classes to allow probing for */</span><span class="hljs-number">501</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> *<span class="hljs-title">algo</span>;</span> <span class="hljs-comment">/*  总线访问算法 */</span><span class="hljs-number">502</span> <span class="hljs-type">void</span> *algo_data;<span class="hljs-number">503</span><span class="hljs-number">504</span> <span class="hljs-comment">/* data fields that are valid for all devices */</span><span class="hljs-number">505</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mutex</span> <span class="hljs-title">bus_lock</span>;</span><span class="hljs-number">506</span><span class="hljs-number">507</span> <span class="hljs-type">int</span> timeout; <span class="hljs-comment">/* in jiffies */</span><span class="hljs-number">508</span> <span class="hljs-type">int</span> retries;<span class="hljs-number">509</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span> <span class="hljs-comment">/* the adapter device */</span><span class="hljs-number">510</span><span class="hljs-number">511</span> <span class="hljs-type">int</span> nr;<span class="hljs-number">512</span> <span class="hljs-type">char</span> name[<span class="hljs-number">48</span>];<span class="hljs-number">513</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> <span class="hljs-title">dev_released</span>;</span><span class="hljs-number">514</span><span class="hljs-number">515</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">userspace_clients_lock</span>;</span><span class="hljs-number">516</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">userspace_clients</span>;</span><span class="hljs-number">517</span><span class="hljs-number">518</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_bus_recovery_info</span> *<span class="hljs-title">bus_recovery_info</span>;</span><span class="hljs-number">519</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter_quirks</span> *<span class="hljs-title">quirks</span>;</span><span class="hljs-number">520</span> &#125;;</code></pre></div><p>第 501 行，i2c_algorithm 类型的指针变量 algo，对于一个 I2C 适配器，肯定要对外提供读写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。i2c_algorithm 就是 I2C 适配器与 IIC 设备进行通信的方法。<br>i2c_algorithm 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，内容如下(删除条件编译)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">391</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> &#123;</span>......<span class="hljs-number">398</span> <span class="hljs-type">int</span> (*master_xfer)(<span class="hljs-keyword">struct</span> i2c_adapter *adap, <span class="hljs-keyword">struct</span> i2c_msg *msgs,<span class="hljs-number">399</span>    <span class="hljs-type">int</span> num);<span class="hljs-number">400</span> <span class="hljs-type">int</span> (*smbus_xfer) (<span class="hljs-keyword">struct</span> i2c_adapter *adap, u16 addr,<span class="hljs-number">401</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags, <span class="hljs-type">char</span> read_write,<span class="hljs-number">402</span> u8 command, <span class="hljs-type">int</span> size, <span class="hljs-keyword">union</span> i2c_smbus_data *data);<span class="hljs-number">403</span><span class="hljs-number">404</span> <span class="hljs-comment">/* To determine what the adapter supports */</span><span class="hljs-number">405</span> u32 (*functionality) (<span class="hljs-keyword">struct</span> i2c_adapter *);......<span class="hljs-number">411</span> &#125;;</code></pre></div><ul><li>第 398 行，master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之间的通信。</li><li>第 400 行，smbus_xfer 就是 SMBUS 总线的传输函数。</li></ul><p>综上所述，I2C 总线驱动，或者说 I2C 适配器驱动的主要工作就是初始化 i2c_adapter 结构体变量，然后设置 i2c_algorithm 中的 master_xfer 函数。完成以后通过 i2c_add_numbered_adapter或 i2c_add_adapter 这两个函数向系统注册设置好的 i2c_adapter，这两个函数的原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter)</span><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_numbered_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adap)</span></code></pre></div><p>这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter使用静态总线号。函数参数和返回值含义如下：</p><ul><li><strong>adapter 或 或 adap</strong>：要添加到 Linux 内核中的 i2c_adapter，也就是 I2C 适配器。</li><li><strong>返回值</strong>：0，成功；负值，失败。</li></ul><p>如果要删除 I2C 适配器的话使用 i2c_del_adapter 函数即可，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_del_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter * adap)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>adap</strong>：要删除的 I2C 适配器。<br><strong>返回值</strong>：无。</p><p>关于 I2C 的总线(控制器或适配器)驱动就讲解到这里，一般 SOC 的 I2C 总线驱动都是由半导体厂商编写的，比如 I.MX6U 的 I2C 适配器驱动 NXP 已经编写好了，这个不需要用户去编写。因此 I2C 总线驱动对我们这些 SOC 使用者来说是被屏蔽掉的，我们只要专注于 I2C 设备驱动即可。除非你是在半导体公司上班，工作内容就是写 I2C 适配器驱动.</p><h3 id="I2C-设备驱动"><a href="#I2C-设备驱动" class="headerlink" title="I2C 设备驱动"></a>I2C 设备驱动</h3><p>I2C 设备驱动重点关注两个数据结构：i2c_client 和 i2c_driver，根据总线、设备和驱动模型，I2C 总线上一小节已经讲了。还剩下设备和驱动，i2c_client 就是描述设备信息的，i2c_driver 描述驱动内容，类似于 platform_driver。</p><h4 id="1、i2c-client-结构体"><a href="#1、i2c-client-结构体" class="headerlink" title="1、i2c_client 结构体"></a>1、i2c_client 结构体</h4><p>i2c_client 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">217</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> &#123;</span><span class="hljs-number">218</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags; <span class="hljs-comment">/* 标志 */</span><span class="hljs-number">219</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> addr; <span class="hljs-comment">/* 芯片地址，7 位，存在低 7 位 */</span>......<span class="hljs-number">222</span> <span class="hljs-type">char</span> name[I2C_NAME_SIZE]; <span class="hljs-comment">/* 名字 */</span><span class="hljs-number">223</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> *<span class="hljs-title">adapter</span>;</span> <span class="hljs-comment">/* 对应的 I2C 适配器 */</span><span class="hljs-number">224</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span> <span class="hljs-comment">/* 设备结构体 */</span><span class="hljs-number">225</span> <span class="hljs-type">int</span> irq; <span class="hljs-comment">/* 中断 */</span><span class="hljs-number">226</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">detected</span>;</span>......<span class="hljs-number">230</span> &#125;;</code></pre></div><p>一个设备对应一个 i2c_client，每检测到一个 I2C 设备就会给这个 I2C 设备分配一个i2c_client。</p><h4 id="2-、i2c-driver-结构体"><a href="#2-、i2c-driver-结构体" class="headerlink" title="2 、i2c_driver  结构体"></a>2 、i2c_driver  结构体</h4><p>i2c_driver 类似 platform_driver，是我们编写 I2C 设备驱动重点要处理的内容，i2c_driver 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">161</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> &#123;</span><span class="hljs-number">162</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span><span class="hljs-number">163</span><span class="hljs-number">164</span> <span class="hljs-comment">/* Notifies the driver that a new bus has appeared. You should</span><span class="hljs-comment">165 * avoid using this, it will be removed in a near future.</span><span class="hljs-comment">166 */</span><span class="hljs-number">167</span> <span class="hljs-type">int</span> (*attach_adapter)(<span class="hljs-keyword">struct</span> i2c_adapter *) __deprecated;<span class="hljs-number">168</span><span class="hljs-number">169</span> <span class="hljs-comment">/* Standard driver model interfaces */</span><span class="hljs-number">170</span> <span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> i2c_client *, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *);<span class="hljs-number">171</span> <span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> i2c_client *);<span class="hljs-number">172</span><span class="hljs-number">173</span> <span class="hljs-comment">/* driver model interfaces that don&#x27;t relate to enumeration */</span><span class="hljs-number">174</span> <span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> i2c_client *);<span class="hljs-number">175</span><span class="hljs-number">176</span> <span class="hljs-comment">/* Alert callback, for example for the SMBus alert protocol.</span><span class="hljs-comment">177 * The format and meaning of the data value depends on the</span><span class="hljs-comment">178 * protocol.For the SMBus alert protocol, there is a single bit</span><span class="hljs-comment">179 * of data passed as the alert response&#x27;s low bit (&quot;event</span><span class="hljs-comment">180 flag&quot;). */</span><span class="hljs-number">181</span> <span class="hljs-type">void</span> (*alert)(<span class="hljs-keyword">struct</span> i2c_client *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> data);<span class="hljs-number">182</span><span class="hljs-number">183</span> <span class="hljs-comment">/* a ioctl like command that can be used to perform specific</span><span class="hljs-comment">184 * functions with the device.</span><span class="hljs-comment">185 */</span><span class="hljs-number">186</span> <span class="hljs-type">int</span> (*command)(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">void</span> *arg);<span class="hljs-number">187</span><span class="hljs-number">188</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span><span class="hljs-number">189</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> *<span class="hljs-title">id_table</span>;</span><span class="hljs-number">190</span><span class="hljs-number">191</span> <span class="hljs-comment">/* Device detection callback for automatic device creation */</span><span class="hljs-number">192</span> <span class="hljs-type">int</span> (*detect)(<span class="hljs-keyword">struct</span> i2c_client *, <span class="hljs-keyword">struct</span> i2c_board_info *);<span class="hljs-number">193</span> <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *address_list;<span class="hljs-number">194</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">clients</span>;</span><span class="hljs-number">195</span> &#125;;</code></pre></div><ul><li>第 170 行，当 I2C 设备和驱动匹配成功以后 probe 函数就会执行，和 platform 驱动一样。</li><li>第 188 行，device_driver 驱动结构体，如果使用设备树的话，需要设置 device_driver 的of_match_table 成员变量，也就是驱动的兼容(compatible)属性。</li><li>第 189 行，id_table 是传统的、未使用设备树的设备匹配 ID 表。</li></ul><p>对于我们 I2C 设备驱动编写人来说，重点工作就是构建 i2c_driver，构建完成以后需要向Linux 内核注册这个 i2c_driver。</p><p>i2c_driver 注册函数为 int i2c_register_driver，此函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *owner,</span><span class="hljs-params">                        <span class="hljs-keyword">struct</span> i2c_driver *driver)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>owner</strong> ：一般为 THIS_MODULE。<br><strong>driver</strong>：要注册的 i2c_driver。<br><strong>返回值</strong>：0，成功；负值，失败。</p><p>另外 i2c_add_driver 也常常用于注册 i2c_driver，i2c_add_driver 是一个宏，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">587</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> i2c_add_driver(driver) \</span><span class="hljs-meta">588 i2c_register_driver(THIS_MODULE, driver)</span></code></pre></div><p>2c_add_driver 就是对 i2c_register_driver 做了一个简单的封装，只有一个参数，就是要注册的 i2c_driver。</p><p>注销 I2C 设备驱动的时候需要将前面注册的 i2c_driver 从 Linux 内核中注销掉，需要用到i2c_del_driver 函数，此函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_del_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_driver *driver)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>driver</strong>：要注销的 i2c_driver。<br><strong>返回值</strong>：无。</p><p>i2c_driver 的注册示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* i2c 驱动的 probe 函数 */</span><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>3 &#123;<span class="hljs-number">4</span> <span class="hljs-comment">/* 函数具体程序 */</span><span class="hljs-number">5</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">6</span> &#125;<span class="hljs-number">7</span><span class="hljs-number">8</span> <span class="hljs-comment">/* i2c 驱动的 remove 函数 */</span><span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span>10 &#123;<span class="hljs-number">11</span> <span class="hljs-comment">/* 函数具体程序 */</span><span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">13</span> &#125;<span class="hljs-number">14</span><span class="hljs-number">15</span> <span class="hljs-comment">/* 传统匹配方式 ID 列表 */</span><span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">xxx_id</span>[] =</span> &#123;<span class="hljs-number">17</span> &#123;<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">0</span>&#125;,<span class="hljs-number">18</span> &#123;&#125;<span class="hljs-number">19</span> &#125;;<span class="hljs-number">20</span><span class="hljs-number">21</span> <span class="hljs-comment">/* 设备树匹配列表 */</span><span class="hljs-number">22</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;<span class="hljs-number">23</span> &#123; .compatible = <span class="hljs-string">&quot;xxx&quot;</span> &#125;,<span class="hljs-number">24</span> &#123; <span class="hljs-comment">/* Sentinel */</span> &#125;<span class="hljs-number">25</span> &#125;;<span class="hljs-number">26</span><span class="hljs-number">27</span> <span class="hljs-comment">/* i2c 驱动结构体 */</span><span class="hljs-number">28</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">xxx_driver</span> =</span> &#123;<span class="hljs-number">29</span> .probe = xxx_probe,<span class="hljs-number">30</span> .remove = xxx_remove,<span class="hljs-number">31</span> .driver = &#123;<span class="hljs-number">32</span> .owner = THIS_MODULE,<span class="hljs-number">33</span> .name = <span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-number">34</span> .of_match_table = xxx_of_match,<span class="hljs-number">35</span> &#125;,<span class="hljs-number">36</span> .id_table = xxx_id,<span class="hljs-number">37</span> &#125;;<span class="hljs-number">38</span><span class="hljs-number">39</span> <span class="hljs-comment">/* 驱动入口函数 */</span><span class="hljs-number">40</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>41 &#123;<span class="hljs-number">42</span> <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-number">43</span><span class="hljs-number">44</span> ret = i2c_add_driver(&amp;xxx_driver);<span class="hljs-number">45</span> <span class="hljs-keyword">return</span> ret;<span class="hljs-number">46</span> &#125;<span class="hljs-number">47</span><span class="hljs-number">48</span> <span class="hljs-comment">/* 驱动出口函数 */</span><span class="hljs-number">49</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>50 &#123;<span class="hljs-number">51</span> i2c_del_driver(&amp;xxx_driver);<span class="hljs-number">52</span> &#125;<span class="hljs-number">53</span><span class="hljs-number">54</span> module_init(xxx_init);<span class="hljs-number">55</span> module_exit(xxx_exit);</code></pre></div><p>第 16<del>19 行，i2c_device_id，无设备树的时候匹配 ID 表。<br>第 22</del>25 行，of_device_id，设备树所使用的匹配表。<br>第 28~37 行，i2c_driver，当 I2C 设备和 I2C 驱动匹配成功以后 probe 函数就会执行，这些和 platform 驱动一样，probe 函数里面基本就是标准的字符设备驱动那一套了。</p><h3 id="3、I2C-设备和驱动匹配过程"><a href="#3、I2C-设备和驱动匹配过程" class="headerlink" title="3、I2C  设备和驱动匹配过程"></a>3、I2C  设备和驱动匹配过程</h3><p>I2C 设备和驱动的匹配过程是由 I2C 核心来完成的，drivers&#x2F;i2c&#x2F;i2c-core.c 就是 I2C 的核心部分，I2C 核心提供了一些与具体硬件无关的 API 函数，比如前面讲过的：</p><p><strong>1 、i2c_adapter  注册&#x2F; 注销函数</strong><br>int i2c_add_adapter(struct i2c_adapter *adapter)<br>int i2c_add_numbered_adapter(struct i2c_adapter *adap)<br>void i2c_del_adapter(struct i2c_adapter * adap)</p><p><strong>2 、i2c_driver  注册&#x2F; 注销函数</strong><br>int i2c_register_driver(struct module *owner, struct i2c_driver *driver)<br>int i2c_add_driver (struct i2c_driver *driver)<br>void i2c_del_driver(struct i2c_driver *driver)</p><p>设备和驱动的匹配过程也是由 I2C 总线完成的，I2C 总线的数据结构为 i2c_bus_type，定义在 drivers&#x2F;i2c&#x2F;i2c-core.c 文件，i2c_bus_type 内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">736</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">i2c_bus_type</span> =</span> &#123;<span class="hljs-number">737</span> .name = <span class="hljs-string">&quot;i2c&quot;</span>,<span class="hljs-number">738</span> .match = i2c_device_match,<span class="hljs-number">739</span> .probe = i2c_device_probe,<span class="hljs-number">740</span> .remove = i2c_device_remove,<span class="hljs-number">741</span> .shutdown = i2c_device_shutdown,<span class="hljs-number">742</span> &#125;;</code></pre></div><p>.match 就是 I2C 总线的设备和驱动匹配函数，在这里就是 i2c_device_match 这个函数，此函数内容如下</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">457</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_device_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span>458 &#123;<span class="hljs-number">459</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> i2c_verify_client(dev);<span class="hljs-number">460</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> *<span class="hljs-title">driver</span>;</span><span class="hljs-number">461</span><span class="hljs-number">462</span> <span class="hljs-keyword">if</span> (!client)<span class="hljs-number">463</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">464</span><span class="hljs-number">465</span> <span class="hljs-comment">/* Attempt an OF style match */</span><span class="hljs-number">466</span> <span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))<span class="hljs-number">467</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-number">468</span><span class="hljs-number">469</span> <span class="hljs-comment">/* Then ACPI style match */</span><span class="hljs-number">470</span> <span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))<span class="hljs-number">471</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-number">472</span><span class="hljs-number">473</span> driver = to_i2c_driver(drv);<span class="hljs-number">474</span> <span class="hljs-comment">/* match on an id table if there is one */</span><span class="hljs-number">475</span> <span class="hljs-keyword">if</span> (driver-&gt;id_table)<span class="hljs-number">476</span> <span class="hljs-keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="hljs-literal">NULL</span>;<span class="hljs-number">477</span><span class="hljs-number">478</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">479</span> &#125;</code></pre></div><ul><li>第 466 行，of_driver_match_device 函数用于完成设备树设备和驱动匹配。比较 I2C 设备节点的 compatible 属性和 of_device_id 中的 compatible 属性是否相等，如果相当的话就表示 I2C设备和驱动匹配。</li><li>第 470 行，acpi_driver_match_device 函数用于 ACPI 形式的匹配。</li><li>第 476 行，i2c_match_id 函数用于传统的、无设备树的 I2C 设备和驱动匹配过程。比较 I2C设备名字和 i2c_device_id 的 name 字段是否相等，相等的话就说明 I2C 设备和驱动匹配。</li></ul><h2 id="2-I-MX6U-的-的-I2C-适配器驱动分析"><a href="#2-I-MX6U-的-的-I2C-适配器驱动分析" class="headerlink" title="2| I.MX6U 的 的 I2C 适配器驱动分析"></a>2| I.MX6U 的 的 I2C 适配器驱动分析</h2><p>上一小节我们讲解了Linux 下的 I2C 驱动框架，重点分为 I2C 适配器驱动和 I2C 设备驱动，其中 I2C 适配器驱动就是 SOC 的 I2C 控制器驱动。I2C 设备驱动是需要用户根据不同的 I2C 设备去编写，而 I2C 适配器驱动一般都是 SOC 厂商去编写的，比如 NXP 就编写好了 I.MX6U 的I2C 适配器驱动。在 imx6ull.dtsi 文件中找到 I.MX6U 的 I2C1 控制器节点，节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<span class="hljs-number">2</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">3</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><span class="hljs-number">4</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<span class="hljs-number">5</span> reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">6</span> interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-number">7</span> clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<span class="hljs-number">8</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<span class="hljs-number">9</span> &#125;;</code></pre></div><p>重点关注 i2c1 节点的 compatible 属性值，因为通过 compatible 属性值可以在 Linux 源码里面找到对应的驱动文件。这里i2c1节点的compatible属性值有两个： “fsl,imx6ul-i2c”和“fsl,imx21-i2c”，在 Linux 源码中搜索这两个字符串即可找到对应的驱动文件。I.MX6U 的 I2C 适配器驱动驱动文件为drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-imx.c，在此文件中有如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">244</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> <span class="hljs-title">imx_i2c_devtype</span>[] =</span> &#123;<span class="hljs-number">245</span> &#123;<span class="hljs-number">246</span> .name = <span class="hljs-string">&quot;imx1-i2c&quot;</span>,<span class="hljs-number">247</span> .driver_data = (<span class="hljs-type">kernel_ulong_t</span>)&amp;imx1_i2c_hwdata,<span class="hljs-number">248</span> &#125;, &#123;<span class="hljs-number">249</span> .name = <span class="hljs-string">&quot;imx21-i2c&quot;</span>,<span class="hljs-number">250</span> .driver_data = (<span class="hljs-type">kernel_ulong_t</span>)&amp;imx21_i2c_hwdata,<span class="hljs-number">251</span> &#125;, &#123;<span class="hljs-number">252</span> <span class="hljs-comment">/* sentinel */</span><span class="hljs-number">253</span> &#125;<span class="hljs-number">254</span> &#125;;<span class="hljs-number">255</span> MODULE_DEVICE_TABLE(platform, imx_i2c_devtype);<span class="hljs-number">256</span><span class="hljs-number">257</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">i2c_imx_dt_ids</span>[] =</span> &#123;<span class="hljs-number">258</span> &#123; .compatible = <span class="hljs-string">&quot;fsl,imx1-i2c&quot;</span>, .data = &amp;imx1_i2c_hwdata, &#125;,<span class="hljs-number">259</span> &#123; .compatible = <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>, .data = &amp;imx21_i2c_hwdata, &#125;,<span class="hljs-number">260</span> &#123; .compatible = <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span>, .data = &amp;vf610_i2c_hwdata, &#125;,<span class="hljs-number">261</span> &#123; <span class="hljs-comment">/* sentinel */</span> &#125;<span class="hljs-number">262</span> &#125;;<span class="hljs-number">263</span> MODULE_DEVICE_TABLE(of, i2c_imx_dt_ids);......<span class="hljs-number">1119</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">i2c_imx_driver</span> =</span> &#123;<span class="hljs-number">1120</span> .probe = i2c_imx_probe,<span class="hljs-number">1121</span> .remove = i2c_imx_remove,<span class="hljs-number">1122</span> .driver = &#123;<span class="hljs-number">1123</span> .name = DRIVER_NAME,<span class="hljs-number">1124</span> .owner = THIS_MODULE,<span class="hljs-number">1125</span> .of_match_table = i2c_imx_dt_ids,<span class="hljs-number">1126</span> .pm = IMX_I2C_PM,<span class="hljs-number">1127</span> &#125;,<span class="hljs-number">1128</span> .id_table = imx_i2c_devtype,<span class="hljs-number">1129</span> &#125;;<span class="hljs-number">1130</span><span class="hljs-number">1131</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">i2c_adap_imx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>1132 &#123;<span class="hljs-number">1133</span> <span class="hljs-keyword">return</span> platform_driver_register(&amp;i2c_imx_driver);<span class="hljs-number">1134</span> &#125;<span class="hljs-number">1135</span> subsys_initcall(i2c_adap_imx_init);<span class="hljs-number">1136</span><span class="hljs-number">1137</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">i2c_adap_imx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>1138 &#123;<span class="hljs-number">1139</span> platform_driver_unregister(&amp;i2c_imx_driver);<span class="hljs-number">1140</span> &#125;<span class="hljs-number">1141</span> module_exit(i2c_adap_imx_exit);</code></pre></div><p>从示例代码可以看出，I.MX6U 的 I2C 适配器驱动是个标准的 platform 驱动，由此可以看出，虽然 I2C 总线为别的设备提供了一种总线驱动框架，但是 I2C 适配器却是 platform驱动。就像你的部门老大是你的领导，你是他的下属，但是放到整个公司，你的部门老大却也是老板的下属。</p><p>第 259 行，“fsl,imx21-i2c”属性值，设备树中 i2c1 节点的 compatible 属性值就是与此匹配上的。因此 i2c-imx.c 文件就是 I.MX6U 的 I2C 适配器驱动文件。</p><p>第 1120 行，当设备和驱动匹配成功以后 i2c_imx_probe 函数就会执行，i2c_imx_probe 函数就会完成 I2C 适配器初始化工作。</p><p>i2c_imx_probe 函数内容如下所示(有省略)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">971</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_imx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span>972 &#123;<span class="hljs-number">973</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">of_id</span> =</span><span class="hljs-number">974</span> of_match_device(i2c_imx_dt_ids, &amp;pdev-&gt;dev);<span class="hljs-number">975</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx_i2c_struct</span> *<span class="hljs-title">i2c_imx</span>;</span><span class="hljs-number">976</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">res</span>;</span><span class="hljs-number">977</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imxi2c_platform_data</span> *<span class="hljs-title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);<span class="hljs-number">978</span> <span class="hljs-type">void</span> __iomem *base;<span class="hljs-number">979</span> <span class="hljs-type">int</span> irq, ret;<span class="hljs-number">980</span> <span class="hljs-type">dma_addr_t</span> phy_addr;<span class="hljs-number">981</span><span class="hljs-number">982</span> dev_dbg(&amp;pdev-&gt;dev, <span class="hljs-string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);<span class="hljs-number">983</span><span class="hljs-number">984</span> irq = platform_get_irq(pdev, <span class="hljs-number">0</span>);......<span class="hljs-number">990</span> res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number">0</span>);<span class="hljs-number">991</span> base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);<span class="hljs-number">992</span> <span class="hljs-keyword">if</span> (IS_ERR(base))<span class="hljs-number">993</span> <span class="hljs-keyword">return</span> PTR_ERR(base);<span class="hljs-number">994</span><span class="hljs-number">995</span> phy_addr = (<span class="hljs-type">dma_addr_t</span>)res-&gt;start;<span class="hljs-number">996</span> i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="hljs-keyword">sizeof</span>(*i2c_imx), GFP_KERNEL);<span class="hljs-number">997</span> <span class="hljs-keyword">if</span> (!i2c_imx)<span class="hljs-number">998</span> <span class="hljs-keyword">return</span> -ENOMEM;<span class="hljs-number">999</span><span class="hljs-number">1000</span> <span class="hljs-keyword">if</span> (of_id)<span class="hljs-number">1001</span> i2c_imx-&gt;hwdata = of_id-&gt;data;<span class="hljs-number">1002</span> <span class="hljs-keyword">else</span><span class="hljs-number">1003</span> i2c_imx-&gt;hwdata = (<span class="hljs-keyword">struct</span> imx_i2c_hwdata *)<span class="hljs-number">1004</span> platform_get_device_id(pdev)-&gt;driver_data;<span class="hljs-number">1005</span><span class="hljs-number">1006</span> <span class="hljs-comment">/* Setup i2c_imx driver structure */</span><span class="hljs-number">1007</span> strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name, <span class="hljs-keyword">sizeof</span>(i2c_imx-&gt;adapter.name));<span class="hljs-number">1008</span> i2c_imx-&gt;adapter.owner = THIS_MODULE;<span class="hljs-number">1009</span> i2c_imx-&gt;adapter.algo = &amp;i2c_imx_algo;<span class="hljs-number">1010</span> i2c_imx-&gt;adapter.dev.parent = &amp;pdev-&gt;dev;<span class="hljs-number">1011</span> i2c_imx-&gt;adapter.nr = pdev-&gt;id;<span class="hljs-number">1012</span> i2c_imx-&gt;adapter.dev.of_node = pdev-&gt;dev.of_node;<span class="hljs-number">1013</span> i2c_imx-&gt;base = base;<span class="hljs-number">1014</span><span class="hljs-number">1015</span> <span class="hljs-comment">/* Get I2C clock */</span><span class="hljs-number">1016</span> i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="hljs-literal">NULL</span>);......<span class="hljs-number">1022</span> ret = clk_prepare_enable(i2c_imx-&gt;clk);......<span class="hljs-number">1027</span> <span class="hljs-comment">/* Request IRQ */</span><span class="hljs-number">1028</span> ret = devm_request_irq(&amp;pdev-&gt;dev, irq, i2c_imx_isr,<span class="hljs-number">1029</span> IRQF_NO_SUSPEND, pdev-&gt;name, i2c_imx);......<span class="hljs-number">1035</span> <span class="hljs-comment">/* Init queue */</span><span class="hljs-number">1036</span> init_waitqueue_head(&amp;i2c_imx-&gt;<span class="hljs-built_in">queue</span>);<span class="hljs-number">1037</span><span class="hljs-number">1038</span> <span class="hljs-comment">/* Set up adapter data */</span><span class="hljs-number">1039</span> i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);<span class="hljs-number">1040</span><span class="hljs-number">1041</span> <span class="hljs-comment">/* Set up clock divider */</span><span class="hljs-number">1042</span> i2c_imx-&gt;bitrate = IMX_I2C_BIT_RATE;<span class="hljs-number">1043</span> ret = of_property_read_u32(pdev-&gt;dev.of_node,<span class="hljs-number">1044</span> <span class="hljs-string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);<span class="hljs-number">1045</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)<span class="hljs-number">1046</span> i2c_imx-&gt;bitrate = pdata-&gt;bitrate;<span class="hljs-number">1047</span><span class="hljs-number">1048</span> <span class="hljs-comment">/* Set up chip registers to defaults */</span><span class="hljs-number">1049</span> imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,<span class="hljs-number">1050</span> i2c_imx, IMX_I2C_I2CR);<span class="hljs-number">1051</span> imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);<span class="hljs-number">1052</span><span class="hljs-number">1053</span> <span class="hljs-comment">/* Add I2C adapter */</span><span class="hljs-number">1054</span> ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);<span class="hljs-number">1055</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-number">1056</span> dev_err(&amp;pdev-&gt;dev, <span class="hljs-string">&quot;registration failed\n&quot;</span>);<span class="hljs-number">1057</span> <span class="hljs-keyword">goto</span> clk_disable;<span class="hljs-number">1058</span> &#125;<span class="hljs-number">1059</span><span class="hljs-number">1060</span> <span class="hljs-comment">/* Set up platform driver data */</span><span class="hljs-number">1061</span> platform_set_drvdata(pdev, i2c_imx);<span class="hljs-number">1062</span> clk_disable_unprepare(i2c_imx-&gt;clk);......<span class="hljs-number">1070</span> <span class="hljs-comment">/* Init DMA config if supported */</span><span class="hljs-number">1071</span> i2c_imx_dma_request(i2c_imx, phy_addr);<span class="hljs-number">1072</span><span class="hljs-number">1073</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* Return OK */</span><span class="hljs-number">1074</span><span class="hljs-number">1075</span> clk_disable:<span class="hljs-number">1076</span> clk_disable_unprepare(i2c_imx-&gt;clk);<span class="hljs-number">1077</span> <span class="hljs-keyword">return</span> ret;<span class="hljs-number">1078</span> &#125;</code></pre></div><ul><li><p>第 984 行，调用 platform_get_irq 函数获取中断号。</p></li><li><p>第 990~991 行，调用 platform_get_resource 函数从设备树中获取 I2C1 控制器寄存器物理基地址，也就是 0X021A0000。获取到寄存器基地址以后使用 devm_ioremap_resource 函数对其进行内存映射，得到可以在 Linux 内核中使用的虚拟地址。</p></li><li><p>第 996 行，NXP 使用 imx_i2c_struct 结构体来表示 I.MX 系列 SOC 的 I2C 控制器，这里使用 devm_kzalloc 函数来申请内存。</p></li><li><p>第 1008~1013 行，imx_i2c_struct 结构体要有个叫做 adapter 的成员变量，adapter 就是i2c_adapter，这里初始化i2c_adapter。第1009行设置i2c_adapter的algo成员变量为i2c_imx_algo，也就是设置 i2c_algorithm。</p></li><li><p>第 1028~1029 行，注册 I2C 控制器中断，中断服务函数为 i2c_imx_isr。</p></li><li><p>第 1042~1044 行，设置 I2C 频率默认为 IMX_I2C_BIT_RATE&#x3D;100KHz，如果设备树节点设置了“clock-frequency”属性的话 I2C 频率就使用 clock-frequency 属性值。</p></li><li><p>第 1049~1051 行，设置 I2C1 控制的 I2CR 和 I2SR 寄存器。</p></li><li><p>第 1054 行，调用 i2c_add_numbered_adapter 函数向 Linux 内核注册 i2c_adapter。</p></li><li><p>第 1071 行，申请 DMA，看来 I.MX 的 I2C 适配器驱动采用了 DMA 方式。</p></li><li><p>i2c_imx_probe 函数主要的工作就是一下两点：</p><ul><li><p>①、初始化 i2c_adapter，设置 i2c_algorithm 为 i2c_imx_algo，最后向 Linux 内核注册i2c_adapter。</p></li><li><p>②、初始化 I2C1 控制器的相关寄存器。</p></li></ul></li></ul><hr><p>i2c_imx_algo 包含 I2C1 适配器与 I2C 设备的通信函数 master_xfer，i2c_imx_algo 结构体定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">966</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> <span class="hljs-title">i2c_imx_algo</span> =</span> &#123;<span class="hljs-number">967</span> .master_xfer = i2c_imx_xfer,<span class="hljs-number">968</span> .functionality = i2c_imx_func,<span class="hljs-number">969</span> &#125;;</code></pre></div><p>我们先来看一下. functionality，functionality用于返回此I2C适配器支持什么样的通信协议，在这里 functionality 就是 i2c_imx_func 函数，i2c_imx_func 函数内容如下:</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> u32 <span class="hljs-title function_">i2c_imx_func</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter)</span>&#123;    <span class="hljs-keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL        | I2C_FUNC_SMBUS_READ_BLOCK_DATA;&#125;</code></pre></div><p>重点来看一下 i2c_imx_xfer 函数，因为最终就是通过此函数来完成与 I2C 设备通信的，此函数内容如下(有省略)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">888</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_imx_xfer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter,</span><span class="hljs-params"><span class="hljs-number">889</span> <span class="hljs-keyword">struct</span> i2c_msg *msgs, <span class="hljs-type">int</span> num)</span>890 &#123;<span class="hljs-number">891</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i, temp;<span class="hljs-number">892</span> <span class="hljs-type">int</span> result;<span class="hljs-number">893</span> <span class="hljs-type">bool</span> is_lastmsg = <span class="hljs-literal">false</span>;<span class="hljs-number">894</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx_i2c_struct</span> *<span class="hljs-title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);<span class="hljs-number">895</span><span class="hljs-number">896</span> dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="hljs-string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);<span class="hljs-number">897</span><span class="hljs-number">898</span> <span class="hljs-comment">/* Start I2C transfer */</span><span class="hljs-number">899</span> result = i2c_imx_start(i2c_imx);<span class="hljs-number">900</span> <span class="hljs-keyword">if</span> (result)<span class="hljs-number">901</span> <span class="hljs-keyword">goto</span> fail0;<span class="hljs-number">902</span><span class="hljs-number">903</span> <span class="hljs-comment">/* read/write data */</span><span class="hljs-number">904</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<span class="hljs-number">905</span> <span class="hljs-keyword">if</span> (i == num - <span class="hljs-number">1</span>)<span class="hljs-number">906</span> is_lastmsg = <span class="hljs-literal">true</span>;<span class="hljs-number">907</span><span class="hljs-number">908</span> <span class="hljs-keyword">if</span> (i) &#123;<span class="hljs-number">909</span> dev_dbg(&amp;i2c_imx-&gt;adapter.dev,<span class="hljs-number">910</span> <span class="hljs-string">&quot;&lt;%s&gt; repeated start\n&quot;</span>, __func__);<span class="hljs-number">911</span> temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);<span class="hljs-number">912</span> temp |= I2CR_RSTA;<span class="hljs-number">913</span> imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);<span class="hljs-number">914</span> result = i2c_imx_bus_busy(i2c_imx, <span class="hljs-number">1</span>);<span class="hljs-number">915</span> <span class="hljs-keyword">if</span> (result)<span class="hljs-number">916</span> <span class="hljs-keyword">goto</span> fail0;<span class="hljs-number">917</span> &#125;<span class="hljs-number">918</span> dev_dbg(&amp;i2c_imx-&gt;adapter.dev,<span class="hljs-number">919</span> <span class="hljs-string">&quot;&lt;%s&gt; transfer message: %d\n&quot;</span>, __func__, i);<span class="hljs-number">920</span> <span class="hljs-comment">/* write/read data */</span>......<span class="hljs-number">938</span> <span class="hljs-keyword">if</span> (msgs[i].flags &amp; I2C_M_RD)<span class="hljs-number">939</span> result = i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg);<span class="hljs-number">940</span> <span class="hljs-keyword">else</span> &#123;<span class="hljs-number">941</span> <span class="hljs-keyword">if</span> (i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;= DMA_THRESHOLD)<span class="hljs-number">942</span> result = i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);<span class="hljs-number">943</span> <span class="hljs-keyword">else</span><span class="hljs-number">944</span> result = i2c_imx_write(i2c_imx, &amp;msgs[i]);<span class="hljs-number">945</span> &#125;<span class="hljs-number">946</span> <span class="hljs-keyword">if</span> (result)<span class="hljs-number">947</span> <span class="hljs-keyword">goto</span> fail0;<span class="hljs-number">948</span> &#125;<span class="hljs-number">949</span><span class="hljs-number">950</span> fail0:<span class="hljs-number">951</span> <span class="hljs-comment">/* Stop I2C transfer */</span><span class="hljs-number">952</span> i2c_imx_stop(i2c_imx);<span class="hljs-number">953</span><span class="hljs-number">954</span> dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="hljs-string">&quot;&lt;%s&gt; exit with: %s: %d\n&quot;</span>, __func__,<span class="hljs-number">955</span> (result &lt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;error&quot;</span> : <span class="hljs-string">&quot;success msg&quot;</span>,<span class="hljs-number">956</span> (result &lt; <span class="hljs-number">0</span>) ? result : num);<span class="hljs-number">957</span> <span class="hljs-keyword">return</span> (result &lt; <span class="hljs-number">0</span>) ? result : num;<span class="hljs-number">958</span> &#125;</code></pre></div><ul><li>第 899 行，调用 i2c_imx_start 函数开启 I2C 通信。</li><li>第 939 行，如果是从 I2C 设备读数据的话就调用 i2c_imx_read 函数。</li><li>第 941~945 行，向 I2C 设备写数据，如果要用 DMA 的话就使用 i2c_imx_dma_write 函数来完成写数据。如果不使用 DMA 的话就使用 i2c_imx_write 函数完成写数据。</li><li>第 952 行，I2C 通信完成以后调用 i2c_imx_stop 函数停止 I2C 通信。</li></ul><p>i2c_imx_start、i2c_imx_read、i2c_imx_write 和 i2c_imx_stop 这些函数就是 I2C 寄存器的具体操作函数，函数内容基本和我们裸机篇中讲的 I2C 驱动一样，这里我们就不详细的分析了.</p><h2 id="3-I2C-设备驱动编写流程"><a href="#3-I2C-设备驱动编写流程" class="headerlink" title="3|  I2C  设备驱动编写流程"></a>3|  I2C  设备驱动编写流程</h2><p>I2C 适配器驱动 SOC 厂商已经替我们编写好了，我们需要做的就是编写具体的设备驱动，本小节我们就来学习一下 I2C 设备驱动的详细编写流程。</p><h3 id="I2C-设备信息描述"><a href="#I2C-设备信息描述" class="headerlink" title="I2C 设备信息描述"></a>I2C 设备信息描述</h3><h4 id="1-未使用设备树的时候"><a href="#1-未使用设备树的时候" class="headerlink" title="1.未使用设备树的时候"></a>1.未使用设备树的时候</h4><p>首先肯定要描述 I2C 设备节点信息，先来看一下没有使用设备树的时候是如何在 BSP 里面描述 I2C 设备信息的，在未使用设备树的时候需要在 BSP 里面使用 i2c_board_info 结构体来描述一个具体的 I2C 设备。i2c_board_info 结构体如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">295</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_board_info</span> &#123;</span><span class="hljs-number">296</span> <span class="hljs-type">char</span> type[I2C_NAME_SIZE]; <span class="hljs-comment">/* I2C 设备名字 */</span><span class="hljs-number">297</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags; <span class="hljs-comment">/* 标志 */</span><span class="hljs-number">298</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> addr; <span class="hljs-comment">/* I2C 器件地址 */</span><span class="hljs-number">299</span> <span class="hljs-type">void</span> *platform_data;<span class="hljs-number">300</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_archdata</span> *<span class="hljs-title">archdata</span>;</span><span class="hljs-number">301</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">of_node</span>;</span><span class="hljs-number">302</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fwnode_handle</span> *<span class="hljs-title">fwnode</span>;</span><span class="hljs-number">303</span> <span class="hljs-type">int</span> irq;<span class="hljs-number">304</span> &#125;;</code></pre></div><p>type 和 addr 这两个成员变量是必须要设置的，一个是 I2C 设备的名字，一个是 I2C 设备的器件地址。打开 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-mx27_3ds.c 文件，此文件中关于 OV2640 的 I2C 设备信息描述如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">392</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_board_info</span> <span class="hljs-title">mx27_3ds_i2c_camera</span> =</span> &#123;<span class="hljs-number">393</span> I2C_BOARD_INFO(<span class="hljs-string">&quot;ov2640&quot;</span>, <span class="hljs-number">0x30</span>),<span class="hljs-number">394</span> &#125;;</code></pre></div><p>示例代码中使用 I2C_BOARD_INFO 来完成 mx27_3ds_i2c_camera 的初始化工作，I2C_BOARD_INFO 是一个宏，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">316</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_BOARD_INFO(dev_type, dev_addr) \</span><span class="hljs-meta">317 .type = dev_type, .addr = (dev_addr)</span></code></pre></div><p>可以看出， I2C_BOARD_INFO 宏其实就是设置 i2c_board_info 的 type 和 addr 这两个成员变量，因此示例代码的主要工作就是设置 I2C 设备名字为 ov2640，ov2640 的器件地址为 0X30。</p><p>大家可以在 Linux 源码里面全局搜索 i2c_board_info，会找到大量以 i2c_board_info 定义的I2C 设备信息，这些就是未使用设备树的时候 I2C 设备的描述方式，当采用了设备树以后就不会再使用i2c_board_info 来描述 I2C 设备了。</p><h4 id="2-使用设备树的时候"><a href="#2-使用设备树的时候" class="headerlink" title="2.使用设备树的时候"></a>2.使用设备树的时候</h4><p>使用设备树的时候 I2C 设备信息通过创建相应的节点就行了，比如 NXP 官方的 EVK 开发板在 I2C1 上接了 mag3110 这个磁力计芯片，因此必须在 i2c1 节点下创建 mag3110 子节点，然后在这个子节点内描述 mag3110 这个芯片的相关信息。打开 imx6ull-14x14-evk.dts 这个设备树文件，然后找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;i2c1 &#123;<span class="hljs-number">2</span> clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<span class="hljs-number">3</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">4</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;<span class="hljs-number">5</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">6</span><span class="hljs-number">7</span> mag3110@<span class="hljs-number">0</span>e &#123;<span class="hljs-number">8</span> compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;<span class="hljs-number">9</span> reg = &lt;<span class="hljs-number">0x0e</span>&gt;;<span class="hljs-number">10</span> position = &lt;<span class="hljs-number">2</span>&gt;;<span class="hljs-number">11</span> &#125;;......<span class="hljs-number">20</span> &#125;;</code></pre></div><ul><li>第 7~11 行，向 i2c1 添加 mag3110 子节点，第 7 行“mag3110@0e”是子节点名字，“@”后面的“0e”就是 mag3110 的 I2C 器件地址。</li><li>第 8 行设置 compatible 属性值为“fsl,mag3110”。</li><li>第 9 行的 reg 属性也是设置 mag3110 的器件地址的，因此值为 0x0e。I2C 设备节点的创建重点是 compatible 属性和 reg 属性的设置，一个用于匹配驱动，一个用于设置器件地址。</li></ul><h3 id="I2C-设备数据收发处理流程"><a href="#I2C-设备数据收发处理流程" class="headerlink" title="I2C 设备数据收发处理流程"></a>I2C 设备数据收发处理流程</h3><p>在前面已经说过了，I2C 设备驱动首先要做的就是初始化 i2c_driver 并向 Linux 内核注册。当设备和驱动匹配以后 i2c_driver 里面的 probe 函数就会执行，probe 函数里面所做的就是字符设备驱动那一套了。</p><p>一般需要在 probe 函数里面初始化 I2C 设备，要初始化 I2C 设备就必须能够对 I2C 设备寄存器进行读写操作，这里就要用到 i2c_transfer 函数了。i2c_transfer 函数最终会调用 I2C 适配器中 i2c_algorithm 里面的 master_xfer 函数，对于 I.MX6U 而言就是i2c_imx_xfer 这个函数。i2c_transfer 函数原型如下</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_transfer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adap,</span><span class="hljs-params">                 <span class="hljs-keyword">struct</span> i2c_msg *msgs,</span><span class="hljs-params">                 <span class="hljs-type">int</span> num)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>adap</strong> ：所使用的 I2C 适配器，i2c_client 会保存其对应的 i2c_adapter。<br><strong>msgs</strong>：I2C 要发送的一个或多个消息。<br><strong>num</strong> ：消息数量，也就是 msgs 的数量。<br><strong>返回值</strong>：负值，失败，其他非负值，发送的 msgs 数量。</p><p>我们重点来看一下 msgs 这个参数，这是一个 i2c_msg 类型的指针参数，I2C 进行数据收发说白了就是消息的传递，Linux 内核使用 i2c_msg 结构体来描述一个消息。i2c_msg 结构体定义在 include&#x2F;uapi&#x2F;linux&#x2F;i2c.h 文件中，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">68</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> &#123;</span><span class="hljs-number">69</span> __u16 addr; <span class="hljs-comment">/* 从机地址 */</span><span class="hljs-number">70</span> __u16 flags; <span class="hljs-comment">/* 标志 */</span><span class="hljs-number">71</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_TEN 0x0010</span><span class="hljs-number">72</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RD 0x0001</span><span class="hljs-number">73</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_STOP 0x8000</span><span class="hljs-number">74</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NOSTART 0x4000</span><span class="hljs-number">75</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_REV_DIR_ADDR 0x2000</span><span class="hljs-number">76</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_IGNORE_NAK 0x1000</span><span class="hljs-number">77</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NO_RD_ACK 0x0800</span><span class="hljs-number">78</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RECV_LEN 0x0400</span><span class="hljs-number">79</span> __u16 len; <span class="hljs-comment">/* 消息(本 msg)长度 */</span><span class="hljs-number">80</span> __u8 *buf; <span class="hljs-comment">/* 消息数据 */</span><span class="hljs-number">81</span> &#125;;</code></pre></div><p>使用 i2c_transfer 函数发送数据之前要先构建好 i2c_msg，使用 i2c_transfer 进行 I2C 数据收发的示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 设备结构体 */</span><span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> &#123;</span><span class="hljs-number">3</span> ......<span class="hljs-number">4</span> <span class="hljs-type">void</span> *private_data; <span class="hljs-comment">/* 私有数据，一般会设置为 i2c_client */</span><span class="hljs-number">5</span> &#125;;<span class="hljs-number">6</span><span class="hljs-number">7</span> <span class="hljs-comment">/*</span><span class="hljs-comment">8 * @description  : 读取 I2C 设备多个寄存器数据</span><span class="hljs-comment">9 * @param – dev  : I2C 设备</span><span class="hljs-comment">10 * @param – reg  : 要读取的寄存器首地址</span><span class="hljs-comment">11 * @param – val  : 读取到的数据</span><span class="hljs-comment">12 * @param – len  : 要读取的数据长度</span><span class="hljs-comment">13 * @return : 操作结果</span><span class="hljs-comment">14 */</span><span class="hljs-number">15</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xxx_dev *dev, u8 reg, <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> len)</span>16 &#123;<span class="hljs-number">17</span> <span class="hljs-type">int</span> ret;<span class="hljs-number">18</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>[2];</span><span class="hljs-number">19</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *) dev-&gt;private_data;<span class="hljs-number">20</span><span class="hljs-number">21</span> <span class="hljs-comment">/* msg[0]，第一条写消息，发送要读取的寄存器首地址 */</span><span class="hljs-number">22</span> msg[<span class="hljs-number">0</span>].addr = client-&gt;addr; <span class="hljs-comment">/* I2C 器件地址 */</span><span class="hljs-number">23</span> msg[<span class="hljs-number">0</span>].flags = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 标记为发送数据 */</span><span class="hljs-number">24</span> msg[<span class="hljs-number">0</span>].buf = &amp;reg; <span class="hljs-comment">/* 读取的首地址 */</span><span class="hljs-number">25</span> msg[<span class="hljs-number">0</span>].len = <span class="hljs-number">1</span>; <span class="hljs-comment">/* reg 长度 */</span><span class="hljs-number">26</span><span class="hljs-number">27</span> <span class="hljs-comment">/* msg[1]，第二条读消息，读取寄存器数据 */</span><span class="hljs-number">28</span> msg[<span class="hljs-number">1</span>].addr = client-&gt;addr; <span class="hljs-comment">/* I2C 器件地址 */</span><span class="hljs-number">29</span> msg[<span class="hljs-number">1</span>].flags = I2C_M_RD; <span class="hljs-comment">/* 标记为读取数据  */</span><span class="hljs-number">30</span> msg[<span class="hljs-number">1</span>].buf = val; <span class="hljs-comment">/* 读取数据缓冲区 */</span><span class="hljs-number">31</span> msg[<span class="hljs-number">1</span>].len = len; <span class="hljs-comment">/* 要读取的数据长度 */</span><span class="hljs-number">32</span><span class="hljs-number">33</span> ret = i2c_transfer(client-&gt;adapter, msg, <span class="hljs-number">2</span>);<span class="hljs-number">34</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">2</span>) &#123;<span class="hljs-number">35</span> ret = <span class="hljs-number">0</span>;<span class="hljs-number">36</span> &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-number">37</span> ret = -EREMOTEIO;<span class="hljs-number">38</span> &#125;<span class="hljs-number">39</span> <span class="hljs-keyword">return</span> ret;<span class="hljs-number">40</span> &#125;<span class="hljs-number">41</span><span class="hljs-number">42</span> <span class="hljs-comment">/*</span><span class="hljs-comment">43 * @description  : 向 I2C 设备多个寄存器写入数据</span><span class="hljs-comment">44 * @param – dev  : 要写入的设备结构体</span><span class="hljs-comment">45 * @param – reg  : 要写入的寄存器首地址</span><span class="hljs-comment">46 * @param – val  : 要写入的数据缓冲区</span><span class="hljs-comment">47 * @param – len  : 要写入的数据长度</span><span class="hljs-comment">48 * @return : 操作结果</span><span class="hljs-comment">49 */</span><span class="hljs-number">50</span> <span class="hljs-type">static</span> s32 <span class="hljs-title function_">xxx_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xxx_dev *dev, u8 reg, u8 *buf, u8 len)</span>51 &#123;<span class="hljs-number">52</span> u8 b[<span class="hljs-number">256</span>];<span class="hljs-number">53</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>;</span><span class="hljs-number">54</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *) dev-&gt;private_data;<span class="hljs-number">55</span><span class="hljs-number">56</span> b[<span class="hljs-number">0</span>] = reg; <span class="hljs-comment">/* 寄存器首地址 */</span><span class="hljs-number">57</span> <span class="hljs-built_in">memcpy</span>(&amp;b[<span class="hljs-number">1</span>],buf,len); <span class="hljs-comment">/* 将要发送的数据拷贝到数组 b 里面  */</span><span class="hljs-number">58</span><span class="hljs-number">59</span> msg.addr = client-&gt;addr; <span class="hljs-comment">/* I2C 器件地址 */</span><span class="hljs-number">60</span> msg.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 标记为写数据 */</span><span class="hljs-number">61</span><span class="hljs-number">62</span> msg.buf = b; <span class="hljs-comment">/* 要发送的数据缓冲区 */</span><span class="hljs-number">63</span> msg.len = len + <span class="hljs-number">1</span>; <span class="hljs-comment">/* 要发送的数据长度 */</span><span class="hljs-number">64</span><span class="hljs-number">65</span> <span class="hljs-keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="hljs-number">1</span>);<span class="hljs-number">66</span> &#125;</code></pre></div><ul><li><strong>第2~5行</strong>，设备结构体，在设备结构体里面添加一个执行void的指针成员变量private_data，此成员变量用于保存设备的私有数据。在 I2C 设备驱动中我们一般将其指向 I2C 设备对应的i2c_client。</li><li><strong>第 15~40 行</strong>，xxx_read_regs 函数用于读取 I2C 设备多个寄存器数据。第 18 行定义了一个i2c_msg 数组，2 个数组元素，因为 I2C 读取数据的时候要先发送要读取的寄存器地址，然后再读取数据，所以需要准备两个 i2c_msg。一个用于发送寄存器地址，一个用于读取寄存器值。对于 msg[0]，将 flags 设置为 0，表示写数据。msg[0]的 addr 是 I2C 设备的器件地址，msg[0]的 buf成员变量就是要读取的寄存器地址。对于 msg[1]，将 flags 设置为 I2C_M_RD，表示读取数据。msg[1]的 buf 成员变量用于保存读取到的数据，len 成员变量就是要读取的数据长度。调用i2c_transfer 函数完成 I2C 数据读操作。</li><li><strong>第 50~66 行</strong>，xxx_write_regs 函数用于向 I2C 设备多个寄存器写数据，I2C 写操作要比读操作简单一点，因此一个 i2c_msg 即可。数组 b 用于存放寄存器首地址和要发送的数据，第 59 行设置 msg 的 addr 为 I2C 器件地址。第 60 行设置 msg 的 flags 为 0，也就是写数据。第 62 行设置要发送的数据，也就是数组 b。第 63 行设置 msg 的 len 为 len+1，因为要加上一个字节的寄存器地址。最后通过 i2c_transfer 函数完成向 I2C 设备的写操作。</li></ul><p>另外还有两个API函数分别用于I2C数据的收发操作，这两个函数最终都会调用i2c_transfer。首先来看一下 I2C 数据发送函数 i2c_master_send，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_master_send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_client *client,</span><span class="hljs-params">                    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf,</span><span class="hljs-params">                    <span class="hljs-type">int</span> count)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>client</strong> ：I2C 设备对应的 i2c_client。<br><strong>buf</strong>：要发送的数据。<br><strong>count</strong> ：要发送的数据字节数，要小于 64KB，以为 i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据。<br><strong>返回值</strong>：负值，失败，其他非负值，发送的字节数。</p><p>I2C 数据接收函数为 i2c_master_recv，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_master_recv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_client *client,</span><span class="hljs-params">                    <span class="hljs-type">char</span> *buf,</span><span class="hljs-params">                    <span class="hljs-type">int</span> count)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>client</strong> ：I2C 设备对应的 i2c_client。<br><strong>buf</strong>：要接收的数据。<br><strong>count</strong> ：要接收的数据字节数，要小于 64KB，以为 i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据。<br><strong>返回值</strong>：负值，失败，其他非负值，发送的字节数。</p><p>关于 Linux 下 I2C 设备驱动的编写流程就讲解到这里，重点就是 i2c_msg 的构建和i2c_transfer 函数的调用，接下来我们就编写 AP3216C 这个 I2C 设备的 Linux 驱动。</p><h2 id="4-硬件原理图分析"><a href="#4-硬件原理图分析" class="headerlink" title="4| 硬件原理图分析"></a>4| 硬件原理图分析</h2><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830150606209.png" alt="image-20200830150606209"></p><h2 id="5-实验程序编写"><a href="#5-实验程序编写" class="headerlink" title="5| 实验程序编写"></a>5| 实验程序编写</h2><h3 id="1-修改设备树"><a href="#1-修改设备树" class="headerlink" title="1.修改设备树"></a>1.修改设备树</h3><h4 id="IO-修改或添加"><a href="#IO-修改或添加" class="headerlink" title="IO  修改或添加"></a>IO  修改或添加</h4><p>首先肯定是要修改 IO，AP3216C 用到了 I2C1 接口，I.MX6U-ALPHA 开发板上的 I2C1 接口使用到了 UART4_TXD 和 UART4_RXD，因此肯定要在设备树里面设置这两个 IO。如果要用到 AP3216C 的中断功能的话还需要初始化 AP_INT 对应的 GIO1_IO01 这个 IO，本章实验我们不使用中断功能。因此只需要设置 UART4_TXD 和 UART4_RXD 这两个 IO，NXP 其实已经将他这两个 IO 设置好了，打开 imx6ull-lxg-emmc.dts，然后找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_i2c1: i2c1grp &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="hljs-number">0x4001b8b0</span><span class="hljs-number">4</span> MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="hljs-number">0x4001b8b0</span><span class="hljs-number">5</span> &gt;;<span class="hljs-number">6</span> &#125;;</code></pre></div><p>pinctrl_i2c1 就是 I2C1 的 IO 节点，这里将 UART4_TXD 和 UART4_RXD 这两个 IO 分别复用为 I2C1_SCL 和 I2C1_SDA，电气属性都设置为 0x4001b8b0。</p><h4 id="在-i2c1-节点追加-ap3216c-子节点"><a href="#在-i2c1-节点追加-ap3216c-子节点" class="headerlink" title="在 i2c1  节点追加 ap3216c 子节点"></a>在 i2c1  节点追加 ap3216c 子节点</h4><p>AP3216C 是连接到 I2C1 上的，因此需要在 i2c1 节点下添加 ap3216c 的设备子节点，在imx6ull-lxg-emmc.dts 文件中找到 i2c1 节点，此节点默认内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;i2c1 &#123;<span class="hljs-number">2</span> clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<span class="hljs-number">3</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">4</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;<span class="hljs-number">5</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">6</span><span class="hljs-number">7</span> mag3110@<span class="hljs-number">0</span>e &#123;<span class="hljs-number">8</span> compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;<span class="hljs-number">9</span> reg = &lt;<span class="hljs-number">0x0e</span>&gt;;<span class="hljs-number">10</span> position = &lt;<span class="hljs-number">2</span>&gt;;<span class="hljs-number">11</span> &#125;;<span class="hljs-number">12</span><span class="hljs-number">13</span> fxls8471@<span class="hljs-number">1</span>e &#123;<span class="hljs-number">14</span> compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;<span class="hljs-number">15</span> reg = &lt;<span class="hljs-number">0x1e</span>&gt;;<span class="hljs-number">16</span> position = &lt;<span class="hljs-number">0</span>&gt;;<span class="hljs-number">17</span> interrupt-parent = &lt;&amp;gpio5&gt;;<span class="hljs-number">18</span> interrupts = &lt;<span class="hljs-number">0</span> <span class="hljs-number">8</span>&gt;;<span class="hljs-number">19</span> &#125;;<span class="hljs-number">20</span> &#125;;</code></pre></div><ul><li>第 2 行，clock-frequency 属性为 I2C 频率，这里设置为 100KHz。</li><li>第 4 行，pinctrl-0 属性指定 I2C 所使用的 IO 为上一个示例代码 中的 pinctrl_i2c1 子节点。</li><li>第 7~11 行，mag3110 是个磁力计，NXP 官方的 EVK 开发板上接了 mag3110，因此 NXP在 i2c1 节点下添加了 mag3110 这个子节点。正点原子的 I.MX6U-ALPHA 开发板上没有用到mag3110，因此需要将此节点删除掉。</li><li>第 13~19 行，NXP 官方 EVK 开发板也接了一个 fxls8471，正点原子的 I.MX6U-ALPHA开发板同样没有此器件，所以也要将其删除掉。</li></ul><p>将 i2c1 节点里面原有的 mag3110 和 fxls8471 这两个 I2C 子节点删除，然后添加 ap3216c子节点信息，完成以后的 i2c1 节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;i2c1 &#123;<span class="hljs-number">2</span> clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<span class="hljs-number">3</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">4</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;<span class="hljs-number">5</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">6</span><span class="hljs-number">7</span> ap3216c@<span class="hljs-number">1</span>e &#123;<span class="hljs-number">8</span> compatible = <span class="hljs-string">&quot;lxg,ap3216c&quot;</span>;<span class="hljs-number">9</span> reg = &lt;<span class="hljs-number">0x1e</span>&gt;;<span class="hljs-number">10</span> &#125;;<span class="hljs-number">11</span> &#125;;</code></pre></div><p>第 7 行，ap3216c 子节点，@后面的“1e”是 ap3216c 的器件地址。</p><p>第 8 行，设置 compatible 值为“lxg,ap3216c”。</p><p>第 9 行，reg 属性也是设置 ap3216c 器件地址的，因此 reg 设置为 0x1e。</p><p>设备树修改完成以后使用“make dtbs”重新编译一下，然后使用新的设备树启动 Linux 内核。&#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices 目录下存放着所有 I2C 设备，如果设备树修改正确的话，会在&#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices 目录下看到一个名为“0-001e”的子目录，如图所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830151556292.png" alt="image-20200830151556292"></p><p>图中的“0-001e”就是 ap3216c 的设备目录，“1e”就是 ap3216c 器件地址。进入0-001e 目录，可以看到“name”文件，name 问价就保存着此设备名字，在这里就是“ap3216c”，如图  所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830151629603.png" alt="image-20200830151629603"></p><h3 id="2-AP3216C-驱动编写"><a href="#2-AP3216C-驱动编写" class="headerlink" title="2.AP3216C  驱动编写"></a>2.AP3216C  驱动编写</h3><p>新建名为“21_iic”的文件夹，然后在 21_iic 文件夹里面创建 vscode 工程，工作区命名为“iic”。工程创建好以后新建 ap3216c.c 和 ap3216creg.h 这两个文件，ap3216c.c 为 AP3216C 的驱动代码，ap3216creg.h 是 AP3216C 寄存器头文件。先在 ap3216creg.h 中定义好 AP3216C 的寄存器，输入如下内容，</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> AP3216C_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_ADDR    0X1E<span class="hljs-comment">/* AP3216C器件地址  */</span></span><span class="hljs-comment">/* AP3316C寄存器 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_SYSTEMCONG0x00<span class="hljs-comment">/* 配置寄存器       */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_INTSTATUS0X01<span class="hljs-comment">/* 中断状态寄存器   */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_INTCLEAR0X02<span class="hljs-comment">/* 中断清除寄存器   */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_IRDATALOW0x0A<span class="hljs-comment">/* IR数据低字节     */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_IRDATAHIGH0x0B<span class="hljs-comment">/* IR数据高字节     */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_ALSDATALOW0x0C<span class="hljs-comment">/* ALS数据低字节    */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_ALSDATAHIGH0X0D<span class="hljs-comment">/* ALS数据高字节    */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_PSDATALOW0X0E<span class="hljs-comment">/* PS数据低字节     */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_PSDATAHIGH0X0F<span class="hljs-comment">/* PS数据高字节     */</span></span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>ap3216creg.h 没什么好讲的，就是一些寄存器宏定义。然后在 ap3216c.c 输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ap3216creg.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_CNT1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AP3216C_NAME<span class="hljs-string">&quot;ap3216c&quot;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ap3216c_dev</span> &#123;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-comment">/* 设备号  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-comment">/* cdev */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-comment">/* 类 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-comment">/* 设备  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>*<span class="hljs-title">nd</span>;</span> <span class="hljs-comment">/* 设备节点 */</span><span class="hljs-type">int</span> major;<span class="hljs-comment">/* 主设备号 */</span><span class="hljs-type">void</span> *private_data;<span class="hljs-comment">/* 私有数据 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ir, als, ps;<span class="hljs-comment">/* 三个光传感器数据 */</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ap3216c_dev</span> <span class="hljs-title">ap3216cdev</span>;</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 从ap3216c读取多个寄存器数据</span><span class="hljs-comment"> * @param - dev:  ap3216c设备</span><span class="hljs-comment"> * @param - reg:  要读取的寄存器首地址</span><span class="hljs-comment"> * @param - val:  读取到的数据</span><span class="hljs-comment"> * @param - len:  要读取的数据长度</span><span class="hljs-comment"> * @return : 操作结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg, <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> len)</span>&#123;<span class="hljs-type">int</span> ret;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>[2];</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;private_data;<span class="hljs-comment">/* msg[0]为发送要读取的首地址 */</span>msg[<span class="hljs-number">0</span>].addr = client-&gt;addr;<span class="hljs-comment">/* ap3216c地址 */</span>msg[<span class="hljs-number">0</span>].flags = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 标记为发送数据 */</span>msg[<span class="hljs-number">0</span>].buf = &amp;reg;<span class="hljs-comment">/* 读取的首地址 */</span>msg[<span class="hljs-number">0</span>].len = <span class="hljs-number">1</span>;<span class="hljs-comment">/* reg长度*/</span><span class="hljs-comment">/* msg[1]读取数据 */</span>msg[<span class="hljs-number">1</span>].addr = client-&gt;addr;<span class="hljs-comment">/* ap3216c地址 */</span>msg[<span class="hljs-number">1</span>].flags = I2C_M_RD;<span class="hljs-comment">/* 标记为读取数据*/</span>msg[<span class="hljs-number">1</span>].buf = val;<span class="hljs-comment">/* 读取数据缓冲区 */</span>msg[<span class="hljs-number">1</span>].len = len;<span class="hljs-comment">/* 要读取的数据长度*/</span>ret = i2c_transfer(client-&gt;adapter, msg, <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">2</span>) &#123;ret = <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> &#123;printk(<span class="hljs-string">&quot;i2c rd failed=%d reg=%06x len=%d\n&quot;</span>,ret, reg, len);ret = -EREMOTEIO;&#125;<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向ap3216c多个寄存器写入数据</span><span class="hljs-comment"> * @param - dev:  ap3216c设备</span><span class="hljs-comment"> * @param - reg:  要写入的寄存器首地址</span><span class="hljs-comment"> * @param - val:  要写入的数据缓冲区</span><span class="hljs-comment"> * @param - len:  要写入的数据长度</span><span class="hljs-comment"> * @return   :   操作结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> s32 <span class="hljs-title function_">ap3216c_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span>&#123;u8 b[<span class="hljs-number">256</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;private_data;b[<span class="hljs-number">0</span>] = reg;<span class="hljs-comment">/* 寄存器首地址 */</span><span class="hljs-built_in">memcpy</span>(&amp;b[<span class="hljs-number">1</span>],buf,len);<span class="hljs-comment">/* 将要写入的数据拷贝到数组b里面 */</span>msg.addr = client-&gt;addr;<span class="hljs-comment">/* ap3216c地址 */</span>msg.flags = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 标记为写数据 */</span>msg.buf = b;<span class="hljs-comment">/* 要写入的数据缓冲区 */</span>msg.len = len + <span class="hljs-number">1</span>;<span class="hljs-comment">/* 要写入的数据长度 */</span><span class="hljs-keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 读取ap3216c指定寄存器值，读取一个寄存器</span><span class="hljs-comment"> * @param - dev:  ap3216c设备</span><span class="hljs-comment"> * @param - reg:  要读取的寄存器</span><span class="hljs-comment"> * @return   :   读取到的寄存器值</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">ap3216c_read_reg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg)</span>&#123;u8 data = <span class="hljs-number">0</span>;ap3216c_read_regs(dev, reg, &amp;data, <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> data;<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;private_data;<span class="hljs-keyword">return</span> i2c_smbus_read_byte_data(client, reg);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向ap3216c指定寄存器写入指定的值，写一个寄存器</span><span class="hljs-comment"> * @param - dev:  ap3216c设备</span><span class="hljs-comment"> * @param - reg:  要写的寄存器</span><span class="hljs-comment"> * @param - data: 要写入的值</span><span class="hljs-comment"> * @return   :    无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ap3216c_write_reg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 data)</span>&#123;u8 buf = <span class="hljs-number">0</span>;buf = data;ap3216c_write_regs(dev, reg, &amp;buf, <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 读取AP3216C的数据，读取原始数据，包括ALS,PS和IR, 注意！</span><span class="hljs-comment"> *: 如果同时打开ALS,IR+PS的话两次数据读取的时间间隔要大于112.5ms</span><span class="hljs-comment"> * @param - ir: ir数据</span><span class="hljs-comment"> * @param - ps : ps数据</span><span class="hljs-comment"> * @param - ps : als数据 </span><span class="hljs-comment"> * @return : 无。</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ap3216c_readdata</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i =<span class="hljs-number">0</span>;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">6</span>];<span class="hljs-comment">/* 循环读取所有传感器数据 */</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)    &#123;        buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);    &#125;    <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0X80</span>) <span class="hljs-comment">/* IR_OF位为1,则数据无效 */</span>dev-&gt;ir = <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-comment">/* 读取IR传感器的数据   */</span>dev-&gt;ir = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)buf[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">2</span>) | (buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0X03</span>); dev-&gt;als = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)buf[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | buf[<span class="hljs-number">2</span>];<span class="hljs-comment">/* 读取ALS传感器的数据  */</span>      <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">4</span>] &amp; <span class="hljs-number">0x40</span>)<span class="hljs-comment">/* IR_OF位为1,则数据无效 */</span>dev-&gt;ps = <span class="hljs-number">0</span>;    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 读取PS传感器的数据    */</span>dev-&gt;ps = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)(buf[<span class="hljs-number">5</span>] &amp; <span class="hljs-number">0X3F</span>) &lt;&lt; <span class="hljs-number">4</span>) | (buf[<span class="hljs-number">4</span>] &amp; <span class="hljs-number">0X0F</span>); &#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 打开设备</span><span class="hljs-comment"> * @param - inode : 传递给驱动的inode</span><span class="hljs-comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><span class="hljs-comment"> *   一般在open的时候将private_data指向设备结构体。</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;ap3216cdev;<span class="hljs-comment">/* 初始化AP3216C */</span>ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="hljs-number">0x04</span>);<span class="hljs-comment">/* 复位AP3216C */</span>mdelay(<span class="hljs-number">50</span>);<span class="hljs-comment">/* AP3216C复位最少10ms */</span>ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="hljs-number">0X03</span>);<span class="hljs-comment">/* 开启ALS、PS+IR */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 从设备读取数据 </span><span class="hljs-comment"> * @param - filp : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @param - buf : 返回给用户空间的数据缓冲区</span><span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span><span class="hljs-comment"> * @param - offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">ap3216c_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *off)</span>&#123;<span class="hljs-type">short</span> data[<span class="hljs-number">3</span>];<span class="hljs-type">long</span> err = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ap3216c_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> ap3216c_dev *)filp-&gt;private_data;ap3216c_readdata(dev);data[<span class="hljs-number">0</span>] = dev-&gt;ir;data[<span class="hljs-number">1</span>] = dev-&gt;als;data[<span class="hljs-number">2</span>] = dev-&gt;ps;err = copy_to_user(buf, data, <span class="hljs-keyword">sizeof</span>(data));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 关闭/释放设备</span><span class="hljs-comment"> * @param - filp : 要关闭的设备文件(文件描述符)</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* AP3216C操作函数 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">ap3216c_ops</span> =</span> &#123;.owner = THIS_MODULE,.open = ap3216c_open,.read = ap3216c_read,.release = ap3216c_release,&#125;; <span class="hljs-comment">/*</span><span class="hljs-comment">  * @description     : i2c驱动的probe函数，当驱动与</span><span class="hljs-comment">  *                    设备匹配以后此函数就会执行</span><span class="hljs-comment">  * @param - client  : i2c设备</span><span class="hljs-comment">  * @param - id      : i2c设备ID</span><span class="hljs-comment">  * @return          : 0，成功;其他负值,失败</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span>&#123;<span class="hljs-comment">/* 1、构建设备号 */</span><span class="hljs-keyword">if</span> (ap3216cdev.major) &#123;ap3216cdev.devid = MKDEV(ap3216cdev.major, <span class="hljs-number">0</span>);register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);&#125; <span class="hljs-keyword">else</span> &#123;alloc_chrdev_region(&amp;ap3216cdev.devid, <span class="hljs-number">0</span>, AP3216C_CNT, AP3216C_NAME);ap3216cdev.major = MAJOR(ap3216cdev.devid);&#125;<span class="hljs-comment">/* 2、注册设备 */</span>cdev_init(&amp;ap3216cdev.cdev, &amp;ap3216c_ops);cdev_add(&amp;ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);<span class="hljs-comment">/* 3、创建类 */</span>ap3216cdev.class = class_create(THIS_MODULE, AP3216C_NAME);<span class="hljs-keyword">if</span> (IS_ERR(ap3216cdev.class)) &#123;<span class="hljs-keyword">return</span> PTR_ERR(ap3216cdev.class);&#125;<span class="hljs-comment">/* 4、创建设备 */</span>ap3216cdev.device = device_create(ap3216cdev.class, <span class="hljs-literal">NULL</span>, ap3216cdev.devid, <span class="hljs-literal">NULL</span>, AP3216C_NAME);<span class="hljs-keyword">if</span> (IS_ERR(ap3216cdev.device)) &#123;<span class="hljs-keyword">return</span> PTR_ERR(ap3216cdev.device);&#125;ap3216cdev.private_data = client;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span><span class="hljs-comment"> * @param - client : i2c设备</span><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span>&#123;<span class="hljs-comment">/* 删除设备 */</span>cdev_del(&amp;ap3216cdev.cdev);unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);<span class="hljs-comment">/* 注销掉类和设备 */</span>device_destroy(ap3216cdev.class, ap3216cdev.devid);class_destroy(ap3216cdev.class);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 传统匹配方式ID列表 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">ap3216c_id</span>[] =</span> &#123;&#123;<span class="hljs-string">&quot;lxg,ap3216c&quot;</span>, <span class="hljs-number">0</span>&#125;,  &#123;&#125;&#125;;<span class="hljs-comment">/* 设备树匹配列表 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">ap3216c_of_match</span>[] =</span> &#123;&#123; .compatible = <span class="hljs-string">&quot;lxg,ap3216c&quot;</span> &#125;,&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;&#125;;<span class="hljs-comment">/* i2c驱动结构体 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">ap3216c_driver</span> =</span> &#123;.probe = ap3216c_probe,.remove = ap3216c_remove,.driver = &#123;.owner = THIS_MODULE,   .name = <span class="hljs-string">&quot;ap3216c&quot;</span>,   .of_match_table = ap3216c_of_match,    &#125;,.id_table = ap3216c_id,&#125;;   <span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动入口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ap3216c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = i2c_add_driver(&amp;ap3216c_driver);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动出口函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">ap3216c_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;i2c_del_driver(&amp;ap3216c_driver);&#125;<span class="hljs-comment">/* module_i2c_driver(ap3216c_driver) */</span>module_init(ap3216c_init);module_exit(ap3216c_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>具体分析参考正点原子IMX6UL驱动开发指南61.5节</p><h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3.编写测试 APP"></a>3.编写测试 APP</h3><p>新建 ap3216cApp.c 文件，然后在里面输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/ioctl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: main主程序</span><span class="hljs-comment"> * @param - argc : argv数组元素个数</span><span class="hljs-comment"> * @param - argv : 具体参数</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<span class="hljs-type">int</span> fd;<span class="hljs-type">char</span> *filename;<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> databuf[<span class="hljs-number">3</span>];<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ir, als, ps;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;filename = argv[<span class="hljs-number">1</span>];fd = open(filename, O_RDWR);<span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;ret = read(fd, databuf, <span class="hljs-keyword">sizeof</span>(databuf));<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 数据读取成功 */</span>ir =  databuf[<span class="hljs-number">0</span>]; <span class="hljs-comment">/* ir传感器数据 */</span>als = databuf[<span class="hljs-number">1</span>]; <span class="hljs-comment">/* als传感器数据 */</span>ps =  databuf[<span class="hljs-number">2</span>]; <span class="hljs-comment">/* ps传感器数据 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ir = %d, als = %d, ps = %d\r\n&quot;</span>, ir, als, ps);&#125;usleep(<span class="hljs-number">200000</span>); <span class="hljs-comment">/*100ms */</span>&#125;close(fd);<span class="hljs-comment">/* 关闭文件 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>ap3216cApp.c 文件内容很简单，就是在 while 循环中不断的读取 AP3216C 的设备文件，从而得到 ir、als 和 ps 这三个数据值，然后将其输出到终端上。</p><h2 id="6-运行测试"><a href="#6-运行测试" class="headerlink" title="6| 运行测试"></a>6| 运行测试</h2><p>编译运行。</p><p>当驱动模块加载成功以后使用 ap3216cApp 来测试，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs c">./ap3216cApp /dev/ap3216c</code></pre></div><p>测试 APP 会不断的从 AP3216C 中读取数据，然后输出到终端上，如图  所示：</p><p><img src="/2020/09/13/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/18%E3%80%81Linux_I2C%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200830154214853.png" alt="image-20200830154214853"></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1、esp-idf应用程序启动流程</title>
    <link href="/2020/09/12/NOTE/ARM/ESP/1%E3%80%81esp-idf%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/09/12/NOTE/ARM/ESP/1%E3%80%81esp-idf%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="esp-idf-应用程序启动流程"><a href="#esp-idf-应用程序启动流程" class="headerlink" title="esp-idf 应用程序启动流程"></a>esp-idf 应用程序启动流程</h1><h2 id="一、应用程序的内存布局"><a href="#一、应用程序的内存布局" class="headerlink" title="一、应用程序的内存布局"></a>一、应用程序的内存布局</h2><h3 id="IRAM（指令-RAM）"><a href="#IRAM（指令-RAM）" class="headerlink" title="IRAM（指令 RAM）"></a>IRAM（指令 RAM）</h3><p>ESP-IDF 将内部 SRAM0 区域的一部分分配为指令 RAM。</p><p>除了开始的 64kB 用作 PRO CPU 和 APP CPU 的高速缓存外，剩余内存区域（从 <code>0x40080000</code> 至 <code>0x400A0000</code> ）被用来存储应用程序中部分需要在RAM中运行的代码。</p><p>一些 ESP-IDF 的组件和 WiFi 协议栈的部分代码通过链接脚本文件被存放到了这块内存区域。</p><p>如果一些应用程序的代码需要放在 IRAM 中运行，可以使用 <code>IRAM_ATTR</code> 宏定义进行声明。</p><h3 id="IROM（代码从-Flash-中运行）"><a href="#IROM（代码从-Flash-中运行）" class="headerlink" title="IROM（代码从 Flash 中运行）"></a>IROM（代码从 Flash 中运行）</h3><p>如果一个函数没有被显式地声明放在 IRAM 或者 RTC 内存中，则将其置于 Flash 中。ESP-IDF 将从 Flash 中执行的代码放在 <code>0x400D0000 — 0x40400000</code> 区域的开始，在启动阶段，二级引导程序会初始化 Flash MMU，将代码在 Flash 中的位置映射到这个区域的开头。对这个区域的访问会被透明地缓存到 <code>0x40070000 — 0x40080000</code> 范围内的两个 32kB 的块中。</p><p>请注意，使用 Window ABI <code>CALLx</code> 指令可能无法访问 <code>0x40000000 — 0x40400000</code> 区域以外的代码，所以要特别留意应用程序是否使用了 <code>0x40400000 — 0x40800000</code> 或者 <code>0x40800000 — 0x40C00000</code> 区域，ESP-IDF 默认不会使用这两个区域。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ESP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>ESP32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11| Linux异步通知实验</title>
    <link href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/11%E3%80%81%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/11%E3%80%81%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="异步通知实验"><a href="#异步通知实验" class="headerlink" title="异步通知实验"></a>异步通知实验</h1><p>在前面<strong>使用阻塞或者非阻塞的方式来读取驱动中按键值都是应用程序主动读取的</strong>，<strong>对于非阻塞方式来说还需要应用程序通过 poll 函数不断的轮询</strong>。<strong>最好的方式就是驱动程序能主动向应用程序发出通知，报告自己可以访问，然后应用程序在从驱动程序中读取或写入数据，类似于我们在裸机例程中讲解的中断</strong>。Linux 提供了异步通知这个机制来完成此功能，本章我们就来学习一下异步通知以及如何在驱动中添加异步通知相关处理代码。</p><h2 id="一、异步通知"><a href="#一、异步通知" class="headerlink" title="一、异步通知"></a>一、异步通知</h2><h3 id="1-异步通知简介"><a href="#1-异步通知简介" class="headerlink" title="1| 异步通知简介"></a>1| 异步通知简介</h3><p>我们首先来回顾一下“中断”，中断是处理器提供的一种异步机制，我们配置好中断以后就可以让处理器去处理其他的事情了，当中断发生以后会触发我们事先设置好的中断服务函数，在中断服务函数中做具体的处理。Linux 应用程序可以通过阻塞或者非阻塞这两种方式来访问驱动设备，通过阻塞方式访问的话应用程序会处于休眠态，等待驱动设备可以使用，非阻塞方式的话会通过 poll 函数来不断的轮询，查看驱动设备文件是否可以使用。这两种方式都需要应用程序主动的去查询设备的使用情况，如果能提供一种类似中断的机制，当驱动程序可以访问的时候主动告诉应用程序那就最好了。</p><p>“信号”为此应运而生，信号类似于我们硬件上使用的“中断”，只不过信号是软件层次上的。算是在软件层次上对中断的一种模拟，驱动可以通过主动向应用程序发送信号的方式来报告自己可以访问了，应用程序获取到信号以后就可以从驱动设备中读取或者写入数据了。整个过程就相当于应用程序收到了驱动发送过来了的一个中断，然后应用程序去响应这个中断，在整个处理过程中应用程序并没有去查询驱动设备是否可以访问，一切都是由驱动设备自己告诉给应用程序的。</p><p><strong>阻塞、非阻塞、异步通知，这三种是针对不同的场合提出来的不同的解决方法，没有优劣之分，在实际的工作和学习中，根据自己的实际需求选择合适的处理方法即可。</strong></p><p>异步通知的核心就是信号，在 <strong>arch&#x2F;xtensa&#x2F;include&#x2F;uapi&#x2F;asm&#x2F;signal.h</strong> 文件中定义了 Linux 所支持的所有信号，这些信号如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">34</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGHUP 1 <span class="hljs-comment">/* 终端挂起或控制进程终止 */</span></span><span class="hljs-number">35</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGINT 2 <span class="hljs-comment">/* 终端中断(Ctrl+C 组合键) */</span></span><span class="hljs-number">36</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGQUIT 3 <span class="hljs-comment">/* 终端退出(Ctrl+\组合键) */</span></span><span class="hljs-number">37</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGILL 4 <span class="hljs-comment">/* 非法指令 */</span></span><span class="hljs-number">38</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGTRAP 5 <span class="hljs-comment">/* debug 使用，有断点指令产生  */</span></span><span class="hljs-number">39</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGABRT 6 <span class="hljs-comment">/* 由 abort(3)发出的退出指令 */</span></span><span class="hljs-number">40</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGIOT 6 <span class="hljs-comment">/* IOT 指令 */</span></span><span class="hljs-number">41</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGBUS 7 <span class="hljs-comment">/* 总线错误 */</span></span><span class="hljs-number">42</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGFPE 8 <span class="hljs-comment">/* 浮点运算错误 */</span></span><span class="hljs-number">43</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGKILL 9 <span class="hljs-comment">/* 杀死、终止进程 */</span></span><span class="hljs-number">44</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGUSR1 10 <span class="hljs-comment">/* 用户自定义信号 1 */</span></span><span class="hljs-number">45</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGSEGV 11 <span class="hljs-comment">/* 段违例(无效的内存段) */</span></span><span class="hljs-number">46</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGUSR2 12 <span class="hljs-comment">/* 用户自定义信号 2 */</span></span><span class="hljs-number">47</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGPIPE 13 <span class="hljs-comment">/* 向非读管道写入数据 */</span></span><span class="hljs-number">48</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGALRM 14 <span class="hljs-comment">/* 闹钟 */</span></span><span class="hljs-number">49</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGTERM 15 <span class="hljs-comment">/* 软件终止 */</span></span><span class="hljs-number">50</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGSTKFLT 16 <span class="hljs-comment">/* 栈异常 */</span></span><span class="hljs-number">51</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGCHLD 17 <span class="hljs-comment">/* 子进程结束 */</span></span><span class="hljs-number">52</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGCONT 18 <span class="hljs-comment">/* 进程继续 */</span></span><span class="hljs-number">53</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGSTOP 19 <span class="hljs-comment">/* 停止进程的执行，只是暂停 */</span></span><span class="hljs-number">54</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGTSTP 20 <span class="hljs-comment">/* 停止进程的运行(Ctrl+Z 组合键) */</span></span><span class="hljs-number">55</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGTTIN 21 <span class="hljs-comment">/* 后台进程需要从终端读取数据  */</span></span><span class="hljs-number">56</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGTTOU 22 <span class="hljs-comment">/* 后台进程需要向终端写数据 */</span></span><span class="hljs-number">57</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGURG 23 <span class="hljs-comment">/* 有&quot;紧急&quot;数据 */</span></span><span class="hljs-number">58</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGXCPU 24 <span class="hljs-comment">/* 超过 CPU 资源限制 */</span></span><span class="hljs-number">59</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGXFSZ 25 <span class="hljs-comment">/* 文件大小超额 */</span></span><span class="hljs-number">60</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGVTALRM 26 <span class="hljs-comment">/* 虚拟时钟信号 */</span></span><span class="hljs-number">61</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGPROF 27 <span class="hljs-comment">/* 时钟信号描述 */</span></span><span class="hljs-number">62</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGWINCH 28 <span class="hljs-comment">/* 窗口大小改变 */</span></span><span class="hljs-number">63</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGIO 29 <span class="hljs-comment">/* 可以进行输入/输出操作 */</span></span><span class="hljs-number">64</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGPOLL SIGIO</span><span class="hljs-number">65</span> <span class="hljs-comment">/* #define SIGLOS 29 */</span><span class="hljs-number">66</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGPWR 30 <span class="hljs-comment">/* 断点重启 */</span></span><span class="hljs-number">67</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGSYS 31 <span class="hljs-comment">/* 非法的系统调用 */</span></span><span class="hljs-number">68</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SIGUNUSED 31 <span class="hljs-comment">/* 未使用信号 */</span></span></code></pre></div><p>在示例代码 中的这些信号中，除了 SIGKILL(9)和 SIGSTOP(19)这两个信号不能被忽略外，其他的信号都可以忽略。这些信号就相当于中断号，不同的中断号代表了不同的中断，不同的中断所做的处理不同，因此，驱动程序可以通过向应用程序发送不同的信号来实现不同的功能。</p><p>我们使用中断的时候需要设置中断处理函数，同样的，如果要在应用程序中使用信号，那么就必须设置信号所使用的信号处理函数，在应用程序中使用 signal 函数来设置指定信号的处理函数，signal 函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><strong>signum</strong>：要设置处理函数的信号。</li><li><strong>handler</strong> ：信号的处理函数。</li><li><strong>返回值</strong>：设置成功的话返回信号的前一个处理函数，设置失败的话返回 SIG_ERR。</li></ul><p>信号处理函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></code></pre></div><p>我们前面讲解的使用“kill -9 PID”杀死指定进程的方法就是向指定的进程(PID)发送SIGKILL 这个信号。</p><p>当按下键盘上的 CTRL+C 组合键以后会向当前正在占用终端的应用程序发出 SIGINT 信号，SIGINT 信号默认的动作是关闭当前应用程序。这里我们修改一下 SIGINT 信号的默认处理函数，当按下 CTRL+C 组合键以后先在终端上打印出“SIGINT signal！”这行字符串，然后再关闭当前应用程序。新建 signaltest.c 文件，然后输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nSIGINT signal!\r\n&quot;</span>);    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    signal(SIGINT, sigint_handler);    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)        ;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>在示例代码  中我们设置 SIGINT 信号的处理函数为 sigint_handler，当按下 CTRL+C向 signaltest 发送 SIGINT 信号以后 sigint_handler 函数就会执行，此函数先输出一行“SIGINT<br>signal!”字符串，然后调用 exit 函数关闭 signaltest 应用程序。使用如下命令编译 signaltest.c：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">gcc signaltest.c -o <span class="hljs-built_in">test</span></code></pre></div><p>然后输入“.&#x2F;test”命令打开 test 这个应用程序，然后按下键盘上的 CTRL+C 组<br>合键，结果如图所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/11%E3%80%81%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E5%AE%9E%E9%AA%8C/image-20200827145821350.png" alt="image-20200827145821350"></p><p>从图  可以看出，当按下 CTRL+C 组合键以后 sigint_handler 这个 SIGINT 信号处理函数执行了，并且输出了“SIGINT signal！”这行字符串。</p><h3 id="2-驱动中的信号处理"><a href="#2-驱动中的信号处理" class="headerlink" title="2| 驱动中的信号处理"></a>2| 驱动中的信号处理</h3><h4 id="1-fasync-struct-结构体"><a href="#1-fasync-struct-结构体" class="headerlink" title="1. fasync_struct 结构体"></a>1. fasync_struct 结构体</h4><p>首先我们需要在驱动程序中定义一个 fasync_struct 结构体指针变量，fasync_struct 结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> &#123;</span>    <span class="hljs-type">spinlock_t</span> fa_lock;    <span class="hljs-type">int</span> magic;    <span class="hljs-type">int</span> fa_fd;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fa_next</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">fa_file</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">fa_rcu</span>;</span>&#125;;</code></pre></div><p>一般将 fasync_struct 结构体指针变量定义到设备结构体中，比如在上一章节的imx6uirq_dev结构体中添加一个 fasync_struct 结构体指针变量。</p><h4 id="2-fasync函数"><a href="#2-fasync函数" class="headerlink" title="2.fasync函数"></a>2.fasync函数</h4><p>如果要<strong>使用异步通知</strong>，<strong>需要在设备驱动中实现 file_operations 操作集中的 fasync 函数</strong>，此函数格式如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">int</span> on)</code></pre></div><p>fasync 函数里面一般通过调用 fasync_helper 函数来初始化前面定义的 fasync_struct 结构体指针，fasync_helper 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fasync_helper</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> file * filp, <span class="hljs-type">int</span> on, <span class="hljs-keyword">struct</span> fasync_struct **fapp)</span></code></pre></div><p>fasync_helper 函数的前三个参数就是 fasync 函数的那三个参数，第四个参数就是要初始化的 fasync_struct 结构体指针变量。</p><p>当应用程序通过<code>fcntl(fd, F_SETFL, flags | FASYNC)</code>改变fasync 标记的时候，驱动程序 file_operations 操作集中的 fasync 函数就会执行。</p><p>驱动程序中的 fasync 函数参考示例如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> &#123;</span><span class="hljs-number">2</span> ......<span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">async_queue</span>;</span> <span class="hljs-comment">/* 异步相关结构体 */</span><span class="hljs-number">4</span> &#125;;<span class="hljs-number">5</span><span class="hljs-number">6</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_fasync</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">int</span> on)</span>7 &#123;<span class="hljs-number">8</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> *<span class="hljs-title">dev</span> =</span> (xxx_dev)filp-&gt;private_data;<span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-keyword">if</span> (fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue) &lt; <span class="hljs-number">0</span>)<span class="hljs-number">11</span> <span class="hljs-keyword">return</span> -EIO;<span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">13</span> &#125;<span class="hljs-number">14</span><span class="hljs-number">15</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">xxx_ops</span> =</span> &#123;<span class="hljs-number">16</span> ......<span class="hljs-number">17</span> .fasync = xxx_fasync,<span class="hljs-number">18</span> ......<span class="hljs-number">19</span> &#125;;</code></pre></div><p>在关闭驱动文件的时候需要在 file_operations 操作集中的 release 函数中释放fasync_struct，fasync_struct 的释放函数同样为 fasync_helper，release 函数参数参考实例如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>2 &#123;<span class="hljs-number">3</span> <span class="hljs-keyword">return</span> xxx_fasync(<span class="hljs-number">-1</span>, filp, <span class="hljs-number">0</span>); <span class="hljs-comment">/*  删除异步通知 */</span><span class="hljs-number">4</span> &#125;<span class="hljs-number">5</span><span class="hljs-number">6</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">xxx_ops</span> =</span> &#123;<span class="hljs-number">7</span> ......<span class="hljs-number">8</span> .release = xxx_release,<span class="hljs-number">9</span> &#125;;</code></pre></div><p>第 3 行通过调用示例代码中的 xxx_fasync 函数来完成 fasync_struct 的释放工作，但是，其最终还是通过 fasync_helper 函数完成释放工作。</p><h4 id="3-kill-fasync函数"><a href="#3-kill-fasync函数" class="headerlink" title="3.kill_fasync函数"></a>3.kill_fasync函数</h4><p>当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。<strong>kill_fasync函数负责发送指定的信号</strong>，kill_fasync 函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kill_fasync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fasync_struct **fp, <span class="hljs-type">int</span> sig, <span class="hljs-type">int</span> band)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><strong>fp</strong>：要操作的 fasync_struct。</li><li><strong>sig</strong> ：要发送的信号。</li><li><strong>band</strong> ：可读时设置为 POLL_IN，可写时设置为 POLL_OUT。</li><li><strong>返回值</strong>：无。</li></ul><h3 id="3-应用程序对异步通知的处理"><a href="#3-应用程序对异步通知的处理" class="headerlink" title="3| 应用程序对异步通知的处理"></a>3| 应用程序对异步通知的处理</h3><p>应用程序对异步通知的处理包括以下三步：</p><p><strong>1 、注册信号处理函数</strong></p><p>应用程序根据驱动程序所使用的信号来设置信号的处理函数，应用程序使用 signal 函数来设置信号的处理函数。前面已经详细的讲过了，这里就不细讲了。</p><p><strong>2 、将本应用程序的进程号告诉给内核</strong></p><p>使用<code> fcntl(fd, F_SETOWN, getpid())</code>将本应用程序的进程号告诉给内核。</p><p><strong>3 、开启异步通知</strong></p><p>使用如下两行程序开启异步通知：</p><div class="hljs code-wrapper"><pre><code class="hljs c">flags = fcntl(fd, F_GETFL); <span class="hljs-comment">/* 获取当前的进程状态  */</span>fcntl(fd, F_SETFL, flags | FASYNC); <span class="hljs-comment">/* 开启当前进程异步通知功能 */</span></code></pre></div><p>重点就是通过 fcntl 函数设置进程状态为 FASYNC，经过这一步，驱动程序中的 fasync 函数就会执行。</p><h2 id="二、硬件原理图分析"><a href="#二、硬件原理图分析" class="headerlink" title="二、硬件原理图分析"></a>二、硬件原理图分析</h2><p>参考前面的按键实验。</p><h2 id="三、实验程序编写"><a href="#三、实验程序编写" class="headerlink" title="三、实验程序编写"></a>三、实验程序编写</h2><p>本实验我们在上一章实验“15_noblockio”的基础上完成，在其中加入异步通知相关内容即可，当按键按下以后驱动程序向应用程序发送 SIGIO 信号，应用程序获取到 SIGIO 信号以后读取并且打印出按键值。</p><h3 id="修改设备树文件"><a href="#修改设备树文件" class="headerlink" title="修改设备树文件"></a>修改设备树文件</h3><p>因为是在实验“15_noblockio”的基础上完成的，因此不需要修改设备树。</p><h3 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a>驱动程序编写</h3><p>新建名为“16_asyncnoti”的文件夹，然后在 16_asyncnoti 文件夹里面创建 vscode 工程，工作区命名为“asyncnoti”。将“15_noblockio”实验中的 noblockio.c 复制到 16_asyncnoti 文件夹中，并重命名为 asyncnoti.c。</p><p>接下来我们就修改 asyncnoti.c 这个文件，在其中添加异步通知关的代码，完成以后的asyncnoti.c 内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CNT 1<span class="hljs-comment">/* 设备号个数 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_NAME <span class="hljs-string">&quot;noblockio&quot;</span><span class="hljs-comment">/* 设备名 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE 0X01 <span class="hljs-comment">/* KEY0 按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY 0XFF <span class="hljs-comment">/* 无效的按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_CNT 1  <span class="hljs-comment">/* 按键数量 */</span></span><span class="hljs-comment">/* 中断 IO 描述结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> &#123;</span><span class="hljs-type">int</span> gpio; <span class="hljs-comment">/* gpio */</span><span class="hljs-type">int</span> irqnum; <span class="hljs-comment">/* 中断号 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value; <span class="hljs-comment">/* 按键对应的键值  */</span><span class="hljs-type">char</span> name[<span class="hljs-number">10</span>]; <span class="hljs-comment">/* 名字 */</span><span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *); <span class="hljs-comment">/* 中断服务函数 */</span>&#125;;<span class="hljs-comment">/* imx6uirq设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span><span class="hljs-comment">/* 设备树节点 */</span><span class="hljs-type">atomic_t</span> keyvalue; <span class="hljs-comment">/* 有效的按键键值 */</span><span class="hljs-type">atomic_t</span> releasekey; <span class="hljs-comment">/* 标记是否完成一次完成的按键*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> <span class="hljs-comment">/* 定义一个定时器*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> <span class="hljs-title">irqkeydesc</span>[<span class="hljs-title">KEY_CNT</span>];</span> <span class="hljs-comment">/* 按键描述数组 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> curkeynum; <span class="hljs-comment">/* 当前的按键号 */</span><span class="hljs-type">wait_queue_head_t</span> r_wait;<span class="hljs-comment">/* 读等待对列头 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">async_queue</span>;</span> <span class="hljs-comment">/*  异步相关结构体 */</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> <span class="hljs-title">imx6uirq</span>;</span><span class="hljs-comment">/* @description : 中断服务函数，开启定时器，延时 10ms，</span><span class="hljs-comment"> * 定时器用于按键消抖。</span><span class="hljs-comment"> * @param - irq : 中断号</span><span class="hljs-comment"> * @param - dev_id : 设备结构。</span><span class="hljs-comment"> * @return : 中断执行结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">key0_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)dev_id;dev-&gt;curkeynum = <span class="hljs-number">0</span>;dev-&gt;timer.data = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span>)dev_id;mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="hljs-number">10</span>));<span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);&#125;<span class="hljs-comment">/* @description : 定时器服务函数，用于按键消抖，定时器到了以后</span><span class="hljs-comment"> * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><span class="hljs-comment"> * @param – arg  : 设备结构变量</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> *<span class="hljs-title">keydesc</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)arg;num = dev-&gt;curkeynum;keydesc = &amp;dev-&gt;irqkeydesc[num];value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/* 读取 IO 值 */</span><span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">/* 按键松开 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="hljs-number">0x80</span> | keydesc-&gt;value);<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 标记松开按键 */</span>&#125;<span class="hljs-keyword">if</span>(<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey)) &#123;<span class="hljs-comment">/* 一次完整的按键过程 */</span><span class="hljs-keyword">if</span>(dev-&gt;async_queue)kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN);<span class="hljs-comment">/* 释放SIGIO信号 */</span>&#125;<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><span class="hljs-comment">/* 唤醒进程 */</span><span class="hljs-keyword">if</span>(<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey)) &#123;<span class="hljs-comment">/* 完成一次按键过程 */</span><span class="hljs-comment">/* wake_up(&amp;dev-&gt;r_wait); */</span>wake_up_interruptible(&amp;dev-&gt;r_wait);&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : 按键 IO 初始化</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;imx6uirq.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);<span class="hljs-keyword">if</span> (imx6uirq.nd == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;k:key node not find!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-comment">/* 提取 GPIO */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd,<span class="hljs-string">&quot;key-gpios&quot;</span>, i);<span class="hljs-keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:can&#x27;t get key%d\r\n&quot;</span>, i);&#125;&#125;<span class="hljs-comment">/* 初始化 key 所使用的 IO，并且设置成中断模式 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;<span class="hljs-built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-number">0</span>,   <span class="hljs-keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));<span class="hljs-built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-string">&quot;KEY%d&quot;</span>, i);gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(imx6uirq.nd, i);<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(imx6uirq.irqkeydesc[i].gpio);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>printk(<span class="hljs-string">&quot;k:key%d:gpio=%d, irqnum=%d\r\n&quot;</span>, i,   imx6uirq.irqkeydesc[i].gpio,   imx6uirq.irqkeydesc[i].irqnum);&#125;<span class="hljs-comment">/* 申请中断 */</span>imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].handler = key0_handler;imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].value = KEY0VALUE;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;ret = request_irq(imx6uirq.irqkeydesc[i].irqnum,  imx6uirq.irqkeydesc[i].handler,  IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,  imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:irq %d request failed!\r\n&quot;</span>,   imx6uirq.irqkeydesc[i].irqnum);<span class="hljs-keyword">return</span> -EFAULT;&#125;&#125;<span class="hljs-comment">/* 创建定时器 */</span>init_timer(&amp;imx6uirq.timer);imx6uirq.timer.function = timer_function;<span class="hljs-comment">/*  初始化等待队列头 */</span>init_waitqueue_head(&amp;imx6uirq.r_wait);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;imx6uirq; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : 从设备读取数据</span><span class="hljs-comment"> * @param – filp : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @param – buf : 返回给用户空间的数据缓冲区</span><span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span><span class="hljs-comment"> * @param – offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">imx6uirq_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf,</span><span class="hljs-params"> <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> keyvalue = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> releasekey = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)   filp-&gt;private_data;<span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK)&#123;<span class="hljs-comment">/*  非阻塞访问 */</span><span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey) == <span class="hljs-number">0</span>) <span class="hljs-comment">/*  没有按键按下 */</span><span class="hljs-keyword">return</span> -EAGAIN;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 阻塞访问 */</span><span class="hljs-comment">/* 加入等待队列，等待被唤醒,也就是有按键按下 */</span>ret = wait_event_interruptible(dev-&gt;r_wait,   <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey));<span class="hljs-keyword">if</span> (ret)&#123;<span class="hljs-keyword">goto</span> wait_error;&#125;&#125;keyvalue = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;keyvalue);releasekey = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey);<span class="hljs-keyword">if</span> (releasekey)&#123; <span class="hljs-comment">/* 有按键按下 */</span><span class="hljs-keyword">if</span> (keyvalue &amp; <span class="hljs-number">0x80</span>)&#123;keyvalue &amp;= ~<span class="hljs-number">0x80</span>;ret = copy_to_user(buf, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">goto</span> data_error;&#125;<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 按下标志清零 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">goto</span> data_error;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;wait_error:<span class="hljs-keyword">return</span> ret;data_error:<span class="hljs-keyword">return</span> -EINVAL;&#125; <span class="hljs-comment">/*</span><span class="hljs-comment">  * @description     : poll函数，用于处理非阻塞访问</span><span class="hljs-comment">  * @param - filp    : 要打开的设备文件(文件描述符)</span><span class="hljs-comment">  * @param - wait    : 等待列表(poll_table)</span><span class="hljs-comment">  * @return          : 设备或者资源状态，</span><span class="hljs-comment">  */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-keyword">struct</span> poll_table_struct *wait)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;poll_wait(filp, &amp;dev-&gt;r_wait, wait);<span class="hljs-comment">/* 将等待队列头添加到poll_table中 */</span><span class="hljs-keyword">if</span>(<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey)) &#123;<span class="hljs-comment">/* 按键按下 */</span>mask = POLLIN | POLLRDNORM;<span class="hljs-comment">/* 返回PLLIN */</span>&#125;<span class="hljs-keyword">return</span> mask;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description     : fasync函数，用于处理异步通知</span><span class="hljs-comment"> * @param - fd: 文件描述符</span><span class="hljs-comment"> * @param - filp    : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @param - on      : 模式</span><span class="hljs-comment"> * @return          : 负数表示函数执行失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_fasync</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">int</span> on)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;<span class="hljs-keyword">return</span> fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description     : release函数，应用程序调用close关闭驱动文件的时候会执行</span><span class="hljs-comment"> * @param - inode: inode节点</span><span class="hljs-comment"> * @param - filp    : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @return          : 负数表示函数执行失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-keyword">return</span> imx6uirq_fasync(<span class="hljs-number">-1</span>, filp, <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">/* 设备操作函数 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">imx6uirq_fops</span> =</span> &#123;.owner = THIS_MODULE,.open = imx6uirq_open,.read = imx6uirq_read,.poll = imx6uirq_poll,.fasync = imx6uirq_fasync,.release = imx6uirq_release,&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">imx6uirq_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 注册设备号 */</span>imx6uirq.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(imx6uirq.major)&#123;imx6uirq.devid = MKDEV(imx6uirq.major, imx6uirq.minor);ret = register_chrdev_region(imx6uirq.devid, DEV_CNT, DEV_NAME);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;imx6uirq.devid, <span class="hljs-number">0</span>, DEV_CNT, DEV_NAME);&#125;imx6uirq.major = MAJOR(imx6uirq.devid);imx6uirq.minor = MINOR(imx6uirq.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;k:imx6uirq  MAJOR:%d  MINOR:%d\r\n&quot;</span>, imx6uirq.major, imx6uirq.minor);<span class="hljs-comment">/* 添加字符设备 */</span>imx6uirq.cdev.owner = imx6uirq_fops.owner;cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);ret = cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, DEV_CNT);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>imx6uirq.class = class_create(THIS_MODULE, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.class))&#123;printk(<span class="hljs-string">&quot;k:fail to create class!\r\n&quot;</span>);result = PTR_ERR(imx6uirq.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>imx6uirq.device = device_create(imx6uirq.class, <span class="hljs-literal">NULL</span>, imx6uirq.devid, <span class="hljs-literal">NULL</span>, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.device))&#123;printk(<span class="hljs-string">&quot;k:fail to create device!\r\n&quot;</span>);result = PTR_ERR(imx6uirq.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 5、初始化按键 */</span><span class="hljs-type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="hljs-number">0</span>);keyio_init();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(imx6uirq.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;imx6uirq.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(imx6uirq.devid, DEV_CNT);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">imx6uirq_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 删除定时器 */</span>del_timer_sync(&amp;imx6uirq.timer);<span class="hljs-comment">/* 释放中断 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);&#125;<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(imx6uirq.class, imx6uirq.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(imx6uirq.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;imx6uirq.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(imx6uirq.devid, DEV_CNT);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(imx6uirq_init);module_exit(imx6uirq_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><ul><li>添加 fcntl.h 头文件，因为要用到相关的 API 函数。</li><li>在设备结构体 imx6uirq_dev 中添加 fasync_struct 指针变量。</li><li>如果是一次完整的按键过程，那么就通过 kill_fasync 函数发送 SIGIO 信号。</li><li>imx6uirq_fasync 函数，为 file_operations 操作集中的 fasync 函数，此函数内容很简单，就是调用一下 fasync_helper。</li><li>release 函数，应用程序调用 close 函数关闭驱动设备文件的时候此函数就会执行，在此函数中释放掉 fasync_struct 指针变量。</li></ul><h3 id="编写测试APP"><a href="#编写测试APP" class="headerlink" title="编写测试APP"></a>编写测试APP</h3><p>测试 APP 要实现的内容很简单，设置 SIGIO 信号的处理函数为 sigio_signal_func，当驱动程序向应用程序发送 SIGIO 信号以后 sigio_signal_func 函数就会执行。sigio_signal_func 函数内容很简单，就是通过 read 函数读取按键值。新建名为 asyncnotiApp.c 的文件，然后输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/ioctl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;poll.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/select.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/time.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;signal.h&quot;</span></span><span class="hljs-type">static</span> <span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 文件描述符 */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * SIGIO信号处理函数</span><span class="hljs-comment"> * @param - signum : 信号值</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sigio_signal_func</span><span class="hljs-params">(<span class="hljs-type">int</span> signum)</span>&#123;<span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> keyvalue = <span class="hljs-number">0</span>;err = read(fd, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));<span class="hljs-keyword">if</span>(err &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">/* 读取错误 */</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sigio signal! key value=%d\r\n&quot;</span>, keyvalue);&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: main主程序</span><span class="hljs-comment"> * @param - argc : argv数组元素个数</span><span class="hljs-comment"> * @param - argv : 具体参数</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<span class="hljs-type">int</span> flags = <span class="hljs-number">0</span>;<span class="hljs-type">char</span> *filename;<span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;filename = argv[<span class="hljs-number">1</span>];fd = open(filename, O_RDWR);<span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-comment">/* 设置信号SIGIO的处理函数 */</span>signal(SIGIO, sigio_signal_func);fcntl(fd, F_SETOWN, getpid());<span class="hljs-comment">/* 将当前进程的进程号告诉给内核 */</span>flags = fcntl(fd, F_GETFL);<span class="hljs-comment">/* 获取当前的进程状态 */</span>fcntl(fd, F_SETFL, flags | FASYNC);<span class="hljs-comment">/* 设置进程启用异步通知功能 */</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;sleep(<span class="hljs-number">2</span>);&#125;close(fd);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><ul><li>sigio_signal_func 函数，SIGIO 信号的处理函数，当驱动程序有效按键按下以后就会发送 SIGIO 信号，此函数就会执行。此函数通过 read 函数读取按键值，然后通过printf 函数打印在终端上。</li><li>通过 signal 函数设置 SIGIO 信号的处理函数为 sigio_signal_func。</li><li>设置当前进程的状态，开启异步通知的功能。 </li><li>while 循环，等待信号产生。</li></ul><h2 id="四、运行测试"><a href="#四、运行测试" class="headerlink" title="四、运行测试"></a>四、运行测试</h2><p>编译运行。</p><p>驱动加载成功以后使用如下命令来测试中断：</p><div class="hljs code-wrapper"><pre><code class="hljs c">./asyncnotiApp /dev/asyncnoti</code></pre></div><p>按下开发板上的 KEY0 键，终端就会输出按键值，如图 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/11%E3%80%81%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E5%AE%9E%E9%AA%8C/image-20200827160817641.png" alt="image-20200827160817641"></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10| Linux阻塞非阻塞IO实验</title>
    <link href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux阻塞非阻塞IO实验"><a href="#Linux阻塞非阻塞IO实验" class="headerlink" title="Linux阻塞非阻塞IO实验"></a>Linux阻塞非阻塞IO实验</h1><p>阻塞和非阻塞 IO 是 Linux 驱动开发里面很常见的两种<strong>设备访问模式</strong>，在编写驱动的时候一定要考虑到阻塞和非阻塞。本章我们就来学习一下阻塞和非阻塞 IO，以及如何在驱动程序中处理阻塞与非阻塞，如何在驱动程序使用等待队列和 poll 机制。</p><h2 id="一、阻塞和非阻塞IO"><a href="#一、阻塞和非阻塞IO" class="headerlink" title="一、阻塞和非阻塞IO"></a>一、阻塞和非阻塞IO</h2><h3 id="1-阻塞和非阻塞简介"><a href="#1-阻塞和非阻塞简介" class="headerlink" title="1|阻塞和非阻塞简介"></a>1|阻塞和非阻塞简介</h3><p>这里的“IO”并不是我们学习 STM32 或者其他单片机的时候所说的“GPIO”(也就是引脚)。这里的 IO 指的是 Input&#x2F;Output，也就是输入&#x2F;输出，是应用程序对驱动设备的输入&#x2F;输出操作。当<br>应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。</p><p><strong>阻塞式 IO 如图所示：</strong></p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826141315957.png" alt="image-20200826141315957"></p><p>图 52.1.1.1 中应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。</p><p><strong>非阻塞 IO 如图所示：</strong></p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826141512429.png" alt="image-20200826141512429"></p><p>从图 52.1.1.2 可以看出，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。</p><p>应用程序可以使用如下所示示例代码来实现阻塞访问：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> fd;<span class="hljs-number">2</span> <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<span class="hljs-number">3</span><span class="hljs-number">4</span> fd = open(<span class="hljs-string">&quot;/dev/xxx_dev&quot;</span>, O_RDWR); <span class="hljs-comment">/* 阻塞方式打开 */</span><span class="hljs-number">5</span> ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data)); <span class="hljs-comment">/* 读取数据 */</span></code></pre></div><p>从示例代码 可以看出，对于设备驱动文件的默认读取方式就是阻塞式的，所以我们前面所有的例程测试 APP 都是采用阻塞 IO。如果应用程序要采用非阻塞的方式来访问驱动设备文件，可以使用如下所示代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> fd;<span class="hljs-number">2</span> <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<span class="hljs-number">3</span><span class="hljs-number">4</span> fd = open(<span class="hljs-string">&quot;/dev/xxx_dev&quot;</span>, O_RDWR | O_NONBLOCK);  <span class="hljs-comment">/* 非阻塞方式打开 */</span><span class="hljs-number">5</span> ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data)); <span class="hljs-comment">/* 读取数据 */</span></code></pre></div><p>第 4 行使用 open 函数打开“&#x2F;dev&#x2F;xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候就是非阻塞方式的了。</p><h3 id="2-等待队列"><a href="#2-等待队列" class="headerlink" title="2|等待队列"></a>2|等待队列</h3><h4 id="1-等待队列头"><a href="#1-等待队列头" class="headerlink" title="1.等待队列头"></a><strong>1.等待队列头</strong></h4><p><strong>阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来</strong>。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。Linux 内核提供了等待队列(wait queue)来实现阻塞进程的唤醒工作，如果我们要在驱动中使用等待队列，必须创建并初始化一个等待队列头，等待队列头使用结构体wait_queue_head_t 表示，wait_queue_head_t 结构体定义在文件 include&#x2F;linux&#x2F;wait.h中，结构体内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">39</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue_head</span> &#123;</span><span class="hljs-number">40</span> <span class="hljs-type">spinlock_t</span> lock;<span class="hljs-number">41</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">task_list</span>;</span><span class="hljs-number">42</span> &#125;;<span class="hljs-number">43</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue_head</span> <span class="hljs-title">wait_queue_head_t</span>;</span></code></pre></div><p>定义好等待队列头以后需要初始化，使用 init_waitqueue_head 函数初始化等待队列头，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init_waitqueue_head</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q)</span></code></pre></div><p>参数 q 就是要初始化的等待队列头。</p><p>也可以使用宏 <strong>DECLARE_WAIT_QUEUE_HEAD</strong> 来一次性完成等待队列头的定义的初始化。</p><hr><h4 id="2-等待队列项"><a href="#2-等待队列项" class="headerlink" title="2.等待队列项"></a><strong>2.等待队列项</strong></h4><p>等待队列头就是一个等待队列的头部，每个访问设备的进程都是一个队列项，当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面。结构体 wait_queue_t 表示等待队列项，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue</span> &#123;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;    <span class="hljs-type">void</span> *private;    <span class="hljs-type">wait_queue_func_t</span> func;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">task_list</span>;</span>&#125;;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue</span> <span class="hljs-title">wait_queue_t</span>;</span></code></pre></div><p>使用宏 <strong>DECLARE_WAITQUEUE</strong> 定义并初始化一个等待队列项，宏的内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">DECLARE_WAITQUEUE(name, tsk)</code></pre></div><p><strong>name</strong> 就是等待队列项的名字，<strong>tsk</strong> 表示这个等待队列项属于哪个任务(进程)，一般设置为current ， 在 Linux 内 核 中 current 相 当 于 一 个 全 局 变 量 ， 表 示 当 前 进 程 。 因 此 宏DECLARE_WAITQUEUE 就是给当前正在运行的进程创建并初始化了一个等待队列项。</p><hr><h4 id="3-将队列项添加-x2F-移除等待队列头"><a href="#3-将队列项添加-x2F-移除等待队列头" class="headerlink" title="3.将队列项添加&#x2F;移除等待队列头"></a><strong>3.将队列项添加&#x2F;移除等待队列头</strong></h4><p>当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，只有添加到等待队列头中以后进程才能进入休眠态。当设备可以访问以后再将进程对应的等待队列项从等待队列头中移除即可，等待队列项添加 API 函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">add_wait_queue</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q,</span><span class="hljs-params">                    <span class="hljs-type">wait_queue_t</span> *wait)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><strong>q</strong> ：等待队列项要加入的等待队列头。<br><strong>wait</strong>：要加入的等待队列项。<br><strong>返回值</strong>：无。</li></ul><p>等待队列项移除 API 函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">remove_wait_queue</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q,</span><span class="hljs-params">                       <span class="hljs-type">wait_queue_t</span> *wait)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><strong>q</strong> ：要删除的等待队列项所处的等待队列头。<br><strong>wait</strong>：要删除的等待队列项。<br><strong>返回值</strong>：无。</li></ul><hr><h4 id="4-等待唤醒"><a href="#4-等待唤醒" class="headerlink" title="4.等待唤醒"></a><strong>4.等待唤醒</strong></h4><p>当设备可以使用的时候就要唤醒进入休眠态的进程，唤醒可以使用如下两个函数：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">wake_up</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q)</span><span class="hljs-type">void</span> <span class="hljs-title function_">wake_up_interruptible</span><span class="hljs-params">(<span class="hljs-type">wait_queue_head_t</span> *q)</span></code></pre></div><p>参数 q 就是要唤醒的等待队列头，这两个函数会<strong>将这个等待队列头中的所有进程都唤醒</strong>。<strong>wake_up</strong> 函数可以唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 状态的进程，而 <strong>wake_up_interruptible</strong> 函数只能唤醒处于 TASK_INTERRUPTIBLE 状态的进程。</p><hr><h4 id="5-等待事件"><a href="#5-等待事件" class="headerlink" title="5.等待事件"></a><strong>5.等待事件</strong></h4><p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程，和等待事件有关的 API 函数如表  所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826142839512.png" alt="image-20200826142839512"></p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200826142846893.png" alt="image-20200826142846893"></p><h3 id="3-轮询"><a href="#3-轮询" class="headerlink" title="3|轮询"></a>3|轮询</h3><p>如果用户应用程序以非阻塞的方式访问设备，设备驱动程序就要提供非阻塞的处理方式，也就是轮询。<strong>poll、epoll 和 select 可以用于处理轮询</strong>，应用程序通过 select、epoll 或 poll 函数来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。当应用程序调用 select、epoll 或 poll 函数的时候设备驱动程序中的 poll 函数就会执行，因此需要在设备驱动程序中编写 poll 函数。我们先来看一下应用程序中使用的 select、poll 和 epoll这三个函数。</p><h4 id="1-select-函数"><a href="#1-select-函数" class="headerlink" title="1.select  函数"></a>1.select  函数</h4><p>select 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,</span><span class="hljs-params">           fd_set *readfds,</span><span class="hljs-params">           fd_set *writefds,</span><span class="hljs-params">           fd_set *exceptfds,</span><span class="hljs-params">           <span class="hljs-keyword">struct</span> timeval *timeout)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><p><strong>nfds</strong> ：所要监视的这三类文件描述集合中，最大文件描述符加 1。</p></li><li><p><strong>readfds 、writefds 和 和 exceptfds</strong>：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，这三个参数都是 fd_set 类型的，fd_set 类型变量的每一个位都代表了一个文件描述符。readfds 用于监视指定描述符集的读变化，也就是监视这些文件是否可以读取，只要这些集合里面有一个文件可以读取那么 seclect 就会返回一个大于 0 的值表示文件可以读取。如果没有文件可以读取，那么就会根据 timeout 参数来判断是否超时。可以将 readfs设置为 NULL，表示不关心任何文件的读变化。writefds 和 readfs 类似，只是 writefs 用于监视这些文件是否可以进行写操作。exceptfds 用于监视这些文件的异常。</p><p>比如我们现在要从一个设备文件中读取数据，那么就可以定义一个 fd_set 变量，这个变量要传递给参数 readfds。当我们定义好一个 fd_set 变量以后可以使用如下所示几个宏进行操作：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FD_ZERO</span><span class="hljs-params">(fd_set *<span class="hljs-built_in">set</span>)</span><span class="hljs-type">void</span> <span class="hljs-title function_">FD_SET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span><span class="hljs-type">void</span> <span class="hljs-title function_">FD_CLR</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span><span class="hljs-type">int</span> <span class="hljs-title function_">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span></code></pre></div><p><strong>FD_ZERO</strong> 用于将 fd_set 变量的所有位都清零，<strong>FD_SET</strong> 用于将 fd_set 变量的某个位置 1，也就是向 fd_set 添加一个文件描述符，参数 fd 就是要加入的文件描述符。<strong>FD_CLR</strong> 用户将 fd_set变量的某个位清零，也就是将一个文件描述符从 fd_set 中删除，参数 fd 就是要删除的文件描述符。<strong>FD_ISSET</strong> 用于测试一个文件是否属于某个集合，参数 fd 就是要判断的文件描述符。</p></li><li><p><strong>timeout</strong> :超时时间，当我们调用 select 函数等待某些文件描述符可以设置超时时间，超时时间使用结构体 timeval 表示，结构体定义如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span>    <span class="hljs-type">long</span> tv_sec; <span class="hljs-comment">/* 秒 */</span>    <span class="hljs-type">long</span> tv_usec; <span class="hljs-comment">/* 微妙 */</span> &#125;;</code></pre></div><p>当 timeout 为 NULL 的时候就表示无限期的等待。</p></li><li><p><strong>返回值</strong>：0，表示的话就表示超时发生，但是没有任何文件描述符可以进行操作；-1，发生错误；其他值，可以进行操作的文件描述符个数。</p></li></ul><p>使用 select 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>2 &#123;<span class="hljs-number">3</span> <span class="hljs-type">int</span> ret, fd; <span class="hljs-comment">/* 要监视的文件描述符 */</span><span class="hljs-number">4</span> fd_set readfds; <span class="hljs-comment">/* 读操作文件描述符集 */</span><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span> <span class="hljs-comment">/* 超时结构体 */</span><span class="hljs-number">6</span><span class="hljs-number">7</span> fd = open(<span class="hljs-string">&quot;dev_xxx&quot;</span>, O_RDWR | O_NONBLOCK); <span class="hljs-comment">/* 非阻塞式访问 */</span><span class="hljs-number">8</span><span class="hljs-number">9</span>FD_ZERO(&amp;readfds); <span class="hljs-comment">/* 清除 readfds */</span><span class="hljs-number">10</span> FD_SET(fd, &amp;readfds); <span class="hljs-comment">/* 将 fd 添加到 readfds 里面 */</span><span class="hljs-number">11</span><span class="hljs-number">12</span> <span class="hljs-comment">/* 构造超时时间 */</span><span class="hljs-number">13</span> timeout.tv_sec = <span class="hljs-number">0</span>;<span class="hljs-number">14</span> timeout.tv_usec = <span class="hljs-number">500000</span>; <span class="hljs-comment">/* 500ms */</span><span class="hljs-number">15</span><span class="hljs-number">16</span> ret = select(fd + <span class="hljs-number">1</span>, &amp;readfds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;timeout);<span class="hljs-number">17</span> <span class="hljs-keyword">switch</span> (ret) &#123;<span class="hljs-number">18</span> <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* 超时 */</span><span class="hljs-number">19</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timeout!\r\n&quot;</span>);<span class="hljs-number">20</span> <span class="hljs-keyword">break</span>;<span class="hljs-number">21</span> <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>: <span class="hljs-comment">/* 错误 */</span><span class="hljs-number">22</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error!\r\n&quot;</span>);<span class="hljs-number">23</span> <span class="hljs-keyword">break</span>;<span class="hljs-number">24</span> <span class="hljs-keyword">default</span>: <span class="hljs-comment">/* 可以读取数据 */</span><span class="hljs-number">25</span> <span class="hljs-keyword">if</span>(FD_ISSET(fd, &amp;readfds)) &#123; <span class="hljs-comment">/* 判断是否为 fd 文件描述符 */</span><span class="hljs-number">26</span> <span class="hljs-comment">/* 使用 read 函数读取数据 */</span><span class="hljs-number">27</span> &#125;<span class="hljs-number">28</span> <span class="hljs-keyword">break</span>;<span class="hljs-number">29</span> &#125;<span class="hljs-number">30</span> &#125;</code></pre></div><h4 id="2-poll-函数"><a href="#2-poll-函数" class="headerlink" title="2.poll  函数"></a>2.poll  函数</h4><p>在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，可以<br>修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使用 poll 函数，poll 函数本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制，Linux 应用程序中 poll 函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds,</span><span class="hljs-params">         <span class="hljs-type">nfds_t</span> nfds,</span><span class="hljs-params">         <span class="hljs-type">int</span> timeout)</span></code></pre></div><ul><li><p>函数参数和返回值含义如下：<br><strong>fds</strong> ：要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的，pollfd 结构体如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span>    <span class="hljs-type">int</span> fd; <span class="hljs-comment">/* 文件描述符 */</span>    <span class="hljs-type">short</span> events; <span class="hljs-comment">/* 请求的事件 */</span>    <span class="hljs-type">short</span> revents; <span class="hljs-comment">/* 返回的事件 */</span>&#125;;</code></pre></div><p>fd 是要监视的文件描述符，如果 fd 无效的话那么 events 监视事件也就无效，并且 revents返回 0。events 是要监视的事件，可监视的事件类型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">POLLIN 有数据可以读取。POLLPRI 有紧急的数据需要读取。POLLOUT  可以写数据。POLLERR  指定的文件描述符发生错误。POLLHUP  指定的文件描述符挂起。POLLNVAL 无效的请求。POLLRDNORM  等同于 POLLIN</code></pre></div><p>revents 是返回参数，也就是返回的事件，由 Linux 内核设置具体的返回事件。</p></li><li><p><strong>nfds</strong>：poll 函数要监视的文件描述符数量。</p></li><li><p><strong>timeout</strong> ：超时时间，单位为 ms。</p></li><li><p><strong>返回值</strong>：返回 revents 域中不为 0 的 pollfd 结构体个数，也就是发生事件或错误的文件描述符数量；0，超时；-1，发生错误，并且设置 errno 为错误类型。</p></li></ul><p>使用 poll 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>2 &#123;<span class="hljs-number">3</span> <span class="hljs-type">int</span> ret;<span class="hljs-number">4</span> <span class="hljs-type">int</span> fd; <span class="hljs-comment">/* 要监视的文件描述符 */</span><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>;</span><span class="hljs-number">6</span><span class="hljs-number">7</span> fd = open(filename, O_RDWR | O_NONBLOCK); <span class="hljs-comment">/* 非阻塞式访问 */</span><span class="hljs-number">8</span><span class="hljs-number">9</span> <span class="hljs-comment">/* 构造结构体 */</span><span class="hljs-number">10</span> fds.fd = fd;<span class="hljs-number">11</span> fds.events = POLLIN; <span class="hljs-comment">/* 监视数据是否可以读取 */</span><span class="hljs-number">12</span><span class="hljs-number">13</span> ret = poll(&amp;fds, <span class="hljs-number">1</span>, <span class="hljs-number">500</span>); <span class="hljs-comment">/* 轮询文件是否可操作，超时 500ms */</span><span class="hljs-number">14</span> <span class="hljs-keyword">if</span> (ret) &#123; <span class="hljs-comment">/* 数据有效 */</span><span class="hljs-number">15</span> ......<span class="hljs-number">16</span> <span class="hljs-comment">/* 读取数据 */</span><span class="hljs-number">17</span> ......<span class="hljs-number">18</span> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 超时 */</span><span class="hljs-number">19</span> ......<span class="hljs-number">20</span> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 错误 */</span><span class="hljs-number">21</span> ......<span class="hljs-number">22</span> &#125;<span class="hljs-number">23</span> &#125;</code></pre></div><h4 id="3-epoll-函数"><a href="#3-epoll-函数" class="headerlink" title="3.epoll  函数"></a>3.epoll  函数</h4><p>传统的 selcet 和 poll 函数都会随着所监听的 fd 数量的增加，出现效率低下的问题，而且poll 函数每次必须遍历所有的描述符来检查就绪的描述符，这个过程很浪费时间。为此，epoll应运而生，epoll 就是为处理大并发而准备的，一般常常在网络编程中使用 epoll 函数。应用程序需要先使用 epoll_create 函数创建一个 epoll 句柄，epoll_create 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><strong>size</strong> ：从 Linux2.6.8 开始此参数已经没有意义了，随便填写一个大于 0 的值就可以。</li><li><strong>返回值</strong>：epoll 句柄，如果为-1 的话表示创建失败。</li></ul><p>epoll 句柄创建成功以后使用 epoll_ctl 函数向其中添加要监视的文件描述符以及监视的事<br>件，epoll_ctl 函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd,</span><span class="hljs-params">              <span class="hljs-type">int</span> op,</span><span class="hljs-params">              <span class="hljs-type">int</span>  fd,</span><span class="hljs-params">              <span class="hljs-keyword">struct</span> epoll_event *event)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><p><strong>epfd</strong> ：要操作的 epoll 句柄，也就是使用 epoll_create 函数创建的 epoll 句柄。</p></li><li><p><strong>op</strong> ：表示要对 epfd(epoll 句柄)进行的操作，可以设置为：</p><div class="hljs code-wrapper"><pre><code class="hljs c">EPOLL_CTL_ADD  向 epfd 添加文件参数 fd 表示的描述符。EPOLL_CTL_MOD  修改参数 fd 的 event 事件。EPOLL_CTL_DEL 从 epfd 中删除 fd 描述符。</code></pre></div></li><li><p><strong>fd</strong>：要监视的文件描述符。</p></li><li><p><strong>event</strong> ：要监视的事件类型，为 epoll_event 结构体类型指针，epoll_event 结构体类型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span>    <span class="hljs-type">uint32_t</span> events; <span class="hljs-comment">/* epoll 事件 */</span>    <span class="hljs-type">epoll_data_t</span> data; <span class="hljs-comment">/* 用户数据 */</span>&#125;;</code></pre></div><p>结构体 epoll_event 的 events 成员变量表示要监视的事件，可选的事件如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">EPOLLIN</span>  有数据可以读取。EPOLLOUT 可以写数据。EPOLLPRI 有紧急的数据需要读取。EPOLLERR 指定的文件描述符发生错误。EPOLLHUP 指定的文件描述符挂起。EPOLLET  设置 <span class="hljs-literal">epoll</span> 为边沿触发，默认触发模式为水平触发。EPOLLONESHOT 一次性的监视，当监视完成以后还需要再次监视某个 fd，那么就需要将fd 重新添加到 <span class="hljs-literal">epoll</span> 里面。</code></pre></div><p>上面这些事件可以进行“或”操作，也就是说可以设置监视多个事件。</p></li><li><p>返回值：0，成功；-1，失败，并且设置 errno 的值为相应的错误码。</p></li></ul><p>一切都设置好以后应用程序就可以通过 epoll_wait 函数来等待事件的发生，类似 select 函数。epoll_wait 函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd,</span><span class="hljs-params">               <span class="hljs-keyword">struct</span> epoll_event *events,</span><span class="hljs-params">               <span class="hljs-type">int</span> maxevents,</span><span class="hljs-params">               <span class="hljs-type">int</span> timeout)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><strong>epfd</strong> ：要等待的 epoll。</li><li><strong>events</strong> ：指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调用者可以根据 events 判断发生了哪些事件。</li><li><strong>maxevents</strong>：events 数组大小，必须大于 0。</li><li><strong>timeout</strong> ：超时时间，单位为 ms。</li><li><strong>返回值</strong>：0，超时；-1，错误；其他值，准备就绪的文件描述符数量。</li></ul><p>epoll 更多的是用在大规模的并发服务器上，因为在这种场合下 select 和 poll 并不适合。当设计到的文件描述符(fd)比较少的时候就适合用 selcet 和 poll，本章我们就使用 sellect 和poll 这两个函数.</p><h3 id="4-Linux-驱动下的-poll-操作函数"><a href="#4-Linux-驱动下的-poll-操作函数" class="headerlink" title="4| Linux  驱动下的 poll  操作函数"></a>4| Linux  驱动下的 poll  操作函数</h3><p>当应用程序调用 select 或 poll 函数来对驱动程序进行非阻塞访问的时候，驱动程序file_operations 操作集中的 poll 函数就会执行。所以驱动程序的编写者需要提供对应的 poll 函数，poll 函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-keyword">struct</span> poll_table_struct *wait)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><p><strong>filp</strong> ：要打开的设备文件(文件描述符)。</p></li><li><p><strong>wait</strong> ：结构体 poll_table_struct 类型指针，由应用程序传递进来的。一般将此参数传递给poll_wait 函数。</p></li><li><p><strong>返回值</strong>:向应用程序返回设备或者资源状态，可以返回的资源状态如下：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">POLLIN</span> 有数据可以读取。POLLPRI 有紧急的数据需要读取。POLLOUT  可以写数据。POLLERR  指定的文件描述符发生错误。POLLHUP  指定的文件描述符挂起。POLLNVAL 无效的请求。POLLRDNORM  等同于 POLLIN，普通数据可读</code></pre></div></li></ul><p>我们需要在驱动程序的 poll 函数中调用 poll_wait 函数，poll_wait 函数不会引起阻塞，只是将应用程序添加到 poll_table 中，poll_wait 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">poll_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file * filp, <span class="hljs-type">wait_queue_head_t</span> * wait_address, poll_table *p)</span></code></pre></div><p>参数 wait_address 是要添加到 poll_table 中的等待队列头，参数 p 就是 poll_table，就是file_operations 中 poll 函数的 wait 参数。</p><h2 id="二、阻塞-IO-实验"><a href="#二、阻塞-IO-实验" class="headerlink" title="二、阻塞 IO  实验"></a>二、阻塞 IO  实验</h2><p>在上一章 Linux 中断实验中，我们直接在应用程序中通过 read 函数不断的读取按键状态，当按键有效的时候就打印出按键值。这种方法有个缺点，那就是 imx6uirqApp 这个测试应用程序拥有很高的 CPU 占用率，大家可以在开发板中加载上一章的驱动程序模块 imx6uirq.ko，然后以后台运行模式打开 imx6uirqApp 这个测试软件，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">./imx6uirqApp /dev/imx6uirq &amp;</code></pre></div><p>测试驱动是否正常工作，如果驱动工作正常的话输入“top”命令查看 imx6uirqApp 这个应用程序的 CPU 使用率，结果如图  所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827114714058.png" alt="image-20200827114714058"></p><p>从图可以看出，imx6uirqApp 这个应用程序的 CPU 使用率竟然高达 99.6%，这仅仅是一个读取按键值的应用程序，这么高的 CPU 使用率显然是有问题的！原因就在于我们是直接在 while 循环中通过 read 函数读取按键值，因此 imx6uirqApp 这个软件会一直运行，一直读取按键值，CPU 使用率肯定就会很高。最好的方法就是在没有有效的按键事件发生的时候，imx6uirqApp 这个应用程序应该处于休眠状态，当有按键事件发生以后 imx6uirqApp 这个应用程序才运行，打印出按键值，这样就会降低 CPU 使用率，本小节我们就使用阻塞 IO 来实现此功能。</p><h3 id="1-驱动程序编写"><a href="#1-驱动程序编写" class="headerlink" title="1|驱动程序编写"></a>1|驱动程序编写</h3><p>本章实验我们在上一章的“13_irq”实验的基础上完成，主要是对其添加阻塞访问相关的代码。新建名为“14_blockio”的文件夹，然后在 14_blockio 文件夹里面创建 vscode 工程，工作区命名为“blockio”。将“13_irq”实验中的 imx6uirq.c 复制到 14_blockio 文件夹中，并重命名为 blockio.c。</p><p>接下来我们就修改 blockio.c 这个文件，在其中添加阻塞相关的代码，完成以后的blockio.c 内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CNT 1<span class="hljs-comment">/* 设备号个数 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_NAME <span class="hljs-string">&quot;blockio&quot;</span><span class="hljs-comment">/* 设备名 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE 0X01 <span class="hljs-comment">/* KEY0 按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY 0XFF <span class="hljs-comment">/* 无效的按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_CNT 1  <span class="hljs-comment">/* 按键数量 */</span></span><span class="hljs-comment">/* 中断 IO 描述结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> &#123;</span><span class="hljs-type">int</span> gpio; <span class="hljs-comment">/* gpio */</span><span class="hljs-type">int</span> irqnum; <span class="hljs-comment">/* 中断号 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value; <span class="hljs-comment">/* 按键对应的键值  */</span><span class="hljs-type">char</span> name[<span class="hljs-number">10</span>]; <span class="hljs-comment">/* 名字 */</span><span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *); <span class="hljs-comment">/* 中断服务函数 */</span>&#125;;<span class="hljs-comment">/* imx6uirq设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span><span class="hljs-comment">/* 设备树节点 */</span><span class="hljs-type">atomic_t</span> keyvalue; <span class="hljs-comment">/* 有效的按键键值 */</span><span class="hljs-type">atomic_t</span> releasekey; <span class="hljs-comment">/* 标记是否完成一次完成的按键*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> <span class="hljs-comment">/* 定义一个定时器*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> <span class="hljs-title">irqkeydesc</span>[<span class="hljs-title">KEY_CNT</span>];</span> <span class="hljs-comment">/* 按键描述数组 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> curkeynum; <span class="hljs-comment">/* 当前的按键号 */</span><span class="hljs-type">wait_queue_head_t</span> r_wait;<span class="hljs-comment">/* 读等待对列头 */</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> <span class="hljs-title">imx6uirq</span>;</span><span class="hljs-comment">/* @description : 中断服务函数，开启定时器，延时 10ms，</span><span class="hljs-comment"> * 定时器用于按键消抖。</span><span class="hljs-comment"> * @param - irq : 中断号</span><span class="hljs-comment"> * @param - dev_id : 设备结构。</span><span class="hljs-comment"> * @return : 中断执行结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">key0_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)dev_id;dev-&gt;curkeynum = <span class="hljs-number">0</span>;dev-&gt;timer.data = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span>)dev_id;mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="hljs-number">10</span>));<span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);&#125;<span class="hljs-comment">/* @description : 定时器服务函数，用于按键消抖，定时器到了以后</span><span class="hljs-comment"> * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><span class="hljs-comment"> * @param – arg  : 设备结构变量</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> *<span class="hljs-title">keydesc</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)arg;num = dev-&gt;curkeynum;keydesc = &amp;dev-&gt;irqkeydesc[num];value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/* 读取 IO 值 */</span><span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">/* 按键松开 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="hljs-number">0x80</span> | keydesc-&gt;value);<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 标记松开按键 */</span>&#125;<span class="hljs-comment">/*  唤醒进程 */</span><span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey))&#123; <span class="hljs-comment">/*  完成一次按键过程 */</span><span class="hljs-comment">/* wake_up(&amp;dev-&gt;r_wait); */</span>wake_up_interruptible(&amp;dev-&gt;r_wait);&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : 按键 IO 初始化</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;imx6uirq.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);<span class="hljs-keyword">if</span> (imx6uirq.nd == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;k:key node not find!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-comment">/* 提取 GPIO */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd,<span class="hljs-string">&quot;key-gpios&quot;</span>, i);<span class="hljs-keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:can&#x27;t get key%d\r\n&quot;</span>, i);&#125;&#125;<span class="hljs-comment">/* 初始化 key 所使用的 IO，并且设置成中断模式 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;<span class="hljs-built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-number">0</span>,   <span class="hljs-keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));<span class="hljs-built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-string">&quot;KEY%d&quot;</span>, i);gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(imx6uirq.nd, i);<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(imx6uirq.irqkeydesc[i].gpio);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>printk(<span class="hljs-string">&quot;k:key%d:gpio=%d, irqnum=%d\r\n&quot;</span>, i,   imx6uirq.irqkeydesc[i].gpio,   imx6uirq.irqkeydesc[i].irqnum);&#125;<span class="hljs-comment">/* 申请中断 */</span>imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].handler = key0_handler;imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].value = KEY0VALUE;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;ret = request_irq(imx6uirq.irqkeydesc[i].irqnum,  imx6uirq.irqkeydesc[i].handler,  IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,  imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:irq %d request failed!\r\n&quot;</span>,   imx6uirq.irqkeydesc[i].irqnum);<span class="hljs-keyword">return</span> -EFAULT;&#125;&#125;<span class="hljs-comment">/* 创建定时器 */</span>init_timer(&amp;imx6uirq.timer);imx6uirq.timer.function = timer_function;<span class="hljs-comment">/*  初始化等待队列头 */</span>init_waitqueue_head(&amp;imx6uirq.r_wait);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;imx6uirq; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : 从设备读取数据</span><span class="hljs-comment"> * @param – filp : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @param – buf : 返回给用户空间的数据缓冲区</span><span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span><span class="hljs-comment"> * @param – offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">imx6uirq_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf,</span><span class="hljs-params"> <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> keyvalue = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> releasekey = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)   filp-&gt;private_data;<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><span class="hljs-comment">/*  加入等待队列，等待被唤醒, 也就是有按键按下 */</span>ret = wait_event_interruptible(dev-&gt;r_wait,   <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey));<span class="hljs-keyword">if</span> (ret) &#123;<span class="hljs-keyword">goto</span> wait_error;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>DECLARE_WAITQUEUE(wait, current); <span class="hljs-comment">/*  定义一个等待队列 */</span><span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/*  没有按键按下 */</span>add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait); <span class="hljs-comment">/*  添加到等待队列头 */</span>__set_current_state(TASK_INTERRUPTIBLE); <span class="hljs-comment">/*  设置任务状态 */</span>schedule(); <span class="hljs-comment">/*  进行一次任务切换 */</span><span class="hljs-keyword">if</span> (signal_pending(current))&#123; <span class="hljs-comment">/*  判断是否为信号引起的唤醒 */</span>ret = -ERESTARTSYS;<span class="hljs-keyword">goto</span> wait_error;&#125;__set_current_state(TASK_RUNNING);<span class="hljs-comment">/* 设置为运行状态 */</span>remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait); <span class="hljs-comment">/* 将等待队列移除 */</span>&#125;keyvalue = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;keyvalue);releasekey = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey);<span class="hljs-keyword">if</span> (releasekey)&#123; <span class="hljs-comment">/* 有按键按下 */</span><span class="hljs-keyword">if</span> (keyvalue &amp; <span class="hljs-number">0x80</span>)&#123;keyvalue &amp;= ~<span class="hljs-number">0x80</span>;ret = copy_to_user(buf, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">goto</span> data_error;&#125;<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 按下标志清零 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">goto</span> data_error;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;wait_error:set_current_state(TASK_RUNNING);<span class="hljs-comment">/*  设置任务为运行态 */</span>remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait); <span class="hljs-comment">/*  将等待队列移除 */</span><span class="hljs-keyword">return</span> ret;data_error:<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-comment">/* 设备操作函数 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">imx6uirq_fops</span> =</span> &#123;.owner = THIS_MODULE,.open = imx6uirq_open,.read = imx6uirq_read,&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">imx6uirq_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 注册设备号 */</span>imx6uirq.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(imx6uirq.major)&#123;imx6uirq.devid = MKDEV(imx6uirq.major, imx6uirq.minor);ret = register_chrdev_region(imx6uirq.devid, DEV_CNT, DEV_NAME);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;imx6uirq.devid, <span class="hljs-number">0</span>, DEV_CNT, DEV_NAME);&#125;imx6uirq.major = MAJOR(imx6uirq.devid);imx6uirq.minor = MINOR(imx6uirq.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;k:imx6uirq  MAJOR:%d  MINOR:%d\r\n&quot;</span>, imx6uirq.major, imx6uirq.minor);<span class="hljs-comment">/* 添加字符设备 */</span>imx6uirq.cdev.owner = imx6uirq_fops.owner;cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);ret = cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, DEV_CNT);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>imx6uirq.class = class_create(THIS_MODULE, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.class))&#123;printk(<span class="hljs-string">&quot;k:fail to create class!\r\n&quot;</span>);result = PTR_ERR(imx6uirq.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>imx6uirq.device = device_create(imx6uirq.class, <span class="hljs-literal">NULL</span>, imx6uirq.devid, <span class="hljs-literal">NULL</span>, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.device))&#123;printk(<span class="hljs-string">&quot;k:fail to create device!\r\n&quot;</span>);result = PTR_ERR(imx6uirq.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 5、初始化按键 */</span><span class="hljs-type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="hljs-number">0</span>);keyio_init();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(imx6uirq.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;imx6uirq.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(imx6uirq.devid, DEV_CNT);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">imx6uirq_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 删除定时器 */</span>del_timer_sync(&amp;imx6uirq.timer);<span class="hljs-comment">/* 释放中断 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);&#125;<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(imx6uirq.class, imx6uirq.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(imx6uirq.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;imx6uirq.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(imx6uirq.devid, DEV_CNT);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(imx6uirq_init);module_exit(imx6uirq_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><ul><li>修改设备文件名字为“blockio”，当驱动程序加载成功以后就会在根文件系统中出现一个名为“&#x2F;dev&#x2F;blockio”的文件。</li><li>在设备结构体中添加一个等待队列头 r_wait，因为在 Linux 驱动中处理阻塞 IO需要用到等待队列.</li><li>定时器中断处理函数执行，表示有按键按下，先判断一下是否是一次有效的按键，如果是的话就通过 wake_up 或者 wake_up_interruptible 函数来唤醒等待队列r_wait。</li><li>keyio_init中调用 init_waitqueue_head 函数初始化等待队列头 r_wait。</li><li>read函数中采用等待事件来处理 read 的阻塞访问，wait_event_interruptible 函数等待releasekey 有效，也就是有按键按下。如果按键没有按下的话进程就会进入休眠状态，因为采用了 wait_event_interruptible 函数，因此进入休眠态的进程可以被信号打断。</li><li>首先使用 DECLARE_WAITQUEUE 宏定义一个等待队列，如果没有按键按下的话就使用add_wait_queue 函数将当前任务的等待队列添加到等待队列头 r_wait 中。随后调用__set_current_state 函数设置当前进程的状态为 TASK_INTERRUPTIBLE，也就是可以被信号打断。接下来调用 schedule 函数进行一次任务切换，当前进程就会进入到休眠态。如果有按键按下，那么进入休眠态的进程就会唤醒，然后接着从休眠点开始运行。被唤醒后首先通过 signal_pending 函数判断一下进程是不是由信号唤醒的，如果是由信号唤醒的话就直接返回-ERESTARTSYS 这个错误码。如果不是由信号唤醒的(也就是被按键唤醒的)那么就调用__set_current_state 函数将任务状态设置为 TASK_RUNNING，然后调用remove_wait_queue 函数将进程从等待队列中删除。</li></ul><p>使用等待队列实现阻塞访问重点注意两点：<br>①、将任务或者进程加入到等待队列头，<br>②、在合适的点唤醒等待队列，一般都是中断处理函数里面。</p><h3 id="2-APP编写"><a href="#2-APP编写" class="headerlink" title="2|APP编写"></a>2|APP编写</h3><p>测试 APP 直接使用前面所编写的 imx6uirqApp.c，将 imx6uirqApp.c 复制到本节实验文件夹下，并且重命名为 blockioApp.c，不需要修改任何内容。</p><h3 id="3-运行测试"><a href="#3-运行测试" class="headerlink" title="3|运行测试"></a>3|运行测试</h3><p>编译运行。</p><p>驱动加载成功以后使用如下命令打开 blockioApp 这个测试 APP，并且以后台模式运行：</p><div class="hljs code-wrapper"><pre><code class="hljs c">./blockioApp /dev/blockio &amp;</code></pre></div><p>按下开发板上的 KEY0 按键，结果如图 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827121431518.png" alt="image-20200827121431518"></p><p>输入“top”命令，查看 blockioAPP 这个应用 APP 的 CPU 使用率，如图  所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827121452839.png" alt="image-20200827121452839"></p><p>可以看出，当我们在按键驱动程序里面加入阻塞访问以后，blockioApp 这个应用程序的 CPU 使用率从 99.6%降低到了 0.0%。大家注意，这里的 0.0%并不是说 blockioApp 这个应用程序不使用 CPU 了，只是因为使用率太小了，CPU 使用率可能为0.00001%，但是图只能显示出小数点后一位，因此就显示成了 0.0%。</p><h2 id="三、非阻塞-IO-实验"><a href="#三、非阻塞-IO-实验" class="headerlink" title="三、非阻塞 IO 实验"></a>三、非阻塞 IO 实验</h2><h3 id="1-驱动程序编写-1"><a href="#1-驱动程序编写-1" class="headerlink" title="1|驱动程序编写"></a>1|驱动程序编写</h3><p>本实验我们在“14_blockio”实验的基础上完成，上一小节实验我们已经在驱动中添加了阻塞 IO 的代码，本小节我们继续完善驱动，加入非阻塞 IO 驱动代码。新建名为“15_noblockio”的文件夹，然后在 15_noblockio 文件夹里面创建 vscode 工程，工作区命名为“noblockio”。将“14_blockio”实验中的 blockio.c 复制到 15_noblockio 文件夹中，并重命名为 noblockio.c。</p><p>接下来我们就修改 noblockio.c 这个文件，在其中添加非阻塞相关的代码，完成以后的 noblockio.c 内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CNT 1<span class="hljs-comment">/* 设备号个数 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_NAME <span class="hljs-string">&quot;noblockio&quot;</span><span class="hljs-comment">/* 设备名 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE 0X01 <span class="hljs-comment">/* KEY0 按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY 0XFF <span class="hljs-comment">/* 无效的按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_CNT 1  <span class="hljs-comment">/* 按键数量 */</span></span><span class="hljs-comment">/* 中断 IO 描述结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> &#123;</span><span class="hljs-type">int</span> gpio; <span class="hljs-comment">/* gpio */</span><span class="hljs-type">int</span> irqnum; <span class="hljs-comment">/* 中断号 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value; <span class="hljs-comment">/* 按键对应的键值  */</span><span class="hljs-type">char</span> name[<span class="hljs-number">10</span>]; <span class="hljs-comment">/* 名字 */</span><span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *); <span class="hljs-comment">/* 中断服务函数 */</span>&#125;;<span class="hljs-comment">/* imx6uirq设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span><span class="hljs-comment">/* 设备树节点 */</span><span class="hljs-type">atomic_t</span> keyvalue; <span class="hljs-comment">/* 有效的按键键值 */</span><span class="hljs-type">atomic_t</span> releasekey; <span class="hljs-comment">/* 标记是否完成一次完成的按键*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> <span class="hljs-comment">/* 定义一个定时器*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> <span class="hljs-title">irqkeydesc</span>[<span class="hljs-title">KEY_CNT</span>];</span> <span class="hljs-comment">/* 按键描述数组 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> curkeynum; <span class="hljs-comment">/* 当前的按键号 */</span><span class="hljs-type">wait_queue_head_t</span> r_wait;<span class="hljs-comment">/* 读等待对列头 */</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> <span class="hljs-title">imx6uirq</span>;</span><span class="hljs-comment">/* @description : 中断服务函数，开启定时器，延时 10ms，</span><span class="hljs-comment"> * 定时器用于按键消抖。</span><span class="hljs-comment"> * @param - irq : 中断号</span><span class="hljs-comment"> * @param - dev_id : 设备结构。</span><span class="hljs-comment"> * @return : 中断执行结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">key0_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)dev_id;dev-&gt;curkeynum = <span class="hljs-number">0</span>;dev-&gt;timer.data = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span>)dev_id;mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="hljs-number">10</span>));<span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);&#125;<span class="hljs-comment">/* @description : 定时器服务函数，用于按键消抖，定时器到了以后</span><span class="hljs-comment"> * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><span class="hljs-comment"> * @param – arg  : 设备结构变量</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> *<span class="hljs-title">keydesc</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)arg;num = dev-&gt;curkeynum;keydesc = &amp;dev-&gt;irqkeydesc[num];value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/* 读取 IO 值 */</span><span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">/* 按键松开 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="hljs-number">0x80</span> | keydesc-&gt;value);<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 标记松开按键 */</span>&#125;<span class="hljs-comment">/*  唤醒进程 */</span><span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey))&#123; <span class="hljs-comment">/*  完成一次按键过程 */</span><span class="hljs-comment">/* wake_up(&amp;dev-&gt;r_wait); */</span>wake_up_interruptible(&amp;dev-&gt;r_wait);&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : 按键 IO 初始化</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;imx6uirq.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);<span class="hljs-keyword">if</span> (imx6uirq.nd == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;k:key node not find!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-comment">/* 提取 GPIO */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd,<span class="hljs-string">&quot;key-gpios&quot;</span>, i);<span class="hljs-keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:can&#x27;t get key%d\r\n&quot;</span>, i);&#125;&#125;<span class="hljs-comment">/* 初始化 key 所使用的 IO，并且设置成中断模式 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;<span class="hljs-built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-number">0</span>,   <span class="hljs-keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));<span class="hljs-built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-string">&quot;KEY%d&quot;</span>, i);gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(imx6uirq.nd, i);<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(imx6uirq.irqkeydesc[i].gpio);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>printk(<span class="hljs-string">&quot;k:key%d:gpio=%d, irqnum=%d\r\n&quot;</span>, i,   imx6uirq.irqkeydesc[i].gpio,   imx6uirq.irqkeydesc[i].irqnum);&#125;<span class="hljs-comment">/* 申请中断 */</span>imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].handler = key0_handler;imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].value = KEY0VALUE;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;ret = request_irq(imx6uirq.irqkeydesc[i].irqnum,  imx6uirq.irqkeydesc[i].handler,  IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,  imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:irq %d request failed!\r\n&quot;</span>,   imx6uirq.irqkeydesc[i].irqnum);<span class="hljs-keyword">return</span> -EFAULT;&#125;&#125;<span class="hljs-comment">/* 创建定时器 */</span>init_timer(&amp;imx6uirq.timer);imx6uirq.timer.function = timer_function;<span class="hljs-comment">/*  初始化等待队列头 */</span>init_waitqueue_head(&amp;imx6uirq.r_wait);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;imx6uirq; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : 从设备读取数据</span><span class="hljs-comment"> * @param – filp : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @param – buf : 返回给用户空间的数据缓冲区</span><span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span><span class="hljs-comment"> * @param – offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">imx6uirq_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf,</span><span class="hljs-params"> <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> keyvalue = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> releasekey = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)   filp-&gt;private_data;<span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK)&#123;<span class="hljs-comment">/*  非阻塞访问 */</span><span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey) == <span class="hljs-number">0</span>) <span class="hljs-comment">/*  没有按键按下 */</span><span class="hljs-keyword">return</span> -EAGAIN;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 阻塞访问 */</span><span class="hljs-comment">/* 加入等待队列，等待被唤醒,也就是有按键按下 */</span>ret = wait_event_interruptible(dev-&gt;r_wait,   <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey));<span class="hljs-keyword">if</span> (ret)&#123;<span class="hljs-keyword">goto</span> wait_error;&#125;&#125;keyvalue = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;keyvalue);releasekey = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey);<span class="hljs-keyword">if</span> (releasekey)&#123; <span class="hljs-comment">/* 有按键按下 */</span><span class="hljs-keyword">if</span> (keyvalue &amp; <span class="hljs-number">0x80</span>)&#123;keyvalue &amp;= ~<span class="hljs-number">0x80</span>;ret = copy_to_user(buf, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">goto</span> data_error;&#125;<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 按下标志清零 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">goto</span> data_error;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;wait_error:<span class="hljs-keyword">return</span> ret;data_error:<span class="hljs-keyword">return</span> -EINVAL;&#125; <span class="hljs-comment">/*</span><span class="hljs-comment">  * @description     : poll函数，用于处理非阻塞访问</span><span class="hljs-comment">  * @param - filp    : 要打开的设备文件(文件描述符)</span><span class="hljs-comment">  * @param - wait    : 等待列表(poll_table)</span><span class="hljs-comment">  * @return          : 设备或者资源状态，</span><span class="hljs-comment">  */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-keyword">struct</span> poll_table_struct *wait)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;poll_wait(filp, &amp;dev-&gt;r_wait, wait);<span class="hljs-comment">/* 将等待队列头添加到poll_table中 */</span><span class="hljs-keyword">if</span>(<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey)) &#123;<span class="hljs-comment">/* 按键按下 */</span>mask = POLLIN | POLLRDNORM;<span class="hljs-comment">/* 返回PLLIN */</span>&#125;<span class="hljs-keyword">return</span> mask;&#125;<span class="hljs-comment">/* 设备操作函数 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">imx6uirq_fops</span> =</span> &#123;.owner = THIS_MODULE,.open = imx6uirq_open,.read = imx6uirq_read,.poll = imx6uirq_poll,&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">imx6uirq_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 注册设备号 */</span>imx6uirq.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(imx6uirq.major)&#123;imx6uirq.devid = MKDEV(imx6uirq.major, imx6uirq.minor);ret = register_chrdev_region(imx6uirq.devid, DEV_CNT, DEV_NAME);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;imx6uirq.devid, <span class="hljs-number">0</span>, DEV_CNT, DEV_NAME);&#125;imx6uirq.major = MAJOR(imx6uirq.devid);imx6uirq.minor = MINOR(imx6uirq.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;k:imx6uirq  MAJOR:%d  MINOR:%d\r\n&quot;</span>, imx6uirq.major, imx6uirq.minor);<span class="hljs-comment">/* 添加字符设备 */</span>imx6uirq.cdev.owner = imx6uirq_fops.owner;cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);ret = cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, DEV_CNT);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>imx6uirq.class = class_create(THIS_MODULE, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.class))&#123;printk(<span class="hljs-string">&quot;k:fail to create class!\r\n&quot;</span>);result = PTR_ERR(imx6uirq.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>imx6uirq.device = device_create(imx6uirq.class, <span class="hljs-literal">NULL</span>, imx6uirq.devid, <span class="hljs-literal">NULL</span>, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.device))&#123;printk(<span class="hljs-string">&quot;k:fail to create device!\r\n&quot;</span>);result = PTR_ERR(imx6uirq.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 5、初始化按键 */</span><span class="hljs-type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="hljs-number">0</span>);keyio_init();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(imx6uirq.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;imx6uirq.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(imx6uirq.devid, DEV_CNT);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">imx6uirq_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 删除定时器 */</span>del_timer_sync(&amp;imx6uirq.timer);<span class="hljs-comment">/* 释放中断 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);&#125;<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(imx6uirq.class, imx6uirq.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(imx6uirq.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;imx6uirq.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(imx6uirq.devid, DEV_CNT);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(imx6uirq_init);module_exit(imx6uirq_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><ul><li>修改设备文件名字为“noblockio”，当驱动程序加载成功以后就会在根文件系统中出现一个名为“&#x2F;dev&#x2F;noblockio”的文件。</li><li>判断是否为非阻塞式读取访问，如果是的话就判断按键是否有效，也就是判断一下有没有按键按下，如果没有的话就返回-EAGAIN。</li><li>imx6uirq_poll 函数就是 file_operations 驱动操作集中的 poll 函数，当应用程序调用 select 或者 poll 函数的时候 imx6uirq_poll 函数就会执行。调用 poll_wait 函数将等待队列头添加到 poll_table 中，判断按键是否有效，如果按键有效的话就向应用程序返回 POLLIN 这个事件，表示有数据可以读取。</li></ul><h3 id="2-编写测试APP"><a href="#2-编写测试APP" class="headerlink" title="2|编写测试APP"></a>2|编写测试APP</h3><p>新建名为 noblockioApp.c 测试 APP 文件，然后在其中输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/ioctl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;poll.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/select.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/time.h&quot;</span></span><span class="hljs-comment">/*</span><span class="hljs-comment">* @description : main 主程序</span><span class="hljs-comment">* @param - argc : argv 数组元素个数</span><span class="hljs-comment">* @param - argv : 具体参数</span><span class="hljs-comment">* @return : 0 成功;其他 失败</span><span class="hljs-comment">*/</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, fd = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> *filename;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>;</span>    fd_set readfds;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    filename = argv[<span class="hljs-number">1</span>];    <span class="hljs-comment">/* 打开驱动文件 */</span>    fd =  open(filename, O_RDWR | O_NONBLOCK);  <span class="hljs-comment">/* 非阻塞访问 */</span>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>    <span class="hljs-comment">/* POLL */</span><span class="hljs-comment">/* 构造结构体 */</span>fds.fd = fd;fds.events = POLLIN;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;ret = poll(&amp;fds, <span class="hljs-number">1</span>, <span class="hljs-number">500</span>);<span class="hljs-keyword">if</span> (ret) &#123;<span class="hljs-comment">/* 数据有效 */</span>ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data));<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">/* 读取错误 */</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(data)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key value = %d \r\n&quot;</span>, data);&#125; &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 超时 */</span><span class="hljs-comment">/* 用户自定义超时处理 */</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">/* 错误 */</span><span class="hljs-comment">/* 用户自定义错误处理 */</span>&#125;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-comment">/* SELECT */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;FD_ZERO(&amp;readfds);FD_SET(fd, &amp;readfds);<span class="hljs-comment">/* 构造超时时间 */</span>timeout.tv_sec = <span class="hljs-number">0</span>;timeout.tv_usec = <span class="hljs-number">500000</span>; <span class="hljs-comment">/* 500ms */</span>ret = select(fd + <span class="hljs-number">1</span>, &amp;readfds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;timeout);<span class="hljs-keyword">switch</span> (ret) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* 超时 */</span><span class="hljs-comment">/* 用户自定义超时处理 */</span><span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<span class="hljs-comment">/* 错误 */</span><span class="hljs-comment">/* 用户自定义错误处理 */</span><span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:  <span class="hljs-comment">/* 可以读取数据 */</span><span class="hljs-keyword">if</span>(FD_ISSET(fd, &amp;readfds)) &#123;ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data));<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">/* 读取错误 */</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (data)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key value=%d\r\n&quot;</span>, data);&#125;&#125;<span class="hljs-keyword">break</span>;&#125;&#125;close(fd);<span class="hljs-keyword">return</span> ret;&#125;</code></pre></div><p>前面注释的使用 poll 函数来实现非阻塞访问，在 while 循环中使用 poll 函数不断的轮询，检查驱动程序是否有数据可以读取，如果可以读取的话就调用 read 函数读取按键数据。</p><p>后面一段代码使用 select 函数来实现非阻塞访问。</p><h3 id="3-运行测试-1"><a href="#3-运行测试-1" class="headerlink" title="3|运行测试"></a>3|运行测试</h3><p>编译运行。</p><p>输入“top”命令，查看 noblockioAPP 这个应用 APP 的 CPU 使用率，如图 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/10%E3%80%81Linux%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/image-20200827124533321.png" alt="image-20200827124533321"></p><p>可以看出，采用非阻塞方式读处理以后，noblockioApp 的 CPU 占用率也低至0.0%，和中的 blockioApp 一样，这里的 0.0%并不是说 noblockioApp 这个应用程序不使用 CPU 了，只是因为使用率太小了，而图中只能显示出小数点后一位，因此就显示成了0.0%。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12| Platform 设备驱动实验</title>
    <link href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Platform-设备驱动实验"><a href="#Platform-设备驱动实验" class="headerlink" title="Platform 设备驱动实验"></a>Platform 设备驱动实验</h1><p>我们在前面几章编写的设备驱动都非常的简单，都是对IO进行最简单的读写操作。像I2C、SPI、LCD 等这些复杂外设的驱动就不能这么去写了，Linux 系统要考虑到驱动的可重用性，因此提出了驱动的分离与分层这样的软件思路，在这个思路下诞生了我们将来最常打交道的platform 设备驱动，也叫做平台设备驱动。本章我们就来学习一下 Linux 下的驱动分离与分层，以及 platform 框架下的设备驱动该如何编写。</p><h2 id="一、-Linux-驱动的分离与分层"><a href="#一、-Linux-驱动的分离与分层" class="headerlink" title="一、 Linux 驱动的分离与分层"></a>一、 Linux 驱动的分离与分层</h2><h3 id="驱动的分隔与分离"><a href="#驱动的分隔与分离" class="headerlink" title="驱动的分隔与分离"></a>驱动的分隔与分离</h3><p>对于 Linux 这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在 Linux 内核中存在大量无意义的重复代码。尤其是驱动程序，因为驱动程序占用了 Linux内核代码量的大头，如果不对驱动程序加以管理，任由重复的代码肆意增加，那么用不了多久Linux 内核的文件数量就庞大到无法接受的地步。</p><p>假如现在有三个平台 A、B 和 C，这三个平台(这里的平台说的是 SOC)上都有 MPU6050 这个I2C接口的六轴传感器，按照我们写裸机I2C驱动的时候的思路，每个平台都有一个MPU6050<br>的驱动，因此编写出来的最简单的驱动框架如图  所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144020801.png" alt="image-20200828144020801"></p><p>从图可以看出，每种平台下都有一个主机驱动和设备驱动，主机驱动肯定是必须要的，毕竟不同的平台其 I2C 控制器不同。但是右侧的设备驱动就没必要每个平台都写一个，因为不管对于那个 SOC 来说，MPU6050 都是一样，通过 I2C 接口读写数据就行了，只需要一个MPU6050 的驱动程序即可。如果再来几个 I2C 设备，比如 AT24C02、FT5206(电容触摸屏)等，如果按照图  中的写法，那么设备端的驱动将会重复的编写好几次。显然在 Linux 驱动程序中这种写法是不推荐的，最好的做法就是每个平台的 I2C 控制器都提供一个统一的接口(也叫做主机驱动)，每个设备的话也只提供一个驱动程序(设备驱动)，每个设备通过统一的 I2C接口驱动来访问，这样就可以大大简化驱动文件，比如 三种平台下的 MPU6050 驱动框架就可以简化为图  所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144129336.png" alt="image-20200828144129336"></p><p>实际的 I2C 驱动设备肯定有很多种，不止 MPU6050 这一个，那么实际的驱动架构如图所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144146616.png" alt="image-20200828144146616"></p><p>这个就是驱动的分隔，也就是将主机驱动和设备驱动分隔开来，比如 I2C、SPI 等等都会采用驱动分隔的方式来简化驱动的开发。</p><p>在实际的驱动开发中，一般 I2C 主机控制器驱动已经由半导体厂家编写好了，而设备驱动一般也由设备器件的厂家编写好了，我们只需要提供设备信息即可，比如 I2C 设备的话提供设备连接到了哪个 I2C 接口上，I2C 的速度是多少等等。相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于驱动只负责驱动，设备只负责设备，想办法将两者进行匹配即可。这个就是 Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。总线就是驱动和设备信息的月老，负责给两者牵线搭桥，如图 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828144329833.png" alt="image-20200828144329833"></p><p>当我们向系统注册一个驱动的时候，总线就会在右侧的设备中查找，看看有没有与之匹配的设备，如果有的话就将两者联系起来。同样的，当向系统中注册一个设备的时候，总线就会在左侧的驱动中查找看有没有与之匹配的设备，有的话也联系起来。Linux 内核中大量的驱动程序都采用总线、驱动和设备模式，我们一会要重点讲解的 platform 驱动就是这一思想下的产物。</p><h3 id="驱动的分层"><a href="#驱动的分层" class="headerlink" title="驱动的分层"></a>驱动的分层</h3><p>上一小节讲了驱动的分隔与分离，本节我们来简单看一下驱动的分层，大家应该听说过网络的 7 层模型，不同的层负责不同的内容。同样的，Linux 下的驱动往往也是分层的，分层的目的也是为了在不同的层处理不同的内容。以其他书籍或者资料常常使用到的input(输入子系统，后面会有专门的章节详细的讲解)为例，简单介绍一下驱动的分层。</p><p>input 子系统负责管理所有跟输入有关的驱动，包括键盘、鼠标、触摸等，最底层的就是设备原始驱动，负责获取输入设备的原始值，获取到的输入事件上报给 input 核心层。input 核心层会处理各种 IO 模型，并且提供 file_operations 操作集合。我们在编写输入设备驱动的时候只需要处理好输入事件的上报即可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。可以看出借助分层模型可以极大的简化我们的驱动编写，对于驱动编写来说非常的友好。</p><h2 id="二、platform-平台驱动模型简介"><a href="#二、platform-平台驱动模型简介" class="headerlink" title="二、platform  平台驱动模型简介"></a>二、platform  平台驱动模型简介</h2><p>前面我们讲了设备驱动的分离，并且引出了总线(bus)、驱动(driver)和设备(device)模型，比如 I2C、SPI、USB 等总线。但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？为了解决此问题，Linux 提出了 platform 这个虚拟总线，相应的就有 platform_driver 和 platform_device。</p><h3 id="1-platform总线"><a href="#1-platform总线" class="headerlink" title="1| platform总线"></a>1| platform总线</h3><p>Linux系统内核使用bus_type结构体表示总线，此结构体定义在文件include&#x2F;linux&#x2F;device.h，bus_type 结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">/* 总线名字 */</span><span class="hljs-number">3</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name;<span class="hljs-number">4</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev_root</span>;</span><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_attribute</span> *<span class="hljs-title">dev_attrs</span>;</span><span class="hljs-number">6</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">bus_groups</span>;</span> <span class="hljs-comment">/* 总线属性 */</span><span class="hljs-number">7</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">dev_groups</span>;</span> <span class="hljs-comment">/* 设备属性 */</span><span class="hljs-number">8</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">drv_groups</span>;</span> <span class="hljs-comment">/* 驱动属性 */</span><span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-type">int</span> (*match)(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv);<span class="hljs-number">11</span> <span class="hljs-type">int</span> (*uevent)(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> kobj_uevent_env *env);<span class="hljs-number">12</span> <span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">13</span> <span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">14</span> <span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">15</span><span class="hljs-number">16</span> <span class="hljs-type">int</span> (*online)(<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">17</span> <span class="hljs-type">int</span> (*offline)(<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">18</span> <span class="hljs-type">int</span> (*suspend)(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">pm_message_t</span> state);<span class="hljs-number">19</span> <span class="hljs-type">int</span> (*resume)(<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">20</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> *<span class="hljs-title">pm</span>;</span><span class="hljs-number">21</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iommu_ops</span> *<span class="hljs-title">iommu_ops</span>;</span><span class="hljs-number">22</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> *<span class="hljs-title">p</span>;</span><span class="hljs-number">23</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span> <span class="hljs-title">lock_key</span>;</span><span class="hljs-number">24</span> &#125;;</code></pre></div><p>第 10 行，match 函数，此函数很重要，单词 match 的意思就是“匹配、相配”，因此此函数就是完成设备和驱动之间匹配的，总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。match 函数有两个参数：dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。</p><hr><p>platform 总线是 bus_type 的一个具体实例，定义在文件 drivers&#x2F;base&#x2F;platform.c，platform 总线定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">platform_bus_type</span> =</span> &#123;<span class="hljs-number">2</span> .name = <span class="hljs-string">&quot;platform&quot;</span>,<span class="hljs-number">3</span> .dev_groups = platform_dev_groups,<span class="hljs-number">4</span> .match = platform_match,<span class="hljs-number">5</span> .uevent = platform_uevent,<span class="hljs-number">6</span> .pm = &amp;platform_dev_pm_ops,<span class="hljs-number">7</span> &#125;;</code></pre></div><p>platform_bus_type 就是 platform 平台总线，其中 platform_match 就是匹配函数。我们来看一下驱动和设备是如何匹配的，platform_match 函数定义在文件drivers&#x2F;base&#x2F;platform.c 中，函数内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">platform_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span>2 &#123;<span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">pdev</span> =</span> to_platform_device(dev);<span class="hljs-number">4</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> *<span class="hljs-title">pdrv</span> =</span> to_platform_driver(drv);<span class="hljs-number">5</span><span class="hljs-number">6</span> <span class="hljs-comment">/*When driver_override is set,only bind to the matching driver*/</span><span class="hljs-number">7</span> <span class="hljs-keyword">if</span> (pdev-&gt;driver_override)<span class="hljs-number">8</span> <span class="hljs-keyword">return</span> !<span class="hljs-built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);<span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-comment">/* Attempt an OF style match first */</span><span class="hljs-number">11</span> <span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))<span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-number">13</span><span class="hljs-number">14</span> <span class="hljs-comment">/* Then try ACPI style match */</span><span class="hljs-number">15</span> <span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))<span class="hljs-number">16</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-number">17</span><span class="hljs-number">18</span> <span class="hljs-comment">/* Then try to match against the id table */</span><span class="hljs-number">19</span> <span class="hljs-keyword">if</span> (pdrv-&gt;id_table)<span class="hljs-number">20</span> <span class="hljs-keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="hljs-literal">NULL</span>;<span class="hljs-number">21</span><span class="hljs-number">22</span> <span class="hljs-comment">/* fall-back to driver name match */</span><span class="hljs-number">23</span> <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="hljs-number">0</span>);<span class="hljs-number">24</span> &#125;</code></pre></div><p>驱动和设备的匹配有四种方法，我们依次来看一下：</p><p>第 11~12 行，第一种匹配方式， OF 类型的匹配，也就是设备树采用的匹配方式，of_driver_match_device 函数定义在文件 include&#x2F;linux&#x2F;of_device.h 中。device_driver 结构体(表示设备驱动)中有个名为of_match_table的成员变量，此成员变量保存着驱动的compatible匹配表，设备树中的每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较，查看是否有相同的条目，如果有的话就表示设备和此驱动匹配，设备和驱动匹配成功以后 probe 函数就会执行。</p><p>第 15~16 行，第二种匹配方式，ACPI 匹配方式。</p><p>第 19~20 行，第三种匹配方式，id_table 匹配，每个 platform_driver 结构体有一个 id_table成员变量，顾名思义，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱动类型。</p><p>第 23 行，第四种匹配方式，如果第三种匹配方式的 id_table 不存在的话就直接比较驱动和设备的 name 字段，看看是不是相等，如果相等的话就匹配成功。</p><p>对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了.</p><h3 id="2-platform驱动"><a href="#2-platform驱动" class="headerlink" title="2| platform驱动"></a>2| platform驱动</h3><p>platform_driver 结 构 体 表 示 platform 驱 动 ， 此 结 构 体 定 义 在 文 件include&#x2F;linux&#x2F;platform_device.h 中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> platform_device *);<span class="hljs-number">3</span> <span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> platform_device *);<span class="hljs-number">4</span> <span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> platform_device *);<span class="hljs-number">5</span> <span class="hljs-type">int</span> (*suspend)(<span class="hljs-keyword">struct</span> platform_device *, <span class="hljs-type">pm_message_t</span> state);<span class="hljs-number">6</span> <span class="hljs-type">int</span> (*resume)(<span class="hljs-keyword">struct</span> platform_device *);<span class="hljs-number">7</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span><span class="hljs-number">8</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> *<span class="hljs-title">id_table</span>;</span><span class="hljs-number">9</span> <span class="hljs-type">bool</span> prevent_deferred_probe;<span class="hljs-number">10</span> &#125;;</code></pre></div><p>第 2 行，probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行，非常重要的函数！！一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。</p><p>第 7 行，driver 成员，为 device_driver 结构体变量，Linux 内核里面大量使用到了面向对象的思维，device_driver 相当于基类，提供了最基础的驱动框架。plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。</p><p>第 8 行，id_table 表，也就是我们上一小节讲解 platform 总线匹配驱动和设备的时候采用的第三种方法，id_table 是个表(也就是数组)，每个元素的类型为 platform_device_id，platform_device_id 结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-type">char</span> name[PLATFORM_NAME_SIZE];<span class="hljs-number">3</span> <span class="hljs-type">kernel_ulong_t</span> driver_data;<span class="hljs-number">4</span> &#125;;</code></pre></div><hr><p>device_driver 结构体定义在 include&#x2F;linux&#x2F;device.h，device_driver 结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> *<span class="hljs-title">bus</span>;</span><span class="hljs-number">4</span><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><span class="hljs-number">6</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mod_name; <span class="hljs-comment">/* used for built-in modules */</span><span class="hljs-number">7</span><span class="hljs-number">8</span> <span class="hljs-type">bool</span> suppress_bind_attrs; <span class="hljs-comment">/* disables bind/unbind via sysfs */</span><span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">of_match_table</span>;</span><span class="hljs-number">11</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">acpi_device_id</span> *<span class="hljs-title">acpi_match_table</span>;</span><span class="hljs-number">12</span><span class="hljs-number">13</span> <span class="hljs-type">int</span> (*probe) (<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">14</span> <span class="hljs-type">int</span> (*remove) (<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">15</span> <span class="hljs-type">void</span> (*shutdown) (<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">16</span> <span class="hljs-type">int</span> (*suspend) (<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">pm_message_t</span> state);<span class="hljs-number">17</span> <span class="hljs-type">int</span> (*resume) (<span class="hljs-keyword">struct</span> device *dev);<span class="hljs-number">18</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span><span class="hljs-number">19</span><span class="hljs-number">20</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> *<span class="hljs-title">pm</span>;</span><span class="hljs-number">21</span><span class="hljs-number">22</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">driver_private</span> *<span class="hljs-title">p</span>;</span><span class="hljs-number">23</span> &#125;;</code></pre></div><p>第 10 行，of_match_table 就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型，此结构体定义在文件 include&#x2F;linux&#x2F;mod_devicetable.h 中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-type">char</span> name[<span class="hljs-number">32</span>];<span class="hljs-number">3</span> <span class="hljs-type">char</span> type[<span class="hljs-number">32</span>];<span class="hljs-number">4</span> <span class="hljs-type">char</span> compatible[<span class="hljs-number">128</span>];<span class="hljs-number">5</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data;<span class="hljs-number">6</span> &#125;;</code></pre></div><p>第 4 行的 compatible 非常重要，因为对于设备树而言，就是通过设备节点的 compatible 属性值和 of_match_table 中每个项目的 compatible 成员变量进行比较，如果有相等的就表示设备和此驱动匹配成功。</p><p>在编写 platform 驱动的时候，首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量，重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等。当我们定义并初始化好 platform_driver 结构体变量以后，需要在驱动入口函数里面调用platform_driver_register 函数向 Linux 内核注册一个 platform 驱动，platform_driver_register 函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_driver_register</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *driver)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>driver</strong>：要注册的 platform 驱动。<br><strong>返回值</strong>：负数，失败；0，成功。</p><p>还需要在驱动卸载函数中通过 platform_driver_unregister 函数卸载 platform 驱动，platform_driver_unregister 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_driver_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *drv)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>drv</strong>：要卸载的 platform 驱动。<br><strong>返回值</strong>：无。</p><p>platform 驱动框架如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 设备结构体 */</span><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span>&#123;</span><span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-number">3</span> <span class="hljs-comment">/* 设备结构体其他具体内容 */</span><span class="hljs-number">4</span> &#125;;<span class="hljs-number">5</span><span class="hljs-number">6</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> <span class="hljs-title">xxxdev</span>;</span> <span class="hljs-comment">/* 定义个设备结构体变量 */</span><span class="hljs-number">7</span><span class="hljs-number">8</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>9 &#123;<span class="hljs-number">10</span> <span class="hljs-comment">/* 函数具体内容 */</span><span class="hljs-number">11</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">12</span> &#125;<span class="hljs-number">13</span><span class="hljs-number">14</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">xxx_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>15 &#123;<span class="hljs-number">16</span> <span class="hljs-comment">/* 函数具体内容 */</span><span class="hljs-number">17</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">18</span> &#125;<span class="hljs-number">19</span><span class="hljs-number">20</span> <span class="hljs-comment">/*</span><span class="hljs-comment">21 * 字符设备驱动操作集</span><span class="hljs-comment">22 */</span><span class="hljs-number">23</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">xxx_fops</span> =</span> &#123;<span class="hljs-number">24</span> .owner = THIS_MODULE,<span class="hljs-number">25</span> .open = xxx_open,<span class="hljs-number">26</span> .write = xxx_write,<span class="hljs-number">27</span> &#125;;<span class="hljs-number">28</span><span class="hljs-number">29</span> <span class="hljs-comment">/*</span><span class="hljs-comment">30 * platform 驱动的 probe 函数</span><span class="hljs-comment">31 * 驱动与设备匹配成功以后此函数就会执行</span><span class="hljs-comment">32 */</span><span class="hljs-number">33</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>34 &#123;<span class="hljs-number">35</span> ......<span class="hljs-number">36</span> cdev_init(&amp;xxxdev.cdev, &amp;xxx_fops); <span class="hljs-comment">/* 注册字符设备驱动 */</span><span class="hljs-number">37</span> <span class="hljs-comment">/* 函数具体内容 */</span><span class="hljs-number">38</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">39</span> &#125;<span class="hljs-number">40</span><span class="hljs-number">41</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>42 &#123;<span class="hljs-number">43</span> ......<span class="hljs-number">44</span> cdev_del(&amp;xxxdev.cdev);<span class="hljs-comment">/* 删除 cdev */</span><span class="hljs-number">45</span> <span class="hljs-comment">/* 函数具体内容 */</span><span class="hljs-number">46</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">47</span> &#125;<span class="hljs-number">48</span><span class="hljs-number">49</span> <span class="hljs-comment">/* 匹配列表 */</span><span class="hljs-number">50</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;<span class="hljs-number">51</span> &#123; .compatible = <span class="hljs-string">&quot;xxx-gpio&quot;</span> &#125;,<span class="hljs-number">52</span> &#123; <span class="hljs-comment">/* Sentinel */</span> &#125;<span class="hljs-number">53</span> &#125;;<span class="hljs-number">54</span><span class="hljs-number">55</span> <span class="hljs-comment">/*</span><span class="hljs-comment">56 * platform 平台驱动结构体</span><span class="hljs-comment">57 */</span><span class="hljs-number">58</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">xxx_driver</span> =</span> &#123;<span class="hljs-number">59</span> .driver = &#123;<span class="hljs-number">60</span> .name = <span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-number">61</span> .of_match_table = xxx_of_match,<span class="hljs-number">62</span> &#125;,<span class="hljs-number">63</span> .probe = xxx_probe,<span class="hljs-number">64</span> .remove = xxx_remove,<span class="hljs-number">65</span> &#125;;<span class="hljs-number">66</span><span class="hljs-number">67</span> <span class="hljs-comment">/* 驱动模块加载 */</span><span class="hljs-number">68</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxdriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>69 &#123;<span class="hljs-number">70</span> <span class="hljs-keyword">return</span> platform_driver_register(&amp;xxx_driver);<span class="hljs-number">71</span> &#125;<span class="hljs-number">72</span><span class="hljs-number">73</span> <span class="hljs-comment">/* 驱动模块卸载 */</span><span class="hljs-number">74</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxxdriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>75 &#123;<span class="hljs-number">76</span> platform_driver_unregister(&amp;xxx_driver);<span class="hljs-number">77</span> &#125;<span class="hljs-number">78</span><span class="hljs-number">79</span> module_init(xxxdriver_init);<span class="hljs-number">80</span> module_exit(xxxdriver_exit);<span class="hljs-number">81</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-number">82</span> MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>第 1~27 行，传统的字符设备驱动，所谓的 platform 驱动并不是独立于字符设备驱动、块设备驱动和网络设备驱动之外的其他种类的驱动。platform 只是为了驱动的分离与分层而提出来的一种框架，其驱动的具体实现还是需要字符设备驱动、块设备驱动或网络设备驱动。</p><p>第 33~39 行，xxx_probe 函数，当驱动和设备匹配成功以后此函数就会执行，以前在驱动入口 init 函数里面编写的字符设备驱动程序就全部放到此 probe 函数里面。比如注册字符设备<br>驱动、添加 cdev、创建类等等。</p><p>第 41~47 行，xxx_remove 函数，platform_driver 结构体中的 remove 成员变量，当关闭platform备驱动的时候此函数就会执行，以前在驱动卸载 exit 函数里面要做的事情就放到此函数中来。比如，使用 iounmap 释放内存、删除 cdev，注销设备号等等。</p><p>第 50~53 行，xxx_of_match 匹配表，如果使用设备树的话将通过此匹配表进行驱动和设备的匹配。第 51 行设置了一个匹配项，此匹配项的 compatible 值为“xxx-gpio”，因此当设备树中设备节点的 compatible 属性值为“xxx-gpio”的时候此设备就会与此驱动匹配。第 52 行是一个标记，of_device_id 表最后一个匹配项必须是空的。</p><p>第 58<del>65 行，定义一个 platform_driver 结构体变量 xxx_driver，表示 platform 驱动，第 59</del>62行设置 paltform_driver 中的 device_driver 成员变量的 name 和 of_match_table 这两个属性。其中name 属性用于传统的驱动与设备匹配，也就是检查驱动和设备的 name 字段是不是相同。of_match_table 属性就是用于设备树下的驱动与设备检查。对于一个完整的驱动程序，必须提供有设备树和无设备树两种匹配方法。最后 63 和 64 这两行设置 probe 和 remove 这两成员变量。</p><p>第68~71行，驱动入口函数，调用platform_driver_register函数向Linux内核注册一个platform驱动，也就是上面定义的 xxx_driver 结构体变量。</p><p>第 74~77 行，驱动出口函数，调用 platform_driver_unregister 函数卸载前面注册的 platform驱动。</p><p>总体来说，platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，只是套<br>上了一张“platform”的皮，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分<br>离与分层。</p><h3 id="3-platform设备"><a href="#3-platform设备" class="headerlink" title="3| platform设备"></a>3| platform设备</h3><p>platform 驱动已经准备好了，我们还需要 platform 设备，否则的话单单一个驱动也做不了什么。platform_device 这个结构体表示 platform 设备，这里我们要注意，如果内核支持设备树的话就不要再使用 platform_device 来描述设备了，因为改用设备树去描述了。当然了，你如果一定要用 platform_device 来描述设备信息的话也是可以的。platform_device 结构体定义在文件include&#x2F;linux&#x2F;platform_device.h 中，结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">22</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> &#123;</span><span class="hljs-number">23</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-number">24</span> <span class="hljs-type">int</span> id;<span class="hljs-number">25</span> <span class="hljs-type">bool</span> id_auto;<span class="hljs-number">26</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span><span class="hljs-number">27</span> u32 num_resources;<span class="hljs-number">28</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">resource</span>;</span><span class="hljs-number">29</span><span class="hljs-number">30</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> *<span class="hljs-title">id_entry</span>;</span><span class="hljs-number">31</span> <span class="hljs-type">char</span> *driver_override; <span class="hljs-comment">/* Driver name to force a match */</span><span class="hljs-number">32</span><span class="hljs-number">33</span> <span class="hljs-comment">/* MFD cell pointer */</span><span class="hljs-number">34</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mfd_cell</span> *<span class="hljs-title">mfd_cell</span>;</span><span class="hljs-number">35</span><span class="hljs-number">36</span> <span class="hljs-comment">/* arch specific additions */</span><span class="hljs-number">37</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pdev_archdata</span> <span class="hljs-title">archdata</span>;</span><span class="hljs-number">38</span> &#125;;</code></pre></div><p>第 23 行，name 表示设备名字，要和所使用的 platform 驱动的 name 字段相同，否则的话设备就无法匹配到对应的驱动。比如对应的 platform 驱动的 name 字段为“xxx-gpio”，那么此 name字段也要设置为“xxx-gpio”。</p><p>第 27 行，num_resources 表示资源数量，一般为第 28 行 resource 资源的大小。</p><p>第 28 行，resource 表示资源，也就是设备信息，比如外设寄存器等。Linux 内核使用resource结构体表示资源，resource 结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">18</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> &#123;</span><span class="hljs-number">19</span> <span class="hljs-type">resource_size_t</span> start;<span class="hljs-number">20</span> <span class="hljs-type">resource_size_t</span> end;<span class="hljs-number">21</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-number">22</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<span class="hljs-number">23</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">parent</span>, *<span class="hljs-title">sibling</span>, *<span class="hljs-title">child</span>;</span><span class="hljs-number">24</span> &#125;;</code></pre></div><p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name 表示资源名字，flags 表示资源类型，可选的资源类型都定义在了文件include&#x2F;linux&#x2F;ioport.h 里面，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">29</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BITS 0x000000ff <span class="hljs-comment">/* Bus-specific bits */</span></span><span class="hljs-number">30</span><span class="hljs-number">31</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_TYPE_BITS  0x00001f00 <span class="hljs-comment">/* Resource type */</span></span><span class="hljs-number">32</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IO 0x00000100 <span class="hljs-comment">/* PCI/ISA I/O ports */</span></span><span class="hljs-number">33</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM 0x00000200</span><span class="hljs-number">34</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_REG 0x00000300 <span class="hljs-comment">/* Register offsets */</span></span><span class="hljs-number">35</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IRQ 0x00000400</span><span class="hljs-number">36</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DMA 0x00000800</span><span class="hljs-number">37</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUS 0x00001000</span>......<span class="hljs-number">104</span> <span class="hljs-comment">/* PCI control bits. Shares IORESOURCE_BITS with above PCI ROM. */</span><span class="hljs-number">105</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_PCI_FIXED (1&lt;&lt;4) <span class="hljs-comment">/* Do not move resource */</span></span></code></pre></div><p>在以前不支持设备树的Linux版本中，用户需要编写platform_device变量来描述设备信息，然后使用 platform_device_register 函数将设备信息注册到 Linux 内核中，此函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_device_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>pdev</strong>：要注册的 platform 设备。<br><strong>返回值</strong>：负数，失败；0，成功。</p><p>如果不再使用 platform 的话可以通过 platform_device_unregister 函数注销掉相应的platform设备，platform_device_unregister 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_device_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>pdev</strong>：要注销的 platform 设备。<br><strong>返回值</strong>：无。</p><p>platform 设备信息框架如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 寄存器地址定义*/</span><span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH1_REGISTER_BASE (0X20000000) <span class="hljs-comment">/* 外设 1 寄存器首地址 */</span></span><span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH2_REGISTER_BASE (0X020E0068) <span class="hljs-comment">/* 外设 2 寄存器首地址 */</span></span><span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_LENGTH 4</span><span class="hljs-number">5</span><span class="hljs-number">6</span> <span class="hljs-comment">/* 资源 */</span><span class="hljs-number">7</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> <span class="hljs-title">xxx_resources</span>[] =</span> &#123;<span class="hljs-number">8</span> [<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">9</span> .start = PERIPH1_REGISTER_BASE,<span class="hljs-number">10</span> .end = (PERIPH1_REGISTER_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<span class="hljs-number">11</span> .flags = IORESOURCE_MEM,<span class="hljs-number">12</span> &#125;,<span class="hljs-number">13</span> [<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">14</span> .start = PERIPH2_REGISTER_BASE,<span class="hljs-number">15</span> .end = (PERIPH2_REGISTER_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<span class="hljs-number">16</span> .flags = IORESOURCE_MEM,<span class="hljs-number">17</span> &#125;,<span class="hljs-number">18</span> &#125;;<span class="hljs-number">19</span><span class="hljs-number">20</span> <span class="hljs-comment">/* platform 设备结构体 */</span><span class="hljs-number">21</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">xxxdevice</span> =</span> &#123;<span class="hljs-number">22</span> .name = <span class="hljs-string">&quot;xxx-gpio&quot;</span>,<span class="hljs-number">23</span> .id = <span class="hljs-number">-1</span>,<span class="hljs-number">24</span> .num_resources = ARRAY_SIZE(xxx_resources),<span class="hljs-number">25</span> .resource = xxx_resources,<span class="hljs-number">26</span> &#125;;<span class="hljs-number">27</span><span class="hljs-number">28</span> <span class="hljs-comment">/* 设备模块加载 */</span><span class="hljs-number">29</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxdevice_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>30 &#123;<span class="hljs-number">31</span> <span class="hljs-keyword">return</span> platform_device_register(&amp;xxxdevice);<span class="hljs-number">32</span> &#125;<span class="hljs-number">33</span><span class="hljs-number">34</span> <span class="hljs-comment">/* 设备模块注销 */</span><span class="hljs-number">35</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_resourcesdevice_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>36 &#123;<span class="hljs-number">37</span> platform_device_unregister(&amp;xxxdevice);<span class="hljs-number">38</span> &#125;<span class="hljs-number">39</span><span class="hljs-number">40</span> module_init(xxxdevice_init);<span class="hljs-number">41</span> module_exit(xxxdevice_exit);<span class="hljs-number">42</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-number">43</span> MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>第 7~18 行，数组 xxx_resources 表示设备资源，一共有两个资源，分别为设备外设 1 和外设 2 的寄存器信息。因此 flags 都为 IORESOURCE_MEM，表示资源为内存类型的。</p><p>第 21~26 行，platform 设备结构体变量，注意 name 字段要和所使用的驱动中的 name 字段一致，否则驱动和设备无法匹配成功。num_resources 表示资源大小，其实就是数组 xxx_resources的元素数量，这里用 ARRAY_SIZE 来测量一个数组的元素个数。</p><p>第 29~32 行，设备模块加载函数，在此函数中调用 platform_device_register 向 Linux 内核注册 platform 设备。</p><p>第 35~38 行，设备模块卸载函数，在此函数中调用 platform_device_unregister 从 Linux 内核中卸载 platform 设备。</p><p>示例代码 主要是在不支持设备树的 Linux 版本中使用的，当 Linux 内核支持了设备树以后就不需要用户手动去注册 platform 设备了。因为设备信息都放到了设备树中去描述，Linux 内核启动的时候会从设备树中读取设备信息，然后将其组织成 platform_device 形式，至于设备树到 platform_device 的具体过程就不去详细的追究了，感兴趣的可以去看一下，网上也有很多博客详细的讲解了整个过程。</p><p>关于 platform 下的总线、驱动和设备就讲解到这里，我们接下来就使用 platform 驱动框架来编写一个 LED 灯驱动，本章我们不使用设备树来描述设备信息，我们采用自定义platform_device这种“古老”方式来编写LED的设备信息。下一章我们来编写设备树下的platform驱动，这样我们就掌握了无设备树和有设备树这两种 platform 驱动的开发方式。</p><h2 id="三、‘古老的’-platform驱动开发方式（无设备树）"><a href="#三、‘古老的’-platform驱动开发方式（无设备树）" class="headerlink" title="三、‘古老的’ platform驱动开发方式（无设备树）"></a>三、‘古老的’ platform驱动开发方式（无设备树）</h2><p>我们需要编写一个驱动模块和一个设备模块，其中驱动模块是 platform 驱动程序，设备模块是 platform 的设备信息。当这两个模块都加载成功以后就会匹配成功，然后 platform驱动模块中的 probe 函数就会执行，probe 函数中就是传统的字符设备驱动那一套。</p><h3 id="1-platform-设备与驱动程序编写"><a href="#1-platform-设备与驱动程序编写" class="headerlink" title="1| platform 设备与驱动程序编写"></a>1| platform 设备与驱动程序编写</h3><p>新建名为“17_platform”的文件夹，然后在 17_platform 文件夹里面创建 vscode 工程，工作<br>区命名为“platform”。新建名为 leddevice.c 和 leddriver.c 这两个文件，这两个文件分别为LED灯的 platform 设备文件和 LED 灯的 platform 的驱动文件。在 leddevice.c 中输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><span class="hljs-comment">/* </span><span class="hljs-comment"> * 寄存器地址定义</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_CCGR1_BASE(0X020C406C)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_DR_BASE(0X0209C000)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_GDIR_BASE(0X0209C004)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_LENGTH4</span><span class="hljs-comment">/* @description: 释放flatform设备模块的时候此函数会执行</span><span class="hljs-comment"> * @param - dev : 要释放的设备 </span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span><span class="hljs-title function_">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span>&#123;printk(<span class="hljs-string">&quot;k:led device released!\r\n&quot;</span>);&#125;<span class="hljs-comment">/*  </span><span class="hljs-comment"> * 设备资源信息，也就是LED0所使用的所有寄存器</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> <span class="hljs-title">led_resources</span>[] =</span> &#123;[<span class="hljs-number">0</span>] = &#123;.start = CCM_CCGR1_BASE,.end = (CCM_CCGR1_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),.flags = IORESOURCE_MEM,&#125;,[<span class="hljs-number">1</span>] = &#123;.start= SW_MUX_GPIO1_IO03_BASE,.end= (SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),.flags= IORESOURCE_MEM,&#125;,[<span class="hljs-number">2</span>] = &#123;.start= SW_PAD_GPIO1_IO03_BASE,.end= (SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),.flags= IORESOURCE_MEM,&#125;,[<span class="hljs-number">3</span>] = &#123;.start= GPIO1_DR_BASE,.end= (GPIO1_DR_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),.flags= IORESOURCE_MEM,&#125;,[<span class="hljs-number">4</span>] = &#123;.start= GPIO1_GDIR_BASE,.end= (GPIO1_GDIR_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),.flags= IORESOURCE_MEM,&#125;,&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * platform设备结构体 </span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">leddevice</span> =</span> &#123;.name = <span class="hljs-string">&quot;imx6ul-led&quot;</span>,.id = <span class="hljs-number">-1</span>,.dev = &#123;.release = &amp;led_release,&#125;,.num_resources = ARRAY_SIZE(led_resources),.resource = led_resources,&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 设备模块加载 </span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddevice_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-keyword">return</span> platform_device_register(&amp;leddevice);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 设备模块注销</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddevice_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;platform_device_unregister(&amp;leddevice);&#125;module_init(leddevice_init);module_exit(leddevice_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>leddevice.c 文件内容就是按照示例代码  platform 设备模板编写的。</p><p>第 56~82 行，led_resources 数组，也就是设备资源，描述了 LED 所要使用到的寄存器信息，也就是 IORESOURCE_MEM 资源。</p><p>第 88~96，platform 设备结构体变量 leddevice，这里要注意 name 字段为“imx6ul-led”，所以稍后编写 platform 驱动中的 name 字段也要为“imx6ul-led”，否则设备和驱动匹配失败。</p><p>第 103~106 行，设备模块加载函数，在此函数里面通过 platform_device_register 向 Linux 内核注册 leddevice 这个 platform 设备。</p><p>第 113~116 行，设备模块卸载函数，在此函数里面通过 platform_device_unregister 从 Linux内核中删除掉 leddevice 这个 platform 设备。</p><p>leddevice.c 文件编写完成以后就编写 leddriver.c 这个 platform 驱动文件，在 leddriver.c 里<br>面输入如下内容:</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_CNT1<span class="hljs-comment">/* 设备号长度 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_NAME<span class="hljs-string">&quot;platled&quot;</span><span class="hljs-comment">/* 设备名字 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 1</span><span class="hljs-comment">/* 寄存器名 */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *IMX6U_CCM_CCGR1;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_MUX_GPIO1_IO03;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_PAD_GPIO1_IO03;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_DR;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_GDIR;<span class="hljs-comment">/* leddev设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span>&#123;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-comment">/* 设备号*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-comment">/* cdev*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-comment">/* 类 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-comment">/* 设备*/</span><span class="hljs-type">int</span> major;<span class="hljs-comment">/* 主设备号*/</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span> <span class="hljs-title">leddev</span>;</span> <span class="hljs-comment">/* led设备 */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: LED打开/关闭</span><span class="hljs-comment"> * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">led0_switch</span><span class="hljs-params">(u8 sta)</span>&#123;u32 val = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(sta == LEDON)&#123;val = readl(GPIO1_DR);val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, GPIO1_DR);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sta == LEDOFF)&#123;val = readl(GPIO1_DR);val|= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, GPIO1_DR);&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 打开设备</span><span class="hljs-comment"> * @param - inode : 传递给驱动的inode</span><span class="hljs-comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><span class="hljs-comment"> *   一般在open的时候将private_data指向设备结构体。</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;leddev; <span class="hljs-comment">/* 设置私有数据  */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向设备写数据 </span><span class="hljs-comment"> * @param - filp : 设备文件，表示打开的文件描述符</span><span class="hljs-comment"> * @param - buf : 要写给设备写入的数据</span><span class="hljs-comment"> * @param - cnt : 要写入的数据长度</span><span class="hljs-comment"> * @param - offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> retvalue;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">1</span>];<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;retvalue = copy_from_user(databuf, buf, cnt);<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> -EFAULT;&#125;ledstat = databuf[<span class="hljs-number">0</span>];<span class="hljs-comment">/* 获取状态值 */</span><span class="hljs-keyword">if</span>(ledstat == LEDON) &#123;led0_switch(LEDON);<span class="hljs-comment">/* 打开LED灯 */</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ledstat == LEDOFF) &#123;led0_switch(LEDOFF);<span class="hljs-comment">/* 关闭LED灯 */</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作函数 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;.owner = THIS_MODULE,.open = led_open,.write = led_write,&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: flatform驱动的probe函数，当驱动与设备匹配以后此函数就会执行</span><span class="hljs-comment"> * @param - dev : platform设备</span><span class="hljs-comment"> * @return : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>&#123;<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> ressize[<span class="hljs-number">5</span>];u32 val = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">ledsource</span>[5];</span>printk(<span class="hljs-string">&quot;k:led driver and device has matched!\r\n&quot;</span>);<span class="hljs-comment">/* 1、获取资源 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;ledsource[i] = platform_get_resource(dev, IORESOURCE_MEM, i); <span class="hljs-comment">/* 依次MEM类型资源 */</span><span class="hljs-keyword">if</span> (!ledsource[i]) &#123;dev_err(&amp;dev-&gt;dev, <span class="hljs-string">&quot;No MEM resource for always on\n&quot;</span>);<span class="hljs-keyword">return</span> -ENXIO;&#125;ressize[i] = resource_size(ledsource[i]);&#125;<span class="hljs-comment">/* 2、初始化LED */</span><span class="hljs-comment">/* 寄存器地址映射 */</span> IMX6U_CCM_CCGR1 = ioremap(ledsource[<span class="hljs-number">0</span>]-&gt;start, ressize[<span class="hljs-number">0</span>]);SW_MUX_GPIO1_IO03 = ioremap(ledsource[<span class="hljs-number">1</span>]-&gt;start, ressize[<span class="hljs-number">1</span>]);  SW_PAD_GPIO1_IO03 = ioremap(ledsource[<span class="hljs-number">2</span>]-&gt;start, ressize[<span class="hljs-number">2</span>]);GPIO1_DR = ioremap(ledsource[<span class="hljs-number">3</span>]-&gt;start, ressize[<span class="hljs-number">3</span>]);GPIO1_GDIR = ioremap(ledsource[<span class="hljs-number">4</span>]-&gt;start, ressize[<span class="hljs-number">4</span>]);val = readl(IMX6U_CCM_CCGR1);val &amp;= ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);<span class="hljs-comment">/* 清除以前的设置 */</span>val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);<span class="hljs-comment">/* 设置新值 */</span>writel(val, IMX6U_CCM_CCGR1);<span class="hljs-comment">/* 设置GPIO1_IO03复用功能，将其复用为GPIO1_IO03 */</span>writel(<span class="hljs-number">5</span>, SW_MUX_GPIO1_IO03);writel(<span class="hljs-number">0x10B0</span>, SW_PAD_GPIO1_IO03);<span class="hljs-comment">/* 设置GPIO1_IO03为输出功能 */</span>val = readl(GPIO1_GDIR);val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);<span class="hljs-comment">/* 清除以前的设置 */</span>val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);<span class="hljs-comment">/* 设置为输出 */</span>writel(val, GPIO1_GDIR);<span class="hljs-comment">/* 默认关闭LED1 */</span>val = readl(GPIO1_DR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>) ;writel(val, GPIO1_DR);<span class="hljs-comment">/* 注册字符设备驱动 */</span><span class="hljs-comment">/*1、创建设备号 */</span><span class="hljs-keyword">if</span> (leddev.major) &#123;<span class="hljs-comment">/*  定义了设备号 */</span>leddev.devid = MKDEV(leddev.major, <span class="hljs-number">0</span>);register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 没有定义设备号 */</span>alloc_chrdev_region(&amp;leddev.devid, <span class="hljs-number">0</span>, LEDDEV_CNT, LEDDEV_NAME);<span class="hljs-comment">/* 申请设备号 */</span>leddev.major = MAJOR(leddev.devid);<span class="hljs-comment">/* 获取分配号的主设备号 */</span>&#125;<span class="hljs-comment">/* 2、初始化cdev */</span>leddev.cdev.owner = THIS_MODULE;cdev_init(&amp;leddev.cdev, &amp;led_fops);<span class="hljs-comment">/* 3、添加一个cdev */</span>cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);<span class="hljs-comment">/* 4、创建类 */</span>leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);<span class="hljs-keyword">if</span> (IS_ERR(leddev.class)) &#123;<span class="hljs-keyword">return</span> PTR_ERR(leddev.class);&#125;<span class="hljs-comment">/* 5、创建设备 */</span>leddev.device = device_create(leddev.class, <span class="hljs-literal">NULL</span>, leddev.devid, <span class="hljs-literal">NULL</span>, LEDDEV_NAME);<span class="hljs-keyword">if</span> (IS_ERR(leddev.device)) &#123;<span class="hljs-keyword">return</span> PTR_ERR(leddev.device);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span><span class="hljs-comment"> * @param - dev : platform设备</span><span class="hljs-comment"> * @return : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>&#123;iounmap(IMX6U_CCM_CCGR1);iounmap(SW_MUX_GPIO1_IO03);iounmap(SW_PAD_GPIO1_IO03);iounmap(GPIO1_DR);iounmap(GPIO1_GDIR);cdev_del(&amp;leddev.cdev);<span class="hljs-comment">/*  删除cdev */</span>unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="hljs-comment">/* 注销设备号 */</span>device_destroy(leddev.class, leddev.devid);class_destroy(leddev.class);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* platform驱动结构体 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">led_driver</span> =</span> &#123;.driver= &#123;.name= <span class="hljs-string">&quot;imx6ul-led&quot;</span>,<span class="hljs-comment">/* 驱动名字，用于和设备匹配 */</span>&#125;,.probe= led_probe,.remove= led_remove,&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动模块加载函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-keyword">return</span> platform_driver_register(&amp;led_driver);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动模块卸载函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;platform_driver_unregister(&amp;led_driver);&#125;module_init(leddriver_init);module_exit(leddriver_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>leddriver.c 文件内容就是按照示例代码的 platform 驱动模板编写的。</p><p>probe 函数，当设备和驱动匹配以后此函数就会执行，当匹配成功以后会在终端上输出“led driver and device has matched!”这样语句。在 probe 函数里面初始化 LED、注册字符设备驱动。也就是将原来在驱动加载函数里面做的工作全部放到 probe 函数里面完成。</p><p>remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面释放内存、注销字符设备等。也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中完成。</p><p>platform_driver 驱动结构体，注意 name 字段为”imx6ul-led”，和我们在leddevice.c 文件里面设置的设备 name 字段一致。</p><p>驱动模块加载函数，在此函数里面通过 platform_driver_register 向 Linux 内核注册 led_driver 驱动。<br>驱动模块卸载函数，在此函数里面通过 platform_driver_unregister 从 Linux内核卸载 led_driver 驱动。</p><h3 id="2-测试-APP-编写"><a href="#2-测试-APP-编写" class="headerlink" title="2| 测试 APP  编写"></a>2| 测试 APP  编写</h3><p>测试 APP 的内容很简单，就是打开和关闭 LED 灯，新建 ledApp.c 这个文件，然后在里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 1</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: main主程序</span><span class="hljs-comment"> * @param - argc : argv数组元素个数</span><span class="hljs-comment"> * @param - argv : 具体参数</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<span class="hljs-type">int</span> fd, retvalue;<span class="hljs-type">char</span> *filename;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">2</span>];<span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;filename = argv[<span class="hljs-number">1</span>];<span class="hljs-comment">/* 打开led驱动 */</span>fd = open(filename, O_RDWR);<span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s open failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;databuf[<span class="hljs-number">0</span>] = atoi(argv[<span class="hljs-number">2</span>]);<span class="hljs-comment">/* 要执行的操作：打开或关闭 */</span>retvalue = write(fd, databuf, <span class="hljs-keyword">sizeof</span>(databuf));<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LED Control Failed!\r\n&quot;</span>);close(fd);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;retvalue = close(fd); <span class="hljs-comment">/* 关闭文件 */</span><span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s close failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="3-运行测试"><a href="#3-运行测试" class="headerlink" title="3| 运行测试"></a>3| 运行测试</h3><p>编译驱动程序</p><p>编写 Makefile 文件，本章实验的 Makefile 文件和第四十章实验基本一样，只是将 obj-m 变<br>量的值改为“leddevice.o leddriver.o”，Makefile 内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">1 KERNELDIR := /home/zuozhongkai/linux/IMX6ULL/linux/temp/linux-imx-rel_imx_4.1.15_2.1.0_ga_alientek......4 obj-m :=  leddevice.o leddriver.o</code></pre></div><p>将编译出来 leddevice.ko 、 leddriver.ko 和 ledApp 这两个文件拷贝到rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15 目录中，重启开发板，进入到目录 lib&#x2F;modules&#x2F;4.1.15 中，输入如下命令加载 leddevice.ko 设备模块和 leddriver.ko 这个驱动模块。</p><div class="hljs code-wrapper"><pre><code class="hljs sh">depmod //第一次加载驱动的时候需要运行此命令modprobe leddevice.ko //加载设备模块modprobe leddriver.ko //加载驱动模块</code></pre></div><p>根文件系统中&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;目录下保存着当前板子 platform 总线下的设备和驱动，其中devices 子目录为 platform 设备，drivers 子目录为 plartofm 驱动。查看&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices&#x2F; 目录，看看我们的设备是否存在，我们在 leddevice.c 中设置 leddevice(platform_device 类型)的name 字段为“imx6ul-led”，也就是设备名字为 imx6ul-led，因此肯定在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices&#x2F;目录下存在一个名字“imx6ul-led”的文件，否则说明我们的设备模块加载失败，结果如图所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828154257279.png" alt="image-20200828154257279"></p><p>同理，查看&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录，看一下驱动是否存在，我们在 leddriver.c 中设置led_driver (platform_driver 类型)的 name 字段为“imx6ul-led”，因此会在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录下存在名为“imx6ul-led”这个文件，结果如图 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828154439288.png" alt="image-20200828154439288"></p><p>驱动模块和设备模块加载成功以后 platform 总线就会进行匹配，当驱动和设备匹配成功以<br>后就会输出如图 所示一行语句：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828154419442.png" alt="image-20200828154419442"></p><p>驱动和设备匹配成功以后就可以测试 LED 灯驱动了，输入如下命令打开 LED 灯：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/ledApp /</span>dev<span class="hljs-regexp">/platled 1 /</span><span class="hljs-regexp">/打开 LED 灯</span></code></pre></div><p>在输入如下命令关闭 LED 灯：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/ledApp /</span>dev<span class="hljs-regexp">/platled 0 /</span><span class="hljs-regexp">/关闭 LED 灯</span></code></pre></div><p>观察一下 LED 灯能否打开和关闭，如果可以的话就说明驱动工作正常，如果要卸载驱动的话输入如下命令即可：</p><div class="hljs code-wrapper"><pre><code class="hljs c">rmmod leddevice.kormmod leddriver.ko</code></pre></div><h2 id="四、设备树下的-platform-驱动"><a href="#四、设备树下的-platform-驱动" class="headerlink" title="四、设备树下的 platform 驱动"></a>四、设备树下的 platform 驱动</h2><p>上一章我们详细的讲解了 Linux 下的驱动分离与分层，以及总线、设备和驱动这样的驱动框架。基于总线、设备和驱动这样的驱动框架，Linux 内核提出来 platform 这个虚拟总线，相应的也有 platform 设备和 platform 驱动。</p><p>上一章我们讲解了传统的、未采用设备树的 platform 设备和驱动编写方法。最新的 Linux 内核已经支持了设备树，因此在设备树下如何编写 platform驱动就显得尤为重要，本章我们就来学习一下如何在设备树下编写 platform 驱动。</p><h3 id="1-设备树下的-platform-驱动简介"><a href="#1-设备树下的-platform-驱动简介" class="headerlink" title="1| 设备树下的 platform  驱动简介"></a>1| 设备树下的 platform  驱动简介</h3><p>platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的platform 驱动的时候我们需要注意一下几点：</p><h4 id="1、在设备树中创建设备节点"><a href="#1、在设备树中创建设备节点" class="headerlink" title="1、在设备树中创建设备节点"></a>1、在设备树中创建设备节点</h4><p>毫无疑问，肯定要先在设备树中创建设备节点来描述设备信息，重点是要设置好 compatible属性的值，因为 platform 总线需要通过设备节点的 compatible 属性值来匹配驱动！这点要切记。比如，我们可以编写如下所示的设备节点来描述我们本章实验要用到的 LED 这个设备：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> gpioled &#123;<span class="hljs-number">2</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">3</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">4</span> compatible = <span class="hljs-string">&quot;atkalpha-gpioled&quot;</span>;<span class="hljs-number">5</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">6</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_led&gt;;<span class="hljs-number">7</span> led-gpio = &lt;&amp;gpio1 <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">8</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">9</span> &#125;;</code></pre></div><p>示例中的 gpioled 节点其实就是 之前中创建的 gpioled 设备节点，我们可以直接拿过来用。注意第 4 行的 compatible 属性值为“atkalpha-gpioled”，因此一会在编写 platform驱动的时候 of_match_table 属性表中要有“atkalpha-gpioled”。</p><h4 id="2-、编写-platform-驱动的时候要注意兼容属性"><a href="#2-、编写-platform-驱动的时候要注意兼容属性" class="headerlink" title="2 、编写 platform 驱动的时候要注意兼容属性"></a>2 、编写 platform 驱动的时候要注意兼容属性</h4><p>上一章已经详细的讲解过了，在使用设备树的时候 platform 驱动会通过 of_match_table 来保存兼容性值，也就是表明此驱动兼容哪些设备。所以，of_match_table 将会尤为重要，比如本例程的 platform 驱动中 platform_driver 就可以按照如下所示设置：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">leds_of_match</span>[] =</span> &#123;<span class="hljs-number">2</span> &#123; .compatible = <span class="hljs-string">&quot;atkalpha-gpioled&quot;</span> &#125;, <span class="hljs-comment">/*  兼容属性 */</span><span class="hljs-number">3</span> &#123; <span class="hljs-comment">/* Sentinel */</span> &#125;<span class="hljs-number">4</span> &#125;;<span class="hljs-number">5</span><span class="hljs-number">6</span> MODULE_DEVICE_TABLE(of, leds_of_match);<span class="hljs-number">7</span><span class="hljs-number">8</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">leds_platform_driver</span> =</span> &#123;<span class="hljs-number">9</span> .driver = &#123;<span class="hljs-number">10</span> .name = <span class="hljs-string">&quot;imx6ul-led&quot;</span>,<span class="hljs-number">11</span> .of_match_table = leds_of_match,<span class="hljs-number">12</span> &#125;,<span class="hljs-number">13</span> .probe = leds_probe,<span class="hljs-number">14</span> .remove = leds_remove,<span class="hljs-number">15</span> &#125;;</code></pre></div><p>第 1~4 行，of_device_id 表，也就是驱动的兼容表，是一个数组，每个数组元素为of_device_id<br>类型。每个数组元素都是一个兼容属性，表示兼容的设备，一个驱动可以跟多个设备匹配。这里我们仅仅匹配了一个设备，那就是创建的 gpioled 这个设备。第 2 行的 compatible 值为“atkalpha-gpioled”，驱动中的 compatible 属性和设备中的 compatible 属性相匹配，因此驱动中对应的 probe 函数就会执行。注意第 3 行是一个空元素，在编写 of_device_id 的时候最后一个元素一定要为空！</p><p>第 6 行，通过 MODULE_DEVICE_TABLE 声明一下 leds_of_match 这个设备匹配表。</p><p>第 11 行，设置 platform_driver 中的 of_match_table 匹配表为上面创建的 leds_of_match，至此我们就设置好了 platform 驱动的匹配表了。</p><h4 id="3-、编写-platform-驱动"><a href="#3-、编写-platform-驱动" class="headerlink" title="3 、编写 platform 驱动"></a>3 、编写 platform 驱动</h4><p>基于设备树的 platform 驱动和上一章无设备树的 platform 驱动基本一样，都是当驱动和设备匹配成功以后就会执行 probe 函数。我们需要在 probe 函数里面执行字符设备驱动那一套，当注销驱动模块的时候 remove 函数就会执行，都是大同小异的。</p><h3 id="2-实验程序编写"><a href="#2-实验程序编写" class="headerlink" title="2| 实验程序编写"></a>2| 实验程序编写</h3><h4 id="1、修改设备树文件"><a href="#1、修改设备树文件" class="headerlink" title="1、修改设备树文件"></a>1、修改设备树文件</h4><p>首先修改设备树文件，加上我们需要的设备信息，本章我们就使用到一个 LED 灯，因此可以直接使用之前小节编写的 gpioled 子节点即可，不需要再重复添加。</p><h4 id="2、platform-驱动程序编写"><a href="#2、platform-驱动程序编写" class="headerlink" title="2、platform  驱动程序编写"></a>2、platform  驱动程序编写</h4><p>设备已经准备好了，接下来就要编写相应的 platform 驱动了，新建名为“18_dtsplatform”的文件夹，然后在 18_dtsplatform 文件夹里面创建 vscode 工程，工作区命名为“dtsplatform”。新建名为 leddriver.c 的驱动文件，在 leddriver.c 中输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_CNT1<span class="hljs-comment">/* 设备号长度 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_NAME<span class="hljs-string">&quot;dtsplatled&quot;</span><span class="hljs-comment">/* 设备名字 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 1</span><span class="hljs-comment">/* leddev设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span>&#123;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-comment">/* 设备号*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-comment">/* cdev*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-comment">/* 类 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-comment">/* 设备*/</span><span class="hljs-type">int</span> major;<span class="hljs-comment">/* 主设备号*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">node</span>;</span><span class="hljs-comment">/* LED设备节点 */</span><span class="hljs-type">int</span> led0;<span class="hljs-comment">/* LED灯GPIO标号 */</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span> <span class="hljs-title">leddev</span>;</span> <span class="hljs-comment">/* led设备 */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: LED打开/关闭</span><span class="hljs-comment"> * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">led0_switch</span><span class="hljs-params">(u8 sta)</span>&#123;<span class="hljs-keyword">if</span> (sta == LEDON )gpio_set_value(leddev.led0, <span class="hljs-number">0</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sta == LEDOFF)gpio_set_value(leddev.led0, <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 打开设备</span><span class="hljs-comment"> * @param - inode : 传递给驱动的inode</span><span class="hljs-comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><span class="hljs-comment"> *   一般在open的时候将private_data指向设备结构体。</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;leddev; <span class="hljs-comment">/* 设置私有数据  */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向设备写数据 </span><span class="hljs-comment"> * @param - filp : 设备文件，表示打开的文件描述符</span><span class="hljs-comment"> * @param - buf : 要写给设备写入的数据</span><span class="hljs-comment"> * @param - cnt : 要写入的数据长度</span><span class="hljs-comment"> * @param - offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> retvalue;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">2</span>];<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;retvalue = copy_from_user(databuf, buf, cnt);<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;printk(<span class="hljs-string">&quot;kernel write failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EFAULT;&#125;ledstat = databuf[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span> (ledstat == LEDON) &#123;led0_switch(LEDON);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ledstat == LEDOFF) &#123;led0_switch(LEDOFF);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作函数 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;.owner = THIS_MODULE,.open = led_open,.write = led_write,&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: flatform驱动的probe函数，当驱动与</span><span class="hljs-comment"> *   设备匹配以后此函数就会执行</span><span class="hljs-comment"> * @param - dev : platform设备</span><span class="hljs-comment"> * @return : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>&#123;printk(<span class="hljs-string">&quot;k:led driver and device was matched!\r\n&quot;</span>);<span class="hljs-comment">/* 1、设置设备号 */</span><span class="hljs-keyword">if</span> (leddev.major) &#123;leddev.devid = MKDEV(leddev.major, <span class="hljs-number">0</span>);register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);&#125; <span class="hljs-keyword">else</span> &#123;alloc_chrdev_region(&amp;leddev.devid, <span class="hljs-number">0</span>, LEDDEV_CNT, LEDDEV_NAME);leddev.major = MAJOR(leddev.devid);&#125;<span class="hljs-comment">/* 2、注册设备      */</span>cdev_init(&amp;leddev.cdev, &amp;led_fops);cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);<span class="hljs-comment">/* 3、创建类      */</span>leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);<span class="hljs-keyword">if</span> (IS_ERR(leddev.class)) &#123;<span class="hljs-keyword">return</span> PTR_ERR(leddev.class);&#125;<span class="hljs-comment">/* 4、创建设备 */</span>leddev.device = device_create(leddev.class, <span class="hljs-literal">NULL</span>, leddev.devid, <span class="hljs-literal">NULL</span>, LEDDEV_NAME);<span class="hljs-keyword">if</span> (IS_ERR(leddev.device)) &#123;<span class="hljs-keyword">return</span> PTR_ERR(leddev.device);&#125;<span class="hljs-comment">/* 5、初始化IO */</span>leddev.node = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);<span class="hljs-keyword">if</span> (leddev.node == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;k:gpioled node nost find!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125; leddev.led0 = of_get_named_gpio(leddev.node, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (leddev.led0 &lt; <span class="hljs-number">0</span>) &#123;printk(<span class="hljs-string">&quot;k:can&#x27;t get led-gpio\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;gpio_request(leddev.led0, <span class="hljs-string">&quot;led0&quot;</span>);gpio_direction_output(leddev.led0, <span class="hljs-number">1</span>); <span class="hljs-comment">/* led0 IO设置为输出，默认高电平*/</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span><span class="hljs-comment"> * @param - dev : platform设备</span><span class="hljs-comment"> * @return : 0，成功;其他负值,失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span>&#123;gpio_set_value(leddev.led0, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 卸载驱动的时候关闭LED */</span>cdev_del(&amp;leddev.cdev);<span class="hljs-comment">/*  删除cdev */</span>unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="hljs-comment">/* 注销设备号 */</span>device_destroy(leddev.class, leddev.devid);class_destroy(leddev.class);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 匹配列表 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">led_of_match</span>[] =</span> &#123;&#123; .compatible = <span class="hljs-string">&quot;atkalpha-gpioled&quot;</span> &#125;,&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;&#125;;<span class="hljs-comment">/* platform驱动结构体 */</span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">led_driver</span> =</span> &#123;.driver= &#123;.name= <span class="hljs-string">&quot;imx6ul-led&quot;</span>,<span class="hljs-comment">/* 驱动名字，用于和设备匹配 */</span>.of_match_table= led_of_match, <span class="hljs-comment">/* 设备树匹配表  */</span>&#125;,.probe= led_probe,.remove= led_remove,&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动模块加载函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-keyword">return</span> platform_driver_register(&amp;led_driver);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 驱动模块卸载函数</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;platform_driver_unregister(&amp;led_driver);&#125;module_init(leddriver_init);module_exit(leddriver_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>platform 驱动的 probe 函数，当设备树中的设备节点与驱动之间匹配成功以后此函数就会执行，原来在驱动加载函数里面做的工作现在全部放到 probe 函数里面完成。</p><p>remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面释放内存、注销字符设备等，也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中完成。</p><p>匹配表，描述了此驱动都和什么样的设备匹配，添加了一条值为”atkalpha-gpioled”的compatible 属性值，当设备树中某个设备节点的 compatible 属性值也为“atkalpha-gpioled”的时候就会与此驱动匹配。</p><p>platform_driver 驱动结构体，设置这个 platform 驱动的名字为“imx6ul-led”，因此，当驱动加载成功以后就会在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录下存在一个名为“imx6u-led”的文件。 设置 of_match_table 为上面的 led_of_match。</p><h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3| 编写测试 APP"></a>3| 编写测试 APP</h3><p>测试 APP 就直接使用上一小节编写的 ledApp.c 即可。</p><h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4| 运行测试"></a>4| 运行测试</h3><p>编译运行。</p><p>驱动模块加载完成以后到&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录下查看驱动是否存在，我们在leddriver.c 中设置 led_driver (platform_driver 类型)的 name 字段为“imx6ul-led”，因此会在<br>&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;目录下存在名为“imx6ul-led”这个文件，结果如图 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828160111754.png" alt="image-20200828160111754"></p><p>同理，在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices&#x2F;目录下也存在 led 的设备文件，也就是设备树中 gpioled 这个节点，如图 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828160034597.png" alt="image-20200828160034597"></p><p>驱动和模块都存在，当驱动和设备匹配成功以后就会输出如图 所示一行语句：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/12%E3%80%81platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200828160050525.png" alt="image-20200828160050525"></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8| Linux  内核定时器实验</title>
    <link href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-内核定时器实验"><a href="#Linux-内核定时器实验" class="headerlink" title="Linux  内核定时器实验"></a>Linux  内核定时器实验</h1><p>定时器是我们最常用到的功能，一般用来完成定时功能，本章我们就来学习一下 Linux 内核提供的定时器 API 函数，通过这些定时器 API 函数我们可以完成很多要求定时的应用。Linux内核也提供了短延时函数，比如微秒、纳秒、毫秒延时函数，本章我们就来学习一下这些和时间有关的功能。</p><h2 id="一、Linux-时间管理和内核定时器简介"><a href="#一、Linux-时间管理和内核定时器简介" class="headerlink" title="一、Linux  时间管理和内核定时器简介"></a>一、Linux  时间管理和内核定时器简介</h2><h3 id="1-内核时间管理简介"><a href="#1-内核时间管理简介" class="headerlink" title="1|内核时间管理简介"></a>1|内核时间管理简介</h3><p>学习过 UCOS 或 FreeRTOS 的同学应该知道，UCOS 或 FreeRTOS 是需要一个硬件定时器提供系统时钟，一般使用 Systick 作为系统时钟源。同理，Linux 要运行，也是需要一个系统时钟的，至于这个系统时钟是由哪个定时器提供的，笔者没有去研究过 Linux 内核，但是在 Cortex-A7 内核中有个通用定时器，在《Cortex-A7 Technical ReferenceManua.pdf》的“9:Generic Timer”章节有简单的讲解，关于这个通用定时器的详细内容，可以参考《ARM ArchitectureReferenceManual ARMv7-A and ARMv7-R edition.pdf》的“chapter B8 The Generic Timer”章节。这个通用定时器是可选的，按照笔者学习 FreeRTOS 和 STM32 的经验，猜测 Linux 会将这个通用定时器作为 Linux 系统时钟源(前提是 SOC 得选配这个通用定时器)。具体是怎么做的笔者没有深入研究过，这里仅仅是猜测！不过对于我们 Linux 驱动编写者来说，不需要深入研究这些具体的实现，只需要掌握相应的 API 函数即可，除非你是内核编写者或者内核爱好者。</p><p>Linux 内核中有大量的函数需要时间管理，比如周期性的调度程序、延时程序、对于我们驱动编写者来说最常用的定时器。硬件定时器提供时钟源，时钟源的频率可以设置， 设置好以后就周期性的产生定时中断，系统使用定时中断来计时。中断周期性产生的频率就是系统频率，也叫做节拍率(tick rate)(有的资料也叫系统频率)，比如 1000Hz，100Hz 等等说的就是系统节拍率。系统节拍率是可以设置的，单位是 Hz，我们在编译 Linux 内核的时候可以通过图形化界面设置系统节拍率，按照如下路径打开配置界面：</p><div class="hljs code-wrapper"><pre><code class="hljs clean">-&gt; Kernel Features-&gt; Timer frequency (&lt;choice&gt; [=y])</code></pre></div><p>选中“Timer frequency”，打开以后如图  所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/image-20200823184757745.png" alt="image-20200823184757745"></p><p>从图 可以看出，可选的系统节拍率为 100Hz、200Hz、250Hz、300Hz、500Hz 和1000Hz，默认情况下选择 100Hz。设置好以后打开 Linux 内核源码根目录下的.config 文件，在此文件中有如图 所示定义：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/image-20200823185001187.png" alt="image-20200823185001187"></p><p>图 中的 CONFIG_HZ 为 100，Linux 内核会使用 CONFIG_HZ 来设置自己的系统时钟。打开文件 include&#x2F;asm-generic&#x2F;param.h，有如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">6</span> <span class="hljs-meta"># <span class="hljs-keyword">undef</span> HZ</span><span class="hljs-number">7</span> <span class="hljs-meta"># <span class="hljs-keyword">define</span> HZ CONFIG_HZ</span><span class="hljs-number">8</span> <span class="hljs-meta"># <span class="hljs-keyword">define</span> USER_HZ 100</span><span class="hljs-number">9</span> <span class="hljs-meta"># <span class="hljs-keyword">define</span> CLOCKS_PER_SEC (USER_HZ)</span></code></pre></div><p>第 7 行定义了一个宏 HZ，宏 HZ 就是 CONFIG_HZ，因此 HZ&#x3D;100，我们后面编写 Linux驱动的时候会常常用到 HZ，因为 HZ 表示一秒的节拍数，也就是频率。大多数初学者看到系统节拍率默认为 100Hz 的时候都会有疑问，怎么这么小？100Hz 是可选的节拍率里面最小的。为什么不选择大一点的呢？这里就引出了一个问题：</p><p><strong>高节拍率和低节拍率的优缺点：</strong></p><ul><li>①、高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。</li><li>②、高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担，1000Hz 和 100Hz的系统节拍率相比，系统要花费 10 倍的“精力”去处理中断。中断服务函数占用处理器的时间增加，但是现在的处理器性能都很强大，所以采用 1000Hz 的系统节拍率并不会增加太大的负载压力。根据自己的实际情况，选择合适的系统节拍率，本教程我们全部采用默认的 100Hz 系统节拍率。</li></ul><p><strong>Linux 内核使用全局变量 jiffies 来记录系统从启动以来的系统节拍数</strong>，系统启动的时候会将 jiffies 初始化为 0，jiffies 定义在文件 include&#x2F;linux&#x2F;jiffies.h 中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">76</span> <span class="hljs-keyword">extern</span> u64 __jiffy_data jiffies_64;<span class="hljs-number">77</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-keyword">volatile</span> __jiffy_data jiffies;</code></pre></div><p>第 76 行，定义了一个 64 位的 jiffies_64。<br>第 77 行，定义了一个 unsigned long 类型的 32 位的 jiffies。jiffies_64 和 jiffies 其实是同一个东西，jiffies_64 用于 64 位系统，而 jiffies 用于 32 位系统。为了兼容不同的硬件，jiffies 其实就是 jiffies_64 的低 32 位，jiffies_64 和 jiffies 的结构如图 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/image-20200823185320525.png" alt="image-20200823185320525"></p><p>当我们访问 jiffies 的时候其实访问的是 jiffies_64 的低 32 位，使用 get_jiffies_64 这个函数可以获取 jiffies_64 的值。在 32 位的系统上读取 jiffies 的值，在 64 位的系统上 jiffes 和 jiffies_64表示同一个变量，因此也可以直接读取 jiffies 的值。所以不管是 32 位的系统还是 64 位系统，都可以使用 jiffies。</p><p>前面说了 HZ 表示每秒的节拍数，<strong>jiffies 表示系统运行的 jiffies 节拍数</strong>，<strong>所以 jiffies&#x2F;HZ 就是系统运行时间，单位为秒</strong>。不管是 32 位还是 64 位的 jiffies，都有溢出的风险，溢出以后会重新从 0 开始计数，相当于绕回来了，因此有些资料也将这个现象也叫做绕回。假如 HZ 为最大值 1000 的时候，32 位的 jiffies 只需要 49.7 天就发生了绕回，对于 64 位的 jiffies 来说大概需要5.8 亿年才能绕回，因此 jiffies_64 的绕回忽略不计。处理 32 位 jiffies 的绕回显得尤为重要，Linux 内核提供了如表所示的几个 API 函数来处理绕回。</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/image-20200823185539719.png" alt="image-20200823185539719"></p><p>如果 unkown 超过 known 的话，time_after 函数返回真，否则返回假。如果 unkown 没有超过 known 的话 time_before 函数返回真，否则返回假。time_after_eq 函数和 time_after 函数类似，只是多了判断等于这个条件。同理，time_before_eq 函数和 time_before 函数也类似。比如我们要判断某段代码执行时间有没有超时，此时就可以使用如下所示代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout;<span class="hljs-number">2</span> timeout = jiffies + (<span class="hljs-number">2</span> * HZ); <span class="hljs-comment">/* 超时的时间点 */</span><span class="hljs-number">3</span><span class="hljs-number">4</span> <span class="hljs-comment">/*************************************</span><span class="hljs-comment">5 具体的代码</span><span class="hljs-comment">6 ************************************/</span><span class="hljs-number">7</span><span class="hljs-number">8</span> <span class="hljs-comment">/* 判断有没有超时 */</span><span class="hljs-number">9</span> <span class="hljs-keyword">if</span>(time_before(jiffies, timeout)) &#123;<span class="hljs-number">10</span> <span class="hljs-comment">/* 超时未发生 */</span><span class="hljs-number">11</span> &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-number">12</span> <span class="hljs-comment">/* 超时发生 */</span><span class="hljs-number">13</span> &#125;</code></pre></div><p>timeout 就是超时时间点，比如我们要判断代码执行时间是不是超过了 2 秒，那么超时时间点就是 jiffies+(2*HZ)，如果 jiffies 大于 timeout 那就表示超时了，否则就是没有超时。第 4~6 行就是具体的代码段。第 9 行通过函数 time_before 来判断 jiffies 是否小于 timeout，如果小于的话就表示没有超时。为了方便开发，Linux 内核提供了几个 jiffies 和 ms、us、ns 之间的转换函数，如表 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/image-20200823185852339.png" alt="image-20200823185852339"></p><h3 id="2-内核定时器简介"><a href="#2-内核定时器简介" class="headerlink" title="2|内核定时器简介"></a>2|内核定时器简介</h3><p>定时器是一个很常用的功能，需要周期性处理的工作都要用到定时器。Linux 内核定时器采用系统时钟来实现，并不是裸机的 PIT 等硬件定时器。Linux 内核定时器使用很简单，只需要提供超时时间(相当于定时值)和定时处理函数即可，当超时时间到了以后设置的定时处理函数就会执行，和我们使用硬件定时器的套路一样，只是使用内核定时器不需要做一大堆的寄存器初始化工作。在使用内核定时器的时候要注意一点，内核定时器并不是周期性运行的，超时以后就会自动关闭，因此如果想要实现周期性定时，那么就需要在定时处理函数中重新开启定时器。Linux 内核使用 timer_list 结构体表示内核定时器，timer_list 定义在文件include&#x2F;linux&#x2F;timer.h 中，定义如下(省略掉条件编译)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires; <span class="hljs-comment">/* 定时器超时时间，单位是节拍数 */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tvec_base</span> *<span class="hljs-title">base</span>;</span>    <span class="hljs-type">void</span> (*function)(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>); <span class="hljs-comment">/* 定时处理函数 */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data; <span class="hljs-comment">/* 要传递给 function 函数的参数 */</span>    <span class="hljs-type">int</span> slack;&#125;;</code></pre></div><p>要使用内核定时器首先要先定义一个 timer_list 变量，表示定时器，tiemr_list 结构体的expires 成员变量表示超时时间，单位为节拍数。比如我们现在需要定义一个周期为 2 秒的定时器，那么这个定时器的超时时间就是 jiffies+(2<em>HZ)，因此 expires&#x3D;jiffies+(2</em>HZ)。function 就是定时器超时以后的定时处理函数，我们要做的工作就放到这个函数里面，需要我们编写这个定时处理函数。定义好定时器以后还需要通过一系列的 API 函数来初始化此定时器，这些函数如下：</p><hr><h4 id="1-、init-timer-函数"><a href="#1-、init-timer-函数" class="headerlink" title="1 、init_timer  函数"></a>1 、init_timer  函数</h4><p><strong>init_timer 函数负责初始化 timer_list 类型变量</strong>，当我们定义了一个 timer_list 变量以后一定要先用 init_timer 初始化一下。init_timer 函数原型如下</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>timer</strong>：要初始化定时器。<br><strong>返回值</strong>：没有返回值。</p><hr><h4 id="2-、add-timer-函数"><a href="#2-、add-timer-函数" class="headerlink" title="2 、add_timer  函数"></a>2 、add_timer  函数</h4><p><strong>add_timer函数用于向Linux 内核注册定时器</strong>，使用 add_timer函数向内核注册定时器以后，定时器就会开始运行，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">add_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>timer</strong>：要注册的定时器。<br><strong>返回值</strong>：没有返回值。</p><hr><h4 id="3-、del-timer-函数"><a href="#3-、del-timer-函数" class="headerlink" title="3 、del_timer  函数"></a>3 、del_timer  函数</h4><p><strong>del_timer 函数用于删除一个定时器</strong>，不管定时器有没有被激活，都可以使用此函数删除。在多处理器系统上，定时器可能会在其他的处理器上运行，因此在调用 del_timer 函数删除定时器之前要先等待其他处理器的定时处理器函数退出。del_timer 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">del_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list * timer)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>timer</strong>：要删除的定时器。<br><strong>返回值</strong>：0，定时器还没被激活；1，定时器已经激活。</p><hr><h4 id="4-、del-timer-sync-函数"><a href="#4-、del-timer-sync-函数" class="headerlink" title="4 、del_timer_sync  函数"></a>4 、del_timer_sync  函数</h4><p><strong>del_timer_sync 函数是 del_timer 函数的同步版，会等待其他处理器使用完定时器再删除</strong>，del_timer_sync 不能使用在中断上下文中。del_timer_sync 函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">del_timer_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>timer</strong>：要删除的定时器。<br><strong>返回值</strong>：0，定时器还没被激活；1，定时器已经激活。</p><hr><h4 id="5-、mod-timer-函数"><a href="#5-、mod-timer-函数" class="headerlink" title="5 、mod_timer  函数"></a>5 、mod_timer  函数</h4><p><strong>mod_timer 函数用于修改定时值，如果定时器还没有激活的话，mod_timer 函数会激活定时器</strong>！函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mod_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>timer</strong>：要修改超时时间(定时值)的定时器。<br><strong>expires</strong>：修改后的超时时间。<br><strong>返回值</strong>：0，调用 mod_timer 函数前定时器未被激活；1，调用 mod_timer 函数前定时器已被激活。</p><hr><p>关于内核定时器常用的 API 函数就讲这些，内核定时器一般的使用流程如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> <span class="hljs-comment">/* 定义定时器 */</span><span class="hljs-number">2</span><span class="hljs-number">3</span> <span class="hljs-comment">/* 定时器回调函数 */</span><span class="hljs-number">4</span> <span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>5 &#123;<span class="hljs-number">6</span> <span class="hljs-comment">/*</span><span class="hljs-comment">7 * 定时器处理代码</span><span class="hljs-comment">8 */</span><span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-comment">/* 如果需要定时器周期性运行的话就使用 mod_timer</span><span class="hljs-comment">11 * 函数重新设置超时值并且启动定时器。</span><span class="hljs-comment">12 */</span><span class="hljs-number">13</span> mod_timer(&amp;dev-&gt;timertest, jiffies + msecs_to_jiffies(<span class="hljs-number">2000</span>));<span class="hljs-number">14</span> &#125;<span class="hljs-number">15</span><span class="hljs-number">16</span> <span class="hljs-comment">/* 初始化函数 */</span><span class="hljs-number">17</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>18 &#123;<span class="hljs-number">19</span> init_timer(&amp;timer); <span class="hljs-comment">/* 初始化定时器 */</span><span class="hljs-number">20</span><span class="hljs-number">21</span> timer.function = function; <span class="hljs-comment">/* 设置定时处理函数 */</span><span class="hljs-number">22</span> timer.expires=jffies + msecs_to_jiffies(<span class="hljs-number">2000</span>);<span class="hljs-comment">/* 超时时间 2 秒 */</span><span class="hljs-number">23</span> timer.data = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)&amp;dev; <span class="hljs-comment">/* 将设备结构体作为参数 */</span><span class="hljs-number">24</span><span class="hljs-number">25</span> add_timer(&amp;timer); <span class="hljs-comment">/* 启动定时器 */</span><span class="hljs-number">26</span> &#125;<span class="hljs-number">27</span><span class="hljs-number">28</span> <span class="hljs-comment">/* 退出函数 */</span><span class="hljs-number">29</span> <span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>30 &#123;<span class="hljs-number">31</span> del_timer(&amp;timer); <span class="hljs-comment">/* 删除定时器 */</span><span class="hljs-number">32</span> <span class="hljs-comment">/* 或者使用 */</span><span class="hljs-number">33</span> del_timer_sync(&amp;timer);<span class="hljs-number">34</span> &#125;</code></pre></div><h3 id="3-Linux-内核短延时函数"><a href="#3-Linux-内核短延时函数" class="headerlink" title="3|Linux 内核短延时函数"></a>3|Linux 内核短延时函数</h3><p>有时候我们需要在内核中实现短延时，尤其是在 Linux 驱动中。Linux 内核提供了毫秒、微秒和纳秒延时函数，这三个函数如表 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/image-20200823191316445.png" alt="image-20200823191316445"></p><h2 id="二、硬件原理图分析"><a href="#二、硬件原理图分析" class="headerlink" title="二、硬件原理图分析"></a>二、硬件原理图分析</h2><p>本章使用通过设置一个定时器来实现周期性的闪烁 LED 灯，原理图参考前面的文档。</p><h2 id="三、实验程序编写"><a href="#三、实验程序编写" class="headerlink" title="三、实验程序编写"></a>三、实验程序编写</h2><h3 id="1-驱动程序编写"><a href="#1-驱动程序编写" class="headerlink" title="1|驱动程序编写"></a>1|驱动程序编写</h3><p>新建名为“12_timer”的文件夹，然后在 12_timer 文件夹里面创建 vscode 工程，工作区命名为“timer”。工程创建好以后新建 timer.c 文件，在 timer.c 里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLOSE_CMD (_IO(0XEF, 0x1)) <span class="hljs-comment">/* 关闭定时器 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPEN_CMD (_IO(0XEF, 0x2)) <span class="hljs-comment">/* 打开定时器 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SETPERIOD_CMD (_IO(0XEF, 0x3)) <span class="hljs-comment">/* 设置定时器周期命令 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 1 <span class="hljs-comment">/* 开灯 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 0 <span class="hljs-comment">/* 关灯 */</span></span><span class="hljs-comment">/* 设备号个数 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMER_DEV_NUM 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_NAME <span class="hljs-string">&quot;timer&quot;</span></span><span class="hljs-comment">/* timerdev设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span><span class="hljs-comment">//设备树节点</span><span class="hljs-type">int</span> led_gpio;<span class="hljs-comment">//led所使用的GPIO编号</span><span class="hljs-type">int</span> timerperiod; <span class="hljs-comment">/* 定时周期,单位为 ms */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> <span class="hljs-comment">/* 定义一个定时器  */</span><span class="hljs-type">spinlock_t</span> lock; <span class="hljs-comment">/* 定义自旋锁 */</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_dev</span> <span class="hljs-title">timerdev</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;timerdev.nd = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);<span class="hljs-keyword">if</span>(timerdev.nd == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> -EINVAL;&#125;timerdev.led_gpio = of_get_named_gpio(timerdev.nd,<span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(timerdev.led_gpio &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;kernel:can&#x27;t get led\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;printk(<span class="hljs-string">&quot;kernel:led_gpio index=%d\r\n&quot;</span>, timerdev.led_gpio);<span class="hljs-comment">/* 初始化 led 所使用的 IO */</span>gpio_request(timerdev.led_gpio, <span class="hljs-string">&quot;led&quot;</span>); <span class="hljs-comment">/* 请求 IO */</span>ret = gpio_direction_output(timerdev.led_gpio, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 设置为输出 */</span><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:can&#x27;t set gpio!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">timer_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;filp-&gt;private_data = &amp;timerdev; <span class="hljs-comment">/* 设置私有数据 */</span>timerdev.timerperiod = <span class="hljs-number">1000</span>; <span class="hljs-comment">/* 默认周期为 1s */</span>ret = led_init();<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : ioctl 函数，</span><span class="hljs-comment"> * @param – filp : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @param - cmd : 应用程序发送过来的命令</span><span class="hljs-comment"> * @param - arg : 参数</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">timer_unlocked_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, </span><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> timer_dev *)filp-&gt;private_data;<span class="hljs-type">int</span> timerperiod;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<span class="hljs-keyword">switch</span> (cmd)&#123;<span class="hljs-keyword">case</span> CLOSE_CMD:<span class="hljs-comment">/* 关闭定时器 */</span>del_timer_sync(&amp;dev-&gt;timer);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> OPEN_CMD:<span class="hljs-comment">/* 打开定时器 */</span>spin_lock_irqsave(&amp;dev-&gt;lock, flags);timerperiod = dev-&gt;timerperiod;spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(timerperiod));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> SETPERIOD_CMD:<span class="hljs-comment">/* 设置定时器周期 */</span>spin_lock_irqsave(&amp;dev-&gt;lock, flags);dev-&gt;timerperiod = arg;spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(arg));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 定时器回调函数 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> timer_dev *)arg;<span class="hljs-type">static</span> <span class="hljs-type">int</span> sta = <span class="hljs-number">1</span>;<span class="hljs-type">int</span> timerperiod;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;sta = !sta; <span class="hljs-comment">/* 每次都取反，实现 LED 灯反转 */</span>gpio_set_value(dev-&gt;led_gpio, sta);<span class="hljs-comment">/* 重启定时器 */</span>spin_lock_irqsave(&amp;dev-&gt;lock, flags);timerperiod = dev-&gt;timerperiod;spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(dev-&gt;timerperiod));&#125;<span class="hljs-comment">/* 设备操作集合 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">timer_fops</span> =</span> &#123;.owner = THIS_MODULE,.open = timer_open,.unlocked_ioctl = timer_unlocked_ioctl,&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">timer_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 初始化自旋锁 */</span>spin_lock_init(&amp;timerdev.lock);<span class="hljs-comment">/* 注册设备号 */</span>timerdev.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(timerdev.major)&#123;timerdev.devid = MKDEV(timerdev.major, timerdev.minor);ret = register_chrdev_region(timerdev.devid, TIMER_DEV_NUM, DEV_NAME);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;timerdev.devid, <span class="hljs-number">0</span>, TIMER_DEV_NUM, DEV_NAME);&#125;timerdev.major = MAJOR(timerdev.devid);timerdev.minor = MINOR(timerdev.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;k:timerdev  MAJOR:%d  MINOR:%d\r\n&quot;</span>, timerdev.major, timerdev.minor);<span class="hljs-comment">/* 添加字符设备 */</span>timerdev.cdev.owner = timer_fops.owner;cdev_init(&amp;timerdev.cdev, &amp;timer_fops);ret = cdev_add(&amp;timerdev.cdev, timerdev.devid, TIMER_DEV_NUM);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>timerdev.class = class_create(THIS_MODULE, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(timerdev.class))&#123;printk(<span class="hljs-string">&quot;k:fail to create class!\r\n&quot;</span>);result = PTR_ERR(timerdev.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>timerdev.device = device_create(timerdev.class, <span class="hljs-literal">NULL</span>, timerdev.devid, <span class="hljs-literal">NULL</span>, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(timerdev.device))&#123;printk(<span class="hljs-string">&quot;k:fail to create device!\r\n&quot;</span>);result = PTR_ERR(timerdev.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 初始化 timer，设置定时器处理函数,还未设置周期，所有不会激活定时器 */</span>init_timer(&amp;timerdev.timer);timerdev.timer.function = timer_function;timerdev.timer.data = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)&amp;timerdev;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(timerdev.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;timerdev.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(timerdev.devid, TIMER_DEV_NUM);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">timer_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;gpio_set_value(timerdev.led_gpio, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 卸载驱动的时候关闭 LED */</span>del_timer_sync(&amp;timerdev.timer); <span class="hljs-comment">/* 删除 timer  */</span><span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(timerdev.class, timerdev.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(timerdev.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;timerdev.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(timerdev.devid, TIMER_DEV_NUM);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(timer_init);module_exit(timer_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p><code>struct timer_dev</code>，定时器设备结构体，定义了一个定时器成员变量 timer。<br><code>led_init</code>，LED 灯初始化函数，从设备树中获取 LED 灯信息，然后初始化相应的 IO。<br><code>timer_open</code>，函数 timer_open，对应应用程序的 open 函数，应用程序调用 open 函数打开&#x2F;dev&#x2F;timer 驱动文件的时候此函数就会执行。此函数设置文件私有数据为 timerdev，并且初始化定时周期默认为 1 秒，最后调用 led_init 函数初始化 LED 所使用的 IO。<br><code>timer_unlocked_ioctl</code>，函数 timer_unlocked_ioctl，对应应用程序的 ioctl 函数，应用程序调用 ioctl函数向驱动发送控制信息，此函数响应并执行。此函数有三个参数：filp，cmd 和 arg，其中 filp是对应的设备文件，cmd 是应用程序发送过来的命令信息，arg 是应用程序发送过来的参数，在本章例程中 arg 参数表示定时周期。一共有三种命令 CLOSE_CMD，OPEN_CMD 和 SETPERIOD_CMD，这三个命令分别为关闭定时器、打开定时器、设置定时周期。这三个命令的左右如下：</p><ul><li><strong>CLOSE_CMD</strong>: 关闭定时器命令， ，调用 del_timer_sync 函数关闭定时器。</li><li><strong>OPEN_CMD</strong>：打开定时器命令，调用 mod_timer 函数打开定时器，定时周期为 timerdev 的timeperiod 成员变量，定时周期默认是 1 秒。</li><li><strong>SETPERIOD_CMD</strong>：设置定时器周期命令，参数 arg 就是新的定时周期，设置 timerdev 的timeperiod 成员变量为 arg 所表示定时周期指。并且使用 mod_timer 重新打开定时器，使定时器以新的周期运行。</li></ul><p><code>static struct file_operations timer_fops</code>，定时器驱动操作函数集 timer_fops。<br><code>timer_function</code>，函数 timer_function，定时器服务函数，此函有一个参数 arg，在本例程中arg 参数就是 timerdev 的地址，这样通过 arg 参数就可以访问到设备结构体。当定时周期到了以后此函数就会被调用。在此函数中将 LED 灯的状态取反，实现 LED 灯闪烁的效果。因为内核定时器不是循环的定时器，执行一次以后就结束了，因此又调用了 mod_timer 函数重新开启定时器。<br><code>timer_init</code>，函数 timer_init，驱动入口函数。初始化定时器，设置定时器的定时处理函数为 timer_function，另外设置要传递给 timer_function 函数的参数为 timerdev的地址。在此函数中并没有调用 timer_add 函数来开启定时器，因此定时器默认是关闭的，除非应用程序发送打开命令。<br>最后，驱动出口函数，关闭 LED，也就是卸载驱动以后 LED 处于熄灭状态。调用 del_timer_sync 函数删除定时器，也可以使用 del_timer 函数。</p><h3 id="2-编写测试APP"><a href="#2-编写测试APP" class="headerlink" title="2|编写测试APP"></a>2|编写测试APP</h3><p>测试 APP 我们要实现的内容如下：<br>①、运行 APP 以后提示我们输入要测试的命令，输入 1 表示关闭定时器、输入 2 表示打开定时器，输入 3 设置定时器周期。<br>②、如果要设置定时器周期的话，需要让用户输入要设置的周期值，单位为毫秒。</p><p>新建名为 timerApp.c 的文件，然后输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/ioctl.h&quot;</span></span><span class="hljs-comment">/* 命令值 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLOSE_CMD (_IO(0XEF, 0x1)) <span class="hljs-comment">/* 关闭定时器 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPEN_CMD (_IO(0XEF, 0x2)) <span class="hljs-comment">/* 打开定时器 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SETPERIOD_CMD (_IO(0XEF, 0x3)) <span class="hljs-comment">/* 设置定时器周期命令 */</span></span><span class="hljs-comment">/*</span><span class="hljs-comment">* @description : main 主程序</span><span class="hljs-comment">* @param - argc : argv 数组元素个数</span><span class="hljs-comment">* @param - argv : 具体参数</span><span class="hljs-comment">* @return : 0 成功;其他 失败</span><span class="hljs-comment">*/</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, fd = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> *filename;    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd;    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arg;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];        <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    filename = argv[<span class="hljs-number">1</span>];    <span class="hljs-comment">/* 打开 key 驱动 */</span>    fd =  open(filename, O_RDWR);    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input CMD:&quot;</span>);        ret = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;cmd);        <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">/* 参数输入错误 */</span>            gets(str);          <span class="hljs-comment">/* 防止卡死 */</span>        &#125;        <span class="hljs-keyword">if</span>(cmd == <span class="hljs-number">1</span>)            <span class="hljs-comment">/* 关闭 LED 灯 */</span>            cmd = CLOSE_CMD;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmd == <span class="hljs-number">2</span>)       <span class="hljs-comment">/* 打开 LED 灯 */</span>            cmd = OPEN_CMD;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmd == <span class="hljs-number">3</span>) &#123;            cmd = SETPERIOD_CMD; <span class="hljs-comment">/* 设置周期值 */</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input Timer Period:&quot;</span>);            ret = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arg);            <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">/* 参数输入错误 */</span>                gets(str);          <span class="hljs-comment">/* 防止卡死 */</span>            &#125;        &#125;        ioctl(fd, cmd, arg); <span class="hljs-comment">/* 控制定时器的打开和关闭 */</span>    &#125;    close(fd);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>while(1)循环，让用户输入要测试的命令，然后通过第 72 行的 ioctl 函数发送给驱动程序。如果是设置定时器周期命令 SETPERIOD_CMD，那么 ioctl 函数的 arg 参数就是用户输入的周期值。</p><h2 id="四、运行测试"><a href="#四、运行测试" class="headerlink" title="四、运行测试"></a>四、运行测试</h2><p>编译运行：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/8%E3%80%81Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/image-20200824125443397.png" alt="image-20200824125443397"></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9| Linux 中断实验</title>
    <link href="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-中断实验"><a href="#Linux-中断实验" class="headerlink" title="Linux 中断实验"></a>Linux 中断实验</h1><p>不管是裸机实验还是 Linux 下的驱动实验，中断都是频繁使用的功能，在裸机中使用中断我们需要做一大堆的工作，比如配置寄存器，使能 IRQ 等等。Linux 内核提供了完善的中断框架，我们只需要申请中断，然后注册中断处理函数即可，使用非常方便，不需要一系列复杂的寄存器配置。本章我们就来学习一下如何在 Linux 下使用中断。</p><h2 id="一、-Linux-中断简介"><a href="#一、-Linux-中断简介" class="headerlink" title="一、 Linux 中断简介"></a>一、 Linux 中断简介</h2><h3 id="1-Linux-中断-API-函数"><a href="#1-Linux-中断-API-函数" class="headerlink" title="1|Linux  中断 API 函数"></a>1|Linux  中断 API 函数</h3><p>先来回顾一下裸机实验里面中断的处理方法：<br>①、使能中断，初始化相应的寄存器。<br>②、注册中断服务函数，也就是向 irqTable 数组的指定标号处写入中断服务函数<br>②、中断发生以后进入 IRQ 中断服务函数，在 IRQ 中断服务函数在数组 irqTable 里面查找具体的中断处理函数，找到以后执行相应的中断处理函数。</p><hr><p>在 Linux 内核中也提供了大量的中断相关的 API 函数，我们来看一下这些跟中断有关的API 函数：</p><h4 id="1-、中断号"><a href="#1-、中断号" class="headerlink" title="1 、中断号"></a><strong>1 、中断号</strong></h4><p>每个中断都有一个中断号，通过中断号即可区分不同的中断，有的资料也把中断号叫做中断线。在 Linux 内核中使用一个 int 变量表示中断号.</p><h4 id="2-、request-irq-函数"><a href="#2-、request-irq-函数" class="headerlink" title="2 、request_irq  函数"></a><strong>2 、request_irq  函数</strong></h4><p>在 Linux 内核中要想使用某个中断是需要申请的，request_irq 函数用于申请中断，request_irq函数可能会导致睡眠，因此不能在中断上下文或者其他禁止睡眠的代码段中使用 request_irq 函数。request_irq 函数会激活(使能)中断，所以不需要我们手动去使能中断，request_irq 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">request_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq,</span><span class="hljs-params">                <span class="hljs-type">irq_handler_t</span> handler,</span><span class="hljs-params">                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,</span><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><span class="hljs-params">                <span class="hljs-type">void</span> *dev)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li><p><strong>irq</strong>：要申请中断的中断号。</p></li><li><p><strong>handler</strong>：中断处理函数，当中断发生以后就会执行此中断处理函数。</p></li><li><p><strong>flags</strong>：中断标志，可以在文件 include&#x2F;linux&#x2F;interrupt.h 里面查看所有的中断标志，这里我们介绍几个常用的中断标志，如表所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200824142754531.png" alt="image-20200824142754531"></p><p>比如 I.MX6U-ALPHA 开发板上的 KEY0 使用 GPIO1_IO18，按下 KEY0 以后为低电平，因此可以设置为下降沿触发，也就是将 flags 设置为 IRQF_TRIGGER_FALLING。表 中的这些标志可以通过“|”来实现多种组合。</p></li><li><p><strong>name</strong>：中断名字，设置以后可以在&#x2F;proc&#x2F;interrupts 文件中看到对应的中断名字。</p></li><li><p><strong>dev</strong> ：如果将 flags 设置为 IRQF_SHARED 的话，dev 用来区分不同的中断，一般情况下将dev 设置为设备结构体，dev 会传递给中断处理函数 irq_handler_t 的第二个参数。</p></li><li><p><strong>返回值</strong>：0 中断申请成功，其他负值 中断申请失败，如果返回-EBUSY 的话表示中断已经被申请了。</p></li></ul><hr><h4 id="3-、free-irq-函数"><a href="#3-、free-irq-函数" class="headerlink" title="3 、free_irq  函数"></a><strong>3 、free_irq  函数</strong></h4><p>使用中断的时候需要通过 request_irq 函数申请，使用完成以后就要通过 free_irq 函数释放掉相应的中断。如果中断不是共享的，那么 free_irq 会删除中断处理函数并且禁止中断。free_irq函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq,</span><span class="hljs-params">                <span class="hljs-type">void</span> *dev)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>irq</strong> ：要释放的中断。<br><strong>dev</strong>：如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉。<br><strong>返回值</strong>：无。</p><hr><h4 id="4-、中断处理函数"><a href="#4-、中断处理函数" class="headerlink" title="4 、中断处理函数"></a><strong>4 、中断处理函数</strong></h4><p>使用 request_irq 函数申请中断的时候需要设置中断处理函数，中断处理函数格式如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">irqreturn_t</span> (*<span class="hljs-type">irq_handler_t</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *)</code></pre></div><ul><li>第一个参数是要中断处理函数要相应的中断号。</li><li>第二个参数是一个指向 void 的指针，也就是个通用指针，需要与 request_irq 函数的 dev 参数保持一致。用于区分共享中断的不同设备，dev 也可以指向设备数据结构。</li></ul><p>中断处理函数的返回值为 irqreturn_t 类型，irqreturn_t类型定义如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">10</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">irqreturn</span> &#123;</span><span class="hljs-number">11</span> IRQ_NONE = (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">0</span>),<span class="hljs-number">12</span> IRQ_HANDLED = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>),<span class="hljs-number">13</span> IRQ_WAKE_THREAD = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>),<span class="hljs-number">14</span> &#125;;<span class="hljs-number">15</span><span class="hljs-number">16</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">irqreturn</span> <span class="hljs-title">irqreturn_t</span>;</span></code></pre></div><p>可以看出 irqreturn_t 是个枚举类型，一共有三种返回值。一般中断服务函数返回值使用如下形式：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED)</code></pre></div><hr><h4 id="5-、中断使能与禁止函数"><a href="#5-、中断使能与禁止函数" class="headerlink" title="5 、中断使能与禁止函数"></a><strong>5 、中断使能与禁止函数</strong></h4><p>常用的中断使用和禁止函数如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">enable_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span><span class="hljs-type">void</span> <span class="hljs-title function_">disable_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span></code></pre></div><p>enable_irq 和 disable_irq 用于使能和禁止指定的中断，irq 就是要禁止的中断号。disable_irq函数要等到当前正在执行的中断处理函数执行完才返回，因此使用者需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出。在这种情况下，可以使用另外一个中断禁止函数：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">disable_irq_nosync</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span></code></pre></div><p>disable_irq_nosync 函数调用以后立即返回，不会等待当前中断处理程序执行完毕。上面三个函数都是使能或者禁止某一个中断，有时候我们需要关闭当前处理器的整个中断系统，也就是在学习 STM32 的时候常说的关闭全局中断，这个时候可以使用如下两个函数</p><div class="hljs code-wrapper"><pre><code class="hljs c">local_irq_enable()local_irq_disable()</code></pre></div><p>local_irq_enable 用于使能当前处理器中断系统，local_irq_disable 用于禁止当前处理器中断系统。假如 A 任务调用 local_irq_disable 关闭全局中断 10S，当关闭了 2S 的时候 B 任务开始运行，B 任务也调用 local_irq_disable 关闭全局中断 3S，3 秒以后 B 任务调用local_irq_enable 函数将全局中断打开了。此时才过去 2+3&#x3D;5 秒的时间，然后全局中断就被打开了，此时 A 任务要关闭 10S 全局中断的愿望就破灭了，然后 A 任务就“生气了”，结果很严重，可能系统都要被A 任务整崩溃。为了解决这个问题，B 任务不能直接简单粗暴的通过 local_irq_enable 函数来打开全局中断，而是将中断状态恢复到以前的状态，要考虑到别的任务的感受，此时就要用到下面两个函数：</p><div class="hljs code-wrapper"><pre><code class="hljs c">local_irq_save(flags) local_irq_restore(flags)</code></pre></div><p>这两个函数是一对，local_irq_save 函数用于禁止中断，并且将中断状态保存在 flags 中。local_irq_restore 用于恢复中断，将中断到 flags 状态。</p><h3 id="2-上半部与下半部"><a href="#2-上半部与下半部" class="headerlink" title="2|上半部与下半部"></a>2|上半部与下半部</h3><p>在有些资料中也将上半部和下半部称为顶半部和底半部，都是一个意思。我们在使用request_irq 申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。我们都知道中断处理函数一定要快点执行完毕，越短越好，但是现实往往是残酷的，有些中断处理过程就是比较费时间，我们必须要对其进行处理，缩小中断处理函数的执行时间。比如电容触摸屏通过中断通知 SOC 有触摸事件发生，SOC 响应中断，然后通过 IIC 接口读取触摸坐标值并将其上报给系统。但是我们都知道 IIC 的速度最高也只有400Kbit&#x2F;S，所以在中断中通过 IIC 读取数据就会浪费时间。我们可以将通过 IIC 读取触摸数据的操作暂后执行，中断处理函数仅仅相应中断，然后清除中断标志位即可。这个时候中断处理过程就分为了两部分：</p><ul><li>上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。</li><li>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。</li></ul><p>因此，Linux 内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，那些对时间敏感、执行速度快的操作可以放到中断处理函数中，也就是上半部。剩下的所有工作都可以放到下半部去执行，比如在上半部将数据拷贝到内存中，关于数据的具体处理就可以放到下半部去执行。至于哪些代码属于上半部，哪些代码属于下半部并没有明确的规定，一切根据实际使用情况去判断，这个就很考验驱动编写人员的功底了。这里有一些可以借鉴的参考点：</p><ul><li>①、如果要处理的内容不希望被其他中断打断，那么可以放到上半部。</li><li>②、如果要处理的任务对时间敏感，可以放到上半部。</li><li>③、如果要处理的任务与硬件有关，可以放到上半部</li><li>④、除了上述三点以外的其他任务，优先考虑放到下半部。</li></ul><p>上半部处理很简单，直接编写中断处理函数就行了，关键是下半部该怎么做呢？Linux 内核提供了多种下半部机制，接下来我们来学习一下这些下半部机制。</p><h4 id="1、软中断"><a href="#1、软中断" class="headerlink" title="1、软中断"></a>1、软中断</h4><p>一开始 Linux 内核提供了“bottom half”机制来实现下半部，简称“BH”。后面引入了软中断和 tasklet 来替代“BH”机制，完全可以使用软中断和 tasklet 来替代 BH，从 2.5 版本的 Linux内核开始 BH 已经被抛弃了。<strong>Linux 内核使用结构体 softirq_action 表示软中断</strong>，softirq_action结构体定义在文件 include&#x2F;linux&#x2F;interrupt.h 中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">433</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span></span><span class="hljs-class">434 &#123;</span><span class="hljs-number">435</span> <span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action *);<span class="hljs-number">436</span> &#125;;</code></pre></div><p>在 kernel&#x2F;softirq.c 文件中一共定义了 10 个软中断，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> <span class="hljs-title">softirq_vec</span>[<span class="hljs-title">NR_SOFTIRQS</span>];</span></code></pre></div><p>NR_SOFTIRQS 是枚举类型，定义在文件 include&#x2F;linux&#x2F;interrupt.h 中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>    HI_SOFTIRQ=<span class="hljs-number">0</span>, <span class="hljs-comment">/* 高优先级软中断 */</span>    TIMER_SOFTIRQ, <span class="hljs-comment">/* 定时器软中断 */</span>    NET_TX_SOFTIRQ, <span class="hljs-comment">/* 网络数据发送软中断 */</span>    NET_RX_SOFTIRQ, <span class="hljs-comment">/* 网络数据接收软中断 */</span>    BLOCK_SOFTIRQ,    BLOCK_IOPOLL_SOFTIRQ,    TASKLET_SOFTIRQ, <span class="hljs-comment">/* tasklet 软中断 */</span>    SCHED_SOFTIRQ, <span class="hljs-comment">/* 调度软中断 */</span>    HRTIMER_SOFTIRQ, <span class="hljs-comment">/* 高精度定时器软中断  */</span>    RCU_SOFTIRQ, <span class="hljs-comment">/* RCU 软中断  */</span>    NR_SOFTIRQS&#125;;</code></pre></div><p>可以看出，一共有 10 个软中断，因此 NR_SOFTIRQS 为 10，因此数组 softirq_vec 有 10 个元素。softirq_action 结构体中的 action 成员变量就是软中断的服务函数，数组 softirq_vec是个全局数组，因此所有的 CPU(对于 SMP 系统而言)都可以访问到，每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。要使用软中断，必须先使用open_softirq 函数注册对应的软中断处理函数，open_softirq 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">open_softirq</span><span class="hljs-params">(<span class="hljs-type">int</span> nr, <span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action *))</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li>nr：要开启的软中断，在示例代码 51.1.2.3 中选择一个。</li><li>action：软中断对应的处理函数。</li><li>返回值：没有返回值。</li></ul><p>注册好软中断以后需要通过 raise_softirq 函数触发，raise_softirq 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">raise_softirq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li>nr：要触发的软中断，在示例代码 51.1.2.3 中选择一个。</li><li>返回值：没有返回值。</li></ul><p>软中断必须在编译的时候静态注册！Linux 内核使用 softirq_init 函数初始化软中断.</p><h4 id="2、tasklet"><a href="#2、tasklet" class="headerlink" title="2、tasklet"></a>2、tasklet</h4><p>tasklet 是利用软中断来实现的另外一种下半部机制，在软中断和 tasklet 之间，建议大家使用 tasklet。Linux 内核使用结构体</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">484</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span></span><span class="hljs-class">485 &#123;</span><span class="hljs-number">486</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">/* 下一个 tasklet */</span><span class="hljs-number">487</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> state; <span class="hljs-comment">/* tasklet 状态 */</span><span class="hljs-number">488</span> <span class="hljs-type">atomic_t</span> count; <span class="hljs-comment">/* 计数器，记录对 tasklet 的引用数 */</span><span class="hljs-number">489</span> <span class="hljs-type">void</span> (*func)(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>); <span class="hljs-comment">/* tasklet  执行的函数 */</span><span class="hljs-number">490</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data; <span class="hljs-comment">/* 函数 func 的参数 */</span><span class="hljs-number">491</span> &#125;;</code></pre></div><p>第 489 行的 func 函数就是 tasklet 要执行的处理函数，用户定义函数内容，相当于中断处理函数。如果要使用 tasklet，必须先定义一个 tasklet，然后使用 tasklet_init 函数初始化tasklet，taskled_init 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tasklet_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tasklet_struct *t,</span><span class="hljs-params">                  <span class="hljs-type">void</span> (*func)(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>),</span><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data)</span>;</code></pre></div><p>函数参数和返回值含义如下：</p><ul><li>t：要初始化的 tasklet</li><li>func：tasklet 的处理函数。</li><li>data ：要传递给 func 函数的参数</li><li>返回值：没有返回值。</li></ul><p>也 可 以 使 用 宏 DECLARE_TASKLET 来 一 次 性 完 成 tasklet 的 定 义 和 初 始 化 ，DECLARE_TASKLET 定义在 include&#x2F;linux&#x2F;interrupt.h 文件中，定义如下:</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">DECLARE_TASKLET(<span class="hljs-params">name</span>, <span class="hljs-params">func</span>, <span class="hljs-params">data</span>)</span></code></pre></div><p>其中 name 为要定义的 tasklet 名字，这个名字就是一个 tasklet_struct 类型的时候变量，func就是 tasklet 的处理函数，data 是传递给 func 函数的参数。</p><p>在上半部，也就是中断处理函数中调用 tasklet_schedule 函数就能使 tasklet 在合适的时间运<br>行，tasklet_schedule 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tasklet_schedule</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tasklet_struct *t)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li>t：要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name。</li><li>返回值：没有返回值。</li></ul><p>关于 tasklet 的参考使用示例如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 定义 taselet */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> <span class="hljs-title">testtasklet</span>;</span><span class="hljs-comment">/* tasklet 处理函数 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">testtasklet_func</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data)</span>&#123;    <span class="hljs-comment">/* tasklet 具体处理内容 */</span>&#125;<span class="hljs-comment">/* 中断处理函数 */</span><span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">test_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>&#123;    ......    <span class="hljs-comment">/* 调度 tasklet */</span>    tasklet_schedule(&amp;testtasklet);    ......&#125;<span class="hljs-comment">/* 驱动入口函数 */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    ......    <span class="hljs-comment">/* 初始化 tasklet */</span>    tasklet_init(&amp;testtasklet, testtasklet_func, data);    <span class="hljs-comment">/* 注册中断处理函数 */</span>    request_irq(xxx_irq, test_handler, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;xxx&quot;</span>, &amp;xxx_dev);    ......&#125;</code></pre></div><h4 id="3、工作队列"><a href="#3、工作队列" class="headerlink" title="3、工作队列"></a>3、工作队列</h4><p>工作队列是另外一种下半部执行方式，工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。因此如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet。</p><p>Linux 内核使用 work_struct 结构体表示一个工作，内容如下(省略掉条件编译)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> &#123;</span>    <span class="hljs-type">atomic_long_t</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span>    <span class="hljs-type">work_func_t</span> func; <span class="hljs-comment">/* 工作队列处理函数 */</span>&#125;;</code></pre></div><p>这些工作组织成工作队列，工作队列使用 workqueue_struct 结构体表示，内容如下(省略掉条件编译)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_struct</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pwqs</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span>    <span class="hljs-type">int</span> work_color;    <span class="hljs-type">int</span> flush_color;    <span class="hljs-type">atomic_t</span> nr_pwqs_to_flush;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wq_flusher</span> *<span class="hljs-title">first_flusher</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">flusher_queue</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">flusher_overflow</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">maydays</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> *<span class="hljs-title">rescuer</span>;</span>    <span class="hljs-type">int</span> nr_drainers;    <span class="hljs-type">int</span> saved_max_active;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_attrs</span> *<span class="hljs-title">unbound_attrs</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> *<span class="hljs-title">dfl_pwq</span>;</span>    <span class="hljs-type">char</span> name[WQ_NAME_LEN];    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags ____cacheline_aligned;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_pwqs</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">numa_pwq_tbl</span>[];</span>&#125;;</code></pre></div><p>Linux 内核使用工作者线程(worker thread)来处理工作队列中的各个工作，Linux 内核使用worker 结构体表示工作者线程，worker 结构体内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">hentry</span>;</span>    &#125;;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> *<span class="hljs-title">current_work</span>;</span>    <span class="hljs-type">work_func_t</span> current_func;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> *<span class="hljs-title">current_pwq</span>;</span>    <span class="hljs-type">bool</span> desc_valid;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">scheduled</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker_pool</span> *<span class="hljs-title">pool</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> last_active;    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;    <span class="hljs-type">int</span> id;    <span class="hljs-type">char</span> desc[WORKER_DESC_LEN];    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_struct</span> *<span class="hljs-title">rescue_wq</span>;</span>&#125;;</code></pre></div><p>从示例代码 可以看出，每个 worker 都有一个工作队列，工作者线程处理自己工作队列中的所有工作。在实际的驱动开发中，我们只需要定义工作(work_struct)即可，关于工作队列和工作者线程我们基本不用去管。简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作，INIT_WORK 宏定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_WORK(_work, _func) </span></code></pre></div><p>_work 表示要初始化的工作，_func 是工作对应的处理函数。</p><p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_WORK(n, f)</span></code></pre></div><p>n 表示定义的工作(work_struct)，f 表示工作对应的处理函数。<br>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work，函数原<br>型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">schedule_work</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span></code></pre></div><p>函数参数和返回值含义如下：</p><ul><li>work ：要调度的工作。</li><li>返回值：0 成功，其他值 失败。</li></ul><p>关于工作队列的参考使用示例如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 定义工作(work) */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">testwork</span>;</span><span class="hljs-comment">/* work 处理函数 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">testwork_func_t</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span>;&#123;    <span class="hljs-comment">/* work 具体处理内容 */</span>&#125;<span class="hljs-comment">/* 中断处理函数 */</span><span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">test_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>&#123;    ......   <span class="hljs-comment">/* 调度 work */</span>    schedule_work(&amp;testwork);    ......&#125;<span class="hljs-comment">/* 驱动入口函数 */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    ......    <span class="hljs-comment">/* 初始化 work */</span>    INIT_WORK(&amp;testwork, <span class="hljs-type">testwork_func_t</span>);    <span class="hljs-comment">/* 注册中断处理函数 */</span>    request_irq(xxx_irq, test_handler, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;xxx&quot;</span>, &amp;xxx_dev);    ......&#125;</code></pre></div><h3 id="3-设备树中断信息节点"><a href="#3-设备树中断信息节点" class="headerlink" title="3|设备树中断信息节点"></a>3|设备树中断信息节点</h3><p>如果使用设备树的话就需要在设备树中设置好中断属性信息，Linux 内核通过读取设备树中的中断属性信息来配置中断。对于中断控制器而言，设备树绑定信息参考文档Documentation&#x2F;devicetree&#x2F;bindings&#x2F;arm&#x2F;gic.txt。打开 imx6ull.dtsi 文件，其中的 <strong>intc 节点就是I.MX6ULL 的中断控制器节点</strong>，节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> intc: interrupt-controller@<span class="hljs-number">00</span>a01000 &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;<span class="hljs-number">3</span> <span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;3&gt;</span>;</span><span class="hljs-number">4</span> interrupt-controller;<span class="hljs-number">5</span> reg = &lt;<span class="hljs-number">0x00a01000</span> <span class="hljs-number">0x1000</span>&gt;,<span class="hljs-number">6</span>   &lt;<span class="hljs-number">0x00a02000</span> <span class="hljs-number">0x100</span>&gt;;<span class="hljs-number">7</span> &#125;;</code></pre></div><ul><li><p><strong>第 2 行</strong>，<strong>compatible</strong> 属性值为“arm,cortex-a7-gic”在 Linux 内核源码中搜索“arm,cortex-a7-gic”即可找到 GIC 中断控制器驱动文件。</p></li><li><p><strong>第 3 行</strong>，**#interrupt-cells** 和#address-cells、#size-cells 一样。表示此中断控制器下设备的 cells大小，对于设备而言，会使用 interrupts 属性描述中断信息，#interrupt-cells 描述了interrupts 属性的 cells 大小，也就是一条信息有几个 cells。每个 cells 都是 32 位整形值，对于 ARM 处理的GIC 来说，一共有 3 个 cells，这三个 cells 的含义如下：</p><ul><li>第一个 cells：中断类型，0 表示 SPI 中断，1 表示 PPI 中断。</li><li>第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 0<del>987，对于 PPI 中断来说中断号的范围为 0</del>15。</li><li>第三个 cells：标志，bit[3:0]表示中断触发类型，为 1 的时候表示上升沿触发，为 2 的时候表示下降沿触发，为 4 的时候表示高电平触发，为 8 的时候表示低电平触发。bit[15:8]为 PPI中<br>断的 CPU 掩码。</li></ul></li><li><p><strong>第 4 行</strong>，<strong>interrupt-controller</strong> 节点为空，表示当前节点是中断控制器。对于 gpio 来说，gpio 节点也可以作为中断控制器，比如 imx6ull.dtsi 文件中的 gpio5 节点内容如下所示：</p></li><li><p>&#96;&#96;&#96;c<br>1 gpio5: gpio@020ac000 {<br>2         compatible &#x3D; “fsl,imx6ul-gpio”, “fsl,imx35-gpio”;<br>3         reg &#x3D; &lt;0x020ac000 0x4000&gt;;<br>4         interrupts &#x3D; &lt;GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH&gt;,<br>5                      &lt;GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH&gt;;<br>6         gpio-controller;<br>7         #gpio-cells &#x3D; &lt;2&gt;;<br>8         interrupt-controller;<br>9         #interrupt-cells &#x3D; &lt;2&gt;;<br>10 };</p><div class="hljs code-wrapper"><pre><code class="hljs tap">- **第<span class="hljs-number"> 4 </span>行**，interrupts 描述中断源信息，对于 gpio5 来说一共有两条信息，中断类型都是 SPI，触发电平都是 IRQ_TYPE_LEVEL_HIGH。不同之处在于中断源，一个是 74，一个是 75，打开可以打开《IMX6ULL 参考手册》的“Chapter<span class="hljs-number"> 3 </span>Interrupts and DMA Events”章节，找到表 3-1，有如图所示的内容：  ![image-20200825171323009](9、Linux中断实验/image-20200825171323009.png)  从图 可以看出，GPIO5 一共用了<span class="hljs-number"> 2 </span>个中断号，一个是 74，一个是 75。其中<span class="hljs-number"> 74 </span>对应GPIO5_IO00~GPIO5_IO15 这低<span class="hljs-number"> 16 </span>个 IO，75 对应 GPIO5_IO16~GPIOI5_IO31 这高 16位 IO。- 第<span class="hljs-number"> 8 </span>行，interrupt-controller 表明了 gpio5 节点也是个中断控制器，用于控制 gpio5 所有IO的中断。- 第<span class="hljs-number"> 9 </span>行，将<span class="hljs-comment">#interrupt-cells 修改为 2。打开 imx6ull-lxg-emmc.dts 文件，找到如下所示内容：</span>  ```c <span class="hljs-number"> 1 </span>fxls8471@1e &#123; <span class="hljs-number"> 2 </span>compatible = &quot;fsl,fxls8471&quot;; <span class="hljs-number"> 3 </span>reg = &lt;0x1e&gt;; <span class="hljs-number"> 4 </span>position = &lt;0&gt;; <span class="hljs-number"> 5 </span>interrupt-parent = &lt;&amp;gpio5&gt;; <span class="hljs-number"> 6 </span>interrupts = &lt;0 8&gt;; <span class="hljs-number"> 7 </span>&#125;;</code></pre></div><p>fxls8471 是 NXP 官方的 6ULL 开发板上的一个磁力计芯片，fxls8471 有一个中断引脚链接到了 I.MX6ULL 的 SNVS_TAMPER0 因脚上，这个引脚可以复用为 GPIO5_IO00。第 5 行，interrupt-parent 属性设置中断控制器，这里使用 gpio5 作为中断控制器。第 6 行，interrupts 设置中断信息，0 表示 GPIO5_IO00，8 表示低电平触发。简单总结一下与中断有关的设备树属性信息：<br>①、#interrupt-cells，指定中断源的信息 cells 个数。<br>②、interrupt-controller，表示当前节点为中断控制器。<br>③、interrupts，指定中断号，触发方式等。<br>④、interrupt-parent，指定父中断，也就是中断控制器。</p></li></ul><h3 id="4-获取中断号-irq-of-parse-and-map"><a href="#4-获取中断号-irq-of-parse-and-map" class="headerlink" title="4|获取中断号 irq_of_parse_and_map"></a>4|获取中断号 irq_of_parse_and_map</h3><p>编写驱动的时候需要用到中断号，我们用到中断号，中断信息已经写到了设备树里面，因此可以通过 <strong>irq_of_parse_and_map</strong>函数从 interupts 属性中提取到对应的设备号，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">irq_of_parse_and_map</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev,</span><span class="hljs-params">                                  <span class="hljs-type">int</span> index)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong> ：设备节点。<br><strong>index</strong>：索引号，interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息。<br><strong>返回值</strong>：中断号。</p><p>如果使用 GPIO 的话，可以使用 <strong>gpio_to_irq</strong> 函数来获取 gpio 对应的中断号，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_to_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gpio)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>gpio</strong> ：要获取的 GPIO 编号。<br><strong>返回值</strong>：GPIO 对应的中断号。</p><h2 id="二、硬件原理分析"><a href="#二、硬件原理分析" class="headerlink" title="二、硬件原理分析"></a>二、硬件原理分析</h2><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200825172109959.png" alt="image-20200825172109959"></p><h2 id="三、实验程序编写"><a href="#三、实验程序编写" class="headerlink" title="三、实验程序编写"></a>三、实验程序编写</h2><p>本章实验我们驱动 I.MX6U-ALPHA 开发板上的 KEY0 按键，不过我们采用中断的方式，并且采用定时器来实现按键消抖，应用程序读取按键值并且通过终端打印出来。通过本章我们可以学习到 Linux 内核中断的使用方法，以及对 Linux 内核定时器的回顾。</p><h3 id="1-修改设备树文件"><a href="#1-修改设备树文件" class="headerlink" title="1|修改设备树文件"></a>1|修改设备树文件</h3><p>本章实验使用到了按键 KEY0，按键 KEY0 使用中断模式，因此需要在“key”节点下添加中断相关属性，添加完成以后的“key”节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> key &#123;<span class="hljs-number">2</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">3</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">4</span> compatible = <span class="hljs-string">&quot;atkalpha-key&quot;</span>;<span class="hljs-number">5</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">6</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_key&gt;;<span class="hljs-number">7</span> key-gpio = &lt;&amp;gpio1 <span class="hljs-number">18</span> GPIO_ACTIVE_LOW&gt;; <span class="hljs-comment">/* KEY0 */</span><span class="hljs-number">8</span> interrupt-parent = &lt;&amp;gpio1&gt;;<span class="hljs-number">9</span> interrupts = &lt;<span class="hljs-number">18</span> IRQ_TYPE_EDGE_BOTH&gt;; <span class="hljs-comment">/* FALLING RISING */</span><span class="hljs-number">10</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">11</span> &#125;;</code></pre></div><p>第 8 行，设置 interrupt-parent 属性值为“gpio1”，因为 KEY0 所使用的 GPIO 为GPIO1_IO18，也就是设置 KEY0 的 GPIO 中断控制器为 gpio1。</p><p>第 9 行，设置 interrupts 属性，也就是设置中断源，第一个 cells 的 18 表示 GPIO1 组的 18号 IO。</p><p>IRQ_TYPE_EDGE_BOTH 定义在文件 include&#x2F;linux&#x2F;irq.h 中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">76</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><span class="hljs-number">77</span> IRQ_TYPE_NONE = <span class="hljs-number">0x00000000</span>,<span class="hljs-number">78</span> IRQ_TYPE_EDGE_RISING = <span class="hljs-number">0x00000001</span>,<span class="hljs-number">79</span> IRQ_TYPE_EDGE_FALLING = <span class="hljs-number">0x00000002</span>,<span class="hljs-number">80</span> IRQ_TYPE_EDGE_BOTH = (IRQ_TYPE_EDGE_FALLING |   IRQ_TYPE_EDGE_RISING),<span class="hljs-number">81</span> IRQ_TYPE_LEVEL_HIGH = <span class="hljs-number">0x00000004</span>,<span class="hljs-number">82</span> IRQ_TYPE_LEVEL_LOW = <span class="hljs-number">0x00000008</span>,<span class="hljs-number">83</span> IRQ_TYPE_LEVEL_MASK = (IRQ_TYPE_LEVEL_LOW |   IRQ_TYPE_LEVEL_HIGH),......<span class="hljs-number">100</span> &#125;;</code></pre></div><p>从示例代码  中可以看出，IRQ_TYPE_EDGE_BOTH 表示上升沿和下降沿同时有效，相当于 KEY0 按下和释放都会触发中断。设备树编写完成以后使用“make dtbs”命令重新编译设备树，然后使用新编译出来的imx6ull-lxg-emmc.dtb 文件启动 Linux 系统。</p><h3 id="2-按键中断驱动程序编写"><a href="#2-按键中断驱动程序编写" class="headerlink" title="2|按键中断驱动程序编写"></a>2|按键中断驱动程序编写</h3><p>新建名为“13_irq”的文件夹，然后在 13_irq 文件夹里面创建 vscode 工程，工作区命名为“imx6uirq”。工程创建好以后新建 imx6uirq.c 文件，在 imx6uirq.c 里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CNT 1<span class="hljs-comment">/* 设备号个数 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_NAME <span class="hljs-string">&quot;imx6u-irq&quot;</span><span class="hljs-comment">/* 设备名 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE 0X01 <span class="hljs-comment">/* KEY0 按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY 0XFF <span class="hljs-comment">/* 无效的按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_CNT 1  <span class="hljs-comment">/* 按键数量 */</span></span><span class="hljs-comment">/* 中断 IO 描述结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> &#123;</span><span class="hljs-type">int</span> gpio; <span class="hljs-comment">/* gpio */</span><span class="hljs-type">int</span> irqnum; <span class="hljs-comment">/* 中断号 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value; <span class="hljs-comment">/* 按键对应的键值  */</span><span class="hljs-type">char</span> name[<span class="hljs-number">10</span>]; <span class="hljs-comment">/* 名字 */</span><span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *); <span class="hljs-comment">/* 中断服务函数 */</span>&#125;;<span class="hljs-comment">/* imx6uirq设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span><span class="hljs-comment">/* 设备树节点 */</span><span class="hljs-type">atomic_t</span> keyvalue; <span class="hljs-comment">/* 有效的按键键值 */</span><span class="hljs-type">atomic_t</span> releasekey; <span class="hljs-comment">/* 标记是否完成一次完成的按键*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> <span class="hljs-comment">/* 定义一个定时器*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> <span class="hljs-title">irqkeydesc</span>[<span class="hljs-title">KEY_CNT</span>];</span> <span class="hljs-comment">/* 按键描述数组 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> curkeynum; <span class="hljs-comment">/* 当前的按键号 */</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> <span class="hljs-title">imx6uirq</span>;</span><span class="hljs-comment">/* @description : 中断服务函数，开启定时器，延时 10ms，</span><span class="hljs-comment"> * 定时器用于按键消抖。</span><span class="hljs-comment"> * @param - irq : 中断号</span><span class="hljs-comment"> * @param - dev_id : 设备结构。</span><span class="hljs-comment"> * @return : 中断执行结果</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">key0_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)dev_id;dev-&gt;curkeynum = <span class="hljs-number">0</span>;dev-&gt;timer.data = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span>)dev_id;mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="hljs-number">10</span>));<span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);&#125;<span class="hljs-comment">/* @description : 定时器服务函数，用于按键消抖，定时器到了以后</span><span class="hljs-comment"> * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><span class="hljs-comment"> * @param – arg  : 设备结构变量</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">timer_function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_keydesc</span> *<span class="hljs-title">keydesc</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)arg;num = dev-&gt;curkeynum;keydesc = &amp;dev-&gt;irqkeydesc[num];value = gpio_get_value(keydesc-&gt;gpio); <span class="hljs-comment">/* 读取 IO 值 */</span><span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">/* 按下按键 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">/* 按键松开 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="hljs-number">0x80</span> | keydesc-&gt;value);<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 标记松开按键 */</span>&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : 按键 IO 初始化</span><span class="hljs-comment"> * @param : 无</span><span class="hljs-comment"> * @return : 无</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;imx6uirq.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);<span class="hljs-keyword">if</span> (imx6uirq.nd == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;k:key node not find!\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-comment">/* 提取 GPIO */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd,<span class="hljs-string">&quot;key-gpios&quot;</span>, i);<span class="hljs-keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:can&#x27;t get key%d\r\n&quot;</span>, i);&#125;&#125;<span class="hljs-comment">/* 初始化 key 所使用的 IO，并且设置成中断模式 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;<span class="hljs-built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-number">0</span>,   <span class="hljs-keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));<span class="hljs-built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="hljs-string">&quot;KEY%d&quot;</span>, i);gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(imx6uirq.nd, i);<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(imx6uirq.irqkeydesc[i].gpio);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>printk(<span class="hljs-string">&quot;k:key%d:gpio=%d, irqnum=%d\r\n&quot;</span>, i,   imx6uirq.irqkeydesc[i].gpio,   imx6uirq.irqkeydesc[i].irqnum);&#125;<span class="hljs-comment">/* 申请中断 */</span>imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].handler = key0_handler;imx6uirq.irqkeydesc[<span class="hljs-number">0</span>].value = KEY0VALUE;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;ret = request_irq(imx6uirq.irqkeydesc[i].irqnum,  imx6uirq.irqkeydesc[i].handler,  IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,  imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:irq %d request failed!\r\n&quot;</span>,   imx6uirq.irqkeydesc[i].irqnum);<span class="hljs-keyword">return</span> -EFAULT;&#125;&#125;<span class="hljs-comment">/* 创建定时器 */</span>init_timer(&amp;imx6uirq.timer);imx6uirq.timer.function = timer_function;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6uirq_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;imx6uirq; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : 从设备读取数据</span><span class="hljs-comment"> * @param – filp : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @param – buf : 返回给用户空间的数据缓冲区</span><span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span><span class="hljs-comment"> * @param – offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">imx6uirq_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf,</span><span class="hljs-params"> <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> keyvalue = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> releasekey = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx6uirq_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> imx6uirq_dev *)   filp-&gt;private_data;keyvalue = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;keyvalue);releasekey = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;releasekey);<span class="hljs-keyword">if</span> (releasekey)&#123; <span class="hljs-comment">/* 有按键按下 */</span><span class="hljs-keyword">if</span> (keyvalue &amp; <span class="hljs-number">0x80</span>)&#123;keyvalue &amp;= ~<span class="hljs-number">0x80</span>;ret = copy_to_user(buf, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">goto</span> data_error;&#125;<span class="hljs-type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 按下标志清零 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">goto</span> data_error;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;data_error:<span class="hljs-keyword">return</span> -EINVAL;&#125;<span class="hljs-comment">/* 设备操作函数 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">imx6uirq_fops</span> =</span> &#123;.owner = THIS_MODULE,.open = imx6uirq_open,.read = imx6uirq_read,&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">imx6uirq_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 注册设备号 */</span>imx6uirq.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(imx6uirq.major)&#123;imx6uirq.devid = MKDEV(imx6uirq.major, imx6uirq.minor);ret = register_chrdev_region(imx6uirq.devid, DEV_CNT, DEV_NAME);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;imx6uirq.devid, <span class="hljs-number">0</span>, DEV_CNT, DEV_NAME);&#125;imx6uirq.major = MAJOR(imx6uirq.devid);imx6uirq.minor = MINOR(imx6uirq.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;k:imx6uirq  MAJOR:%d  MINOR:%d\r\n&quot;</span>, imx6uirq.major, imx6uirq.minor);<span class="hljs-comment">/* 添加字符设备 */</span>imx6uirq.cdev.owner = imx6uirq_fops.owner;cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);ret = cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, DEV_CNT);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;k:register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>imx6uirq.class = class_create(THIS_MODULE, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.class))&#123;printk(<span class="hljs-string">&quot;k:fail to create class!\r\n&quot;</span>);result = PTR_ERR(imx6uirq.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>imx6uirq.device = device_create(imx6uirq.class, <span class="hljs-literal">NULL</span>, imx6uirq.devid, <span class="hljs-literal">NULL</span>, DEV_NAME);<span class="hljs-keyword">if</span>(IS_ERR(imx6uirq.device))&#123;printk(<span class="hljs-string">&quot;k:fail to create device!\r\n&quot;</span>);result = PTR_ERR(imx6uirq.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 5、初始化按键 */</span><span class="hljs-type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);<span class="hljs-type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="hljs-number">0</span>);keyio_init();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(imx6uirq.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;imx6uirq.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(imx6uirq.devid, DEV_CNT);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">imx6uirq_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 删除定时器 */</span>del_timer_sync(&amp;imx6uirq.timer);<span class="hljs-comment">/* 释放中断 */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEY_CNT; i++)&#123;free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);&#125;<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(imx6uirq.class, imx6uirq.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(imx6uirq.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;imx6uirq.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(imx6uirq.devid, DEV_CNT);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(imx6uirq_init);module_exit(imx6uirq_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><ul><li><p>结构体 irq_keydesc 为<strong>按键的中断描述结构体</strong>，gpio 为按键 GPIO 编号，irqnum为按键 IO 对应的中断号，value 为按键对应的键值，name 为按键名字，handler 为按键中断服务函数。使用 irq_keydesc 结构体即可描述一个按键中断。</p></li><li><p>结构体 imx6uirq_dev 为本例程<strong>设备结构体</strong>， keyvalue 保存按键值， releasekey 表示按键是否被释放，如果按键被释放表示发生了一次完整的按键过程。timer 为按键消抖定时器。数组 irqkeydesc 为按键信息数组，数组元素个数就是开发板上的按键个数，I.MX6U-ALIPHA 开发板上只有一个按键，因此 irqkeydesc 数组只有一个元素。curkeynum 表示当前按键。</p></li><li><p>key0_handler 函数，<strong>按键 KEY0 中断处理函数</strong>，参数 dev_id 为设备结构体，也就是 imx6uirq。 curkeynum&#x3D;0，表示当前按键为 KEY0，使用mod_timer函数启动定时器，定时器周期为 10ms。</p></li><li><p>timer_function 函数，<strong>定时器定时处理函数</strong>，参数 arg 是设备结构体，也就是imx6uirq，在此函数中读取按键值。通过 gpio_get_value 函数读取按键值。如果为 0 的话就表示按键被按下去了，按下去的话就设置 imx6uirq 结构体的 keyvalue 成员变量为按键的键值，比如 KEY0 按键的话按键值就是 KEY0VALUE&#x3D;0。如果按键值为 1 的话表示按键被释放了，按键释放了的话就将 imx6uirq 结构体的 keyvalue 成员变量的最高位置 1，表示按键值有效，也就是将keyvalue 与 0x80 进行或运算，表示按键松开了，并且设置 imx6uirq 结构体的 releasekey成员变量为 1，表示按键释放，一次有效的按键过程发生。</p></li><li><p><strong>keyio_init 函数，按键 IO 初始化函数</strong>，在驱动入口函数里面会调用 keyio_init 来初始化按键 IO。轮流初始化所有的按键，包括申请 IO、设置 IO 为输入模式、从设备树中获取 IO 的中断号等等。通过 irq_of_parse_and_map 函数从设备树中获取按键 IO 对应的中断号。也可以使用 gpio_to_irq 函数将某个 IO 设置为中断状态，并且返回其中断号。然后设置 KEY0 按键对应的按键中断处理函数为 key0_handler、KEY0 的按键值为 KEY0VALUE。轮流调用request_irq 函数申请中断号，设置中断触发模式为IRQF_TRIGGER_FALLING 和 IRQF_TRIGGER_RISING，也就是上升沿和下降沿都可以触发中断。最后，初始化定时器，并且设置定时器的定时处理函数。</p></li><li><p><strong>imx6uirq_read 函数，对应应用程序的 read 函数</strong>。此函数向应用程序返回按键值。首先判断 imx6uirq 结构体的 releasekey 成员变量值是否为 1，如果为 1 的话表示有一次有效按键发生，否则的话就直接返回-EINVAL。当有按键事件发生的话就要向应用程序发送按键值，首先判断按键值的最高位是否为 1，如果为 1 的话就表示按键值有效。如果按键值有效的话就将最高位清除，得到真实的按键值，然后通过 copy_to_user 函数返回给应用程序。向应用程序发送按键值完成以后就将 imx6uirq 结构体的 releasekey 成员变量清零，准备下一次按键操作。</p></li><li><p>驱动入口函数，分别初始化 imx6uirq 结构体中的原子变量keyvalue 和 releasekey，调用 keyio_init 函数初始化按键所使用的 IO。</p></li><li><p>驱动出口函数，调用 del_timer_sync 函数删除定时器，轮流释放申请的所有按键中断。</p></li></ul><h3 id="3-编写测试APP"><a href="#3-编写测试APP" class="headerlink" title="3|编写测试APP"></a>3|编写测试APP</h3><p>测试 APP 要实现的内容很简单，通过不断的读取&#x2F;dev&#x2F;imx6uirq 文件来获取按键值，当按键按下以后就会将获取到的按键值输出在终端上，新建名为 imx6uirqApp.c 的文件，然后输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/ioctl.h&quot;</span></span><span class="hljs-comment">/*</span><span class="hljs-comment">* @description : main 主程序</span><span class="hljs-comment">* @param - argc : argv 数组元素个数</span><span class="hljs-comment">* @param - argv : 具体参数</span><span class="hljs-comment">* @return : 0 成功;其他 失败</span><span class="hljs-comment">*/</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, fd = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> *filename;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data;        <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    filename = argv[<span class="hljs-number">1</span>];    <span class="hljs-comment">/* 打开 key 驱动 */</span>    fd =  open(filename, O_RDWR);    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        ret = read(fd, &amp;data, <span class="hljs-keyword">sizeof</span>(data));        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)        &#123; <span class="hljs-comment">/* 数据读取错误或者无效 */</span>        &#125;        <span class="hljs-keyword">else</span>        &#123;             <span class="hljs-comment">/* 数据读取正确 */</span>            <span class="hljs-keyword">if</span> (data) <span class="hljs-comment">/* 读取到数据 */</span>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key value = %#X\r\n&quot;</span>, data);        &#125;    &#125;    close(fd);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p> while 循环用于不断的读取按键值，如果读取到有效的按键值就将其输出到终端上。</p><h2 id="四、运行测试"><a href="#四、运行测试" class="headerlink" title="四、运行测试"></a>四、运行测试</h2><p>编译运行。</p><p>驱动加载成功以后可以通过查看&#x2F;proc&#x2F;interrupts 文件来检查一下对应的中断有没有被注册上，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /proc/interrupts</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200826110945181.png" alt="image-20200826110945181"></p><p>按下按键 如图：</p><p><img src="/2020/09/12/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/9%E3%80%81Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/image-20200826111221680.png" alt="image-20200826111221680"></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5| pinctrl 和 gpio 子系统实验</title>
    <link href="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="pinctrl-和-gpio-子系统实验"><a href="#pinctrl-和-gpio-子系统实验" class="headerlink" title="pinctrl 和 gpio 子系统实验"></a>pinctrl 和 gpio 子系统实验</h1><p>上次我们编写了基于设备树的 LED 驱动，但是驱动的本质还是没变，都是配置 LED 灯所使用的 GPIO 寄存器，驱动开发方式和裸机基本没啥区别。</p><p>Linux 是一个庞大而完善的系统，尤其是驱动框架，像 GPIO 这种最基本的驱动不可能采用“原始”的裸机驱动开发方式，否则就相当于你买了一辆车，结果每天推着车去上班。Linux 内核提供了 pinctrl 和 gpio 子系统用于GPIO 驱动，本章我们就来学习一下如何<strong>借助 pinctrl 和 gpio 子系统来简化 GPIO 驱动开发。</strong></p><h2 id="一、pinctrl-子系统"><a href="#一、pinctrl-子系统" class="headerlink" title="一、pinctrl 子系统"></a>一、pinctrl 子系统</h2><h3 id="1-pinctrl-子系统简介"><a href="#1-pinctrl-子系统简介" class="headerlink" title="1| pinctrl  子系统简介"></a>1| pinctrl  子系统简介</h3><p>Linux驱动讲究<strong>驱动分离与分层</strong>，pinctrl和gpio子系统就是驱动分离与分层思想下的产物，驱动分离与分层其实就是按照面向对象编程的设计思想而设计的设备驱动框架，关于驱动的分离与分层我们后面会讲。</p><p>本来 pinctrl 和 gpio 子系统应该放到驱动分离与分层章节后面讲解，但是不管什么外设驱动，GPIO 驱动基本都是必须的，而 pinctrl 和 gpio 子系统又是 GPIO 驱动必须使用的，所以就将 pintrcl 和 gpio 子系统这一章节提前了。</p><hr><p>我们先来回顾一下上一章是怎么初始化 LED 灯所使用的 GPIO，步骤如下：<br>①、修改设备树，添加相应的节点，节点里面重点是设置 reg 属性，reg 属性包括了 GPIO相关寄存器。</p><p>② 、 获 取 reg 属 性 中 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 和(IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03 这两个寄存器地址，并且初始化这两个寄存器，这两个寄存器用于设置 GPIO1_IO03 这个 PIN 的复用功能、上下拉、速度等。</p><p>③、在②里面将 GPIO1_IO03 这个 PIN 复用为了 GPIO 功能，因此需要设置 GPIO1_IO03这个 GPIO 相关的寄存器，也就是 GPIO1_DR 和 GPIO1_GDIR 这两个寄存器。</p><p>总结一下，②中完成对 GPIO1_IO03 这个 PIN 的初始化，设置这个 PIN 的复用功能、上下<br>拉等，比如将 GPIO_IO03 这个 PIN 设置为 GPIO 功能。③中完成对 GPIO 的初始化，设置 GPIO为输入&#x2F;输出等。如果使用过 STM32 的话应该都记得，STM32 也是要先设置某个 PIN 的复用功能、速度、上下拉等，然后再设置 PIN 所对应的 GPIO。其实对于大多数的 32 位 SOC 而言，引脚的设置基本都是这两方面，因此 Linux 内核针对 PIN 的配置推出了 pinctrl 子系统，对于 GPIO的配置推出了 gpio 子系统。本节我们来学习 pinctrl 子系统，下一节再学习 gpio 子系统。</p><p>大多数 SOC 的 pin 都是支持复用的，比如 I.MX6ULL 的 GPIO1_IO03 既可以作为普通的GPIO 使用，也可以作为 I2C1 的 SDA 等等。此外我们还需要配置 pin 的电气特性，比如上&#x2F;下拉、速度、驱动能力等等。**传统的配置 pin 的方式就是直接操作相应的寄存器，但是这种配置方式比较繁琐、而且容易出问题(比如 pin 功能冲突)**。pinctrl 子系统就是为了解决这个问题而引入的，pinctrl 子系统主要工作内容如下：</p><p>①、获取设备树中 pin 信息。<br>②、根据获取到的 pin 信息来设置 pin 的复用功能<br>③、根据获取到的 pin 信息来设置 pin 的电气特性，比如上&#x2F;下拉、速度、驱动能力等。</p><p>对于我们使用者来讲，只需要在设备树里面设置好某个 pin 的相关属性即可，其他的初始化工作均由 pinctrl 子系统来完成，pinctrl 子系统源码目录为 drivers&#x2F;pinctrl。</p><h3 id="2-I-MX6ULL-的-的-pinctrl-子系统驱动"><a href="#2-I-MX6ULL-的-的-pinctrl-子系统驱动" class="headerlink" title="2|I.MX6ULL 的 的 pinctrl  子系统驱动"></a>2|I.MX6ULL 的 的 pinctrl  子系统驱动</h3><h4 id="PIN-配置信息详解"><a href="#PIN-配置信息详解" class="headerlink" title="PIN 配置信息详解"></a>PIN 配置信息详解</h4><p>要使用 pinctrl 子系统，我们需要在设备树里面设置 PIN 的配置信息，毕竟 pinctrl 子系统要根据你提供的信息来配置 PIN 功能，一般会在设备树里面创建一个节点来描述 PIN 的配置信息。打开 imx6ull.dtsi 文件，找到一个叫做 iomuxc 的节点，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">iomuxc: iomuxc@<span class="hljs-number">020e0000</span> &#123;    compatible = <span class="hljs-string">&quot;fsl,imx6ul-iomuxc&quot;</span>;    reg = &lt;<span class="hljs-number">0x020e0000</span> <span class="hljs-number">0x4000</span>&gt;;&#125;;</code></pre></div><p>iomuxc 节点就是 I.MX6ULL 的 IOMUXC 外设对应的节点，看起来内容很少，没看出什么跟 PIN 的配置有关的内容啊，别急！打开 imx6ull-lxg-emmc.dts，找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c">&amp;iomuxc &#123;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;imx6ul-evk &#123;pinctrl_hog_1: hoggrp<span class="hljs-number">-1</span> &#123;fsl,pins = &lt;MX6UL_PAD_UART1_RTS_B__GPIO1_IO19<span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 CD */</span>MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT<span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 VSELECT */</span>MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        <span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 RESET */</span>&gt;;&#125;;............pinctrl_i2c1: i2c1grp &#123;fsl,pins = &lt;MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="hljs-number">0x4001b8b0</span>MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="hljs-number">0x4001b8b0</span>&gt;;&#125;;......pinctrl_usdhc1: usdhc1grp &#123;fsl,pins = &lt;MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="hljs-number">0x17059</span>MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="hljs-number">0x10071</span>MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="hljs-number">0x17059</span>MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="hljs-number">0x17059</span>MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="hljs-number">0x17059</span>MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="hljs-number">0x17059</span>&gt;;&#125;;.....pinctrl_wdog: wdoggrp &#123;fsl,pins = &lt;MX6UL_PAD_LCD_RESET__WDOG1_WDOG_ANY    <span class="hljs-number">0x30b0</span>&gt;;&#125;;&#125;;&#125;;</code></pre></div><p>示例代码就是向 iomuxc 节点追加数据，不同的外设使用的 PIN 不同、其配置也不同，因此一个萝卜一个坑，将某个外设所使用的所有 PIN 都组织在一个子节点里面。</p><p>示例代码中 pinctrl_i2c1子节点就是和i2c1有关的 PIN 集合。pinctrl_usdhc1子节点是 usdhc1这个外设所使用的 PIN，pinctrl_wdog 子节点是 wdog 外设所使用的 PIN。如果需要在 iomuxc 中添加我们自定义外设的 PIN，那么需要新建一个子节点，然后将这个自定义外设的所有 PIN 配置信息都放到这个子节点中。</p><p>将前面两个实例代码结合起来就可以得到完成的 iomuxc 节点，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> iomuxc: iomuxc@<span class="hljs-number">020e0000</span> &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-iomuxc&quot;</span>;<span class="hljs-number">3</span> reg = &lt;<span class="hljs-number">0x020e0000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">4</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">5</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;<span class="hljs-number">6</span> imx6ul-evk &#123;<span class="hljs-number">7</span> pinctrl_hog_1: hoggrp<span class="hljs-number">-1</span> &#123;<span class="hljs-number">8</span> fsl,pins = &lt;<span class="hljs-number">9</span> MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 <span class="hljs-number">0x17059</span><span class="hljs-number">10</span> MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT <span class="hljs-number">0x17059</span><span class="hljs-number">11</span> MX6UL_PAD_GPIO1_IO09__GPIO1_IO09 <span class="hljs-number">0x17059</span><span class="hljs-number">12</span> MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID <span class="hljs-number">0x13058</span><span class="hljs-number">13</span> &gt;;......<span class="hljs-number">16</span> &#125;;<span class="hljs-number">17</span> &#125;;<span class="hljs-number">18</span> &#125;;</code></pre></div><p>第 2 行，compatible 属性值为“fsl,imx6ul-iomuxc”，前面讲解设备树的时候说过，Linux 内核会根据 compatbile 属性值来查找对应的驱动文件，所以我们在 Linux 内核源码中全局搜索字符串“fsl,imx6ul-iomuxc”就会找到 I.MX6ULL 这颗 SOC 的 pinctrl 驱动文件。稍后我们会讲解这个 pinctrl 驱动文件。</p><p>第 9~12行，pinctrl_hog_1子节点所使用的PIN 配置信息，我们就以第 9行UART1_RTS_B<br>这个 PIN 为例，讲解一下如何添加 PIN 的配置信息，UART1_RTS_B 的配置信息如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 <span class="hljs-number">0x17059</span></code></pre></div><p>首先说明一下，UART1_RTS_B 这个 PIN 是作为 SD 卡的检测引脚，也就是通过此 PIN 就可 以 检 测 到 SD 卡 是 否 有 插 入 。 </p><p>UART1_RTS_B 的 配 置 信 息 分 为 两 部 分 ：<strong>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19</strong> 和 **0x17059 **我们重点来看一下这两部分是什么含义，前面说了，对于一个 PIN的配置主要包括两方面，一个是设置这个 PIN 的复用功能，另一个就是设置这个 PIN 的电气特性。所以我们可以大胆的猜测 UART1_RTS_B 的这两部分配置信息一个是设置 UART1_RTS_B 的复用功能，一个是用来设置 UART1_RTS_B 的电气特性。</p><p>首先来看一下 <strong>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19</strong>，这是一个宏定义，定义在文件<br>arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ul-pinfunc.h 中，imx6ull.dtsi 会引用 imx6ull-pinfunc.h 这个头文件，而imx6ull-pinfunc.h 又会引用 imx6ul-pinfunc.h 这个头文件（绕啊绕！）。从这里可以看出，可以在设备树中引用 C 语言中.h 文件中的内容。</p><p>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 的宏定义内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">190</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__UART1_DCE_RTS 0x0090 0x031C 0x0620 0x0 0x3</span><span class="hljs-number">191</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__UART1_DTE_CTS 0x0090 0x031C 0x0000 0x0 0x0</span><span class="hljs-number">192</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__ENET1_TX_ER 0x0090 0x031C 0x0000 0x1 0x0</span><span class="hljs-number">193</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__USDHC1_CD_B 0x0090 0x031C 0x0668 0x2 0x1</span><span class="hljs-number">194</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__CSI_DATA05 0x0090 0x031C 0x04CC 0x3 0x1</span><span class="hljs-number">195</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__ENET2_1588_EVENT1_OUT 0x0090 0x031C 0x0000 0x4 0x0</span>    <span class="hljs-comment">/*MX6UL_PAD_UART1_RTS_B__GPIO1_IO19*/</span><span class="hljs-number">196</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 0x0090 0x031C 0x0000 0x5 0x0</span>    <span class="hljs-number">197</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_UART1_RTS_B__USDHC2_CD_B 0x0090 0x031C 0x0674 0x8 0x2</span></code></pre></div><p>示例代码 中一共有 8 个以“MX6UL_PAD_UART1_RTS_B”开头的宏定义，大家仔细观察应该就能发现，这 8 个宏定义分别对应 UART1_RTS_B 这个 PIN 的 8 个复用 IO。查阅《I.MX6ULL 参考手册》可以知 UART1_RTS_B 的可选复用 IO 如图 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821224427783.png" alt="image-20200821224427783"></p><p>示 例 代 码 196 行 的 宏 定 义 MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 表 示 将UART1_RTS_B 这个 IO 复用为 GPIO1_IO19。此宏定义后面跟着 5 个数字，也就是这个宏定义的具体值，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">0x0090</span> <span class="hljs-number">0x031C</span> <span class="hljs-number">0x0000</span> <span class="hljs-number">0x5</span> <span class="hljs-number">0x0</span></code></pre></div><p>这 5 个值的含义如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-section">&lt;mux_reg conf_reg input_reg mux_mode input_val&gt;</span></code></pre></div><p>综上所述可知：<br><strong>0x0090</strong> ：mux_reg 寄存器偏移地址，设备树中的 iomuxc 节点就是 IOMUXC 外设对应的节点 ， 根 据 其 reg 属 性 可 知 <strong>IOMUXC 外 设 寄 存 器 起 始 地 址 为 0x020e0000</strong> 。 因 此<strong>0x020e0000+0x0090&#x3D;0x020e0090</strong>，<strong>IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B 寄存器地址正 好 是 0x020e0090</strong> ， 大 家 可 以 在 《 IMX6ULL 参 考 手 册 》 中 找 到IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B 这个寄存器的位域图，如图 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821224659447.png" alt="image-20200821224659447"></p><p>因此可知，0x020e0000+mux_reg 就是 PIN 的复用寄存器地址。</p><ul><li><p><strong>0x031C：conf_reg</strong> 寄存器偏移地址，和 mux_reg 一样，<strong>0x020e0000+0x031c&#x3D;0x020e031c</strong>，这个就是<strong>寄存器IOMUXC_SW_PAD_CTL_PAD_UART1_RTS_B</strong> 的地址。</p></li><li><p><strong>0x0000</strong> ：<strong>input_reg</strong> 寄存器偏移地址，有些外设有 input_reg 寄存器，有 input_reg 寄存器的外设需要配置 input_reg 寄存器。没有的话就不需要设置，UART1_RTS_B 这个 PIN 在做GPIO1_IO19 的时候是没有 input_reg 寄存器，因此这里 intput_reg 是无效的。</p></li><li><p><strong>0x5</strong> ： <strong>mux_reg</strong> 寄存器值 ， 在这里就相当于设置<br>IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B 寄存器为 0x5，也即是设置 UART1_RTS_B 这个 PIN 复用为 GPIO1_IO19。</p></li><li><p><strong>0x0</strong>：<strong>input_val</strong> 寄存器值，在这里无效。</p></li></ul><p>这就是宏 MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 的含义，看的比较仔细的同学应该会发现并没有 conf_reg 寄存器的值，config_reg 寄存器是设置一个 PIN 的电气特性的，这么重要的寄存器怎么没有值呢？回到示例代码中，第 9 行的内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 <span class="hljs-number">0x17059</span></code></pre></div><p>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 我们上面已经分析了，就剩下了一个 0x17059，反应快的同学应该已经猜出来了，0x17059 就是 conf_reg 寄存器值！此值由用户自行设置，通过此值来设置一个 IO 的上&#x2F;下拉、驱动能力和速度等。在这里就相当于设置寄存器IOMUXC_SW_PAD_CTL_PAD_UART1_RTS_B 的值为 0x17059。</p><hr><h4 id="PIN-驱动程序讲解"><a href="#PIN-驱动程序讲解" class="headerlink" title="PIN 驱动程序讲解"></a>PIN 驱动程序讲解</h4><p>本节会涉及到 Linux 驱动分层与分离、平台设备驱动等还未讲解的知识，所以本小节教程可以不用看，不会影响后续的实验。如果对 Linux 内核的 pinctrl 子系统实现原理感兴趣的话可以看本小节。</p><p>所有的东西都已经准备好了，包括寄存器地址和寄存器值，Linux 内核相应的驱动文件就会根据这些值来做相应的初始化。接下来就找一下哪个驱动文件来做这一件事情，iomuxc 节点中 compatible 属性的值为“fsl,imx6ul-iomuxc”，在 Linux 内核中全局搜索“fsl,imx6ul-iomuxc”字符串就会找到对应的驱动文件。在文件drivers&#x2F;pinctrl&#x2F;freescale&#x2F;pinctrl-imx6ul.c中有如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">326</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">imx6ul_pinctrl_of_match</span>[] =</span> &#123;<span class="hljs-number">327</span> &#123; .compatible = <span class="hljs-string">&quot;fsl,imx6ul-iomuxc&quot;</span>, .data =&amp;imx6ul_pinctrl_info, &#125;,<span class="hljs-number">328</span> &#123; .compatible = <span class="hljs-string">&quot;fsl,imx6ull-iomuxc-snvs&quot;</span>, .data =&amp;imx6ull_snvs_pinctrl_info, &#125;,<span class="hljs-number">329</span> &#123; <span class="hljs-comment">/* sentinel */</span> &#125;<span class="hljs-number">330</span> &#125;;<span class="hljs-number">331</span><span class="hljs-number">332</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">imx6ul_pinctrl_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span>333 &#123;<span class="hljs-number">334</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">match</span>;</span><span class="hljs-number">335</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imx_pinctrl_soc_info</span> *<span class="hljs-title">pinctrl_info</span>;</span><span class="hljs-number">336</span><span class="hljs-number">337</span> match = of_match_device(imx6ul_pinctrl_of_match, &amp;pdev-&gt;dev);<span class="hljs-number">338</span><span class="hljs-number">339</span> <span class="hljs-keyword">if</span> (!match)<span class="hljs-number">340</span> <span class="hljs-keyword">return</span> -ENODEV;<span class="hljs-number">341</span><span class="hljs-number">342</span> pinctrl_info = (<span class="hljs-keyword">struct</span> imx_pinctrl_soc_info *) match-&gt;data;<span class="hljs-number">343</span><span class="hljs-number">344</span> <span class="hljs-keyword">return</span> imx_pinctrl_probe(pdev, pinctrl_info);<span class="hljs-number">345</span> &#125;<span class="hljs-number">346</span><span class="hljs-number">347</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">imx6ul_pinctrl_driver</span> =</span> &#123;<span class="hljs-number">348</span> .driver = &#123;<span class="hljs-number">349</span> .name = <span class="hljs-string">&quot;imx6ul-pinctrl&quot;</span>,<span class="hljs-number">350</span> .owner = THIS_MODULE,<span class="hljs-number">351</span> .of_match_table = of_match_ptr(imx6ul_pinctrl_of_match),<span class="hljs-number">352</span> &#125;,<span class="hljs-number">353</span> .probe = imx6ul_pinctrl_probe,<span class="hljs-number">354</span> .remove = imx_pinctrl_remove,<span class="hljs-number">355</span> &#125;;</code></pre></div><p><strong>第326~330行</strong>，of_device_id结构体数组，前面讲解设备树的时候说过了，of_device_id里面保存着这个驱动文件的兼容性值，设备树中的 compatible 属性值会和 of_device_id 中的所有兼容性字符串比较，查看是否可以使用此驱动。imx6ul_pinctrl_of_match 结构体数组一共有两个兼容性字符串，分别为“fsl,imx6ul-iomuxc”和“fsl,imx6ull-iomuxc-snvs”，因此iomuxc 节点与此驱动匹配，所以 pinctrl-imx6ul.c 会完成 I.MX6ULL 的 PIN 配置工作。</p><p><strong>第 347~355 行</strong>，platform_driver 是平台设备驱动，这个是我们后面章节要讲解的内容，platform_driver 是个结构体，有个 probe 成员变量。在这里大家只需要知道，当设备和驱动匹配成功以后 platform_driver 的 probe 成员变量所代表的函数就会执行，在 353 行设置probe 成员变量为 imx6ul_pinctrl_probe 函数，因此在本章实验中 imx6ul_pinctrl_probe这个函数就会执行，可以认为 imx6ul_pinctrl_probe 函数就是 I.MX6ULL 这个 SOC的 PIN 配置入口函数。以此为入口，如图 所示的函数调用路径：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821230014797.png" alt="image-20200821230014797"></p><p>在图  中函数 imx_pinctrl_parse_groups 负责获取设备树中关于 PIN 的配置信息，也就是我们前面分析的那 6 个 u32 类型的值。</p><p><strong>后续具体参考正点原子IMX6U驱动开发指南45.1.2.2节</strong></p><h3 id="3-设备树中添加-pinctrl-节点模板"><a href="#3-设备树中添加-pinctrl-节点模板" class="headerlink" title="3|  设备树中添加 pinctrl  节点模板"></a>3|  设备树中添加 pinctrl  节点模板</h3><p>我们已经对 pinctrl 有了比较深入的了解，接下来我们学习一下如何在设备树中添加某个外设 的 PIN 信 息 。 关 于 I.MX 系 列 SOC 的 pinctrl 设 备 树 绑 定 信 息 可 以 参 考 文 档Documentation&#x2F;devicetree&#x2F;bindings&#x2F;pinctrl&#x2F;fsl,imx-pinctrl.txt。</p><p>这里我们虚拟一个名为“test”的设备，test 使用了 GPIO1_IO00 这个 PIN 的 GPIO 功能，pinctrl 节点添加过程如下：</p><h4 id="1-、创建对应的节点"><a href="#1-、创建对应的节点" class="headerlink" title="1 、创建对应的节点"></a>1 、创建对应的节点</h4><p>同一个外设的 PIN 都放到一个节点里面，打开 imx6ull-lxg-emmc.dts，在 iomuxc 节点中的“imx6ul-evk”子节点下添加“pinctrl_test”节点，注意！节点前缀一定要为“pinctrl_”。添加完成以后如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_test: testgrp &#123;<span class="hljs-number">2</span> <span class="hljs-comment">/* 具体的 PIN 信息 */</span><span class="hljs-number">3</span> &#125;;</code></pre></div><h4 id="2-、添加“-fsl-pins-”属性"><a href="#2-、添加“-fsl-pins-”属性" class="headerlink" title="2 、添加“ fsl ,pins ”属性"></a>2 、添加“ fsl ,pins ”属性</h4><p>设备树是通过属性来保存信息的，因此我们需要添加一个属性，属性名字一定要为<strong>“fsl,pins”</strong>，因为对于 I.MX 系列 SOC 而言，pinctrl 驱动程序是通过读取“fsl,pins”属性值来获取 PIN 的配置信息，完成以后如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_test: testgrp &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> <span class="hljs-comment">/* 设备所使用的 PIN 配置信息 */</span><span class="hljs-number">4</span> &gt;;<span class="hljs-number">5</span> &#125;;</code></pre></div><h4 id="3-、在“fsl-pins-”属性中添加-PIN-配置信息"><a href="#3-、在“fsl-pins-”属性中添加-PIN-配置信息" class="headerlink" title="3 、在“fsl,pins ”属性中添加 PIN  配置信息"></a>3 、在“fsl,pins ”属性中添加 PIN  配置信息</h4><p>最后在“fsl,pins”属性中添加具体的 PIN 配置信息，完成以后如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_test: testgrp &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6UL_PAD_GPIO1_IO00__GPIO1_IO00 config <span class="hljs-comment">/*config 是具体设置值*/</span><span class="hljs-number">4</span> &gt;;<span class="hljs-number">5</span> &#125;;</code></pre></div><p>至此，我们已经在 imx6ull-alientek-emmc.dts 文件中添加好了 test 设备所使用的 PIN 配置信息。</p><h2 id="二、gpio-子系统"><a href="#二、gpio-子系统" class="headerlink" title="二、gpio 子系统"></a>二、gpio 子系统</h2><h3 id="1-GPIO-子系统简介"><a href="#1-GPIO-子系统简介" class="headerlink" title="1|GPIO 子系统简介"></a>1|GPIO 子系统简介</h3><p>上一小节讲解了 pinctrl 子系统，<strong>pinctrl 子系统重点是设置 PIN(有的 SOC 叫做 PAD)的复用和电气属性</strong>，如果 pinctrl 子系统将一个 PIN 复用为 GPIO 的话，那么接下来就要用到 gpio 子系统了。</p><p>gpio 子系统顾名思义，就是<strong>用于初始化 GPIO 并且提供相应的 API 函数，比如设置 GPIO为输入输出，读取 GPIO 的值等</strong>。gpio 子系统的主要目的就是方便驱动开发者使用 gpio，驱动开发者在设备树中添加 gpio 相关信息，然后就可以在驱动程序中使用 gpio 子系统提供的 API函数来操作 GPIO，Linux 内核向驱动开发者屏蔽掉了 GPIO 的设置过程，极大的方便了驱动开发者使用 GPIO。</p><h3 id="2-I-MX6ULL的的-gpio子系统驱动"><a href="#2-I-MX6ULL的的-gpio子系统驱动" class="headerlink" title="2|I.MX6ULL的的 gpio子系统驱动"></a>2|I.MX6ULL的的 gpio子系统驱动</h3><h4 id="1-、设备树中的-gpio-信息"><a href="#1-、设备树中的-gpio-信息" class="headerlink" title="1 、设备树中的 gpio  信息"></a>1 、设备树中的 gpio  信息</h4><p>I.MX6ULL-ALPHA 开发板上的 <strong>UART1_RTS_B</strong> 做为 SD 卡的检测引脚，<strong>UART1_RTS_B</strong> 复用为 <strong>GPIO1_IO19</strong>，通过读取这个 GPIO 的高低电平就可以知道 SD 卡有没有插入。首先肯定是将 UART1_RTS_B 这个 PIN 复用为 GPIO1_IO19，并且设置电气属性，也就是上一小节讲的pinctrl 节点。打开 imx6ull-lxg-emmc.dts， UART1_RTS_B 这个 PIN 的 pincrtl 设置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">316</span> pinctrl_hog_1: hoggrp<span class="hljs-number">-1</span> &#123;<span class="hljs-number">317</span> fsl,pins = &lt;<span class="hljs-number">318</span> MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 <span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 CD */</span>......<span class="hljs-number">322</span> &gt;;<span class="hljs-number">323</span> &#125;;</code></pre></div><p><strong>第 318 行</strong>，设置 UART1_RTS_B 这个 PIN 为 GPIO1_IO19。pinctrl 配置好以后就是设置 gpio 了，SD 卡驱动程序通过读取 GPIO1_IO19 的值来判断 SD卡有没有插入，但是 SD 卡驱动程序怎么知道 CD 引脚连接的 GPIO1_IO19 呢？肯定是需要设备树告诉驱动啊！在设备树中 SD 卡节点下添加一个属性来描述 SD 卡的 CD 引脚就行了，SD卡驱动直接读取这个属性值就知道 SD 卡的 CD 引脚使用的是哪个 GPIO 了。</p><p>SD 卡连接在I.MX6ULL 的 usdhc1 接口上，在 imx6ull-lxg-emmc.dts 中找到名为“usdhc1”的节点，这个节点就是 SD 卡设备节点，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">760</span> &amp;usdhc1 &#123;<span class="hljs-number">761</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;state_100mhz&quot;</span>, <span class="hljs-string">&quot;state_200mhz&quot;</span>;<span class="hljs-number">762</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_usdhc1&gt;;<span class="hljs-number">763</span> pinctrl<span class="hljs-number">-1</span> = &lt;&amp;pinctrl_usdhc1_100mhz&gt;;<span class="hljs-number">764</span> pinctrl<span class="hljs-number">-2</span> = &lt;&amp;pinctrl_usdhc1_200mhz&gt;;<span class="hljs-number">765</span> <span class="hljs-comment">/* pinctrl-3 = &lt;&amp;pinctrl_hog_1&gt;; */</span><span class="hljs-number">766</span> cd-gpios = &lt;&amp;gpio1 <span class="hljs-number">19</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">767</span> keep-power-in-suspend;<span class="hljs-number">768</span> enable-sdio-wakeup;<span class="hljs-number">769</span> vmmc-supply = &lt;&amp;reg_sd1_vmmc&gt;;<span class="hljs-number">770</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">771</span> &#125;;</code></pre></div><p><strong>第 765 行</strong>，此行本来没有，是作者添加的，usdhc1 节点作为 SD 卡设备总节点，usdhc1 节点需要描述 SD 卡所有的信息，因为驱动要使用。本行就是描述 SD 卡的 CD 引脚 pinctrl 信息所在的子节点，因为SD 卡驱动需要根据 pincrtl节点信息来设置 CD引脚的复用功能等。</p><p><strong>762~764行</strong>的 pinctrl-0~2 都是 SD 卡其他 PIN 的 pincrtl 节点信息。但是大家会发现，其实在 usdhc1 节点中并没有“pinctrl-3 &#x3D; &lt;&amp;pinctrl_hog_1&gt;”这一行，也就是说并没有指定 CD 引脚的 pinctrl 信息，那么 SD 卡驱动就没法设置 CD 引脚的复用功能啊？这个不用担心，因为在“iomuxc”节点下引用了 pinctrl_hog_1 这个节点，所以 Linux 内核中的 iomuxc 驱动就会自动初始化 pinctrl_hog_1节点下的所有 PIN。</p><p><strong>第 766 行</strong>，属性“cd-gpios”描述了 SD 卡的 CD 引脚使用的哪个 IO。属性值一共有三个，我们来看一下这三个属性值的含义，“&amp;gpio1”表示 CD 引脚所使用的 IO 属于 GPIO1 组，“19”表示 GPIO1 组的第 19 号 IO，通过这两个值 SD 卡驱动程序就知道 CD 引脚使用了GPIO1_IO19<br>这 GPIO。“GPIO_ACTIVE_LOW”表示低电平有效，如果改为“GPIO_ACTIVE_HIGH”就表示高电平有效。</p><p>根据上面这些信息，SD 卡驱动程序就可以使用 GPIO1_IO19 来检测 SD 卡的 CD 信号了，<br>打开 imx6ull.dtsi，在里面找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">504</span> gpio1: gpio@<span class="hljs-number">0209</span>c000 &#123;<span class="hljs-number">505</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-gpio&quot;</span>, <span class="hljs-string">&quot;fsl,imx35-gpio&quot;</span>;<span class="hljs-number">506</span> reg = &lt;<span class="hljs-number">0x0209c000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">507</span> interrupts = &lt;GIC_SPI <span class="hljs-number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;,<span class="hljs-number">508</span>  &lt;GIC_SPI <span class="hljs-number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-number">509</span> gpio-controller;<span class="hljs-number">510</span> <span class="hljs-meta">#gpio-cells = <span class="hljs-string">&lt;2&gt;</span>;</span><span class="hljs-number">511</span> interrupt-controller;<span class="hljs-number">512</span> <span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;2&gt;</span>;</span><span class="hljs-number">513</span> &#125;;</code></pre></div><p>gpio1 节点信息描述了 GPIO1 控制器的所有信息，重点就是 GPIO1 外设寄存器基地址以及兼 容 属 性 。 关 于 I.MX 系 列 SOC 的 GPIO 控 制 器 绑 定 信 息 请 查 看 文 档Documentation&#x2F;devicetree&#x2F;bindings&#x2F;gpio&#x2F; fsl-imx-gpio.txt。</p><p><strong>第 505 行</strong>，设置 gpio1 节点的 compatible 属性有两个，分别为“fsl,imx6ul-gpio”和“fsl,imx35-gpio”，在 Linux 内核中搜索这两个字符串就可以找到 I.MX6UL 的 GPIO 驱动程序。<br><strong>第 506 行</strong>，的 reg 属性设置了 GPIO1 控制器的寄存器基地址为 0X0209C000，大家可以打开《I.MX6ULL 参考手册》找到“Chapter 28:General Purpose Input&#x2F;Output(GPIO)”章节第28.5 小节，有如图 45.2.2.1 所示的寄存器地址表：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200821231652016.png" alt="image-20200821231652016"></p><p>从图 45.2.2.1 可以看出，GPIO1 控制器的基地址就是 0X0209C000。<br><strong>第 509 行</strong>，“gpio-controller”表示 gpio1 节点是个 GPIO 控制器。<br><strong>第 510 行</strong>，“#gpio-cells”属性和“#address-cells”类似，#gpio-cells 应该为 2，表示一共有两个 cell，第一个 cell 为 GPIO 编号，比如“&amp;gpio1 3”就表示 GPIO1_IO03。第二个 cell 表示GPIO 极 性 ， 如 果 为 0(GPIO_ACTIVE_HIGH) 的 话 表 示 高 电 平 有 效 ， 如 果 为1(GPIO_ACTIVE_LOW)的话表示低电平有效。</p><h4 id="2-、GPIO-驱动程序简介"><a href="#2-、GPIO-驱动程序简介" class="headerlink" title="2 、GPIO 驱动程序简介"></a>2 、GPIO 驱动程序简介</h4><p>本小节会涉及到 Linux 驱动分层与分离、平台设备驱动等还未讲解的知识，所以本小节教程可以不用看，不会影响后续的实验。如果对 Linux 内核的 GPIO 子系统实现原理感兴趣的话<br>可以看本小节。</p><p><strong>具体参考正点原子IMX6U驱动开发指南45.2.2节</strong></p><hr><h3 id="3-gpio-子系统-API-函数"><a href="#3-gpio-子系统-API-函数" class="headerlink" title="3|gpio  子系统 API  函数"></a>3|gpio  子系统 API  函数</h3><p>对于驱动开发人员，设置好设备树以后就可以使用 gpio 子系统提供的 API 函数来操作指定的 GPIO，gpio 子系统向驱动开发人员屏蔽了具体的读写寄存器过程。这就是驱动分层与分离的好处，大家各司其职，做好自己的本职工作即可。</p><p>gpio 子系统提供的常用的 API 函数有下面几个：</p><h4 id="gpio-request-函数"><a href="#gpio-request-函数" class="headerlink" title="gpio_request  函数"></a>gpio_request  函数</h4><p>gpio_request 函数用于申请一个 GPIO 管脚，在使用一个 GPIO 之前一定要使用gpio_request进行申请，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_request</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> gpio, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *label)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要申请的 gpio 标号，使用 of_get_named_gpio 函数从设备树获取指定 GPIO 属性信息，此函数会返回这个 GPIO 的标号。<br><strong>label</strong>：给 gpio 设置个名字。<br><strong>返回值</strong>：0，申请成功；其他值，申请失败。</p><hr><h4 id="gpio-free-函数"><a href="#gpio-free-函数" class="headerlink" title="gpio_free  函数"></a>gpio_free  函数</h4><p>如果不使用某个 GPIO 了，那么就可以调用 gpio_free 函数进行释放。函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">gpio_free</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> gpio)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要释放的 gpio 标号。<br><strong>返回值</strong>：无。</p><hr><h4 id="gpio-direction-input-函数"><a href="#gpio-direction-input-函数" class="headerlink" title="gpio_direction_input  函数"></a>gpio_direction_input  函数</h4><p>此函数用于设置某个 GPIO 为输入，函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_direction_input</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> gpio)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要设置为输入的 GPIO 标号。<br><strong>返回值</strong>：0，设置成功；负值，设置失败。</p><hr><h4 id="gpio-direction-output-函数"><a href="#gpio-direction-output-函数" class="headerlink" title="gpio_direction_output  函数"></a>gpio_direction_output  函数</h4><p>此函数用于设置某个 GPIO 为输出，并且设置默认输出值，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_direction_output</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> gpio, <span class="hljs-type">int</span> value)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要设置为输出的 GPIO 标号。<br><strong>value</strong> ：GPIO 默认输出值。<br><strong>返回值</strong>：0，设置成功；负值，设置失败。</p><hr><h4 id="gpio-get-value-函数"><a href="#gpio-get-value-函数" class="headerlink" title="gpio_get_value  函数"></a>gpio_get_value  函数</h4><p>此函数用于获取某个 GPIO 的值(0 或 1)，此函数是个宏，定义所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> gpio_get_value __gpio_get_value </span><span class="hljs-type">int</span> __gpio_get_value(<span class="hljs-type">unsigned</span> gpio)</code></pre></div><p>函数参数和返回值含义如下：</p><p><strong>gpio</strong>：要获取的 GPIO 标号。<br><strong>返回值</strong>：非负值，得到的 GPIO 值；负值，获取失败。</p><hr><h4 id="gpio-set-value-函数"><a href="#gpio-set-value-函数" class="headerlink" title="gpio_set_value  函数"></a>gpio_set_value  函数</h4><p>此函数用于设置某个 GPIO 的值，此函数是个宏，定义如下</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> gpio_set_value __gpio_set_value</span><span class="hljs-type">void</span> __gpio_set_value(<span class="hljs-type">unsigned</span> gpio, <span class="hljs-type">int</span> value)</code></pre></div><p>函数参数和返回值含义如下：<br><strong>gpio</strong>：要设置的 GPIO 标号。<br><strong>value</strong> ：要设置的值。<br><strong>返回值</strong>：无</p><p>关于 gpio 子系统常用的 API 函数就讲这些，这些是我们用的最多的。</p><hr><h3 id="4-设备树中添加-gpio-节点模板"><a href="#4-设备树中添加-gpio-节点模板" class="headerlink" title="4|设备树中添加 gpio  节点模板"></a>4|设备树中添加 gpio  节点模板</h3><p>继续完成前面的 test 设备，我们已经讲解了如何创建 test 设备的 pinctrl 节点。本节我们来学习一下如何创建 test 设备的 GPIO 节点。</p><h4 id="1-、创建-test-设备节点"><a href="#1-、创建-test-设备节点" class="headerlink" title="1 、创建 test  设备节点"></a>1 、创建 test  设备节点</h4><p>在根节点“&#x2F;”下创建 test 设备子节点，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> test &#123;<span class="hljs-number">2</span> <span class="hljs-comment">/* 节点内容 */</span><span class="hljs-number">3</span> &#125;;</code></pre></div><h4 id="2-、添加-pinctrl-信息"><a href="#2-、添加-pinctrl-信息" class="headerlink" title="2 、添加 pinctrl  信息"></a>2 、添加 pinctrl  信息</h4><p>前面我们创建了 pinctrl_test 节点，此节点描述了 test 设备所使用的 GPIO1_IO00 这个 PIN 的信息，我们要将这节点添加到 test 设备节点中，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> test &#123;<span class="hljs-number">2</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">3</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_test&gt;;<span class="hljs-number">4</span> <span class="hljs-comment">/* 其他节点内容 */</span><span class="hljs-number">5</span> &#125;;</code></pre></div><p><strong>第 2 行</strong>，添加 pinctrl-names 属性，此属性描述 pinctrl 名字为“default”。<br><strong>第 3 行</strong>，添加 pinctrl-0 节点，此节点引用前面创建的 pinctrl_test 节点，表示 tset 设备的所使用的 PIN 信息保存在 pinctrl_test 节点中。</p><h4 id="3-、添加-GPIO-属性信息"><a href="#3-、添加-GPIO-属性信息" class="headerlink" title="3 、添加 GPIO  属性信息"></a>3 、添加 GPIO  属性信息</h4><p>我们最后需要在 test 节点中添加 GPIO 属性信息，表明 test 所使用的 GPIO 是哪个引脚，添加完成以后如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> test &#123;<span class="hljs-number">2</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">3</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_test&gt;;<span class="hljs-number">4</span> gpio = &lt;&amp;gpio1 <span class="hljs-number">0</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">5</span> &#125;;</code></pre></div><p><strong>第 4 行</strong>，test 设备所使用的 gpio。</p><p>关于 pinctrl 子系统和 gpio 子系统就讲解到这里，接下来就使用 pinctrl 和 gpio 子系统来驱动I.MX6ULL-ALPHA 开发板上的 LED 灯。</p><h3 id="5-与-gpio-相关的-OF-函数"><a href="#5-与-gpio-相关的-OF-函数" class="headerlink" title="5|  与 gpio  相关的 OF  函数"></a>5|  与 gpio  相关的 OF  函数</h3><p>在前面示例代码中，我们定义了一个名为“gpio”的属性，gpio 属性描述了 test 这个设备所使用的 GPIO。</p><p>在驱动程序中需要读取 gpio 属性内容，Linux 内核提供了几个与 GPIO 有关的 OF 函数，常用的几个 OF 函数如下所示：</p><h4 id="of-gpio-named-count-函数"><a href="#of-gpio-named-count-函数" class="headerlink" title="of_gpio_named_count  函数"></a>of_gpio_named_count  函数</h4><p>of_gpio_named_count 函数用于<strong>获取设备树某个属性里面定义了几个 GPIO 信息</strong>，要注意的是空的 GPIO 信息也会被统计到，比如：</p><div class="hljs code-wrapper"><pre><code class="hljs c">gpios = &lt;<span class="hljs-number">0</span>             &amp;gpio1 <span class="hljs-number">1</span> <span class="hljs-number">2</span>            <span class="hljs-number">0</span>            &amp;gpio2 <span class="hljs-number">3</span> <span class="hljs-number">4</span>&gt;;</code></pre></div><p>上述代码的“gpios”节点一共定义了 4 个 GPIO，但是有 2 个是空的，没有实际的含义。通过 of_gpio_named_count 函数统计出来的 GPIO 数量就是 4 个，此函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_gpio_named_count</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>propname</strong>：要统计的 GPIO 属性。<br><strong>返回值</strong>：正值，统计到的 GPIO 数量；负值，失败。</p><hr><h4 id="of-gpio-count-函数"><a href="#of-gpio-count-函数" class="headerlink" title="of_gpio_count  函数"></a>of_gpio_count  函数</h4><p>和 of_gpio_named_count 函数一样，但是不同的地方在于，此函数统计的是“gpios”这个属性的 GPIO 数量，而 of_gpio_named_count 函数可以统计任意属性的 GPIO 信息，函数原型如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_gpio_count</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>返回值</strong>：正值，统计到的 GPIO 数量；负值，失败。</p><hr><h4 id="of-get-named-gpio-函数"><a href="#of-get-named-gpio-函数" class="headerlink" title="of_get_named_gpio  函数"></a>of_get_named_gpio  函数</h4><p>此函数获取 GPIO 编号，因为 Linux 内核中关于 GPIO 的 API 函数都要使用 GPIO 编号，此函数会将设备树中类似&lt;&amp;gpio5 7 GPIO_ACTIVE_LOW&gt;的属性信息转换为对应的 GPIO 编号，此函数在驱动中使用很频繁！函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_get_named_gpio</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>*propname,</span><span class="hljs-params">                      <span class="hljs-type">int</span> index)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>propname</strong>：包含要获取 GPIO 信息的属性名。</p><p><strong>index</strong> ：GPIO 索引，因为一个属性里面可能包含多个 GPIO，此参数指定要获取哪个 GPIO的编号，如果只有一个 GPIO 信息的话此参数为 0。<br><strong>返回值</strong>：正值，获取到的 GPIO 编号；负值，失败。</p><h2 id="三、硬件原理图"><a href="#三、硬件原理图" class="headerlink" title="三、硬件原理图"></a>三、硬件原理图</h2><p>参考前面的LED原理图</p><h2 id="四、GPIO-LED实验"><a href="#四、GPIO-LED实验" class="headerlink" title="四、GPIO-LED实验"></a>四、GPIO-LED实验</h2><p>本章实验我们继续研究 LED 灯，在前面实验中我们通过设备树向 dtsled.c 文件传递相应的寄存器物理地址，然后在驱动文件中配置寄存器。本章实验我们使用 pinctrl 和 gpio 子系统来完成 LED 灯驱动。</p><h3 id="1-修改设备树文件"><a href="#1-修改设备树文件" class="headerlink" title="1|修改设备树文件"></a>1|修改设备树文件</h3><h4 id="1、添加pinctrl节点"><a href="#1、添加pinctrl节点" class="headerlink" title="1、添加pinctrl节点"></a>1、添加pinctrl节点</h4><p>I.MX6U-ALPHA 开发板上的 LED 灯使用了 GPIO1_IO03 这个 PIN，打开 imx6ull-lxg-emmc.dts，在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为“pinctrl_led”的子节点，节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> pinctrl_led: ledgrp &#123;<span class="hljs-number">2</span> fsl,pins = &lt;<span class="hljs-number">3</span> MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 <span class="hljs-number">0x10B0</span> <span class="hljs-comment">/* LED0 */</span><span class="hljs-number">4</span> &gt;;<span class="hljs-number">5</span> &#125;;</code></pre></div><p>第 3 行，将 GPIO1_IO03 这个 PIN 复用为 GPIO1_IO03，电气属性值为 0X10B0。</p><h4 id="2-、添加-LED-设备节点"><a href="#2-、添加-LED-设备节点" class="headerlink" title="2 、添加 LED  设备节点"></a>2 、添加 LED  设备节点</h4><p>在根节点“&#x2F;”下创建 LED 灯节点，节点名为“gpioled”，节点内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> gpioled &#123;<span class="hljs-number">2</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">3</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">4</span> compatible = <span class="hljs-string">&quot;atkalpha-gpioled&quot;</span>;<span class="hljs-number">5</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">6</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_led&gt;;<span class="hljs-number">7</span> led-gpio = &lt;&amp;gpio1 <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">8</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">9</span> &#125;</code></pre></div><p><strong>第 6 行</strong>，pinctrl-0 属性设置 LED 灯所使用的 PIN 对应的 pinctrl 节点。<br><strong>第 7 行</strong>，led-gpio 属性指定了 LED 灯所使用的 GPIO，在这里就是 GPIO1 的 IO03，低电平有效。稍后编写驱动程序的时候会获取 led-gpio 属性的内容来得到 GPIO 编号，因为 gpio 子系统的 API 操作函数需要 GPIO 编号。</p><h4 id="3-、检查-PIN-是否被其他外设使用"><a href="#3-、检查-PIN-是否被其他外设使用" class="headerlink" title="3 、检查 PIN  是否被其他外设使用"></a>3 、检查 PIN  是否被其他外设使用</h4><p><strong>这一点非常重要！！！</strong></p><p>很多初次接触设备树的驱动开发人员很容易因为这个小问题栽了大跟头！因为我们所使用的设备树基本都是在半导体厂商提供的设备树文件基础上修改而来的，而半导体厂商提供的设备树是根据自己官方开发板编写的，很多 PIN 的配置和我们所使用的开发板不一样。比如 A 这个引脚在官方开发板接的是 I2C 的 SDA，而我们所使用的硬件可能将 A 这个引脚接到了其他的外设，比如 LED 灯上，接不同的外设，A 这个引脚的配置就不同。一个引脚一次只能实现一个功能，如果A引脚在设备树中配置为了I2C的SDA信号，那么A引脚就不能再配置为GPIO，否则的话驱动程序在申请 GPIO 的时候就会失败。检查 PIN 有没有被其他外设使用包括两个方面：</p><p>①、检查 pinctrl 设置。<br>②、如果这个 PIN 配置为 GPIO 的话，检查这个 GPIO 有没有被别的外设使用。</p><p>在本章实验中 LED 灯使用的 PIN 为 GPIO1_IO03，因此先检查 GPIO_IO03 这个 PIN 有没有被其他的 pinctrl 节点使用，在 imx6ull-lxg-emmc.dts 中找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">480</span> pinctrl_tsc: tscgrp &#123;<span class="hljs-number">481</span> fsl,pins = &lt;<span class="hljs-number">482</span> MX6UL_PAD_GPIO1_IO01__GPIO1_IO01 <span class="hljs-number">0xb0</span><span class="hljs-number">483</span> MX6UL_PAD_GPIO1_IO02__GPIO1_IO02 <span class="hljs-number">0xb0</span><span class="hljs-number">484</span> MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 <span class="hljs-number">0xb0</span><span class="hljs-number">485</span> MX6UL_PAD_GPIO1_IO04__GPIO1_IO04 <span class="hljs-number">0xb0</span><span class="hljs-number">486</span> &gt;;<span class="hljs-number">487</span> &#125;;</code></pre></div><p>pinctrl_tsc 节点是 TSC(电阻触摸屏接口)的 pinctrl 节点，从第 484 行可以看出，默认情况下GPIO1_IO03 作为了 TSC 外设的 PIN。所以我们需要将第 484 行屏蔽掉！和 C 语言一样，在要屏蔽的内容前后加上“&#x2F;*”和“*&#x2F;”符号即可。其实在 I.MX6U-ALPHA 开发板上并没有用到 TSC接口，所以第 482~485 行的内容可以全部屏蔽掉。因为本章实验我们将 GPIO1_IO03 这个 PIN 配置为了 GPIO，所以还需要查找一下有没有其他的外设使用了 GPIO1_IO03，在 imx6ull-lxg-emmc.dts 中搜索“gpio1 3”，找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">723</span> &amp;tsc &#123;<span class="hljs-number">724</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">725</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_tsc&gt;;<span class="hljs-number">726</span> xnur-gpio = &lt;&amp;gpio1 <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;;<span class="hljs-number">727</span> measure-delay-time = &lt;<span class="hljs-number">0xffff</span>&gt;;<span class="hljs-number">728</span> pre-charge-time = &lt;<span class="hljs-number">0xfff</span>&gt;;<span class="hljs-number">729</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">730</span> &#125;;</code></pre></div><p>tsc 是 TSC 的外设节点，从 726 行可以看出，tsc 外设也使用了 GPIO1_IO03，同样我们需要将这一行屏蔽掉。然后在继续搜索“gpio1 3”，看看除了本章的 LED 灯以外还有没有其他的地方也使用了 GPIO1_IO03，找到一个屏蔽一个。</p><p>设备树编写完成以后使用“make dtbs”命令重新编译设备树，然后使用新编译出来的imx6ull-lxg-emmc.dtb 文件启动 Linux 系统。启动成功以后进入“&#x2F;proc&#x2F;device-tree”目录中查看“gpioled”节点是否存在，如果存在的话就说明设备树基本修改成功(具体还要驱动验证)，结果如图所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200822120341272.png" alt="image-20200822120341272"></p><h3 id="2-LED-灯驱动程序编写"><a href="#2-LED-灯驱动程序编写" class="headerlink" title="2| LED  灯驱动程序编写"></a>2| LED  灯驱动程序编写</h3><p>设备树准备好以后就可以编写驱动程序了，本章实验在前面实验驱动文件 dtsled.c 的基础上修改而来。新建名为“5_gpioled”文件夹，然后在 5_gpioled 文件夹里面创建 vscode 工程，工作区命名为“gpioled”。工程创建好以后新建 gpioled.c 文件，在 gpioled.c 里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>LED_OFF = <span class="hljs-number">0</span>,LED_ON = !LED_OFF&#125;<span class="hljs-type">led_switch_t</span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span><span class="hljs-comment">/* gpioled设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-type">char</span> *devname;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span><span class="hljs-comment">//设备树节点</span><span class="hljs-type">int</span> led_gpio;<span class="hljs-comment">//GPIO编号</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>&#123;<span class="hljs-comment">//int val = 0;</span><span class="hljs-keyword">if</span>(sw == LED_ON)&#123;<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-comment">//filp-&gt;private_data = &amp;gpioled;/* 设置私有数据 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;/* 以访问私有数据 */</span><span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = copy_from_user(userDataBuf, buf, cnt);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;led_switch(userDataBuf[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作集合 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;.owner = THIS_MODULE,.write = gpioled_write,.open = gpioled_open,.release = gpioled_release&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 注册设备号 */</span>gpioled.devname = <span class="hljs-string">&quot;gpioled&quot;</span>;gpioled.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(gpioled.major)&#123;gpioled.devid = MKDEV(gpioled.major, gpioled.minor);ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);&#125;gpioled.major = MAJOR(gpioled.devid);gpioled.minor = MINOR(gpioled.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);<span class="hljs-comment">/* 添加字符设备 */</span>gpioled.cdev.owner = gpioled_fops.owner;cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>gpioled.class = class_create(THIS_MODULE, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);result = PTR_ERR(gpioled.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);result = PTR_ERR(gpioled.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 获取设备节点 */</span>gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_findnd;&#125;<span class="hljs-comment">/* 获取LED对应的GPIO */</span>gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;result = -EINVAL;printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);<span class="hljs-keyword">goto</span> fail_get_gpio;&#125;printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);<span class="hljs-comment">/* 申请IO */</span>ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_request_gpio;&#125;<span class="hljs-comment">/* 使用IO */</span>ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_gpio_failed;&#125;<span class="hljs-comment">/* 设置GPIO电平 */</span>printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 默认开灯 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_gpio_failed:<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);fail_request_gpio:fail_get_gpio:fail_findnd:<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 关灯 */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(gpioled_init);module_exit(gpioled_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><h3 id="3-编写测试-APP"><a href="#3-编写测试-APP" class="headerlink" title="3|编写测试 APP"></a>3|编写测试 APP</h3><p>本章直接使用前面的测试 APP，将上一章的 ledApp.c 文件复制到本章实验工程下即可。</p><h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4|运行测试"></a>4|运行测试</h3><p>编译运行，和前面一样。</p><p>加载驱动后，如图：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/5%E3%80%81pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200822121423644.png" alt="image-20200822121423644"></p><p>可以看到成功获取了GPIO编号，说明驱动没问题，然后测试一下开关灯。</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
      <tag>dts设备树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4| Linux  设备树</title>
    <link href="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
    <url>/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-设备树"><a href="#Linux-设备树" class="headerlink" title="Linux  设备树"></a>Linux  设备树</h1><p>什么是“设备树”，本章我们就来详细的谈一谈设备树。掌握设备树是 Linux 驱动开发人员必备的技能！因为在新版本的 Linux 中，ARM 相关的驱动全部采用了设备树(也有支持老式驱动的，比较少)，最新出的 CPU 其驱动开发也基本都是基于设备树的，比如 ST 新出的 STM32MP157、NXP的I.MX8系列等。</p><p>我们所使用的Linux版本为4.1.15，其支持设备树，所以正点原子I.MX6U-ALPHA 开发板的所有 Linux 驱动都是基于设备树的。本章我们就来了解一下设备树的起源、重点学习一下设备树语法。</p><h2 id="一、什么是设备树？"><a href="#一、什么是设备树？" class="headerlink" title="一、什么是设备树？"></a>一、什么是设备树？</h2><p>**设备树(Device Tree)**，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等，如图所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820184958257.png" alt="image-20200820184958257"></p><p>在图中，树的主干就是系统总线，IIC 控制器、GPIO 控制器、SPI 控制器等都是接到系统主线上的分支。IIC 控制器有分为 IIC1 和 IIC2 两种，其中 IIC1 上接了 FT5206 和 AT24C02这两个 IIC 设备，IIC2 上只接了 MPU6050 这个设备。</p><p>DTS 文件的主要功能就是按照图所示的结构来描述板子上的设备信息，DTS 文件描述设备信息是有相应的语法规则要求的，稍后我们会详细的讲解 DTS 语法规则。</p><p>在 3.x 版本(具体哪个版本我也无从考证)以前的 Linux 内核中 ARM 架构并没有采用设备树。在没有设备树的时候 Linux 是如何描述 ARM 架构中的板级信息呢？在 Linux 内核源码中大量的 arch&#x2F;arm&#x2F;mach-xxx 和 arch&#x2F;arm&#x2F;plat-xxx 文件夹，这些文件夹里面的文件就是对应平台下的板级信息。比如在 arch&#x2F;arm&#x2F;mach-smdk2440.c 中有如下内容(有缩减)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">90</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3c2410fb_display</span> <span class="hljs-title">smdk2440_lcd_cfg</span> __<span class="hljs-title">initdata</span> =</span> &#123;<span class="hljs-number">91</span><span class="hljs-number">92</span> .lcdcon5 = S3C2410_LCDCON5_FRM565 |<span class="hljs-number">93</span> S3C2410_LCDCON5_INVVLINE |<span class="hljs-number">94</span> S3C2410_LCDCON5_INVVFRAME |<span class="hljs-number">95</span> S3C2410_LCDCON5_PWREN |<span class="hljs-number">96</span> S3C2410_LCDCON5_HWSWP,......<span class="hljs-number">113</span> &#125;;<span class="hljs-number">114</span><span class="hljs-number">115</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3c2410fb_mach_info</span> <span class="hljs-title">smdk2440_fb_info</span> __<span class="hljs-title">initdata</span> =</span> &#123;<span class="hljs-number">116</span> .displays = &amp;smdk2440_lcd_cfg,<span class="hljs-number">117</span> .num_displays = <span class="hljs-number">1</span>,<span class="hljs-number">118</span> .default_display = <span class="hljs-number">0</span>,......<span class="hljs-number">133</span> &#125;;<span class="hljs-number">134</span><span class="hljs-number">135</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">smdk2440_devices</span>[] __<span class="hljs-title">initdata</span> =</span> &#123;<span class="hljs-number">136</span> &amp;s3c_device_ohci,<span class="hljs-number">137</span> &amp;s3c_device_lcd,<span class="hljs-number">138</span> &amp;s3c_device_wdt,<span class="hljs-number">139</span> &amp;s3c_device_i2c0,<span class="hljs-number">140</span> &amp;s3c_device_iis,<span class="hljs-number">141</span> &#125;;</code></pre></div><p>上述代码中的结构体变量 smdk2440_fb_info 就是描述 SMDK2440 这个开发板上的 LCD 信息的，结构体指针数组 smdk2440_devices 描述的 SMDK2440 这个开发板上的所有平台相关信息。这个仅仅是使用 2440 这个芯片的 SMDK2440 开发板下的 LCD 信息，SMDK2440 开发板还有很多的其他外设硬件和平台硬件信息。使用 2440 这个芯片的板子有很多，每个板子都有描述相应板级信息的文件，这仅仅只是一个 2440。随着智能手机的发展，每年新出的 ARM 架构芯片少说都在数十、数百款，Linux 内核下板级信息文件将会成指数级增长！这些板级信息文件都是.c 或.h 文件，都会被硬编码进 Linux 内核中，导致 Linux 内核“虚胖”。</p><p>就好比你喜欢吃自助餐，然后花了 100 多到一家宣传看着很不错的自助餐厅，结果你想吃的牛排、海鲜、烤肉基本没多少，全都是一些凉菜、炒面、西瓜、饮料等小吃，相信你此时肯定会脱口而出一句“F<em>k!”、<br>“骗子！”。</em></p><p>同样的，当 Linux 之父 linus 看到 ARM 社区向 Linux 内核添加了大量“无用”、冗余的板级信息文件，不禁的发出了一句<strong>“This whole ARM thing is a f*cking pain in the ass”</strong>。从此以后 ARM 社区就引入了 PowerPC 等架构已经采用的设备树(Flattened Device Tree)，将这些描述板级硬件信息的内容都从 Linux 内中分离开来，用一个专属的文件格式来描述，这个专属的文件就叫做设备树，文件扩展名为.dts。</p><p>一个 SOC 可以作出很多不同的板子，这些不同的板子肯定是有共同的信息，<strong>将这些共同的信息提取出来作为一个通用的文件，其他的.dts 文件直接引用这个通用文件即可，这个通用文件就是.dtsi 文件</strong>，类似于 C 语言中的头文件。一般.dts 描述板级信息(也就是开发板上有哪些 IIC 设备、SPI 设备等)，.dtsi 描述 SOC 级信息(也就是 SOC 有几个 CPU、主频是多少、各个外设控制器信息等)。</p><p>这个就是设备树的由来，简而言之就是，Linux 内核中 ARM 架构下有太多的冗余的垃圾板级信息文件，导致 linus 震怒，然后 ARM 社区引入了设备树。</p><h2 id="二、DTS-、DTB-和-和-DTC"><a href="#二、DTS-、DTB-和-和-DTC" class="headerlink" title="二、DTS 、DTB 和 和 DTC"></a>二、DTS 、DTB 和 和 DTC</h2><p>上一小节说了，设备树源文件扩展名为.dts，但是我们在前面移植 Linux 的时候却一直在使用.dtb 文件，那么 DTS 和 DTB 这两个文件是什么关系呢？DTS 是设备树源码文件，DTB 是将DTS 编译以后得到的二进制文件。将.c 文件编译为.o 需要用到 gcc 编译器，那么将.dts 编译为.dtb需要什么工具呢？需要用到 DTC 工具！DTC 工具源码在 Linux 内核的 scripts&#x2F;dtc 目录下，scripts&#x2F;dtc&#x2F;Makefile 文件内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">1 hostprogs-y := dtc2 always := $(hostprogs-y)34 dtc-objs:= dtc.o flattree.o fstree.o data.o livetree.o treesource.o \5 srcpos.o checks.o util.o6 dtc-objs += dtc-lexer.lex.o dtc-parser.tab.o......</code></pre></div><p>可以看出， DTC 工具依赖于 dtc.c、flattree.c、fstree.c 等文件，最终编译并链接出 DTC 这个主机文件。如果要编译 DTS 文件的话只需要进入到 Linux 源码根目录下，然后执行如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">make</span> <span class="hljs-keyword">all</span>或者：<span class="hljs-keyword">make</span> dtbs</code></pre></div><p>“make all”命令是编译 Linux 源码中的所有东西，包括 zImage，.ko 驱动模块以及设备树，如果只是编译设备树的话建议使用“make dtbs”命令。</p><p>基于 ARM 架构的 SOC 有很多种，一种 SOC 又可以制作出很多款板子，每个板子都有一个对应的 DTS 文件，那么如何确定编译哪一个 DTS 文件呢？我们就以 I.MX6ULL 这款芯片对应的板子为例来看一下，打开 arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;Makefile，有如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">381 dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6UL)</span> += \382 imx6ul-14x14-ddr3-arm2.dtb \383 imx6ul-14x14-ddr3-arm2-emmc.dtb \......400 dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6ULL)</span> += \401 imx6ull-14x14-ddr3-arm2.dtb \402 imx6ull-14x14-ddr3-arm2-adc.dtb \403 imx6ull-14x14-ddr3-arm2-cs42888.dtb \404 imx6ull-14x14-ddr3-arm2-ecspi.dtb \405 imx6ull-14x14-ddr3-arm2-emmc.dtb \406 imx6ull-14x14-ddr3-arm2-epdc.dtb \407 imx6ull-14x14-ddr3-arm2-flexcan2.dtb \408 imx6ull-14x14-ddr3-arm2-gpmi-weim.dtb \409 imx6ull-14x14-ddr3-arm2-lcdif.dtb \410 imx6ull-14x14-ddr3-arm2-ldo.dtb \411 imx6ull-14x14-ddr3-arm2-qspi.dtb \412 imx6ull-14x14-ddr3-arm2-qspi-all.dtb \413 imx6ull-14x14-ddr3-arm2-tsc.dtb \414 imx6ull-14x14-ddr3-arm2-uart2.dtb \415 imx6ull-14x14-ddr3-arm2-usb.dtb \416 imx6ull-14x14-ddr3-arm2-wm8958.dtb \417 imx6ull-14x14-evk.dtb \418 imx6ull-14x14-evk-btwifi.dtb \419 imx6ull-14x14-evk-emmc.dtb \420 imx6ull-14x14-evk-gpmi-weim.dtb \421 imx6ull-14x14-evk-usb-certi.dtb \422 imx6ull-lxg-emmc.dtb \423 imx6ull-lxg-nand.dtb \424 imx6ull-9x9-evk.dtb \425 imx6ull-9x9-evk-btwifi.dtb \426 imx6ull-9x9-evk-ldo.dtb427 dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6SLL)</span> += \428 imx6sll-lpddr2-arm2.dtb \429 imx6sll-lpddr3-arm2.dtb \......</code></pre></div><p>可以看出，当选中 I.MX6ULL 这个 SOC 以后(CONFIG_SOC_IMX6ULL&#x3D;y)，所有使用到I.MX6ULL 这个 SOC 的板子对应的.dts 文件都会被编译为.dtb。如果我们使用 I.MX6ULL 新做了一个板子，只需要新建一个此板子对应的.dts 文件，然后将对应的.dtb 文件名添加到 dtb-$(CONFIG_SOC_IMX6ULL)下，这样在编译设备树的时候就会将对应的.dts 编译为二进制的.dtb文件。</p><p>示例代码 中第 422 和 423 行就是我们在给正点原子的 I.MX6U-ALPHA 开发板移植Linux 系统的时候添加的设备树。</p><h2 id="三、DTS-语法"><a href="#三、DTS-语法" class="headerlink" title="三、DTS  语法"></a>三、DTS  语法</h2><p>虽然我们基本上不会从头到尾重写一个.dts 文件，大多时候是直接在 SOC 厂商提供的.dts文件上进行修改。但是 DTS 文件语法我们还是需要详细的学习一遍，因为我们肯定需要修改.dts文件。大家不要看到要学习新的语法就觉得会很复杂，DTS 语法非常的人性化，是一种 ASCII文本文件，不管是阅读还是修改都很方便。</p><p>本节我们就以 imx6ull-lxg-emmc.dts 这个文件为例来讲解一下 DTS 语法。</p><p>关于设备树详细的语法规则请参考《 Devicetree  SpecificationV0.2.pdf 》 和《Power_ePAPR_APPROVED_v1.12.pdf》这两份文档</p><h3 id="1-dtsi-头文件"><a href="#1-dtsi-头文件" class="headerlink" title="1|.dtsi  头文件"></a>1|.dtsi  头文件</h3><p>和 C 语言一样，设备树也支持头文件，设备树的头文件扩展名为.dtsi。在 imx6ull-lxg-emmc.dts 中有如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/input/input.h&gt;</span></span><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ull.dtsi&quot;</span></span></code></pre></div><p>第 12 行，使用“#include”来引用“input.h”这个.h 头文件。<br>第 13 行，使用“#include”来引用“imx6ull.dtsi”这个.dtsi 头文件。</p><p>看到这里，大家可能会疑惑，不是说设备树的扩展名是.dtsi 吗？为什么也可以直接引用 C语言中的.h 头文件呢？这里并没有错，.dts 文件引用 C 语言中的.h 文件，甚至也可以引用.dts 文件，打开 imx6ull-14x14-evk-gpmi-weim.dts 这个文件，此文件中有如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span>#include <span class="hljs-string">&quot;imx6ull-14x14-evk.dts&quot;</span></code></pre></div><p>可以看出，示例代码中直接引用了.dts 文件，因此在.dts 设备树文件中，可以通过“#include”来引用.h、.dtsi 和.dts 文件。只是，我们在编写设备树头文件的时候最好选择.dtsi 后缀。般.dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范围，比如 UART、IIC 等等。比如imx6ull.dtsi 就是描述 I.MX6ULL 这颗 SOC 内部外设情况信息的，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/clock/imx6ul-clock.h&gt;</span></span><span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/gpio/gpio.h&gt;</span></span><span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/interrupt-controller/arm-gic.h&gt;</span></span><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ull-pinfunc.h&quot;</span></span><span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ull-pinfunc-snvs.h&quot;</span></span><span class="hljs-number">15</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;skeleton.dtsi&quot;</span></span><span class="hljs-number">16</span><span class="hljs-number">17</span> / &#123;<span class="hljs-number">18</span> aliases &#123;<span class="hljs-number">19</span> can0 = &amp;flexcan1;......<span class="hljs-number">48</span> &#125;;<span class="hljs-number">49</span><span class="hljs-number">50</span> cpus &#123;<span class="hljs-number">51</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">52</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><span class="hljs-number">53</span><span class="hljs-number">54</span> cpu0: cpu@<span class="hljs-number">0</span> &#123;<span class="hljs-number">55</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<span class="hljs-number">56</span> device_type = <span class="hljs-string">&quot;cpu&quot;</span>;......<span class="hljs-number">89</span> &#125;;<span class="hljs-number">90</span> &#125;;<span class="hljs-number">91</span><span class="hljs-number">92</span> intc: interrupt-controller@<span class="hljs-number">00</span>a01000 &#123;<span class="hljs-number">93</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;<span class="hljs-number">94</span> <span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;3&gt;</span>;</span><span class="hljs-number">95</span> interrupt-controller;<span class="hljs-number">96</span> reg = &lt;<span class="hljs-number">0x00a01000</span> <span class="hljs-number">0x1000</span>&gt;,<span class="hljs-number">97</span> &lt;<span class="hljs-number">0x00a02000</span> <span class="hljs-number">0x100</span>&gt;;<span class="hljs-number">98</span> &#125;;<span class="hljs-number">99</span><span class="hljs-number">100</span> clocks &#123;<span class="hljs-number">101</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">102</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><span class="hljs-number">103</span><span class="hljs-number">104</span> ckil: clock@<span class="hljs-number">0</span> &#123;<span class="hljs-number">105</span> compatible = <span class="hljs-string">&quot;fixed-clock&quot;</span>;<span class="hljs-number">106</span> reg = &lt;<span class="hljs-number">0</span>&gt;;<span class="hljs-number">107</span> <span class="hljs-meta">#clock-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><span class="hljs-number">108</span> clock-frequency = &lt;<span class="hljs-number">32768</span>&gt;;<span class="hljs-number">109</span> clock-output-names = <span class="hljs-string">&quot;ckil&quot;</span>;<span class="hljs-number">110</span> &#125;;......<span class="hljs-number">135</span> &#125;;<span class="hljs-number">136</span><span class="hljs-number">137</span> soc &#123;<span class="hljs-number">138</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">139</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">140</span> compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<span class="hljs-number">141</span> interrupt-parent = &lt;&amp;gpc&gt;;<span class="hljs-number">142</span> ranges;<span class="hljs-number">143</span><span class="hljs-number">144</span> busfreq &#123;<span class="hljs-number">145</span> compatible = <span class="hljs-string">&quot;fsl,imx_busfreq&quot;</span>;......<span class="hljs-number">162</span> &#125;;<span class="hljs-number">197</span><span class="hljs-number">198</span> gpmi: gpmi-nand@<span class="hljs-number">01806000</span>&#123;<span class="hljs-number">199</span> compatible = <span class="hljs-string">&quot;fsl,imx6ull-gpmi-nand&quot;</span>, <span class="hljs-string">&quot;fsl, imx6ul-gpmi-</span><span class="hljs-string">nand&quot;</span>;<span class="hljs-number">200</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">201</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">202</span> reg = &lt;<span class="hljs-number">0x01806000</span> <span class="hljs-number">0x2000</span>&gt;, &lt;<span class="hljs-number">0x01808000</span> <span class="hljs-number">0x4000</span>&gt;;......<span class="hljs-number">216</span> &#125;;......<span class="hljs-number">1177</span> &#125;;<span class="hljs-number">1178</span> &#125;;</code></pre></div><h3 id="2-设备节点"><a href="#2-设备节点" class="headerlink" title="2|设备节点"></a>2|设备节点</h3><p>设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，叫做设备节点，每个节点都通过一些属性信息来描述节点信息，属性就是键—值对。以下是从imx6ull.dtsi 文件中缩减出来的设备树文件内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> / &#123;<span class="hljs-number">2</span> aliases &#123;<span class="hljs-number">3</span> can0 = &amp;flexcan1;<span class="hljs-number">4</span> &#125;;<span class="hljs-number">5</span><span class="hljs-number">6</span> cpus &#123;<span class="hljs-number">7</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">8</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><span class="hljs-number">9</span><span class="hljs-number">10</span> cpu0: cpu@<span class="hljs-number">0</span> &#123;<span class="hljs-number">11</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<span class="hljs-number">12</span> device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<span class="hljs-number">13</span> reg = &lt;<span class="hljs-number">0</span>&gt;;<span class="hljs-number">14</span> &#125;;<span class="hljs-number">15</span> &#125;;<span class="hljs-number">16</span><span class="hljs-number">17</span> intc: interrupt-controller@<span class="hljs-number">00</span>a01000 &#123;<span class="hljs-number">18</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;<span class="hljs-number">19</span> <span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;3&gt;</span>;</span><span class="hljs-number">20</span> interrupt-controller;<span class="hljs-number">21</span> reg = &lt;<span class="hljs-number">0x00a01000</span> <span class="hljs-number">0x1000</span>&gt;,<span class="hljs-number">22</span> &lt;<span class="hljs-number">0x00a02000</span> <span class="hljs-number">0x100</span>&gt;;<span class="hljs-number">23</span> &#125;;<span class="hljs-number">24</span> &#125;</code></pre></div><p>第 1 行， “&#x2F;”是根节点，每个设备树文件只有一个根节点。细心的同学应该会发现，imx6ull.dtsi和 imx6ull-alientek-emmc.dts 这两个文件都有一个“&#x2F;”根节点，这样不会出错吗？不会的，因为这两个“&#x2F;”根节点的内容会合并成一个根节点。第 2、6 和 17 行，aliases、cpus 和 intc 是三个子节点，在设备树中节点命名格式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span><span class="hljs-title">-name</span>@unit-address</code></pre></div><p>其中<strong>“node-name”</strong>是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。<strong>“unit-address”</strong>一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”、“interrupt-controller@00a01000”。</p><p>但是我们在示例代码第0行我们看到的节点命名却如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">cpu0:</span>cpu<span class="hljs-subst">@0</span></code></pre></div><p>上述命令并不是“node-name@unit-address”这样的格式，而是用“：”隔开成了两部分，“：”前面的是节点标签(label)，“：”后面的才是节点名字，格式如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">label: <span class="hljs-keyword">node</span><span class="hljs-title">-name</span>@unit-address</code></pre></div><p>引入 label 的目的就是为了方便访问节点，可以直接通过&amp;label 来访问这个节点，比如通过&amp;cpu0 就可以访问“cpu@0”这个节点，而不需要输入完整的节点名字。再比如节点 “intc:interrupt-controller@00a01000”，节点 label 是 intc，而节点名字就很长了，为“interrupt-controller@00a01000”。很明显通过&amp;intc 来访问“interrupt-controller@00a01000”这个节点要方便很多！</p><p>第 10 行，cpu0 也是一个节点，只是 cpu0 是 cpus 的子节点。每个节点都有不同属性，不同的属性又有不同的内容，属性都是键值对，值可以为空或任意的字节流。设备树源码中常用的几种数据形式如下所示：</p><p><strong>①、字符串</strong></p><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;arm,cortex-a7&quot;</span><span class="hljs-comment">;</span></code></pre></div><p>上述代码设置 compatible 属性的值为字符串“arm,cortex-a7”。<br><strong>②、32  位无符号整数</strong></p><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">reg</span> <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0</span>&gt;<span class="hljs-comment">;</span></code></pre></div><p>上述代码设置 reg 属性的值为 0，reg 的值也可以设置为一组值，比如：</p><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">reg</span> <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0</span> <span class="hljs-number">0</span>x123456 <span class="hljs-number">100</span>&gt;<span class="hljs-comment">;</span></code></pre></div><p><strong>③、字符串列表</strong><br>属性值也可以为字符串列表，字符串和字符串之间采用“,”隔开，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx6ull-gpmi-nand&quot;</span>, <span class="hljs-string">&quot;fsl, imx6ul-gpmi-nand&quot;</span><span class="hljs-comment">;</span></code></pre></div><p>上述代码设置属性 compatible 的值为“fsl,imx6ull-gpmi-nand”和“fsl, imx6ul-gpmi-nand”。</p><h3 id="3-标准属性"><a href="#3-标准属性" class="headerlink" title="3|标准属性"></a>3|标准属性</h3><p>节点是由一堆的属性组成，节点都是具体的设备，不同的设备需要的属性不同，用户可以自定义属性。除了用户自定义属性，有很多属性是标准属性，Linux 下的很多外设驱动都会使用这些标准属性，本节我们就来学习一下几个常用的标准属性。</p><h4 id="1-、compatible-属性"><a href="#1-、compatible-属性" class="headerlink" title="1 、compatible  属性"></a><strong>1 、compatible  属性</strong></h4><p><strong>compatible</strong> 属性也叫做<strong>“兼容性”属性</strong>，这是非常重要的一个属性！compatible 属性的值是一个字符串列表，compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序，compatible 属性的值格式如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;manufacturer,model&quot;</span></code></pre></div><p>其中 <strong>manufacturer</strong> 表示厂商，<strong>model</strong> 一般是模块对应的驱动名字。</p><p>比如 imx6ull-lxg-emmc.dts 中 sound 节点是 I.MX6U-ALPHA 开发板的音频设备节点，I.MX6U-ALPHA 开发板上的音频芯片采用的欧胜(WOLFSON)出品的 WM8960，sound 节点的 compatible 属性值如下：</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx6ul-evk-wm8960&quot;</span>,<span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span><span class="hljs-comment">;</span></code></pre></div><p>属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960”，其中<strong>“fsl”</strong>表示厂商是飞思卡尔，<strong>“imx6ul-evk-wm8960”</strong>和“<strong>imx-audio-wm8960”</strong>表示驱动模块名字。</p><p>sound这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。一般驱动程序文件都会有一个OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。</p><p>比如在文件 imx-wm8960.c 中有如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">632</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">imx_wm8960_dt_ids</span>[] =</span> &#123;<span class="hljs-number">633</span> &#123; .compatible = <span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span>, &#125;,<span class="hljs-number">634</span> &#123; <span class="hljs-comment">/* sentinel */</span> &#125;<span class="hljs-number">635</span> &#125;;<span class="hljs-number">636</span> MODULE_DEVICE_TABLE(of, imx_wm8960_dt_ids);<span class="hljs-number">637</span><span class="hljs-number">638</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">imx_wm8960_driver</span> =</span> &#123;<span class="hljs-number">639</span> .driver = &#123;<span class="hljs-number">640</span> .name = <span class="hljs-string">&quot;imx-wm8960&quot;</span>,<span class="hljs-number">641</span> .pm = &amp;snd_soc_pm_ops,<span class="hljs-number">642</span> .of_match_table = imx_wm8960_dt_ids,<span class="hljs-number">643</span> &#125;,<span class="hljs-number">644</span> .probe = imx_wm8960_probe,<span class="hljs-number">645</span> .remove = imx_wm8960_remove,<span class="hljs-number">646</span> &#125;;</code></pre></div><p><strong>第 632~635 行</strong>的数组 imx_wm8960_dt_ids 就是 imx-wm8960.c 这个驱动文件的匹配表，此匹配表只有一个匹配值“fsl,imx-audio-wm8960”。如果在设备树中有哪个节点的 compatible 属性值与此相等，那么这个节点就会使用此驱动文件。<br><strong>第 642 行</strong>，wm8960 采用了 platform_driver 驱动模式，关于 platform_driver 驱动后面会讲解。此行设置.of_match_table 为 imx_wm8960_dt_ids，也就是设置这个platform_driver 所使用的OF 匹配表。</p><hr><h4 id="2-、model-属性"><a href="#2-、model-属性" class="headerlink" title="2 、model  属性"></a><strong>2 、model  属性</strong></h4><p>model 属性值也是一个字符串，一般 model 属性<strong>描述设备模块信息</strong>，比如名字什么的，比如：</p><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">model</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wm8960-audio&quot;</span><span class="hljs-comment">;</span></code></pre></div><hr><h4 id="3-、status-属性"><a href="#3-、status-属性" class="headerlink" title="3 、status  属性"></a><strong>3 、status  属性</strong></h4><p>status 属性看名字就知道是和<strong>设备状态</strong>有关的，status 属性值也是字符串，字符串是设备的状态信息，可选的状态如表 43.3.3.1 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820192141947.png" alt="image-20200820192141947"></p><hr><h4 id="4-、-address-cells-和-size-cells-属性"><a href="#4-、-address-cells-和-size-cells-属性" class="headerlink" title="4 、#address-cells  和#size-cells  属性"></a><strong>4 、#address-cells  和#size-cells  属性</strong></h4><p>这两个属性的值都是无符号 32 位整形，#address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备中，用于<strong>描述子节点的地址信息</strong>。</p><p>#address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)</p><p>#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。</p><p>#address-cells 和#size-cells 表明了子节点应该如何编写 reg 属性值，<strong>一般 reg 属性都是和地址有关的内容</strong>，和地址相关的信息有两种：<strong>起始地址</strong>和<strong>地址长度</strong>，reg 属性的格式一为：</p><div class="hljs code-wrapper"><pre><code class="hljs gcode">reg = &lt;address<span class="hljs-number">1</span> <span class="hljs-keyword">le</span><span class="hljs-symbol">ngth1</span> address<span class="hljs-number">2</span> <span class="hljs-keyword">le</span><span class="hljs-symbol">ngth2</span> address<span class="hljs-number">3</span> <span class="hljs-keyword">le</span><span class="hljs-symbol">ngth3</span>……&gt;</code></pre></div><p><strong>每个“address length”组合表示一个地址范围</strong>，其中 <strong>address 是起始地址</strong>，<strong>length 是地址长度</strong>，#address-cells 表明 address 这个数据所占用的字长，#size-cells 表明 length 这个数据所占用的字长，比如:</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820192517802.png" alt="image-20200820192517802"></p><p><strong>第 3，4 行</strong>，节点 spi4 的#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;0&gt;，说明 spi4 的子节点 reg 属性中起始地址所占用的字长为 1，地址长度所占用的字长为 0。</p><p><strong>第 8 行</strong>，子节点 gpio_spi: gpio_spi@0 的 reg 属性值为 &lt;0&gt;，因为父节点设置了#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;0&gt;，因此 addres&#x3D;0，没有 length 的值，相当于设置了起始地址，而没有设置地址长度。</p><p><strong>第 14，15 行</strong>，设置 aips3: aips-bus@02200000 节点#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，说明 aips3: aips-bus@02200000 节点起始地址长度所占用的字长为 1，地址长度所占用的字长也为 1。</p><p><strong>第 19 行</strong>，子节点 dcp: dcp@02280000 的 reg 属性值为&lt;0x02280000 0x4000&gt;，因为父节点设置了#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，所以 address&#x3D; 0x02280000，length&#x3D; 0x4000，相当于设置了起始地址为 0x02280000，地址长度为 0x40000。</p><hr><h4 id="5-、reg-属性"><a href="#5-、reg-属性" class="headerlink" title="5 、reg  属性"></a><strong>5 、reg  属性</strong></h4><p>reg 属性前面已经提到过了，reg 属性的值一般是(address，length)对。reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息，比如在 imx6ull.dtsi 中有如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">323</span> uart1: serial@<span class="hljs-number">02020000</span> &#123;<span class="hljs-number">324</span>compatible = <span class="hljs-string">&quot;fsl,imx6ul-uart&quot;</span>,<span class="hljs-number">325</span>  <span class="hljs-string">&quot;fsl,imx6q-uart&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-uart&quot;</span>;<span class="hljs-number">326</span> reg = &lt;<span class="hljs-number">0x02020000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">327</span> interrupts = &lt;GIC_SPI <span class="hljs-number">26</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-number">328</span> clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,<span class="hljs-number">329</span>  &lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;<span class="hljs-number">330</span> clock-names = <span class="hljs-string">&quot;ipg&quot;</span>, <span class="hljs-string">&quot;per&quot;</span>;<span class="hljs-number">331</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<span class="hljs-number">332</span> &#125;;</code></pre></div><p>上述代码是节点 uart1，uart1 节点描述了 I.MX6ULL 的 UART1 相关信息，重点是第 326 行的 reg 属性。</p><p>其中 uart1 的父节点 aips1: aips-bus@02000000 设置了#address-cells &#x3D; &lt;1&gt;、#size-cells &#x3D; &lt;1&gt;，因此 reg 属性中 address&#x3D;0x02020000，length&#x3D;0x4000。</p><p>查阅《I.MX6ULL 参考手册》可知，I.MX6ULL 的 UART1 寄存器首地址为 0x02020000，但是 UART1 的地址长度(范围)并没有 0x4000 这么多，这里我们重点是获取 UART1 寄存器首地址。</p><hr><h4 id="6-、ranges-属性"><a href="#6-、ranges-属性" class="headerlink" title="6 、ranges  属性"></a><strong>6 、ranges  属性</strong></h4><p>ranges属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字矩阵，ranges 是一个地址映射&#x2F;转换表，ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成：</p><p><strong>child-bus-address</strong>：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址所占用的字长。<br><strong>parent-bus-address</strong> ：父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物理地址所占用的字长。<br><strong>length</strong> ：子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长。</p><p>如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换，对于我们所使用的 I.MX6ULL 来说，子地址空间和父地址空间完全相同，因此会在 imx6ull.dtsi中找到大量的值为空的 ranges 属性，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">137</span> soc &#123;<span class="hljs-number">138</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">139</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">140</span> compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<span class="hljs-number">141</span> interrupt-parent = &lt;&amp;gpc&gt;;<span class="hljs-number">142</span> ranges;......<span class="hljs-number">1177</span> &#125;</code></pre></div><p><strong>第 142 行定义了 ranges 属性</strong>，但是 ranges 属性值为空。ranges 属性不为空的示例代码如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> soc &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<span class="hljs-number">3</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">4</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">5</span> ranges = &lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0xe0000000</span> <span class="hljs-number">0x00100000</span>&gt;;<span class="hljs-number">6</span><span class="hljs-number">7</span> serial &#123;<span class="hljs-number">8</span> device_type = <span class="hljs-string">&quot;serial&quot;</span>;<span class="hljs-number">9</span> compatible = <span class="hljs-string">&quot;ns16550&quot;</span>;<span class="hljs-number">10</span> reg = &lt;<span class="hljs-number">0x4600</span> <span class="hljs-number">0x100</span>&gt;;<span class="hljs-number">11</span> clock-frequency = &lt;<span class="hljs-number">0</span>&gt;;<span class="hljs-number">12</span> interrupts = &lt;<span class="hljs-number">0xA</span> <span class="hljs-number">0x8</span>&gt;;<span class="hljs-number">13</span> interrupt-parent = &lt;&amp;ipic&gt;;<span class="hljs-number">14</span> &#125;;<span class="hljs-number">15</span> &#125;;</code></pre></div><p><strong>第 5 行</strong>，节点 soc 定义的 ranges 属性，值为&lt;0x0 0xe0000000 0x00100000&gt;，此属性值指定了一个 1024KB(0x00100000)的地址范围，子地址空间的物理起始地址为 0x0，父地址空间的物理起始地址为 0xe0000000。<br><strong>第 10 行</strong>，serial 是串口设备节点，reg 属性定义了 serial 设备寄存器的起始地址为 0x4600，寄存器长度为 0x100。经过地址转换，serial 设备可以从 0xe0004600 开始进行读写操作，0xe0004600&#x3D;0x4600+0xe0000000。</p><hr><h4 id="7-、name-属性"><a href="#7-、name-属性" class="headerlink" title="7 、name  属性"></a><strong>7 、name  属性</strong></h4><p>name 属性值为字符串，name 属性<strong>用于记录节点名字</strong>，name 属性已经被弃用，不推荐使用name 属性，一些老的设备树文件可能会使用此属性。</p><hr><h4 id="8-、device-type-属性"><a href="#8-、device-type-属性" class="headerlink" title="8 、device_type  属性"></a><strong>8 、device_type  属性</strong></h4><p>device_type 属性值为字符串，IEEE 1275 会用到此属性，用于<strong>描述设备的 FCode</strong>，但是设备树没有 FCode，所以此属性也<strong>被抛弃</strong>了。此属性<strong>只能用于 cpu 节点或者 memory 节点</strong>。imx6ull.dtsi 的 cpu0 节点用到了此属性，内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">54</span> cpu0: cpu@<span class="hljs-number">0</span> &#123;<span class="hljs-number">55</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<span class="hljs-number">56</span> device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<span class="hljs-number">57</span> reg = &lt;<span class="hljs-number">0</span>&gt;;......<span class="hljs-number">89</span> &#125;;</code></pre></div><p>关于标准属性就讲解这么多，其他的比如中断、IIC、SPI 等使用的标准属性等到具体的例程再讲解</p><h3 id="4-根节点-compatible-属性"><a href="#4-根节点-compatible-属性" class="headerlink" title="4|根节点 compatible 属性"></a>4|根节点 compatible 属性</h3><p>每个节点都有 compatible 属性，根节点“&#x2F;”也不例外，imx6ull-lxg-emmc.dts 文件中根节点的 compatible 属性内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">14</span> / &#123;<span class="hljs-number">15</span> model = <span class="hljs-string">&quot;Freescale i.MX6 ULL 14x14 EVK Board&quot;</span>;<span class="hljs-number">16</span> compatible = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;......<span class="hljs-number">148</span> &#125;</code></pre></div><p>可以看出，compatible 有两个值：“fsl,imx6ull-14x14-evk”和“fsl,imx6ull”。前面我们说了，设备节点的 compatible 属性值是为了匹配 Linux 内核中的驱动程序，那么根节点中的 compatible属性是为了做什么工作的？ 通过根节点的 compatible 属性可以知道我们所使用的设备，一般第一个值描述了所使用的硬件设备名字，比如这里使用的是“imx6ull-14x14-evk”这个设备，第二个值描述了设备所使用的 SOC，比如这里使用的是“imx6ull”这颗 SOC。Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。接下来我们就来学习一下 Linux 内核在使用设备树前后是如何判断是否支持某款设备的。</p><h4 id="1、使用设备树之前设备匹配方法"><a href="#1、使用设备树之前设备匹配方法" class="headerlink" title="1、使用设备树之前设备匹配方法"></a>1、使用设备树之前设备匹配方法</h4><p>在没有使用设备树以前，uboot 会向 Linux 内核传递一个叫做 machine id 的值，machine id也就是设备 ID，告诉 Linux 内核自己是个什么设备，看看 Linux 内核是否支持。Linux 内核是支持很多设备的，针对每一个设备(板子)，Linux内核都用<strong>MACHINE_START</strong>和<strong>MACHINE_END</strong>来定义一个 machine_desc 结构体来描述这个设备，比如在文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-mx35_3ds.c 中有如下定义：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">613</span> MACHINE_START(MX35_3DS, <span class="hljs-string">&quot;Freescale MX35PDK&quot;</span>)<span class="hljs-number">614</span> <span class="hljs-comment">/* Maintainer: Freescale Semiconductor, Inc */</span><span class="hljs-number">615</span> .atag_offset = <span class="hljs-number">0x100</span>,<span class="hljs-number">616</span> .map_io = mx35_map_io,<span class="hljs-number">617</span> .init_early = imx35_init_early,<span class="hljs-number">618</span> .init_irq = mx35_init_irq,<span class="hljs-number">619</span> .init_time = mx35pdk_timer_init,<span class="hljs-number">620</span> .init_machine = mx35_3ds_init,<span class="hljs-number">621</span> .reserve = mx35_3ds_reserve,<span class="hljs-number">622</span> .restart = mxc_restart,<span class="hljs-number">623</span> MACHINE_END</code></pre></div><p>其中 MACHINE_START 和MACHINE_END 定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h 中</p><p>根据 MACHINE_START 和 MACHINE_END 的宏定义，将示例代码展开后如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_desc</span> __<span class="hljs-title">mach_desc_MX35_3DS</span> \</span><span class="hljs-class">2 __<span class="hljs-title">used</span> \</span><span class="hljs-class">3 __<span class="hljs-title">attribute__</span>((__<span class="hljs-title">section__</span>(&quot;.<span class="hljs-title">arch</span>.<span class="hljs-title">info</span>.<span class="hljs-title">init</span>&quot;))) =</span> &#123;<span class="hljs-number">4</span> .nr = MACH_TYPE_MX35_3DS,<span class="hljs-number">5</span> .name = <span class="hljs-string">&quot;Freescale MX35PDK&quot;</span>,<span class="hljs-number">6</span> <span class="hljs-comment">/* Maintainer: Freescale Semiconductor, Inc */</span><span class="hljs-number">7</span> .atag_offset = <span class="hljs-number">0x100</span>,<span class="hljs-number">8</span> .map_io = mx35_map_io,<span class="hljs-number">9</span> .init_early = imx35_init_early,<span class="hljs-number">10</span> .init_irq = mx35_init_irq,<span class="hljs-number">11</span> .init_time = mx35pdk_timer_init,<span class="hljs-number">12</span> .init_machine = mx35_3ds_init,<span class="hljs-number">13</span> .reserve = mx35_3ds_reserve,<span class="hljs-number">14</span> .restart = mxc_restart,<span class="hljs-number">15</span> &#125;;</code></pre></div><p>从示例代码中可以看出，这里定义了一个 machine_desc 类型的结构体变量__mach_desc_MX35_3DS ， 这 个 变 量 存 储 在 “ .arch.info.init ” 段 中 。 第 4 行 的MACH_TYPE_MX35_3DS 就 是 “ Freescale MX35PDK ” 这 个 板 子 的 machine id 。</p><p>前面说了，uboot 会给 Linux 内核传递 machine id 这个参数，Linux 内核会检查这个machine id，其实就是将 machine id 与 include&#x2F;generated&#x2F;mach-types.h 中的这些 MACH_TYPE_XXX 宏进行对比，看看有没有相等的，如果相等的话就表示 Linux 内核支持这个设备，如果不支持的话那么这个设备就没法启动 Linux 内核。</p><h4 id="2、使用设备树以后的设备匹配方法"><a href="#2、使用设备树以后的设备匹配方法" class="headerlink" title="2、使用设备树以后的设备匹配方法"></a>2、使用设备树以后的设备匹配方法</h4><p>当 Linux 内核引入设备树以后就不再使用 <strong>MACHINE_START</strong> 了，而是换为了<strong>DT_MACHINE_START</strong>。<strong>DT_MACHINE_START</strong> 也定义在文件arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h 里面，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_MACHINE_START(_name, _namestr) \</span><span class="hljs-meta">static const struct machine_desc __mach_desc_##_name \</span><span class="hljs-meta">__used \</span><span class="hljs-meta">__attribute__((__section__(<span class="hljs-string">&quot;.arch.info.init&quot;</span>))) = &#123; \</span><span class="hljs-meta">.nr = ~0, \</span><span class="hljs-meta">.name = _namestr,</span></code></pre></div><p>可以看出，<strong>DT_MACHINE_START</strong> 和 <strong>MACHINE_START</strong> 基本相同，只是.nr 的设置不同，在 <strong>DT_MACHINE_START</strong> 里面直接将.nr 设置为~0。说明引入设备树以后不会再根据 machine id 来检查 Linux 内核是否支持某个设备了。<br>打开文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-imx6ul.c，有如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">208</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *imx6ul_dt_compat[] __initconst = &#123;<span class="hljs-number">209</span> <span class="hljs-string">&quot;fsl,imx6ul&quot;</span>,<span class="hljs-number">210</span> <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>,<span class="hljs-number">211</span> <span class="hljs-literal">NULL</span>,<span class="hljs-number">212</span> &#125;;<span class="hljs-number">213</span><span class="hljs-number">214</span> DT_MACHINE_START(IMX6UL, <span class="hljs-string">&quot;Freescale i.MX6 Ultralite (Device Tree)&quot;</span>)<span class="hljs-number">215</span> .map_io = imx6ul_map_io,<span class="hljs-number">216</span> .init_irq = imx6ul_init_irq,<span class="hljs-number">217</span> .init_machine = imx6ul_init_machine,<span class="hljs-number">218</span> .init_late = imx6ul_init_late,<span class="hljs-number">219</span> .dt_compat = imx6ul_dt_compat,<span class="hljs-number">220</span> MACHINE_END</code></pre></div><p>machine_desc 结构体中有个**.dt_compat** 成员变量，<strong>此成员变量保存着本设备兼容属性</strong>，示例代码中设置.dt_compat &#x3D; <strong>imx6ul_dt_compat</strong>，<strong>imx6ul_dt_compat</strong> 表里面有”fsl,imx6ul”和”fsl,imx6ull”这两个兼容值。只要某个设备(板子)根节点“&#x2F;”的 compatible 属性值与imx6ul_dt_compat 表中的任何一个值相等，那么就表示 Linux 内核支持此设备。imx6ull-lxg-emmc.dts 中根节点的 compatible 属性值如下：</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span><span class="hljs-comment">;</span></code></pre></div><p>其中“fsl,imx6ull”与 imx6ul_dt_compat 中的“fsl,imx6ull”匹配，因此 I.MX6U-ALPHA 开发板可以正常启动 Linux 内核。</p><p>接下来我们简单看一下 Linux 内核是如何根据设备树根节点的 compatible 属性来匹配出对应的 <strong>machine_desc</strong>，Linux 内核调用 start_kernel 函数来启动内核，start_kernel 函数会调用setup_arch 函数来匹配 machine_desc，setup_arch 函数定义在文件arch&#x2F;arm&#x2F;kernel&#x2F;setup.c 中，函数内容如下(有缩减)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">913</span> <span class="hljs-type">void</span> __init <span class="hljs-title function_">setup_arch</span><span class="hljs-params">(<span class="hljs-type">char</span> **cmdline_p)</span>914 &#123;<span class="hljs-number">915</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_desc</span> *<span class="hljs-title">mdesc</span>;</span><span class="hljs-number">916</span><span class="hljs-number">917</span> setup_processor();<span class="hljs-number">918</span> mdesc = setup_machine_fdt(__atags_pointer);<span class="hljs-number">919</span> <span class="hljs-keyword">if</span> (!mdesc)<span class="hljs-number">920</span> mdesc = setup_machine_tags(__atags_pointer,__machine_arch_type);<span class="hljs-number">921</span> machine_desc = mdesc;<span class="hljs-number">922</span> machine_name = mdesc-&gt;name;......<span class="hljs-number">986</span> &#125;</code></pre></div><p>第 918 行，调用 setup_machine_fdt 函数来获取匹配的 machine_desc，参数就是 atags 的首地址，也就是 uboot 传递给 Linux 内核的 dtb 文件首地址，setup_machine_fdt 函数的返回值就是找到的最匹配的 machine_desc。</p><p><strong>具体详情参考正点原子IMX6U驱动开发指南43.3.4节</strong></p><h3 id="5-向节点追加或修改内容"><a href="#5-向节点追加或修改内容" class="headerlink" title="5|向节点追加或修改内容"></a>5|向节点追加或修改内容</h3><p>产品开发过程中可能面临着频繁的需求更改，比如第一版硬件上有一个 IIC 接口的六轴芯片 MPU6050，第二版硬件又要把这个 MPU6050 更换为 MPU9250 等。一旦硬件修改了，我们就要同步的修改设备树文件，毕竟设备树是描述板子硬件信息的文件。假设现在有个六轴芯片 fxls8471，fxls8471 要接到 I.MX6U-ALPHA 开发板的 I2C1 接口上，那么相当于需要在 i2c1 这个节点上添加一个 fxls8471 子节点。先看一下 I2C1 接口对应的节点，打开文件 imx6ull.dtsi 文件，找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">937</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<span class="hljs-number">938</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">939</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><span class="hljs-number">940</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<span class="hljs-number">941</span> reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">942</span> interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-number">943</span> clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<span class="hljs-number">944</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<span class="hljs-number">945</span> &#125;;</code></pre></div><p>示例代码 就是 I.MX6ULL 的 I2C1 节点，现在要在 i2c1 节点下创建一个子节点，这个子节点就是 fxls8471，最简单的方法就是在 i2c1 下直接添加一个名为 fxls8471 的子节点，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">937</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<span class="hljs-number">938</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">939</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><span class="hljs-number">940</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<span class="hljs-number">941</span> reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-number">942</span> interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-number">943</span> clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<span class="hljs-number">944</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<span class="hljs-number">945</span><span class="hljs-number">946</span> <span class="hljs-comment">//fxls8471 子节点</span><span class="hljs-number">947</span> fxls8471@<span class="hljs-number">1</span>e &#123;<span class="hljs-number">948</span> compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;<span class="hljs-number">949</span> reg = &lt;<span class="hljs-number">0x1e</span>&gt;;<span class="hljs-number">950</span> &#125;;<span class="hljs-number">951</span> &#125;;</code></pre></div><p>第 947~950 行就是添加的 fxls8471 这个芯片对应的子节点。但是这样会有个问题！i2c1 节点是定义在 imx6ull.dtsi 文件中的，而 imx6ull.dtsi 是设备树头文件，其他所有使用到 I.MX6ULL这颗 SOC 的板子都会引用 imx6ull.dtsi 这个文件。直接在 i2c1 节点中添加 fxls8471 就相当于在其他的所有板子上都添加了 fxls8471 这个设备，但是其他的板子并没有这个设备啊！因此，按照示例代码 这样写肯定是不行的。</p><p>这里就要引入另外一个内容，那就是如何向节点追加数据，<strong>我们现在要解决的就是如何向i2c1 节点追加一个名为 fxls8471 的子节点，而且不能影响到其他使用到 I.MX6ULL 的板子</strong>。I.MX6U-ALPHA 开发板使用的设备树文件为 imx6ull-lxg-emmc.dts，因此我们需要在imx6ull-lxg-emmc.dts 文件中完成数据追加的内容，方式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> &amp;i2c1 &#123;<span class="hljs-number">2</span> <span class="hljs-comment">/* 要追加或修改的内容 */</span><span class="hljs-number">3</span> &#125;;</code></pre></div><p>第 1 行，&amp;i2c1 表示要访问 i2c1 这个 label 所对应的节点，也就是 imx6ull.dtsi 中的“i2c1:i2c@021a0000”。<br>第 2 行，花括号内就是要向 i2c1 这个节点添加的内容，包括修改某些属性的值。打开 imx6ull-lxg-emmc.dts，找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">224</span> &amp;i2c1 &#123;<span class="hljs-number">225</span> clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<span class="hljs-number">226</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<span class="hljs-number">227</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;<span class="hljs-number">228</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">229</span><span class="hljs-number">230</span> mag3110@<span class="hljs-number">0</span>e &#123;<span class="hljs-number">231</span> compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;<span class="hljs-number">232</span> reg = &lt;<span class="hljs-number">0x0e</span>&gt;;<span class="hljs-number">233</span> position = &lt;<span class="hljs-number">2</span>&gt;;<span class="hljs-number">234</span> &#125;;<span class="hljs-number">235</span><span class="hljs-number">236</span> fxls8471@<span class="hljs-number">1</span>e &#123;<span class="hljs-number">237</span> compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;<span class="hljs-number">238</span> reg = &lt;<span class="hljs-number">0x1e</span>&gt;;<span class="hljs-number">239</span> position = &lt;<span class="hljs-number">0</span>&gt;;<span class="hljs-number">240</span> interrupt-parent = &lt;&amp;gpio5&gt;;<span class="hljs-number">241</span> interrupts = &lt;<span class="hljs-number">0</span> <span class="hljs-number">8</span>&gt;;<span class="hljs-number">242</span> &#125;;<span class="hljs-number">243</span> &#125;;</code></pre></div><p>示例代码  就是向 i2c1 节点添加&#x2F;修改数据</p><p><strong>第 225 行</strong>的属性“clock-frequency”就表示 i2c1 时钟为 100KHz。“clock-frequency”就是新添加的属性。<br><strong>第 228 行</strong>，将 status 属性的值由原来的 disabled 改为 okay。<br><strong>第 230~234 行</strong>，i2c1 子节点 mag3110，因为 NXP 官方开发板在 I2C1 上接了一个磁力计芯片 mag3110，正点原子的 I.MX6U-ALPHA 开发板并没有使用 mag3110。<br><strong>第 236~242 行</strong>，i2c1 子节点 fxls8471，同样是因为 NXP 官方开发板在 I2C1 上接了 fxls8471这颗六轴芯片。</p><p>因为示例代码 中的内容是 imx6ull-lxg-emmc.dts 这个文件内的，所以不会对使用 I.MX6ULL 这颗 SOC 的其他板子造成任何影响。这个就是向节点追加或修改内容，重点就是通过&amp;label 来访问节点，然后直接在里面编写要追加或者修改的内容</p><h2 id="四、创建小型模板设备树"><a href="#四、创建小型模板设备树" class="headerlink" title="四、创建小型模板设备树"></a>四、创建小型模板设备树</h2><p>上一节已经对 DTS 的语法做了比较详细的讲解，本节我们就根据前面讲解的语法，从头到尾编写一个小型的设备树文件。当然了，这个小型设备树没有实际的意义，做这个的目的是为了掌握设备树的语法。在实际产品开发中，我们是不需要完完全全的重写一个.dts 设备树文件，一般都是使用 SOC 厂商提供好的.dts 文件，我们只需要在上面根据自己的实际情况做相应的修改即可。在编写设备树之前要先定义一个设备，我们就以 I.MX6ULL 这个 SOC 为例，我们需要在设备树里面描述的内容如下：</p><p>①、I.MX6ULL 这个 Cortex-A7 架构的 32 位 CPU。<br>②、I.MX6ULL 内部 ocram，起始地址 0x00900000，大小为 128KB(0x20000)。<br>③、I.MX6ULL 内部 aips1 域下的 ecspi1 外设控制器，寄存器起始地址为 0x02008000 大<br>小为 0x4000。<br>④、I.MX6ULL 内部 aips2 域下的 usbotg1 外设控制器，寄存器起始地址为0x02184000，大小为 0x4000。<br>⑤、I.MX6ULL 内部 aips3 域下的 rngb 外设控制器，寄存器起始地址为 0x02284000，大小为 0x4000。</p><p>为了简单起见，我们就在设备树里面就实现这些内容即可，首先，搭建一个仅含有根节点“&#x2F;”的基础的框架，新建一个名为 myfirst.dts 文件，在里面输入如下所示内容</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> / &#123;<span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<span class="hljs-number">3</span> &#125;</code></pre></div><p>设备树框架很简单，就一个根节点“&#x2F;”，根节点里面只有一个 compatible 属性。我们就在这个基础框架上面将上面列出的内容一点点添加进来。</p><h3 id="1-添加-cpus-节点"><a href="#1-添加-cpus-节点" class="headerlink" title="1|添加 cpus  节点"></a>1|添加 cpus  节点</h3><p>首先添加 CPU 节点，I.MX6ULL 采用 Cortex-A7 架构，而且只有一个 CPU，因此只有一个cpu0 节点，完成以后如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">/&#123;    compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;    cpus &#123;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>        <span class="hljs-comment">//cpu0节点</span>        cpu0:cpu@<span class="hljs-number">0</span> &#123;            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;            reg = &lt;<span class="hljs-number">0</span>&gt;;        &#125;;    &#125;;&#125;;</code></pre></div><p>cpus 节点，此节点用于描述 SOC 内部的所有 CPU，因为 I.MX6ULL 只有一个CPU，因此只有一个 cpu0 子节点。</p><h3 id="2-添加-soc-节点"><a href="#2-添加-soc-节点" class="headerlink" title="2|添加 soc  节点"></a>2|添加 soc  节点</h3><p>像 uart，iic 控制器等等这些都属于 SOC 内部外设，因此一般会创建一个叫做 soc 的父节点来管理这些 SOC 内部外设的子节点，添加 soc 节点以后的 myfirst.dts 文件内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">/&#123;    compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;    cpus &#123;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>        <span class="hljs-comment">//cpu0节点</span>        cpu0:cpu@<span class="hljs-number">0</span> &#123;            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;            reg = &lt;<span class="hljs-number">0</span>&gt;;        &#125;;    &#125;;    <span class="hljs-comment">//soc 节点</span>    soc &#123;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;        ranges;    &#125;;&#125;;</code></pre></div><p>soc 节点，soc 节点设置#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，这样 soc 子节点的 reg 属性中起始地占用一个字长，地址空间长度也占用一个字长。ranges 属性，ranges 属性为空，说明子空间和父空间地址范围相同。</p><h3 id="3-添加-ocram-节点"><a href="#3-添加-ocram-节点" class="headerlink" title="3|添加 ocram  节点"></a>3|添加 ocram  节点</h3><p>根据第②点的要求，添加 ocram 节点，ocram 是 I.MX6ULL 内部 RAM，因此 ocram 节点应该是 soc 节点的子节点。ocram 起始地址为 0x00900000，大小为128KB(0x20000)，添加 ocram节点以后 myfirst.dts 文件内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">/&#123;    compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;    cpus &#123;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>        <span class="hljs-comment">//cpu0节点</span>        cpu0:cpu@<span class="hljs-number">0</span> &#123;            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;            reg = &lt;<span class="hljs-number">0</span>&gt;;        &#125;;    &#125;;    <span class="hljs-comment">//soc 节点</span>    soc &#123;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;        ranges;        <span class="hljs-comment">//ocram 节点</span>        ocram: sram@<span class="hljs-number">00900000</span> &#123;            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;        &#125;;    &#125;;&#125;;</code></pre></div><p>ocram 节点，节点名字@后面的 0x00900000 就是 ocram 的起始地址。reg 属性也指明了 ocram 内存的起始地址为 0x00900000，大小为 0x20000。</p><h3 id="4-添加-aips1-、aips2-和-和-aips3-这三个子节点"><a href="#4-添加-aips1-、aips2-和-和-aips3-这三个子节点" class="headerlink" title="4|添加 aips1 、aips2 和 和 aips3 这三个子节点"></a>4|添加 aips1 、aips2 和 和 aips3 这三个子节点</h3><p>I.MX6ULL 内部分为三个域：aips1<del>3，这三个域分管不同的外设控制器，aips1</del>3 这三个域对应的内存范围如表所示</p><table><thead><tr><th align="center">域</th><th align="center">起始地址</th><th align="center">大小( 十六进制)</th></tr></thead><tbody><tr><td align="center">AIPS1</td><td align="center">0X02000000</td><td align="center">0X100000</td></tr><tr><td align="center">AIPS2</td><td align="center">0X02100000</td><td align="center">0X100000</td></tr><tr><td align="center">AIPS3</td><td align="center">0X02200000</td><td align="center">0X100000</td></tr></tbody></table><p>我们先在设备树中添加这三个域对应的子节点。aips1~3这三个域都属于soc节点的子节点，完成以后的 myfirst.dts 文件内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-title class_">/</span><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span><span class="hljs-punctuation">;</span>    <span class="hljs-title class_">cpus</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>        <span class="hljs-meta">#size-cells = &lt;0&gt;;</span>        <span class="hljs-comment">//cpu0节点</span><span class="hljs-symbol">        cpu0:</span><span class="hljs-title class_">cpu@0</span> <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;arm,cortex-a7&quot;</span><span class="hljs-punctuation">;</span>            device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cpu&quot;</span><span class="hljs-punctuation">;</span>            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span>        <span class="hljs-punctuation">&#125;;</span>    <span class="hljs-punctuation">&#125;;</span>    <span class="hljs-comment">//soc 节点</span>    <span class="hljs-title class_">soc</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>        <span class="hljs-meta">#size-cells = &lt;1&gt;;</span>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span>        <span class="hljs-attr">ranges</span><span class="hljs-punctuation">;</span>        <span class="hljs-comment">//ocram 节点</span><span class="hljs-symbol">        ocram:</span> <span class="hljs-title class_">sram@00900000</span> <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span><span class="hljs-punctuation">;</span>            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;</span><span class="hljs-punctuation">;</span>        <span class="hljs-punctuation">&#125;;</span>    <span class="hljs-punctuation">&#125;;</span>    <span class="hljs-comment">//aips1  节点</span><span class="hljs-symbol">    aips1:</span> <span class="hljs-title class_">aips-bus@02000000</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span>        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>        <span class="hljs-meta">#size-cells = &lt;1&gt;;</span>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;</span><span class="hljs-punctuation">;</span>        <span class="hljs-attr">ranges</span><span class="hljs-punctuation">;</span>    <span class="hljs-punctuation">&#125;;</span>    <span class="hljs-comment">//aips2  节点</span><span class="hljs-symbol">    aips2:</span> <span class="hljs-title class_">aips-bus@02100000</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span>        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>        <span class="hljs-meta">#size-cells = &lt;1&gt;;</span>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;</span><span class="hljs-punctuation">;</span>        <span class="hljs-attr">ranges</span><span class="hljs-punctuation">;</span>    <span class="hljs-punctuation">&#125;;</span>    <span class="hljs-comment">//aips3  节点</span><span class="hljs-symbol">    aips3:</span> <span class="hljs-title class_">aips-bus@02200000</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span>        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>        <span class="hljs-meta">#size-cells = &lt;1&gt;;</span>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;</span><span class="hljs-punctuation">;</span>        <span class="hljs-attr">ranges</span><span class="hljs-punctuation">;</span>    <span class="hljs-punctuation">&#125;;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><h3 id="5-添加-ecspi1-、usbotg1-和-和-rngb-这三个外设控制器节点"><a href="#5-添加-ecspi1-、usbotg1-和-和-rngb-这三个外设控制器节点" class="headerlink" title="5|添加 ecspi1 、usbotg1 和 和 rngb 这三个外设控制器节点"></a>5|添加 ecspi1 、usbotg1 和 和 rngb 这三个外设控制器节点</h3><p>最后我们在 myfirst.dts 文件中加入 ecspi1，usbotg1 和 rngb 这三个外设控制器对应的节点，其中 ecspi1 属于 aips1 的子节点，usbotg1 属于 aips2 的子节点，rngb 属于aips3 的子节点。最终的 myfirst.dts 文件内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">/&#123;    compatible = <span class="hljs-string">&quot;fsl,imx6ull-lxg-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;    cpus &#123;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>        <span class="hljs-comment">//cpu0节点</span>        cpu0:cpu@<span class="hljs-number">0</span> &#123;            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;            reg = &lt;<span class="hljs-number">0</span>&gt;;        &#125;;    &#125;;    <span class="hljs-comment">//soc 节点</span>    soc &#123;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;        ranges;        <span class="hljs-comment">//ocram 节点</span>        ocram: sram@<span class="hljs-number">00900000</span> &#123;            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;        &#125;;    &#125;;    <span class="hljs-comment">//aips1  节点</span>    aips1: aips-bus@<span class="hljs-number">02000000</span> &#123;        compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        reg = &lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;;        ranges;        <span class="hljs-comment">//ecspi1 节点</span>        ecspi1: ecspi@<span class="hljs-number">02008000</span> &#123;            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>            compatible = <span class="hljs-string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="hljs-string">&quot;fsl,imx51-ecspi&quot;</span>;            reg = &lt;<span class="hljs-number">0x02008000</span> <span class="hljs-number">0x4000</span>&gt;;            status = <span class="hljs-string">&quot;disabled&quot;</span>;        &#125;;    &#125;;    <span class="hljs-comment">//aips2  节点</span>    aips2: aips-bus@<span class="hljs-number">02100000</span> &#123;        compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        reg = &lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;;        ranges;        <span class="hljs-comment">//usbotg1 节点</span>        usbotg1: usb@<span class="hljs-number">02184000</span> &#123;            compatible = <span class="hljs-string">&quot;fsl,imx6ul-usb&quot;</span>, <span class="hljs-string">&quot;fsl,imx27-usb&quot;</span>;            reg = &lt;<span class="hljs-number">0x02184000</span> <span class="hljs-number">0x200</span>&gt;;            status = <span class="hljs-string">&quot;disabled&quot;</span>;        &#125;;        &#125;;    <span class="hljs-comment">//aips3  节点</span>    aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;        compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>        reg = &lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;;        ranges;        <span class="hljs-comment">//rngb 节点</span>        rngb: rngb@<span class="hljs-number">02284000</span> &#123;            compatible = <span class="hljs-string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="hljs-string">&quot;fsl,imx-rng&quot;</span>, <span class="hljs-string">&quot;imx-rng&quot;</span>;            reg = &lt;<span class="hljs-number">0x02284000</span> <span class="hljs-number">0x4000</span>&gt;;        &#125;;    &#125;;&#125;;</code></pre></div><p>至此，myfirst.dts 这个小型的模板设备树就编写好了，基本和 imx6ull.dtsi 很像，可以看做是 imx6ull.dtsi 的缩小版。在 myfirst.dts 里面我们仅仅是编写了 I.MX6ULL 的外设控制器节点，像 IIC 接口，SPI 接口下所连接的具体设备我们并没有写，因为具体的设备其设备树属性内容不同，这个等到具体的实验在详细讲解。</p><h2 id="五、设备树在系统中的体现"><a href="#五、设备树在系统中的体现" class="headerlink" title="五、设备树在系统中的体现"></a>五、设备树在系统中的体现</h2><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系统的&#x2F;proc&#x2F;device-tree 目录下根据节点名字创建不同文件夹，如图 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202310685.png" alt="image-20200820202310685"></p><p>图 就是目录&#x2F;proc&#x2F;device-tree 目录下的内容，&#x2F;proc&#x2F;device-tree 目录下是根节点“&#x2F;”的所有属性和子节点，我们依次来看一下这些属性和子节点。</p><h3 id="1-、根节点“-x2F-”各个属性"><a href="#1-、根节点“-x2F-”各个属性" class="headerlink" title="1 、根节点“&#x2F; ”各个属性"></a><strong>1 、根节点“&#x2F; ”各个属性</strong></h3><p>在图中，根节点属性属性表现为一个个的文件(图中细字体文件)，比如图中的“#address-cells”、“#size-cells”、“compatible”、“model”和“name”这 5 个文件，它们在设备树中就是根节点的5个属性。</p><p>既然是文件那么肯定可以查看其内容，输入cat命令来查看model和 compatible 这两个文件的内容，结果如图 所示</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202617800.png" alt="image-20200820202617800"></p><p>从图 可以看出，文件 model 的内容是“Freescale i.MX6 ULL 14x14 EVK Board”，文件 compatible 的内容为“fsl,imx6ull-14x14-evkfsl,imx6ull”。</p><p>打开文件 imx6ull-lxg-emmc.dts查看一下，这不正是根节点“&#x2F;”的 model 和 compatible 属性值吗！</p><h3 id="2-、根节点“-x2F-”各子节点"><a href="#2-、根节点“-x2F-”各子节点" class="headerlink" title="2 、根节点“&#x2F; ”各子节点"></a><strong>2 、根节点“&#x2F; ”各子节点</strong></h3><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202310685.png" alt="image-20200820202310685"></p><p>图中各个文件夹(途中粗字体文件夹)就是根节点“&#x2F;”的各个子节点，比如“aliases”、“backlight”、“chosen”和“clocks”等等。大家可以查看一下 imx6ull-lxg-emmc.dts 和 imx6ull.dtsi 这两个文件，看看根节点的子节点都有哪些，看看是否和图 中的一致。</p><p>&#x2F;proc&#x2F;device-tree 目录就是设备树在根文件系统中的体现，同样是按照树形结构组织的，进入&#x2F;proc&#x2F;device-tree&#x2F;soc 目录中就可以看到 soc 节点的所有子节点，如图  所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820202737979.png" alt="image-20200820202737979"></p><p>和根节点“&#x2F;”一样，图 中的所有文件分别为 soc 节点的属性文件和子节点文件夹。</p><h2 id="六、特殊节点"><a href="#六、特殊节点" class="headerlink" title="六、特殊节点"></a>六、特殊节点</h2><p>在根节点“&#x2F;”中有两个特殊的子节点：<strong>aliases</strong> 和 <strong>chosen</strong>，我们接下来看一下这两个特殊的子节点。</p><h3 id="aliases子节点"><a href="#aliases子节点" class="headerlink" title="aliases子节点"></a>aliases子节点</h3><p>打开 imx6ull.dtsi 文件，aliases 节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">18</span> aliases &#123;<span class="hljs-number">19</span> can0 = &amp;flexcan1;<span class="hljs-number">20</span> can1 = &amp;flexcan2;<span class="hljs-number">21</span> ethernet0 = &amp;fec1;<span class="hljs-number">22</span> ethernet1 = &amp;fec2;<span class="hljs-number">23</span> gpio0 = &amp;gpio1;<span class="hljs-number">24</span> gpio1 = &amp;gpio2;......<span class="hljs-number">42</span> spi0 = &amp;ecspi1;<span class="hljs-number">43</span> spi1 = &amp;ecspi2;<span class="hljs-number">44</span> spi2 = &amp;ecspi3;<span class="hljs-number">45</span> spi3 = &amp;ecspi4;<span class="hljs-number">46</span> usbphy0 = &amp;usbphy1;<span class="hljs-number">47</span> usbphy1 = &amp;usbphy2;<span class="hljs-number">48</span> &#125;;</code></pre></div><p>单词 aliases 的意思是“别名”，因此 aliases 节点的<strong>主要功能就是定义别</strong>名，定义别名的目的就是为了方便访问节点。不过我们一般会在节点命名的时候会加上 label，然后通过&amp;label来访问节点，这样也很方便，而且设备树里面大量的使用&amp;label 的形式来访问节点。</p><h3 id="chosen子节点"><a href="#chosen子节点" class="headerlink" title="chosen子节点"></a>chosen子节点</h3><p>chosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数。一般.dts 文件中 chosen 节点通常为空或者内容很少，imx6ull-lxg-emmc.dts 中 chosen 节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">18</span> chosen &#123;<span class="hljs-number">19</span> <span class="hljs-built_in">stdout</span>-path = &amp;uart1;<span class="hljs-number">20</span> &#125;;</code></pre></div><p>从示例代码中可以看出，chosen 节点仅仅设置了属性“stdout-path”，表示标准输出使用 uart1。但是当我们进入到&#x2F;proc&#x2F;device-tree&#x2F;chosen 目录里面，会发现多了 bootargs 这个属性，如图 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203103001.png" alt="image-20200820203103001"></p><p>输入 cat 命令查看 bootargs 这个文件的内容，结果如图所示</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203119368.png" alt="image-20200820203119368"></p><p>从图可以看出，bootargs 这个文件的内容为“console&#x3D;ttymxc0,115200……”，这个不就是我们在 uboot 中设置的 bootargs 环境变量的值吗？现在有两个疑点：<br>①、我们并没有在设备树中设置 chosen 节点的 bootargs 属性，那么图中 bootargs这个属性是怎么产生的？<br>②、为何 bootargs 文件的内容和 uboot 中 bootargs 环境变量的值一样？它们之间有什么关系？</p><p>前面讲解 uboot 的时候说过，uboot 在启动 Linux 内核的时候会将 bootargs 的值传递给 Linux内核，bootargs 会作为 Linux 内核的命令行参数，Linux 内核启动的时候会打印出命令行参数(也就是 uboot 传递进来的 bootargs 的值)，如图 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203214452.png" alt="image-20200820203214452"></p><p>既然 chosen 节点的 bootargs 属性不是我们在设备树里面设置的，那么只有一种可能，那就是 uboot 自己在 chosen 节点里面添加了 bootargs 属性！并且设置 bootargs 属性的值为 bootargs环境变量的值。因为在启动 Linux 内核之前，只有 uboot 知道 bootargs 环境变量的值，并且 uboot也知道.dtb 设备树文件在 DRAM 中的位置，因此 uboot 的“作案”嫌疑最大。在 uboot 源码中全局搜索“chosen”这个字符串，看看能不能找到一些蛛丝马迹。</p><p>果然不出所料，在common&#x2F;fdt_support.c 文件中发现了“chosen”的身影，fdt_support.c 文件中有个 fdt_chosen 函数，此函数内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">275</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fdt_chosen</span><span class="hljs-params">(<span class="hljs-type">void</span> *fdt)</span>276 &#123;<span class="hljs-number">277</span> <span class="hljs-type">int</span> nodeoffset;<span class="hljs-number">278</span> <span class="hljs-type">int</span> err;<span class="hljs-number">279</span> <span class="hljs-type">char</span> *str; <span class="hljs-comment">/* used to set string properties */</span><span class="hljs-number">280</span><span class="hljs-number">281</span> err = fdt_check_header(fdt);<span class="hljs-number">282</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-number">283</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fdt_chosen: %s\n&quot;</span>, fdt_strerror(err));<span class="hljs-number">284</span> <span class="hljs-keyword">return</span> err;<span class="hljs-number">285</span> &#125;<span class="hljs-number">286</span><span class="hljs-number">287</span> <span class="hljs-comment">/* find or create &quot;/chosen&quot; node. */</span><span class="hljs-number">288</span> nodeoffset = fdt_find_or_add_subnode(fdt, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;chosen&quot;</span>);<span class="hljs-number">289</span> <span class="hljs-keyword">if</span> (nodeoffset &lt; <span class="hljs-number">0</span>)<span class="hljs-number">290</span> <span class="hljs-keyword">return</span> nodeoffset;<span class="hljs-number">291</span><span class="hljs-number">292</span> str = getenv(<span class="hljs-string">&quot;bootargs&quot;</span>);<span class="hljs-number">293</span> <span class="hljs-keyword">if</span> (str) &#123;<span class="hljs-number">294</span> err = fdt_setprop(fdt, nodeoffset, <span class="hljs-string">&quot;bootargs&quot;</span>, str,<span class="hljs-number">295</span> <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<span class="hljs-number">296</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-number">297</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WARNING: could not set bootargs %s.\n&quot;</span>,<span class="hljs-number">298</span> fdt_strerror(err));<span class="hljs-number">299</span> <span class="hljs-keyword">return</span> err;<span class="hljs-number">300</span> &#125;<span class="hljs-number">301</span> &#125;<span class="hljs-number">302</span><span class="hljs-number">303</span> <span class="hljs-keyword">return</span> fdt_fixup_stdout(fdt, nodeoffset);<span class="hljs-number">304</span> &#125;</code></pre></div><p>第 288 行，调用函数 fdt_find_or_add_subnode 从设备树(.dtb)中找到 chosen 节点，如果没有找到的话就会自己创建一个 chosen 节点。<br>第 292 行，读取 uboot 中 bootargs 环境变量的内容。<br>第 294 行，调用函数 fdt_setprop 向 chosen 节点添加 bootargs 属性，并且 bootargs 属性的值就是环境变量 bootargs 的内容。证据“实锤”了，就是 uboot 中的 fdt_chosen 函数在设备树的 chosen 节点中加入了 bootargs属性，并且还设置了 bootargs 属性值。接下来我们顺着 fdt_chosen 函数一点点的抽丝剥茧，看看都有哪些函数调用了 fdt_chosen，一直找到最终的源头。这里我就不卖关子了，直接告诉大家整个流程是怎么样的，见图 :</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820203540965.png" alt="image-20200820203540965"></p><p>图 中框起来的部分就是函数 do_bootm_linux 函数的执行流程，也就是说do_bootm_linux 函数会通过一系列复杂的调用，最终通过 fdt_chosen 函数在 chosen 节点中加入了 bootargs 属性。而我们通过 bootz 命令启动 Linux 内核的时候会运行 do_bootm_linux 函数，至此，真相大白，一切事情的源头都源于如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">bootz</span> <span class="hljs-number">80800000</span> – <span class="hljs-number">83000000</span></code></pre></div><p>当我们输入上述命令并执行以后，do_bootz 函数就会执行，然后一切就按照图  中所示的流程开始运行。</p><h2 id="七、Linux内核解析DTB文件"><a href="#七、Linux内核解析DTB文件" class="headerlink" title="七、Linux内核解析DTB文件"></a>七、Linux内核解析DTB文件</h2><p>Linux 内核在启动的时候会解析 DTB 文件，然后在&#x2F;proc&#x2F;device-tree 目录下生成相应的设备树节点文件。接下来我们简单分析一下 Linux 内核是如何解析 DTB 文件的，流程如图  所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820211529586.png" alt="image-20200820211529586"></p><p>从图中可以看出，在 start_kernel 函数中完成了设备树节点解析的工作，最终实际工作的函数为 unflatten_dt_node。</p><h2 id="八、绑定信息文档"><a href="#八、绑定信息文档" class="headerlink" title="八、绑定信息文档"></a>八、绑定信息文档</h2><p>设备树是用来描述板子上的设备信息的，不同的设备其信息不同，反映到设备树中就是属性不同。</p><p>那么我们在设备树中添加一个硬件对应的节点的时候从哪里查阅相关的说明呢？在Linux 内核源码中有详细的.txt 文档描述了如何添加节点，这些.txt 文档叫做<strong>绑定文档</strong>，路径为：Linux 源码目录&#x2F;Documentation&#x2F;devicetree&#x2F;bindings，如图所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200820211703146.png" alt="image-20200820211703146"></p><p>比如我们现在要想在 I.MX6ULL 这颗 SOC 的 I2C 下添加一个节点，那么就可以查看<strong>Documentation&#x2F;devicetree&#x2F;bindings&#x2F;i2c&#x2F;i2c-imx.txt</strong>，此文档详细的描述了 I.MX 系列的 SOC 如何在设备树中添加 I2C 设备节点，文档内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs nix">* Freescale Inter IC (I2C) <span class="hljs-literal">and</span> High Speed Inter IC (HS-I2C) for i.MXRequired properties:- compatible :- <span class="hljs-string">&quot;fsl,imx1-i2c&quot;</span> for I2C compatible <span class="hljs-keyword">with</span> the one integrated on i.MX1SoC- <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span> for I2C compatible <span class="hljs-keyword">with</span> the one integrated on i.MX21SoC- <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span> for I2C compatible <span class="hljs-keyword">with</span> the one integrated on Vybridvf610 SoC- reg : Should contain I2C/HS-I2C registers location <span class="hljs-literal">and</span> length- interrupts : Should contain I2C/HS-I2C interrupt- clocks : Should contain the I2C/HS-I2C clock specifierOptional properties:- clock-frequency : Constains desired I2C/HS-I2C bus clock frequency <span class="hljs-keyword">in</span>Hz.The absence of the propoerty indicates the default frequency <span class="hljs-number">100</span> kHz.- dmas: A list of two dma specifiers, one for each entry <span class="hljs-keyword">in</span> dma-names.- dma-names: should contain <span class="hljs-string">&quot;tx&quot;</span> <span class="hljs-literal">and</span> <span class="hljs-string">&quot;rx&quot;</span>.Examples:i2c@<span class="hljs-number">83</span>fc4000 &#123; <span class="hljs-comment">/* I2C2 on i.MX51 */</span>    <span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;    <span class="hljs-attr">reg</span> = &lt;<span class="hljs-number">0</span>x83fc4000 <span class="hljs-number">0</span>x4000&gt;;    <span class="hljs-attr">interrupts</span> = &lt;<span class="hljs-number">63</span>&gt;;&#125;;i2c@<span class="hljs-number">70038000</span> &#123; <span class="hljs-comment">/* HS-I2C on i.MX51 */</span>    <span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;    <span class="hljs-attr">reg</span> = &lt;<span class="hljs-number">0</span>x70038000 <span class="hljs-number">0</span>x4000&gt;;    <span class="hljs-attr">interrupts</span> = &lt;<span class="hljs-number">64</span>&gt;;    <span class="hljs-attr">clock-frequency</span> = &lt;<span class="hljs-number">400000</span>&gt;;&#125;;i2c0: i2c@<span class="hljs-number">40066000</span> &#123; <span class="hljs-comment">/* i2c0 on vf610 */</span>    <span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span>;    <span class="hljs-attr">reg</span> = &lt;<span class="hljs-number">0</span>x40066000 <span class="hljs-number">0</span>x1000&gt;;    <span class="hljs-attr">interrupts</span> =&lt;<span class="hljs-number">0</span> <span class="hljs-number">71</span> <span class="hljs-number">0</span>x04&gt;;    <span class="hljs-attr">dmas</span> = &lt;&amp;edma0 <span class="hljs-number">0</span> <span class="hljs-number">50</span>&gt;,    &lt;&amp;edma0 <span class="hljs-number">0</span> <span class="hljs-number">51</span>&gt;;    <span class="hljs-attr">dma-names</span> = <span class="hljs-string">&quot;rx&quot;</span>,<span class="hljs-string">&quot;tx&quot;</span>;&#125;;</code></pre></div><p>有时候使用的一些芯片在 Documentation&#x2F;devicetree&#x2F;bindings 目录下找不到对应的文档，这个时候就要咨询芯片的提供商，让他们给你提供参考的设备树文件。</p><h2 id="九、设备树常用-OF-操作函数"><a href="#九、设备树常用-OF-操作函数" class="headerlink" title="九、设备树常用 OF  操作函数"></a>九、设备树常用 OF  操作函数</h2><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，我们在编写驱动的时候需要获取到这些信息。</p><p>比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性的0X02005482 和 0X400 这两个值，然后初始化外设。</p><p>Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 <strong>include&#x2F;linux&#x2F;of.h</strong> 文件中。</p><h3 id="1-查找节点的OF函数"><a href="#1-查找节点的OF函数" class="headerlink" title="1|查找节点的OF函数"></a>1|查找节点的OF函数</h3><p>设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。Linux 内核使用 device_node 结构体来描述一个节点，此结构体定义在文件 include&#x2F;linux&#x2F;of.h 中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> &#123;</span><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-comment">/* 节点名字 */</span><span class="hljs-type">const</span> <span class="hljs-type">char</span> *type;<span class="hljs-comment">/* 设备类型 */</span>phandle phandle;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *full_name;<span class="hljs-comment">/* 节点全名 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fwnode_handle</span> <span class="hljs-title">fwnode</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span><span class="hljs-title">property</span> *<span class="hljs-title">properties</span>;</span><span class="hljs-comment">/* 属性 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span><span class="hljs-title">property</span> *<span class="hljs-title">deadprops</span>;</span><span class="hljs-comment">/* removed 属性 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span><span class="hljs-title">device_node</span> *<span class="hljs-title">parent</span>;</span><span class="hljs-comment">/* 父节点 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span><span class="hljs-title">device_node</span> *<span class="hljs-title">child</span>;</span><span class="hljs-comment">/* 子节点 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span><span class="hljs-title">device_node</span> *<span class="hljs-title">sibling</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span><span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _flags;<span class="hljs-type">void</span>*data;<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SPARC)</span><span class="hljs-type">const</span> <span class="hljs-type">char</span> *path_component_name;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unique_id;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_irq_controller</span> *<span class="hljs-title">irq_trans</span>;</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;;</code></pre></div><p>与查找节点有关的 OF 函数有 5 个，我们依次来看一下。</p><h4 id="of-find-node-by-name-函数"><a href="#of-find-node-by-name-函数" class="headerlink" title="of_find_node_by_name  函数"></a>of_find_node_by_name  函数</h4><p>of_find_node_by_name 函数通过节点名字查找指定的节点，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from,</span><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;</code></pre></div><p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>name</strong>：要查找的节点名字。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败。</p><hr><h4 id="of-find-node-by-type-函数"><a href="#of-find-node-by-type-函数" class="headerlink" title="of_find_node_by_type 函数"></a>of_find_node_by_type 函数</h4><p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_type</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>type</strong>：要查找的节点对应的 type 字符串，也就是 device_type 属性值。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败。</p><hr><h4 id="of-find-compatible-node-函数"><a href="#of-find-compatible-node-函数" class="headerlink" title="of_find_compatible_node  函数"></a>of_find_compatible_node  函数</h4><p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_compatible_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *compatible)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>type</strong>：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为NULL，表示忽略掉 device_type 属性。<br><strong>compatible</strong> ：要查找的节点所对应的 compatible 属性列表。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败</p><hr><h4 id="of-find-matching-node-and-match-函数"><a href="#of-find-matching-node-and-match-函数" class="headerlink" title="of_find_matching_node_and_match  函数"></a>of_find_matching_node_and_match  函数</h4><p>of_find_matching_node_and_match 函数通过 of_device_id 匹配表来查找指定的节点，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_matching_node_and_match</span><span class="hljs-params">(</span><span class="hljs-params">                            <span class="hljs-keyword">struct</span> device_node *from,</span><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> of_device_id *matches, </span><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> of_device_id **match)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>matches</strong>：of_device_id 匹配表，也就是在此匹配表里面查找节点。<br><strong>match</strong> ：找到的匹配的 of_device_id。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败</p><hr><h4 id="of-find-node-by-path-函数"><a href="#of-find-node-by-path-函数" class="headerlink" title="of_find_node_by_path  函数"></a>of_find_node_by_path  函数</h4><p>of_find_node_by_path 函数通过路径来查找指定的节点，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_path</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>path</strong>：带有全路径的节点名，可以使用节点的别名，比如“&#x2F;backlight”就是 backlight 这个节点的全路径。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败</p><h3 id="2-查找父-x2F-子节点的-OF-函数"><a href="#2-查找父-x2F-子节点的-OF-函数" class="headerlink" title="2|  查找父&#x2F; 子节点的 OF  函数"></a>2|  查找父&#x2F; 子节点的 OF  函数</h3><p>Linux 内核提供了几个查找节点对应的父节点或子节点的 OF 函数，我们依次来看一下。</p><h4 id="of-get-parent-函数"><a href="#of-get-parent-函数" class="headerlink" title="of_get_parent  函数"></a>of_get_parent  函数</h4><p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_get_parent</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *node)</span></code></pre></div><p>函数参数和返回值含义如下：</p><p><strong>node</strong>：要查找的父节点的节点。<br><strong>返回值</strong>：找到的父节点。</p><hr><h4 id="of-get-next-child-函数"><a href="#of-get-next-child-函数" class="headerlink" title="of_get_next_child  函数"></a>of_get_next_child  函数</h4><p>of_get_next_child 函数用迭代的查找子节点，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_get_next_child</span><span class="hljs-params">(</span><span class="hljs-params">                                <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *node, </span><span class="hljs-params">                                <span class="hljs-keyword">struct</span> device_node *prev)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>node</strong>：父节点。<br><strong>prev</strong>：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。<br><strong>返回值</strong>：找到的下一个子节点。</p><h3 id="3-提取属性值的-OF-函数"><a href="#3-提取属性值的-OF-函数" class="headerlink" title="3| 提取属性值的 OF  函数"></a>3| 提取属性值的 OF  函数</h3><p>节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要，Linux 内核中使用<strong>结构体 property 表示属性</strong>，此结构体同样定义在文件include&#x2F;linux&#x2F;of.h 中，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">35</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> &#123;</span><span class="hljs-number">36</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">/* 属性名字 */</span><span class="hljs-number">37</span> <span class="hljs-type">int</span> length; <span class="hljs-comment">/* 属性长度 */</span><span class="hljs-number">38</span> <span class="hljs-type">void</span> *value; <span class="hljs-comment">/* 属性值 */</span><span class="hljs-number">39</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">/* 下一个属性 */</span><span class="hljs-number">40</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _flags;<span class="hljs-number">41</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unique_id;<span class="hljs-number">42</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bin_attribute</span> <span class="hljs-title">attr</span>;</span><span class="hljs-number">43</span> &#125;;</code></pre></div><p>Linux 内核也提供了提取属性值的 OF 函数，我们依次来看一下。</p><h4 id="of-find-property-函数"><a href="#of-find-property-函数" class="headerlink" title="of_find_property  函数"></a>of_find_property  函数</h4><p>of_find_property 函数用于<strong>查找指定的属性</strong>，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">property *<span class="hljs-title function_">of_find_property</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> *lenp)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>name</strong>： 属性名字。<br><strong>lenp</strong>：属性值的字节数<br><strong>返回值</strong>：找到的属性。</p><h4 id="of-property-count-elems-of-size-函数"><a href="#of-property-count-elems-of-size-函数" class="headerlink" title="of_property_count_elems_of_size  函数"></a>of_property_count_elems_of_size  函数</h4><p>of_property_count_elems_of_size 函数用于<strong>获取属性中元素的数量</strong>，比如 reg 属性值是一个数组，那么使用此函数可以获取到这个数组的大小，此函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_count_elems_of_size</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, <span class="hljs-type">int</span> elem_size)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 需要统计元素数量的属性名字。<br><strong>elem_size</strong>：元素长度。<br><strong>返回值</strong>：得到的属性元素数量。</p><hr><h4 id="of-property-read-u32-index-函数"><a href="#of-property-read-u32-index-函数" class="headerlink" title="of_property_read_u32_index  函数"></a>of_property_read_u32_index  函数</h4><p>of_property_read_u32_index 函数<strong>用于从属性中获取指定标号的 u32 类型数据值</strong>(无符号 32位)，比如某个属性有多个 u32 类型的值，那么就可以使用此函数来获取指定标号的数据值，此函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32_index</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                                u32  index,</span><span class="hljs-params">                                u32 *out_value)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 要读取的属性名字。<br><strong>index</strong>：要读取的值标号。<br><strong>out_value</strong>：读取到的值<br><strong>返回值</strong>：0 读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p><hr><h4 id="of-property-read-u-array-函数"><a href="#of-property-read-u-array-函数" class="headerlink" title="of_property_read_u?_array  函数"></a>of_property_read_u?_array  函数</h4><p><strong>of_property_read_u8_array  函数</strong><br><strong>of_property_read_u16_array  函数</strong><br><strong>of_property_read_u32_array  函数</strong><br><strong>of_property_read_u64_array 函数</strong></p><p>这 4 个函数分别是<strong>读取属性中 u8、u16、u32 和 u64 类型的数组数据</strong>，比如大多数的 reg 属性都是数组数据，可以使用这 4 个函数一次读取出 reg 属性中的所有数据。这四个函数的原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u8_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                              <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                              u8 *out_values,</span><span class="hljs-params">                              <span class="hljs-type">size_t</span> sz)</span><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u16_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                               u16 *out_values,</span><span class="hljs-params">                               <span class="hljs-type">size_t</span> sz)</span><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                               u32 *out_values,</span><span class="hljs-params">                               <span class="hljs-type">size_t</span> sz)</span><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u64_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                               u64 *out_values,</span><span class="hljs-params">                               <span class="hljs-type">size_t</span> sz)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 要读取的属性名字。<br><strong>out_value</strong>：读取到的数组值，分别为 u8、u16、u32 和 u64。<br><strong>sz</strong> ：要读取的数组元素数量。<br><strong>返回值</strong>：0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p><hr><h4 id="of-property-read-u-函数"><a href="#of-property-read-u-函数" class="headerlink" title="of_property_read_u?  函数"></a>of_property_read_u?  函数</h4><p><strong>of_property_read_u8  函数</strong><br><strong>of_property_read_u16  函数</strong><br><strong>of_property_read_u32  函数</strong><br><strong>of_property_read_u64  函数</strong><br>有些属性只有一个整形值，这四个函数就是用于读取这种只有一个整形值的属性，分别用于读取 u8、u16、u32 和 u64 类型属性值，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u8</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                        u8 *out_value)</span><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u16</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                         u16 *out_value)</span><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                         u32 *out_value)</span><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u64</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                         u64 *out_value)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 要读取的属性名字。<br><strong>out_value</strong>：读取到的数组值。<br><strong>返回值</strong>：0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p><hr><h4 id="of-property-read-string-函数"><a href="#of-property-read-string-函数" class="headerlink" title="of_property_read_string  函数"></a>of_property_read_string  函数</h4><p>of_property_read_string 函数用于读取属性中字符串值，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_string</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,</span><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> **out_string)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>proname</strong>： 要读取的属性名字。<br><strong>out_string</strong>：读取到的字符串值。<br><strong>返回值</strong>：0，读取成功，负值，读取失败。</p><hr><h4 id="of-n-addr-cells-函数"><a href="#of-n-addr-cells-函数" class="headerlink" title="of_n_addr_cells  函数"></a>of_n_addr_cells  函数</h4><p>of_n_addr_cells 函数用于获取#address-cells 属性值，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_n_addr_cells</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>返回值</strong>：获取到的#address-cells 属性值。</p><hr><h4 id="of-n-size-cells-函数"><a href="#of-n-size-cells-函数" class="headerlink" title="of_n_size_cells  函数"></a>of_n_size_cells  函数</h4><p>of_size_cells 函数用于获取#size-cells 属性值，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_n_size_cells</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>返回值</strong>：获取到的#size-cells 属性值。</p><h3 id="4-其他常用的-OF-函数"><a href="#4-其他常用的-OF-函数" class="headerlink" title="4|其他常用的 OF  函数"></a>4|其他常用的 OF  函数</h3><h4 id="of-device-is-compatible-函数"><a href="#of-device-is-compatible-函数" class="headerlink" title="of_device_is_compatible  函数"></a>of_device_is_compatible  函数</h4><p>of_device_is_compatible 函数用于查看节点的 <strong>compatible 属性是否有包含 compat 指定的字符串</strong>，也就是检查设备节点的兼容性，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_device_is_compatible</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *device,</span><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *compat)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>device</strong>：设备节点。<br><strong>compat</strong>：要查看的字符串。<br><strong>返回值</strong>：0，节点的 compatible 属性中不包含 compat 指定的字符串；正数，节点的 compatible属性中包含 compat 指定的字符串。</p><hr><h4 id="of-get-address-函数"><a href="#of-get-address-函数" class="headerlink" title="of_get_address  函数"></a>of_get_address  函数</h4><p>of_get_address 函数用于<strong>获取地址相关属性</strong>，主要是“reg”或者“assigned-addresses”属性值，函数属性如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> __be32 *<span class="hljs-title function_">of_get_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev,</span><span class="hljs-params">                             <span class="hljs-type">int</span> index,</span><span class="hljs-params">                             u64 *size,</span><span class="hljs-params">                             <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *flags)</span></code></pre></div><p><strong>函数参数和返回值含义如下：</strong><br><strong>dev</strong>：设备节点。<br><strong>index</strong>：要读取的地址标号。<br><strong>size</strong>：地址长度。<br><strong>flags</strong>：参数，比如 IORESOURCE_IO、IORESOURCE_MEM 等<br><strong>返回值</strong>：读取到的地址数据首地址，为 NULL 的话表示读取失败。</p><hr><h4 id="of-translate-address-函数"><a href="#of-translate-address-函数" class="headerlink" title="of_translate_address  函数"></a>of_translate_address  函数</h4><p>of_translate_address 函数负责<strong>将从设备树读取到的地址转换为物理地址</strong>，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">u64 <span class="hljs-title function_">of_translate_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev,</span><span class="hljs-params">                         <span class="hljs-type">const</span> __be32 *in_addr)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong>：设备节点。<br><strong>in_addr</strong>：要转换的地址。<br><strong>返回值</strong>：得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</p><hr><h4 id="of-address-to-resource-函数"><a href="#of-address-to-resource-函数" class="headerlink" title="of_address_to_resource  函数"></a>of_address_to_resource  函数</h4><p>IIC、SPI、GPIO 等这些外设都有对应的寄存器，这些寄存器其实就是一组内存空间，Linux内核使用 <strong>resource 结构体来描述一段内存空间</strong>， “resource”翻译出来就是“资源”，因此用 resource结构体描述的都是设备资源信息，resource 结构体定义在文件 include&#x2F;linux&#x2F;ioport.h 中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">18</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> &#123;</span><span class="hljs-number">19</span> <span class="hljs-type">resource_size_t</span> start;<span class="hljs-number">20</span> <span class="hljs-type">resource_size_t</span> end;<span class="hljs-number">21</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-number">22</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<span class="hljs-number">23</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">parent</span>, *<span class="hljs-title">sibling</span>, *<span class="hljs-title">child</span>;</span><span class="hljs-number">24</span> &#125;;</code></pre></div><p>对于 32 位的 SOC 来说，resource_size_t 是 u32 类型的。</p><p>其中 start 表示开始地址，end 表示结束地址，name 是这个资源的名字，flags 是资源标志位，一般表示资源类型，可选的资源标志定义在文件 include&#x2F;linux&#x2F;ioport.h 中，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BITS 0x000000ff</span><span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_TYPE_BITS 0x00001f00</span><span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IO 0x00000100</span><span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM 0x00000200</span><span class="hljs-number">5</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_REG 0x00000300</span><span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IRQ 0x00000400</span><span class="hljs-number">7</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DMA 0x00000800</span><span class="hljs-number">8</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUS 0x00001000</span><span class="hljs-number">9</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_PREFETCH 0x00002000</span><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_READONLY 0x00004000</span><span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_CACHEABLE 0x00008000</span><span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_RANGELENGTH 0x00010000</span><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_SHADOWABLE 0x00020000</span><span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_SIZEALIGN 0x00040000</span><span class="hljs-number">15</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_STARTALIGN 0x00080000</span><span class="hljs-number">16</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM_64 0x00100000</span><span class="hljs-number">17</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_WINDOW 0x00200000</span><span class="hljs-number">18</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MUXED 0x00400000</span><span class="hljs-number">19</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_EXCLUSIVE 0x08000000</span><span class="hljs-number">20</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DISABLED 0x10000000</span><span class="hljs-number">21</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_UNSET 0x20000000</span><span class="hljs-number">22</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_AUTO 0x40000000</span><span class="hljs-number">23</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUSY 0x80000000</span></code></pre></div><p>大 家 一 般 最 常 见 的 资 源 标 志 就 是 IORESOURCE_MEM 、 IORESOURCE_REG 和<br>IORESOURCE_IRQ 等。</p><p>接下来我们回到 of_address_to_resource 函数，此函数看名字像是从设备树里面提取资源值，但是本质上就是将 reg 属性值转换为 resource 结构体类型，函数原型如下所示</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_address_to_resource</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node  *dev,</span><span class="hljs-params">                           <span class="hljs-type">int</span> index,</span><span class="hljs-params">                           <span class="hljs-keyword">struct</span> resource *r)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>dev</strong>：设备节点。<br><strong>index</strong>：地址资源标号。<br><strong>r</strong>：得到的 resource 类型的资源值。<br><strong>返回值</strong>：0，成功；负值，失败。</p><hr><h4 id="of-iomap-函数"><a href="#of-iomap-函数" class="headerlink" title="of_iomap 函数"></a>of_iomap 函数</h4><p><strong>of_iomap 函数用于直接内存映射</strong>，以前我们会通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了。当然了，你也可以使用 ioremap 函数来完成物理地址到虚拟地址的内存映射，只是在采用设备树以后，大部分的驱动都使用 of_iomap 函数了。of_iomap 函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段，of_iomap 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> __iomem *<span class="hljs-title function_">of_iomap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,</span><span class="hljs-params">                       <span class="hljs-type">int</span> index)</span></code></pre></div><p>函数参数和返回值含义如下：<br><strong>np</strong>：设备节点。<br><strong>index</strong>：reg 属性中要完成内存映射的段，如果reg属性只有一段的话index就设置为0<br><strong>返回值</strong>：经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</p><hr><p>关于设备树常用的 OF 函数就先讲解到这里，Linux 内核中关于设备树的 OF 函数不仅仅只有前面讲的这几个，还有很多 OF 函数我们并没有讲解，这些没有讲解的 OF 函数要结合具体的驱动，比如获取中断号的 OF 函数、获取 GPIO 的 OF 函数等等，这些 OF 函数我们在后面的驱动实验中再详细的讲解。</p><h1 id="设备树下的LED驱动"><a href="#设备树下的LED驱动" class="headerlink" title="设备树下的LED驱动"></a>设备树下的LED驱动</h1><p>本章我们使用设备树来向 Linux 内核传递相关的寄存器物理地址，Linux 驱动文件使用上一章讲解的 OF函数从设备树中获取所需的属性值，然后使用获取到的属性值来初始化相关的 IO。本章实验还是比较简单的，本章实验重点内容如下：</p><p>①、在 imx6ull-lxg-emmc.dts 文件中创建相应的设备节点。<br>②、编写驱动程序(在前面实验基础上完成)，获取设备树中的相关属性值。<br>③、使用获取到的有关属性值来初始化 LED 所使用的 GPIO。</p><h2 id="修改设备树文件"><a href="#修改设备树文件" class="headerlink" title="修改设备树文件"></a>修改设备树文件</h2><p>在根节点“&#x2F;”下创建一个名为“alphaled”的子节点，打开 imx6ull-lxg-emmc.dts 文件，在根节点“&#x2F;”最后面输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> alphaled &#123;<span class="hljs-number">2</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">3</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-number">4</span> compatible = <span class="hljs-string">&quot;atkalpha-led&quot;</span>;<span class="hljs-number">5</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<span class="hljs-number">6</span> reg = &lt; <span class="hljs-number">0X020C406C</span> <span class="hljs-number">0X04</span> <span class="hljs-comment">/* CCM_CCGR1_BASE */</span><span class="hljs-number">7</span> <span class="hljs-number">0X020E0068</span> <span class="hljs-number">0X04</span> <span class="hljs-comment">/* SW_MUX_GPIO1_IO03_BASE */</span><span class="hljs-number">8</span> <span class="hljs-number">0X020E02F4</span> <span class="hljs-number">0X04</span> <span class="hljs-comment">/* SW_PAD_GPIO1_IO03_BASE */</span><span class="hljs-number">9</span> <span class="hljs-number">0X0209C000</span> <span class="hljs-number">0X04</span> <span class="hljs-comment">/* GPIO1_DR_BASE */</span><span class="hljs-number">10</span> <span class="hljs-number">0X0209C004</span> <span class="hljs-number">0X04</span> &gt;; <span class="hljs-comment">/* GPIO1_GDIR_BASE */</span><span class="hljs-number">11</span> &#125;;</code></pre></div><p><strong>第 2、3 行</strong>，属性#address-cells 和#size-cells 都为 1，表示 reg 属性中起始地址占用一个字长(cell)，地址长度也占用一个字长(cell)。<br><strong>第 4 行</strong>，属性 compatbile 设置 alphaled 节点兼容性为“atkalpha-led”。<br><strong>第 5 行</strong>，属性 status 设置状态为“okay”。<br><strong>第 6~10 行</strong>，reg 属性，非常重要！<strong>reg 属性设置了驱动里面所要使用的寄存器物理地址</strong>，比如第 6 行的“0X020C406C 0X04”表示 I.MX6ULL 的 CCM_CCGR1 寄存器，其中寄存器首地址为 0X020C406C，长度为 4 个字节。设备树修改完成以后输入如下命令重新编译一下 imx6ull-lxg-emmc.dts：<code>make dtbs</code></p><p>编译完成以后得到 imx6ull-lxg-emmc.dtb，使用新的 imx6ull-lxg-emmc.dtb 启动Linux 内核。Linux 启动成功以后进入到&#x2F;proc&#x2F;device-tree&#x2F;目录中查看是有“alphaled”这个节点，结果如图 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200821114222276.png" alt="image-20200821114222276"></p><p>可以进入到图中的 alphaled 目录中，查看一下都有哪些属性文件，结果如图所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/4%E3%80%81Linux%E8%AE%BE%E5%A4%87%E6%A0%91/image-20200821114301406.png" alt="image-20200821114301406"></p><p>大家可以查看一下 compatible、status 等属性值是否和我们设置的一致。</p><h2 id="LED灯驱动编写"><a href="#LED灯驱动编写" class="headerlink" title="LED灯驱动编写"></a>LED灯驱动编写</h2><p>设备树准备好以后就可以编写驱动程序了，本章实验在前面实验驱动文件newchrled.c 的基础上修改而来。新建名为“4_dtsled”文件夹，然后在 4_dtsled 文件夹里面创建vscode 工程，工作区命名为“dtsled”。工程创建好以后新建 dtsled.c 文件，在 dtsled.c 里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DTSLED_DEV_NUM 1<span class="hljs-comment">/* 设备号数量 */</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>LED_OFF = <span class="hljs-number">0</span>,LED_ON = !LED_OFF&#125;<span class="hljs-type">led_switch_t</span>;<span class="hljs-comment">/* 寄存器虚拟地址 */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_CCM_CCGR1;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_SW_MUX_GPIO1_IO03;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_SW_PAD_GPIO1_IO03;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_GPIO1_DR;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_GPIO1_GDIR;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>&#123;<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(sw == LED_ON)&#123;<span class="hljs-comment">/* 设置GPIO电平为低电平 默认点亮LED */</span>val = readl(VA_GPIO1_DR);val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>val = readl(VA_GPIO1_DR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);&#125;&#125;<span class="hljs-comment">/* dtsled设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dtsled_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-comment">//字符设备</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-comment">//设备号</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-comment">//类</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-comment">//设备</span><span class="hljs-type">int</span> major;<span class="hljs-comment">//主设备号</span><span class="hljs-type">int</span> minor;<span class="hljs-comment">//次设备号</span><span class="hljs-type">char</span> *chrDevName;<span class="hljs-comment">//设备名</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span><span class="hljs-comment">//设备树节点</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dtsled_dev</span> <span class="hljs-title">dtsled</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dtsled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-comment">//filp-&gt;private_data = &amp;dtsled;/* 设置私有数据 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">dtsled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-comment">//struct dtsled_dev *dev = (struct dtsled_dev*)filp-&gt;private_data;/* 以访问私有数据 */</span><span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = copy_from_user(userDataBuf, buf, cnt);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;led_switch(userDataBuf[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dtsled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作集合 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">dtsled_fops</span> =</span> &#123;.owner = THIS_MODULE,.write = dtsled_write,.open = dtsled_open,.release = dtsled_release&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">dtsled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str;u32 regdata[<span class="hljs-number">10</span>], i = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 注册设备号 */</span>dtsled.chrDevName = <span class="hljs-string">&quot;dtsled&quot;</span>;dtsled.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(dtsled.major)&#123;<span class="hljs-comment">//如果给定了主设备号</span>dtsled.devid = MKDEV(dtsled.major, <span class="hljs-number">0</span>);ret = register_chrdev_region(dtsled.devid, DTSLED_DEV_NUM, dtsled.chrDevName);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果没给定主设备号那么申请设备号</span>ret = alloc_chrdev_region(&amp;dtsled.devid, <span class="hljs-number">0</span>, DTSLED_DEV_NUM, dtsled.chrDevName);&#125;dtsled.major = MAJOR(dtsled.devid);dtsled.minor = MINOR(dtsled.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;dtsled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, dtsled.major, dtsled.minor);<span class="hljs-comment">/* 添加字符设备 */</span>dtsled.cdev.owner = dtsled_fops.owner;cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops);ret = cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_DEV_NUM);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>dtsled.class = class_create(THIS_MODULE, dtsled.chrDevName);<span class="hljs-keyword">if</span>(IS_ERR(dtsled.class))&#123;result = PTR_ERR(dtsled.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>dtsled.device = device_create(dtsled.class, <span class="hljs-literal">NULL</span>,dtsled.devid, <span class="hljs-literal">NULL</span>, dtsled.chrDevName);<span class="hljs-keyword">if</span>(IS_ERR(dtsled.device))&#123;result = PTR_ERR(dtsled.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 获取设备节点 */</span>dtsled.np = of_find_node_by_path(<span class="hljs-string">&quot;/alphaled&quot;</span>);<span class="hljs-keyword">if</span>(dtsled.np == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);ret = -EINVAL;<span class="hljs-keyword">goto</span> fail_findnd;&#125;<span class="hljs-comment">/* 读取status属性 */</span>ret = of_property_read_string(dtsled.np, <span class="hljs-string">&quot;status&quot;</span>, &amp;str);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;no status found!\r\n&quot;</span>);<span class="hljs-keyword">goto</span> fail_rs;&#125;<span class="hljs-keyword">else</span>&#123;printk(<span class="hljs-string">&quot;status=%s\r\n&quot;</span>, str);&#125;<span class="hljs-comment">/* 读取reg属性 */</span>ret = of_property_read_u32_array(dtsled.np, <span class="hljs-string">&quot;reg&quot;</span>, regdata, <span class="hljs-number">10</span>);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;no reg found!\r\n&quot;</span>);<span class="hljs-keyword">goto</span> fail_rs;&#125;<span class="hljs-keyword">else</span>&#123;printk(<span class="hljs-string">&quot;reg data:\r\n&quot;</span>);<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;printk(<span class="hljs-string">&quot;%#X &quot;</span>, regdata[i]);&#125;printk(<span class="hljs-string">&quot;\r\n&quot;</span>);&#125;<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><span class="hljs-comment">/* LED初始化 */</span><span class="hljs-comment">/* -&gt;1.地址映射 */</span>VA_CCM_CCGR1 = ioremap(regdata[<span class="hljs-number">0</span>], regdata[<span class="hljs-number">1</span>]);VA_SW_MUX_GPIO1_IO03 = ioremap(regdata[<span class="hljs-number">2</span>], regdata[<span class="hljs-number">3</span>]);VA_SW_PAD_GPIO1_IO03 = ioremap(regdata[<span class="hljs-number">4</span>], regdata[<span class="hljs-number">5</span>]);VA_GPIO1_DR = ioremap(regdata[<span class="hljs-number">6</span>], regdata[<span class="hljs-number">7</span>]);VA_GPIO1_GDIR = ioremap(regdata[<span class="hljs-number">8</span>], regdata[<span class="hljs-number">9</span>]);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">/* LED初始化 */</span><span class="hljs-comment">/* 使用of_iomap() 可以直接将设备节点的&lt;reg&gt;属性获取并映射，</span><span class="hljs-comment"> * 以省去使用of_property_read_u32_array()，和ioremap()</span><span class="hljs-comment"> * 一般驱动使用设备树节点，都会这么使用，更加方便</span><span class="hljs-comment"> * void __iomem *of_iomap(struct device_node *np, int index)</span><span class="hljs-comment"> * index:reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为 0。</span><span class="hljs-comment"> */</span>VA_CCM_CCGR1 = of_iomap(dtsled.np, <span class="hljs-number">0</span>);VA_SW_MUX_GPIO1_IO03 = of_iomap(dtsled.np, <span class="hljs-number">1</span>);VA_SW_PAD_GPIO1_IO03 = of_iomap(dtsled.np, <span class="hljs-number">2</span>);VA_GPIO1_DR = of_iomap(dtsled.np, <span class="hljs-number">3</span>);VA_GPIO1_GDIR = of_iomap(dtsled.np, <span class="hljs-number">4</span>);<span class="hljs-comment">/* -&gt;2.初始化 */</span><span class="hljs-comment">/* -&gt;-&gt;打开时钟 */</span>val = readl(VA_CCM_CCGR1);val &amp;=  ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);writel(val, VA_CCM_CCGR1);writel(<span class="hljs-number">0x5</span>, VA_SW_MUX_GPIO1_IO03);<span class="hljs-comment">/* 设置复用 */</span>writel(<span class="hljs-number">0x10B0</span>, VA_SW_PAD_GPIO1_IO03);<span class="hljs-comment">/* 设置电气属性 */</span><span class="hljs-comment">/* -&gt;-&gt;设置GPIO方向为输出*/</span>val = readl(VA_GPIO1_GDIR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_GDIR);<span class="hljs-comment">/* -&gt;-&gt;设置GPIO电平为高电平 默认关闭LED */</span>val = readl(VA_GPIO1_DR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_rs:fail_findnd:<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(dtsled.class, dtsled.devid);fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(dtsled.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;dtsled.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(dtsled.devid, DTSLED_DEV_NUM);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">dtsled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 地址映射释放 */</span>iounmap(VA_CCM_CCGR1);iounmap(VA_SW_MUX_GPIO1_IO03);iounmap(VA_SW_PAD_GPIO1_IO03);iounmap(VA_GPIO1_DR);iounmap(VA_GPIO1_GDIR);<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(dtsled.class, dtsled.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(dtsled.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;dtsled.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(dtsled.devid, DTSLED_DEV_NUM);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(dtsled_init);module_exit(dtsled_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><h2 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a>编写测试 APP</h2><p>本章直接使用前面的测试 APP，将上一章的 ledApp.c 文件复制到本章实验工程下即可。</p><h2 id="编译测试运行即可"><a href="#编译测试运行即可" class="headerlink" title="编译测试运行即可"></a>编译测试运行即可</h2>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
      <tag>dts设备树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7| Linux按键输入驱动实验</title>
    <link href="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/7%E3%80%81Linux%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/7%E3%80%81Linux%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux按键输入驱动实验"><a href="#Linux按键输入驱动实验" class="headerlink" title="Linux按键输入驱动实验"></a>Linux按键输入驱动实验</h1><h2 id="1-设备树修改"><a href="#1-设备树修改" class="headerlink" title="1|设备树修改"></a>1|设备树修改</h2><p>I.MX6U-ALPHA 开发板上的 KEY 使用了 UART1_CTS_B 这个 PIN，打开 imx6ull-lxg-emmc.dts，在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为“pinctrl_key”的子节点，节点内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">pinctrl_key: keygrp &#123;    fsl,pins = &lt;        MX6UL_PAD_UART1_CTS_B__GPIO1_IO18 <span class="hljs-number">0xF080</span>    &gt;;&#125;;</code></pre></div><p>在根节点“&#x2F;”下创建 KEY 节点，节点名为“key”，节点内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">key &#123;    <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>    <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span>    compatible = <span class="hljs-string">&quot;atkalpha-key&quot;</span>;    pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;    pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_key&gt;;    key-gpios = &lt;&amp;gpio1 <span class="hljs-number">18</span> GPIO_ACTIVE_LOW&gt;;    status = <span class="hljs-string">&quot;okay&quot;</span>;&#125;;</code></pre></div><p>然后检查 PIN  是否被其他外设使用</p><p>设备树编写完成以后使用“make dtbs”命令重新编译设备树，然后使用新编译出来的imx6ull-lxg-emmc.dtb 文件启动 Linux 系统。</p><p>启动成功以后进入“&#x2F;proc&#x2F;device-tree”目录中查看“key”节点是否存在，如果存在的话就说明设备树基本修改成功(具体还要驱动验证)，结果如图 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/7%E3%80%81Linux%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200823175735837.png" alt="image-20200823175735837"></p><h2 id="2-按键驱动程序编写"><a href="#2-按键驱动程序编写" class="headerlink" title="2|按键驱动程序编写"></a>2|按键驱动程序编写</h2><p>设备树准备好以后就可以编写驱动程序了，新建名为“11_key”的文件夹，然后在 11_key文件夹里面创建 vscode 工程，工作区命名为“key”。工程创建好以后新建 key.c 文件，在 key.c里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-comment">/* 定义按键值 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE 0XF0 <span class="hljs-comment">/* 按键值 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY 0X00 <span class="hljs-comment">/* 无效的按键值 */</span></span><span class="hljs-comment">/* 设备号个数 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYDEV_DEV_NUM 1</span><span class="hljs-comment">/* keydev设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-type">char</span> *devname;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span><span class="hljs-comment">//设备树节点</span><span class="hljs-type">int</span> key_gpio;<span class="hljs-comment">//led所使用的GPIO编号</span><span class="hljs-type">atomic_t</span> keyvalue; <span class="hljs-comment">/* 按键值 */</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_dev</span> <span class="hljs-title">keydev</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;keydev.nd = of_find_node_by_path(<span class="hljs-string">&quot;/key&quot;</span>);<span class="hljs-keyword">if</span>(keydev.nd == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> -EINVAL;&#125;keydev.key_gpio = of_get_named_gpio(keydev.nd,<span class="hljs-string">&quot;key-gpios&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(keydev.key_gpio &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;kernel:can&#x27;t get key\r\n&quot;</span>);<span class="hljs-keyword">return</span> -EINVAL;&#125;printk(<span class="hljs-string">&quot;kernel:key_gpio=%d\r\n&quot;</span>, keydev.key_gpio);<span class="hljs-comment">/* 初始化 key 所使用的 IO */</span>gpio_request(keydev.key_gpio, <span class="hljs-string">&quot;key0&quot;</span>); <span class="hljs-comment">/* 请求 IO */</span>gpio_direction_input(keydev.key_gpio); <span class="hljs-comment">/* 设置为输入 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">key_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;filp-&gt;private_data = &amp;keydev; <span class="hljs-comment">/* 设置私有数据 */</span>ret = keyio_init();<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">key_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> keyvalue;<span class="hljs-keyword">if</span> (gpio_get_value(dev-&gt;key_gpio) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* key0 按下 */</span><span class="hljs-keyword">while</span>(!gpio_get_value(dev-&gt;key_gpio)); <span class="hljs-comment">/* 等待按键释放 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, KEY0VALUE);&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 无效的按键值 */</span><span class="hljs-type">atomic_set</span>(&amp;dev-&gt;keyvalue, INVAKEY);&#125;keyvalue = <span class="hljs-type">atomic_read</span>(&amp;dev-&gt;keyvalue); <span class="hljs-comment">/* 保存按键值 */</span>ret = copy_to_user(buf, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">key_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">key_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作集合 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">key_fops</span> =</span> &#123;.owner = THIS_MODULE,.write = key_write,.read = key_read,.open = key_open,.release = key_release&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">mykey_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 初始化原子变量 */</span><span class="hljs-type">atomic_set</span>(&amp;keydev.keyvalue, INVAKEY);<span class="hljs-comment">/* 注册设备号 */</span>keydev.devname = <span class="hljs-string">&quot;key&quot;</span>;keydev.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(keydev.major)&#123;keydev.devid = MKDEV(keydev.major, keydev.minor);ret = register_chrdev_region(keydev.devid, KEYDEV_DEV_NUM, keydev.devname);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;keydev.devid, <span class="hljs-number">0</span>, KEYDEV_DEV_NUM, keydev.devname);&#125;keydev.major = MAJOR(keydev.devid);keydev.minor = MINOR(keydev.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;keydev  MAJOR:%d  MINOR:%d\r\n&quot;</span>, keydev.major, keydev.minor);<span class="hljs-comment">/* 添加字符设备 */</span>keydev.cdev.owner = key_fops.owner;cdev_init(&amp;keydev.cdev, &amp;key_fops);ret = cdev_add(&amp;keydev.cdev, keydev.devid, KEYDEV_DEV_NUM);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>keydev.class = class_create(THIS_MODULE, keydev.devname);<span class="hljs-keyword">if</span>(IS_ERR(keydev.class))&#123;printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);result = PTR_ERR(keydev.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>keydev.device = device_create(keydev.class, <span class="hljs-literal">NULL</span>, keydev.devid, <span class="hljs-literal">NULL</span>, keydev.devname);<span class="hljs-keyword">if</span>(IS_ERR(keydev.device))&#123;printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);result = PTR_ERR(keydev.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(keydev.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;keydev.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(keydev.devid, KEYDEV_DEV_NUM);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">mykey_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(keydev.class, keydev.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(keydev.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;keydev.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(keydev.devid, KEYDEV_DEV_NUM);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(mykey_init);module_exit(mykey_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>结构体 key_dev 为按键的设备结构体，原子变量 keyvalue 用于记录按键值。</p><p>函数 keyio_init 用于初始化按键，从设备树中获取按键的 gpio 信息，然后设置为输入。将按键的初始化代码提取出来，将其作为独立的一个函数有利于提高程序的模块化设计。</p><p>key_open 函数通过调用 keyio_init 函数来始化按键所使用的 IO，应用程序每次打开按键驱动文件的时候都会初始化一次按键 IO。</p><p>key_read 函数，应用程序通过 read 函数读取按键值的时候此函数就会执行。读取按键 IO 的电平，如果为 0 的话就表示按键按下了，如果按键按下的话就等待按键释放。按键释放以后标记按键值</p><p>驱动入口函数，调用 atomic_set 函数初始化原子变量默认为无效值。</p><p>key.c 文件代码很简单，重点就是 key_read 函数读取按键值，要对 keyvalue 进行保护。</p><h2 id="3-测试APP编写"><a href="#3-测试APP编写" class="headerlink" title="3|测试APP编写"></a>3|测试APP编写</h2><p>新建名为 keyApp.c 的文件，然后输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0VALUE 0XF0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVAKEY 0X00</span><span class="hljs-comment">/*</span><span class="hljs-comment">* @description : main 主程序</span><span class="hljs-comment">* @param - argc : argv 数组元素个数</span><span class="hljs-comment">* @param - argv : 具体参数</span><span class="hljs-comment">* @return : 0 成功;其他 失败</span><span class="hljs-comment">*/</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, fd = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> *filename;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> keyvalue;        <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:\r\n./keyApp     &lt;openFileName&gt;  \r\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    filename = argv[<span class="hljs-number">1</span>];    <span class="hljs-comment">/* 打开 key 驱动 */</span>    fd =  open(filename, O_RDWR);    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-comment">/* 循环读取按键值数据！ */</span>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;        read(fd, &amp;keyvalue, <span class="hljs-keyword">sizeof</span>(keyvalue));        <span class="hljs-keyword">if</span>(keyvalue == KEY0VALUE)&#123;  <span class="hljs-comment">/* KEY0 */</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;KEY0 Press, value = %#X\r\n&quot;</span>, keyvalue);    <span class="hljs-comment">/* 按下 */</span>        &#125;    &#125;    <span class="hljs-comment">/* 关闭 */</span>    ret = close(fd);    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close file %s failed！\r\n&quot;</span>, filename);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>循环读取&#x2F;dev&#x2F;key 文件，也就是循环读取按键值，并且将按键值打印出来。</p><h2 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4|运行测试"></a>4|运行测试</h2><p>编译，加载，运行。</p><p>驱动加载成功以后如下命令来测试：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/keyApp /</span>dev/key</code></pre></div><p>输入上述命令以后,按下开发板的KEY0按键， 终端显示如图 49.4.2.1 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/7%E3%80%81Linux%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20200823184134402.png" alt="image-20200823184134402"></p><p>当我们按下 KEY0 以后就会打印出“KEY0 Press, value &#x3D; 0XF0”，表示按键按下。</p><p>但是大家可能会发现，有时候按下一次 KEY0 但是会输出好几行“KEY0 Press,value &#x3D; 0XF0”，这是因为我们的代码没有做按键消抖处理。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6| Linux 并发与竞争</title>
    <link href="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/"/>
    <url>/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-并发与竞争"><a href="#Linux-并发与竞争" class="headerlink" title="Linux 并发与竞争"></a>Linux 并发与竞争</h1><p>Linux是一个多任务操作系统，肯定会存在多个任务共同操作同一段内存或者设备的情况，多个任务甚至中断都能访问的资源叫做共享资源，就和共享单车一样。</p><p>在驱动开发中要注意对共享资源的保护，也就是要处理对共享资源的并发访问。比如共享单车，大家按照谁扫谁骑走的原则来共用这个单车，如果没有这个并发访问共享单车的原则存在，只怕到时候为了一辆单车要打起来了。在 Linux 驱动编写过程中对于并发控制的管理非常重要，本章我们就来学习一下如何在 Linux 驱动中处理并发。</p><h2 id="1-并发与竞争"><a href="#1-并发与竞争" class="headerlink" title="1|并发与竞争"></a>1|并发与竞争</h2><h3 id="1、并发与竞争简介"><a href="#1、并发与竞争简介" class="headerlink" title="1、并发与竞争简介"></a>1、并发与竞争简介</h3><p>并发就是多个“用户”同时访问同一个共享资源，比如你们公司有一台打印机，你们公司的所有人都可以使用。现在小李和小王要同时使用这一台打印机，都要打印一份文件。</p><p>这两份文档肯定是各自打印出来的，不能相互影响。当两个人同时打印的话如果打印机不做处理的话可能会出现小李的文档打印了一行，然后开始打印小王的文档，这样打印出来的文档就错乱了。</p><p>这是绝对不允许的。如果有多人同时向打印机发送了多份文档，打印机必须保证一次只能打印一份文档，只有打印完成以后才能打印其他的文档。</p><p><strong>Linux 系统是个多任务操作系统，会存在多个任务同时访问同一片内存区域，这些任务可能会相互覆盖这段内存中的数据，造成内存数据混乱。</strong>针对这个问题必须要做处理，严重的话可能会导致系统崩溃。现在的 Linux 系统并发产生的原因很复杂，总结一下有下面几个主要原因：</p><ul><li><strong>①、多线程并发访问</strong>，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。</li><li><strong>②、抢占式并发访问</strong>，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。</li><li><strong>③、中断程序并发访问</strong>，这个无需多说，学过 STM32 的同学应该知道，硬件中断的权利可是很大的。</li><li><strong>④、SMP(多核)核间并发访问</strong>，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并发访问。</li></ul><p>并发访问带来的问题就是竞争，学过FreeRTOS和UCOS的同学应该知道临界区这个概念，所谓的临界区就是共享数据段，对于临界区必须保证一次只有一个线程访问，也就是要保证临界区是原子访问的，注意这里的“原子”不是正点原子的“原子”。我们都知道，原子是化学反应不可再分的基本微粒，这里的原子访问就表示这一个访问是一个步骤，不能再进行拆分。如果多个线程同时操作临界区就表示存在竞争，我们在编写驱动的时候一定要注意避免并发和防止竞争访问。很多 Linux 驱动初学者往往不注意这一点，在驱动程序中埋下了隐患，这类问题往往又很不容易查找，导致驱动调试难度加大、费时费力。所以我们一般在编写驱动的时候就要考虑到并发与竞争，而不是驱动都编写完了然后再处理并发与竞争。</p><h3 id="2、保护内容是什么"><a href="#2、保护内容是什么" class="headerlink" title="2、保护内容是什么"></a>2、保护内容是什么</h3><p>前面一直说要防止并发访问共享资源，换句话说就是要保护共享资源，防止进行并发访问。那么问题来了，什么是共享资源？现实生活中的公共电话、共享单车这些是共享资源，我们都很容易理解，那么在程序中什么是共享资源？也就是保护的内容是什么？我们保护的不是代码，而是数据！某个线程的局部变量不需要保护，我们要保护的是多个线程都会访问的共享数据。一个整形的全局变量 a 是数据，一份要打印的文档也是数据，虽然我们知道了要对共享数据进行保护，那么怎么判断哪些共享数据要保护呢？找到要保护的数据才是重点，而这个也是难点，因为驱动程序各不相同，那么数据也千变万化，一般像全局变量，设备结构体这些肯定是要保护的，至于其他的数据就要根据实际的驱动程序而定了。</p><p>当我们发现驱动程序中存在并发和竞争的时候一定要处理掉，接下来我们依次来学习一下Linux 内核提供的几种并发和竞争的处理方法。 </p><h2 id="2-原子操作"><a href="#2-原子操作" class="headerlink" title="2|原子操作"></a>2|原子操作</h2><h3 id="1、原子操作简介"><a href="#1、原子操作简介" class="headerlink" title="1、原子操作简介"></a>1、原子操作简介</h3><p>首先看一下原子操作，<strong>原子操作就是指不能再进一步分割的操作</strong>，一般原子操作用于变量或者位操作。假如现在要对无符号整形变量 a 赋值，值为 3，对于 C 语言来讲很简单，直接就是：</p><div class="hljs code-wrapper"><pre><code class="hljs c">a = <span class="hljs-number">3</span>;</code></pre></div><p>但是 C 语言要先编译为成汇编指令，ARM 架构不支持直接对寄存器进行读写操作，比如要借助寄存器 R0、R1 等来完成赋值操作。假设变量 a 的地址为 0X3000000，“a&#x3D;3”这一行 C语言可能会被编译为如下所示的汇编代码：</p><div class="hljs code-wrapper"><pre><code class="hljs assembly">1 ldr r0, =0X30000000 /* 变量 a 地址 */2 ldr r1, = 3 /* 要写入的值 */3 str r1, [r0] /* 将 3 写入到 a 变量中 */</code></pre></div><p>示例代码  只是一个简单的举例说明，实际的结果要比示例代码复杂的多。从上述代码可以看出，C 语言里面简简单单的一句“a&#x3D;3”，编译成汇编文件以后变成了 3 句，那么程序在执行的时候肯定是按照示例代码 中的汇编语句一条一条的执行。假设现在线程 A要向 a 变量写入 10 这个值，而线程 B 也要向 a 变量写入 20 这个值，我们理想中的执行顺序如图所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822122404451.png" alt="image-20200822122404451"></p><p>按照图  所示的流程，确实可以实现线程 A 将 a 变量设置为 10，线程 B 将 a 变量设置为 20。但是实际上的执行流程可能如下图所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822122434573.png" alt="image-20200822122434573"></p><p>按照图 所示的流程，线程 A 最终将变量 a 设置为了 20，而并不是要求的 10！线程B 没有问题。这就是一个最简单的设置变量值的并发与竞争的例子，要解决这个问题就要保证示例代码  中的三行汇编指令作为一个整体运行，也就是作为一个原子存在。</p><p>Linux 内核提供了两组原子操作 API 函数，一组是对整形变量进行操作的，一组是对位进行操作的，我们接下来看一下这些 API 函数。</p><h3 id="2、原子整形操作API函数"><a href="#2、原子整形操作API函数" class="headerlink" title="2、原子整形操作API函数"></a>2、原子整形操作API函数</h3><p>Linux 内核定义了叫做 <strong>atomic_t</strong> 的结构体来完成整形数据的原子操作，在使用中用原子变量来代替整形变量，此结构体定义在 <strong>include&#x2F;linux&#x2F;types.h</strong> 文件中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">175</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-number">176</span> <span class="hljs-type">int</span> counter;<span class="hljs-number">177</span> &#125; <span class="hljs-type">atomic_t</span>;</code></pre></div><p>如果要使用原子操作 API 函数，首先要先定义一个 atomic_t 的变量，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">atomic_t</span> a; <span class="hljs-comment">//定义 a</span></code></pre></div><p>也可以在定义原子变量的时候给原子变量赋初值，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">atomic_t</span> b = ATOMIC_INIT(<span class="hljs-number">0</span>); <span class="hljs-comment">//定义原子变量 b 并赋初值为 0</span></code></pre></div><p>可以通过宏 ATOMIC_INIT 向原子变量赋初值。</p><p>原子变量有了，接下来就是对原子变量进行操作，比如读、写、增加、减少等等，Linux 内核提供了大量的原子操作 API 函数，如表所示：</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ATOMIC_INIT(int i)</td><td align="left">定义原子变量的时候对其初始化</td></tr><tr><td align="left">int atomic_read(atomic_t *v)</td><td align="left">读取 v 的值，并且返回。</td></tr><tr><td align="left">void atomic_set(atomic_t *v, int i)</td><td align="left">向 v 写入 i 值。</td></tr><tr><td align="left">void atomic_add(int i, atomic_t *v)</td><td align="left">给 v 加上 i 值。</td></tr><tr><td align="left">void atomic_sub(int i, atomic_t *v)</td><td align="left">从 v 减去 i 值。</td></tr><tr><td align="left">void atomic_inc(atomic_t *v)</td><td align="left">给 v 加 1，也就是自增。</td></tr><tr><td align="left">void atomic_dec(atomic_t *v)</td><td align="left">从 v 减 1，也就是自减</td></tr><tr><td align="left">int atomic_dec_return(atomic_t *v)</td><td align="left">从 v 减 1，并且返回 v 的值。</td></tr><tr><td align="left">int atomic_inc_return(atomic_t *v)</td><td align="left">给 v 加 1，并且返回 v 的值。</td></tr><tr><td align="left">int atomic_sub_and_test(int i, atomic_t *v)</td><td align="left">从 v 减 i，如果结果为 0 就返回真，否则返回假</td></tr><tr><td align="left">int atomic_dec_and_test(atomic_t *v)</td><td align="left">从 v 减 1，如果结果为 0 就返回真，否则返回假</td></tr><tr><td align="left">int atomic_inc_and_test(atomic_t *v)</td><td align="left">给 v 加 1，如果结果为 0 就返回真，否则返回假</td></tr><tr><td align="left">int atomic_add_negative(int i, atomic_t *v)</td><td align="left">给 v 加 i，如果结果为负就返回真，否则返回假</td></tr></tbody></table><p>如果使用 64 位的 SOC 的话，就要用到 64 位的原子变量，Linux 内核也定义了 64 位原子结构体，如下所示</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-type">long</span> <span class="hljs-type">long</span> counter;&#125; <span class="hljs-type">atomic64_t</span>;</code></pre></div><p>相应的也提供了 64 位原子变量的操作 API 函数，这里我们就不详细讲解了，和表 中的 API 函数用法一样，只是将“atomic_”前缀换为“atomic64_”，将 int 换为 long long。如果使用的是 64 位的 SOC，那么就要使用 64 位的原子操作函数。Cortex-A7 是 32 位的架构，所以本文档只使用表 47.2.2.1 中的 32 位原子操作函数。原子变量和相应的 API 函数使用起来很简单，参考如下示例：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">atomic_t</span> v = ATOMIC_INIT(<span class="hljs-number">0</span>); <span class="hljs-comment">/* 定义并初始化原子变零 v=0 */</span><span class="hljs-type">atomic_set</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">/* 设置 v=10 */</span><span class="hljs-type">atomic_read</span>(&amp;v); <span class="hljs-comment">/* 读取 v 的值，肯定是 10 */</span><span class="hljs-type">atomic_inc</span>(&amp;v); <span class="hljs-comment">/* v 的值加 1，v=11 */</span></code></pre></div><h3 id="3、原子位操作-API-函数"><a href="#3、原子位操作-API-函数" class="headerlink" title="3、原子位操作 API  函数"></a>3、原子位操作 API  函数</h3><p>位操作也是很常用的操作，Linux 内核也提供了一系列的原子位操作 API 函数，只不过原子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作，API 函数如表  所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>void set_bit(int nr, void *p)</td><td>将 p 地址的第 nr 位 置 1。</td></tr><tr><td>void clear_bit(int nr,void *p)</td><td>将 p 地址的第 nr 位 清零。</td></tr><tr><td>void change_bit(int nr, void *p)</td><td>将 p 地址的第 nr 位 进行翻转。</td></tr><tr><td>int test_bit(int nr, void *p)</td><td>获取 p 地址的第 nr 位 的值。</td></tr><tr><td>int test_and_set_bit(int nr, void *p)</td><td>将 p 地址的第 nr 位 置 1，并且返回 nr 位原来的值。</td></tr><tr><td>int test_and_clear_bit(int nr, void *p)</td><td>将 p 地址的第 nr 位 清零，并且返回 nr 位原来的值。</td></tr><tr><td>int test_and_change_bit(int nr, void *p)</td><td>将 p 地址的第 nr 位 翻转，并且返回 nr 位原来的值。</td></tr></tbody></table><h2 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3|自旋锁"></a>3|自旋锁</h2><h3 id="1、自旋锁简介"><a href="#1、自旋锁简介" class="headerlink" title="1、自旋锁简介"></a>1、自旋锁简介</h3><p>原子操作只能对整形变量或者位进行保护，但是，在实际的使用环境中怎么可能只有整形变量或位这么简单的临界区。举个最简单的例子，设备结构体变量就不是整型变量，我们对于结构体中成员变量的操作也要保证原子性，在线程 A 对结构体变量使用期间，应该禁止其他的线程来访问此结构体变量，这些工作原子操作都不能胜任，需要本节要讲的锁机制，在 Linux内核中就是<strong>自旋锁</strong>。</p><p><strong>当一个线程要访问某个共享资源的时候首先要先获取相应的锁，锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁</strong>。对于自旋锁而言，如果自旋锁正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线程 B 不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁可用。比如现在有个公用电话亭，一次肯定只能进去一个人打电话，现在电话亭里面有人正在打电话，相当于获得了自旋锁。此时你到了电话亭门口，因为里面有人，所以你不能进去打电话，相当于没有获取自旋锁，这个时候你肯定是站在原地等待，你可能因为无聊的等待而转圈圈消遣时光，反正就是哪里也不能去，要一直等到里面的人打完电话出来。终于，里面的人打完电话出来了，相当于释放了自旋锁，这个时候你就可以使用电话亭打电话了，相当于获取到了自旋锁。</p><p>自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以用，可以访问共享资源。把自旋锁比作一个变量 a，变量 a&#x3D;1 的时候表示共享资源可用，当 a&#x3D;0的时候表示共享资源不可用。现在线程 A 要访问共享资源，发现 a&#x3D;0(自旋锁被其他线程持有)，那么线程 A 就会不断的查询 a 的值，直到 a&#x3D;1。从这里我们可以看到<strong>自旋锁的一个缺点</strong>：那就是等待自旋锁的线程会一直处于自旋状态，这样会浪费处理器时间，降低系统性能，所以自旋锁的持有时间不能太长。所以自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了，这个我们后面会讲解。</p><p>Linux 内核使用结构体 spinlock_t 表示自旋锁，结构体定义如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">64</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><span class="hljs-number">65</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><span class="hljs-number">66</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raw_spinlock</span> <span class="hljs-title">rlock</span>;</span><span class="hljs-number">67</span><span class="hljs-number">68</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span><span class="hljs-number">69</span> <span class="hljs-meta"># <span class="hljs-keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span><span class="hljs-number">70</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-number">71</span> u8 __padding[LOCK_PADSIZE];<span class="hljs-number">72</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lockdep_map</span> <span class="hljs-title">dep_map</span>;</span><span class="hljs-number">73</span> &#125;;<span class="hljs-number">74</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-number">75</span> &#125;;<span class="hljs-number">76</span> &#125; <span class="hljs-type">spinlock_t</span>;</code></pre></div><p>在使用自旋锁之前，肯定要先定义一个自旋锁变量，定义方法如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">spinlock_t</span> lock; <span class="hljs-comment">//定义自旋锁</span></code></pre></div><p>定义好自旋锁变量以后就可以使用相应的 API 函数来操作自旋锁。</p><h3 id="2、自旋锁-API-函数"><a href="#2、自旋锁-API-函数" class="headerlink" title="2、自旋锁 API  函数"></a>2、自旋锁 API  函数</h3><p>最基本的自旋锁 API 函数如表 所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>DEFINE_SPINLOCK(spinlock_t lock)</td><td>定义并初始化一个自选变量。</td></tr><tr><td>int spin_lock_init(spinlock_t *lock)</td><td>初始化自旋锁。</td></tr><tr><td>void spin_lock(spinlock_t *lock)</td><td>获取指定的自旋锁，也叫做加锁。</td></tr><tr><td>void spin_unlock(spinlock_t *lock)</td><td>释放指定的自旋锁。</td></tr><tr><td>int spin_trylock(spinlock_t *lock)</td><td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td></tr><tr><td>int spin_is_locked(spinlock_t *lock)</td><td>检查指定的自旋锁是否被获取，如果没有被获取就返回非 0，否则返回 0。</td></tr></tbody></table><p>(<strong>建议使用下面的 spin_lock_irqsave&#x2F; spin_unlock_irqrestore 函数来获取锁释放锁</strong>)</p><p>表中的自旋锁API函数适用于SMP或支持抢占的单CPU下线程之间的并发访问，也就是用于线程与线程之间，被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数，否则的话会可能会导致死锁现象的发生。</p><p>自旋锁会自动禁止抢占，也就说当线程 A得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，好了，死锁发生了！</p><p>表  中的 API 函数用于线程之间的并发访问，如果此时中断也要插一脚，中断也想访问共享资源，那该怎么办呢？首先可以肯定的是，中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)，否则可能导致锁死现象的发生，如图 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822124306210.png" alt="image-20200822124306210"></p><p>在图  中，线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 functionA 函数的时候中断发生了，中断抢走了 CPU 使用权。右边的中断服务函数也要获取 lock 这个锁，但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程 A 是不可能执行的，线程 A 说“你先放手”，中断说“你先放手”，场面就这么僵持着，死锁发生！</p><p>最好的解决方法就是获取锁之前关闭本地中断，Linux 内核提供了相应的 API 函数，如表</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>void spin_lock_irq(spinlock_t *lock)</td><td>禁止本地中断，并获取自旋锁。</td></tr><tr><td>void spin_unlock_irq(spinlock_t *lock)</td><td>激活本地中断，并释放自旋锁。</td></tr><tr><td>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)</td><td>保存中断状态，禁止本地中断，并获取自旋锁。</td></tr><tr><td>void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)</td><td>将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁。</td></tr></tbody></table><p>使用 spin_lock_irq&#x2F;spin_unlock_irq 的时候需要用户能够确定加锁之前的中断状态，但实际上内核很庞大，运行也是“千变万化”，我们是很难确定某个时刻的中断状态，因此不推荐使用spin_lock_irq&#x2F;spin_unlock_irq。</p><p><strong>建议使用 spin_lock_irqsave&#x2F; spin_unlock_irqrestore</strong>，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。一般在线程中使用 spin_lock_irqsave&#x2F;spin_unlock_irqrestore，在中断中使用 spin_lock&#x2F;spin_unlock，示例代码如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> DEFINE_SPINLOCK(lock) <span class="hljs-comment">/* 定义并初始化一个锁 */</span><span class="hljs-number">2</span><span class="hljs-number">3</span> <span class="hljs-comment">/* 线程 A */</span><span class="hljs-number">4</span> <span class="hljs-type">void</span> <span class="hljs-title function_">functionA</span> <span class="hljs-params">()</span>&#123;<span class="hljs-number">5</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags; <span class="hljs-comment">/* 中断状态 */</span><span class="hljs-number">6</span> spin_lock_irqsave(&amp;lock, flags) <span class="hljs-comment">/* 获取锁 */</span><span class="hljs-number">7</span> <span class="hljs-comment">/* 临界区 */</span><span class="hljs-number">8</span> spin_unlock_irqrestore(&amp;lock, flags)  <span class="hljs-comment">/* 释放锁 */</span><span class="hljs-number">9</span> &#125;<span class="hljs-number">10</span><span class="hljs-number">11</span> <span class="hljs-comment">/* 中断服务函数 */</span><span class="hljs-number">12</span> <span class="hljs-type">void</span> <span class="hljs-title function_">irq</span><span class="hljs-params">()</span> &#123;<span class="hljs-number">13</span> spin_lock(&amp;lock) <span class="hljs-comment">/* 获取锁 */</span><span class="hljs-number">14</span> <span class="hljs-comment">/* 临界区 */</span><span class="hljs-number">15</span> spin_unlock(&amp;lock) <span class="hljs-comment">/* 释放锁 */</span><span class="hljs-number">16</span> &#125;</code></pre></div><p><strong>下半部(BH)</strong> 也会竞争共享资源，有些资料也会将下半部叫做底半部。关于下半部后面的章节会讲解，如果要在下半部里面使用自旋锁，可以使用表  中的 API 函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>void spin_lock_bh(spinlock_t *lock)</td><td>关闭下半部，并获取自旋锁。</td></tr><tr><td>void spin_unlock_bh(spinlock_t *lock)</td><td>打开下半部，并释放自旋锁。</td></tr></tbody></table><h3 id="3、其他类型的锁"><a href="#3、其他类型的锁" class="headerlink" title="3、其他类型的锁"></a>3、其他类型的锁</h3><p>在自旋锁的基础上还衍生出了其他特定场合使用的锁，这些锁在驱动中其实用的不多，更多的是在 Linux 内核中使用，本节我们简单来了解一下这些衍生出来的锁。</p><h4 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h4><p>现在有个学生信息表，此表存放着学生的年龄、家庭住址、班级等信息，此表可以随时被修改和读取。此表肯定是数据，那么必须要对其进行保护，如果我们现在使用自旋锁对其进行保护。每次只能一个读操作或者写操作，但是，实际上此表是可以并发读取的。只需要保证在修改此表的时候没人读取，或者在其他人读取此表的时候没有人修改此表就行了。也就是此表的读和写不能同时进行，但是可以多人并发的读取此表。</p><p>像这样，<strong>当某个数据结构符合读&#x2F;写或生产者&#x2F;消费者模型的时候就可以使用读写自旋锁</strong>。读写自旋锁为读和写操作提供了不同的锁，一次只能允许一个写操作，也就是只能一个线程持有写锁，而且不能进行读操作。但是当没有写操作的时候允许一个或多个线程持有读锁，可以进行并发的读操作。Linux 内核使用 rwlock_t 结构体表示读写锁，结构体定义如下(删除了条件编译)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-type">arch_rwlock_t</span> raw_lock;&#125; <span class="hljs-type">rwlock_t</span>;</code></pre></div><p>读写锁操作 API 函数分为两部分，一个是给读使用的，一个是给写使用的，这些 API 函数如表 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822125245285.png" alt="image-20200822125245285"></p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822125304199.png" alt="image-20200822125304199"></p><h4 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h4><p>顺序锁在读写锁的基础上衍生而来的，使用读写锁的时候读操作和写操作不能同时进行。使用顺序锁的话可以允许在写的时候进行读操作，也就是实现同时读写，但是不允许同时进行并发的写操作。虽然顺序锁的读和写操作可以同时进行，但是如果在读的过程中发生了写操作，最好重新进行读取，保证数据完整性。顺序锁保护的资源不能是指针，因为如果在写操作的时候可能会导致指针无效，而这个时候恰巧有读操作访问指针的话就可能导致意外发生，比如读取野指针导致系统崩溃。Linux 内核使用 seqlock_t 结构体表示顺序锁，结构体定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seqcount</span> <span class="hljs-title">seqcount</span>;</span>    <span class="hljs-type">spinlock_t</span> lock;&#125; <span class="hljs-type">seqlock_t</span>;</code></pre></div><p>关于顺序锁的 API 函数如表 47.3.3.2 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200822125441574.png" alt="image-20200822125441574"></p><h3 id="4、自旋锁使用注意事项"><a href="#4、自旋锁使用注意事项" class="headerlink" title="4、自旋锁使用注意事项"></a>4、自旋锁使用注意事项</h3><p>综合前面关于自旋锁的信息，我们需要在使用自旋锁的时候要注意一下几点：</p><ul><li>①、因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如稍后要讲的信号量和互斥体。</li><li>②、自旋锁保护的临界区内不能调用任何可能导致线程休眠的 API 函数，否则的话可能导致死锁。</li><li>③、不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了！</li><li>④、在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管你用的是单核的还是多核的 SOC，都将其当做多核 SOC 来编写驱动程序。</li></ul><h2 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4|信号量"></a>4|信号量</h2><h3 id="1、信号量简介"><a href="#1、信号量简介" class="headerlink" title="1、信号量简介"></a>1、信号量简介</h3><p>大家如果有学习过 FreeRTOS 或者 UCOS 的话就应该对信号量很熟悉，因为<strong>信号量是同步的一种方式</strong>。Linux 内核也提供了信号量机制，信号量常常用于控制对共享资源的访问。</p><p>举一个很常见的例子，某个停车场有 100 个停车位，这 100 个停车位大家都可以用，对于大家来说这100 个停车位就是共享资源。假设现在这个停车场正常运行，你要把车停到这个这个停车场肯定要先看一下现在停了多少车了？还有没有停车位？当前停车数量就是一个信号量，具体的停车数量就是这个信号量值，当这个值到 100 的时候说明停车场满了。停车场满的时你可以等一会看看有没有其他的车开出停车场，当有车开出停车场的时候停车数量就会减一，也就是说信号量减一，此时你就可以把车停进去了，你把车停进去以后停车数量就会加一，也就是信号量加一。</p><p>这就是一个典型的使用信号量进行共享资源管理的案例，在这个案例中使用的就是<strong>计数型信号量</strong>。</p><p>相比于自旋锁，信号量可以使线程进入休眠状态，比如 A 与 B、C 合租了一套房子，这个房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着，等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继续回房间睡觉，这个时候相当于信号量。</p><p>可以看出，使用信号量会提高处理器的使用效率，毕竟不用一直傻乎乎的在那里“自旋”等待。但是，信号量的开销要比自旋锁大，因为信号量使线程进入休眠状态以后会切换线程，切换线程就会有开销。总结一下信号量的特点：</p><ul><li>①、因为信号量可以使等待资源线程进入休眠状态，因此适用于那些占用资源比较久的场合。</li><li>②、因此信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。</li><li>③、如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。</li></ul><p>信号量有一个信号量值，相当于一个房子有 10 把钥匙，这 10 把钥匙就相当于信号量值为10。因此，可以通过信号量来控制访问共享资源的访问数量，如果要想进房间，那就要先获取一把钥匙，信号量值减 1，直到 10 把钥匙都被拿走，信号量值为 0，这个时候就不允许任何人进入房间了，因为没钥匙了。如果有人从房间出来，那他要归还他所持有的那把钥匙，信号量值加 1，此时有 1 把钥匙了，那么可以允许进去一个人。相当于通过信号量控制访问资源的线程数，在初始化的时候将信号量值设置的大于 1，那么这个信号量就是<strong>计数型信号量</strong>，<strong>计数型信号量不能用于互斥访问</strong>，因为它允许多个线程同时访问共享资源。如果要互斥的访问共享资源那么信号量的值就不能大于 1，此时的信号量就是一个<strong>二值信号量</strong>。</p><h3 id="2、信号量-API-函数"><a href="#2、信号量-API-函数" class="headerlink" title="2、信号量 API  函数"></a>2、信号量 API  函数</h3><p>Linux 内核使用 <strong>semaphore 结构体</strong>表示信号量，结构体内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span>    <span class="hljs-type">raw_spinlock_t</span> lock;    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">wait_list</span>;</span>&#125;;</code></pre></div><p>要想使用信号量就得先定义，然后初始化信号量。有关信号量的 API 函数如表所示：</p><table><thead><tr><th>函数</th><th align="left">描述</th></tr></thead><tbody><tr><td>DEFINE_SEAMPHORE(name)</td><td align="left">定义一个信号量，并且设置信号量的值为 1。</td></tr><tr><td>void sema_init(struct semaphore *sem, int val)</td><td align="left">初始化信号量 sem，设置信号量值为 val</td></tr><tr><td>void down(struct semaphore *sem)</td><td align="left">获取信号量，因为会导致休眠，因此不能在中断中使用。</td></tr><tr><td>int down_trylock(struct semaphore *sem)</td><td align="left">尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0，并且不会进入休眠.</td></tr><tr><td>int down_interruptible(struct semaphore *sem)</td><td align="left">获取信号量，和 down 类似，只是使用 down 进入休眠状态的线程不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的。</td></tr><tr><td>void up(struct semaphore *sem)</td><td align="left">释放信号量</td></tr></tbody></table><p>信号量的使用如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">sem</span>;</span> <span class="hljs-comment">/* 定义信号量 */</span>sema_init(&amp;sem, <span class="hljs-number">1</span>)； <span class="hljs-comment">/* 初始化信号量 */</span>    down(&amp;sem); <span class="hljs-comment">/* 申请信号量 */</span><span class="hljs-comment">/* 临界区 */</span>up(&amp;sem); <span class="hljs-comment">/* 释放信号量 */</span></code></pre></div><h2 id="5-互斥体"><a href="#5-互斥体" class="headerlink" title="5|互斥体"></a>5|互斥体</h2><h3 id="1、互斥体简介"><a href="#1、互斥体简介" class="headerlink" title="1、互斥体简介"></a>1、互斥体简介</h3><p>在 FreeRTOS 和 UCOS 中也有互斥体，将信号量的值设置为 1 就可以使用信号量进行互斥访问了，虽然可以通过信号量实现互斥，但是 Linux 提供了一个比信号量更专业的机制来进行互斥，它就是<strong>互斥体—mutex</strong>。<strong>互斥访问表示一次只有一个线程可以访问共享资源</strong>，不能递归申请互斥体。在我们编写 Linux 驱动的时候遇到需要互斥访问的地方建议使用 mutex。Linux 内核使用 mutex 结构体表示互斥体，定义如下(省略条件编译部分)：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> &#123;</span>    <span class="hljs-comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span>    <span class="hljs-type">atomic_t</span> count;    <span class="hljs-type">spinlock_t</span> wait_lock;&#125;;</code></pre></div><p>在使用 mutex 之前要先定义一个 mutex 变量。在使用 mutex 的时候要注意如下几点：</p><ul><li>①、mutex 可以导致休眠，因此不能在中断中使用 mutex，<strong>中断中只能使用自旋锁</strong>。</li><li>②、和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。</li><li>③、因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁。</li></ul><h3 id="2、互斥体-API-函数"><a href="#2、互斥体-API-函数" class="headerlink" title="2、互斥体 API  函数"></a>2、互斥体 API  函数</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>DEFINE_MUTEX(name)</td><td>定义并初始化一个 mutex 变量。</td></tr><tr><td>void mutex_init(mutex *lock)</td><td>初始化 mutex</td></tr><tr><td>void mutex_lock(struct mutex *lock)</td><td>获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</td></tr><tr><td>void mutex_unlock(struct mutex *lock)</td><td>释放 mutex，也就给 mutex 解锁。</td></tr><tr><td>int mutex_trylock(struct mutex *lock)</td><td>尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。</td></tr><tr><td>int mutex_is_locked(struct mutex *lock)</td><td>判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</td></tr><tr><td>int mutex_lock_interruptible(struct mutex *lock)</td><td>使用此函数获取信号量失败进入休眠以后可以被信号打断。</td></tr></tbody></table><p>互斥体的使用如下所示：</p><p>关于 Linux 中的并发和竞争就讲解到这里，Linux 内核还有很多其他的处理并发和竞争的机制，本章我们主要讲解了常用的原子操作、自旋锁、信号量和互斥体。以后我们在编写 Linux驱动的时候就会频繁的使用到这几种机制，希望大家能够深入理解这几个常用的机制。</p><h1 id="Linux并发与竞争实验"><a href="#Linux并发与竞争实验" class="headerlink" title="Linux并发与竞争实验"></a>Linux并发与竞争实验</h1><p>在上一章中我们学习了 Linux 下的并发与竞争，并且学习了四种常用的处理并发和竞争的机制：原子操作、自旋锁、信号量和互斥体。本章我们就通过四个实验来学习如何在驱动中使用这四种机制。</p><h2 id="1-原子操作实验"><a href="#1-原子操作实验" class="headerlink" title="1|原子操作实验"></a>1|原子操作实验</h2><p>本例程我们在前面的 gpioled.c 文件基础上完成。在本节使用中我们使用原子操作来实现对 LED 这个设备的互斥访问，也就是一次只允许一个应用程序可以使用 LED 灯。</p><h3 id="LED-驱动修改"><a href="#LED-驱动修改" class="headerlink" title="LED  驱动修改"></a>LED  驱动修改</h3><p>实验在实验驱动文件 gpioled.c 的基础上修改而来。新建名为“7_atomic”的文件夹，然后在 7_atomic 文件夹里面创建 vscode 工程，工作区命名为“atomic”。将 5_gpioled实验中的 gpioled.c 复制到 7_atomic 文件夹中，并且重命名为 atomic.c。</p><p>本节实验重点就是使用atomic 来实现一次只能允许一个应用访问 LED，所以我们只需要在 atomic.c 文件源码的基础上加上添加 atomic 相关代码即可，完成以后的 atomic.c 文件内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>LED_OFF = <span class="hljs-number">0</span>,LED_ON = !LED_OFF&#125;<span class="hljs-type">led_switch_t</span>;<span class="hljs-comment">/* 设备号个数 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span><span class="hljs-comment">/* gpioled设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-type">char</span> *devname;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span><span class="hljs-comment">//设备树节点</span><span class="hljs-type">int</span> led_gpio;<span class="hljs-comment">//led所使用的GPIO编号</span><span class="hljs-type">atomic_t</span> lock;<span class="hljs-comment">//原子变量</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>&#123;<span class="hljs-comment">//int val = 0;</span><span class="hljs-keyword">if</span>(sw == LED_ON)&#123;<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-comment">/* 通过判断原子变量的值来检查 LED 有没有被别的应用使用 */</span><span class="hljs-comment">/* 原子变量为1说明没有被使用 */</span><span class="hljs-keyword">if</span> (!atomic_dec_and_test(&amp;gpioled.lock))&#123;<span class="hljs-type">atomic_inc</span>(&amp;gpioled.lock);<span class="hljs-comment">/*  小于 0  的话就加 1, 使其原子变量等于 0 */</span><span class="hljs-keyword">return</span> -EBUSY;<span class="hljs-comment">/* LED  被使用，返回忙 */</span>&#125;filp-&gt;private_data = &amp;gpioled;<span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;/* 以访问私有数据 */</span><span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = copy_from_user(userDataBuf, buf, cnt);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;led_switch(userDataBuf[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;<span class="hljs-comment">/* 关闭驱动文件的时候释放原子变量 */</span><span class="hljs-type">atomic_inc</span>(&amp;dev-&gt;lock);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作集合 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;.owner = THIS_MODULE,.write = gpioled_write,.read = gpioled_read,.open = gpioled_open,.release = gpioled_release&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 初始化原子变量 */</span><span class="hljs-type">atomic_set</span>(&amp;gpioled.lock, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 原子变量初始值为 1 */</span><span class="hljs-comment">/* 注册设备号 */</span>gpioled.devname = <span class="hljs-string">&quot;atomicled&quot;</span>;gpioled.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(gpioled.major)&#123;gpioled.devid = MKDEV(gpioled.major, gpioled.minor);ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);&#125;gpioled.major = MAJOR(gpioled.devid);gpioled.minor = MINOR(gpioled.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);<span class="hljs-comment">/* 添加字符设备 */</span>gpioled.cdev.owner = gpioled_fops.owner;cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>gpioled.class = class_create(THIS_MODULE, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);result = PTR_ERR(gpioled.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);result = PTR_ERR(gpioled.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 获取设备节点 */</span>gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_findnd;&#125;<span class="hljs-comment">/* 获取LED对应的GPIO */</span>gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;result = -EINVAL;printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);<span class="hljs-keyword">goto</span> fail_get_gpio;&#125;printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);<span class="hljs-comment">/* 申请IO */</span>ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_request_gpio;&#125;<span class="hljs-comment">/* 使用IO */</span>ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_gpio_failed;&#125;<span class="hljs-comment">/* 设置GPIO电平 */</span>printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 默认开灯 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_gpio_failed:<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);fail_request_gpio:fail_get_gpio:fail_findnd:<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 关灯 */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(gpioled_init);module_exit(gpioled_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>添加了原子变量 lock，用来实现一次只能允许一个应用访问 LED 灯，led_init 驱动入口函数会将 lock 的值设置为 1。</p><p>每次调用 open 函数打开驱动设备的时候先申请 lock，如果申请成功的话就表示LED灯还没有被其他的应用使用，如果申请失败就表示LED灯正在被其他的应用程序使用。每次打开驱动设备的时候先使用atomic_dec_and_test 函数将 lock 减 1，如果 atomic_dec_and_test函数返回值为真就表示 lock 当前值为 0，说明设备可以使用。如果 atomic_dec_and_test 函数返回值为假，就表示 lock 当前值为负数(lock 值默认是 1)，lock 值为负数的可能性只有一个，那就是其他设备正在使用 LED。其他设备正在使用 LED 灯，那么就只能退出了，在退出之前调用函数 atomic_inc 将 lock 加 1，因为此时 lock 的值被减成了负数，必须要对其加 1，将 lock 的值变为 0。</p><p><strong>LED 灯使用完毕</strong>，应用程序调用 close 函数关闭的驱动文件，<strong>gpioled_release 函数执行</strong>，调用atomic_inc 释放 lcok，也就是将 lock 加 1。</p><p>驱动初始化函数初始化原子变量 lock，初始值设置为 1，这样每次就只允许一个应用使用 LED灯。</p><hr><h3 id="APP编写"><a href="#APP编写" class="headerlink" title="APP编写"></a>APP编写</h3><p>新建名为 atomicApp.c 的测试 APP，在里面输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-comment">/*</span><span class="hljs-comment"> *  usage:</span><span class="hljs-comment"> *  ./ledAPP     &lt;openFileName&gt;     &lt;0:OFF|1:ON&gt;   </span><span class="hljs-comment"> *  ./ledAPP     /dev/gpioled           0               //关灯</span><span class="hljs-comment"> *  ./ledAPP     /dev/gpioled           1               //开灯</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> *filename;    <span class="hljs-type">char</span> writebuf [<span class="hljs-number">1</span>];     filename = argv[<span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:\r\n./ledAPP     &lt;openFileName&gt;     &lt;0:OFF|1:ON&gt;  \r\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-comment">/* 打开 */</span>    fd =  open(filename, O_WRONLY);    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    writebuf[<span class="hljs-number">0</span>] = atoi(argv[<span class="hljs-number">2</span>]);    ret = write(fd, writebuf, <span class="hljs-keyword">sizeof</span>(writebuf));    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s failed!\r\n&quot;</span>, filename);        close(fd);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s success!\r\n&quot;</span>, filename);    &#125;    <span class="hljs-comment">/* 模拟占用 25S LED */</span>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        sleep(<span class="hljs-number">5</span>);        cnt++;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;App running times:%d s.\r\n&quot;</span>, cnt * <span class="hljs-number">5</span>);        <span class="hljs-keyword">if</span>(cnt &gt;= <span class="hljs-number">5</span>) <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">/* 关闭 */</span>    ret = close(fd);    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close file %s failed！\r\n&quot;</span>, filename);    &#125;&#125;</code></pre></div><p>atomicApp.c 中的内容就是在 ledAPP.c 的基础上修改而来的，重点是加入了模拟占用 25 秒 LED 的代码。测试 APP 在获取到 LED 灯驱动的使用权以后会使用 25S，在使用的这段时间如果有其他的应用也去获取 LED 灯使用权的话肯定会失败！</p><h3 id="运行测试："><a href="#运行测试：" class="headerlink" title="运行测试："></a>运行测试：</h3><p>将编译出来的 atomic.ko 和 atomicApp 这两个文件拷贝到 rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15目录中，重启开发板，进入到目录 lib&#x2F;modules&#x2F;4.1.15 中，输入如下命令加载 atomic.ko 驱动模块：</p><div class="hljs code-wrapper"><pre><code class="hljs c">depmod <span class="hljs-comment">//第一次加载驱动的时候需要运行此命令</span>modprobe atomic.ko  <span class="hljs-comment">//加载驱动</span></code></pre></div><p>驱动加载成功以后就可以使用 atomicApp 软件来测试驱动是否工作正常，输入如下命令以后台运行模式打开 LED 灯，“&amp;”表示在后台运行 atomicApp 这个软件：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">./atomicApp /dev/atomicled 1&amp; //打开 LED 灯</code></pre></div><p>然后在app程序结束前，再次输入：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomicApp /</span>dev<span class="hljs-regexp">/atomicled 0 /</span><span class="hljs-regexp">/关闭 LED 灯</span></code></pre></div><p>会发现提示 error can’t open file.</p><h2 id="2-自旋锁实验"><a href="#2-自旋锁实验" class="headerlink" title="2|自旋锁实验"></a>2|自旋锁实验</h2><p>上一节我们使用原子变量实现了一次只能有一个应用程序访问 LED 灯，本节我们使用自旋锁来实现此功能。在使用自旋锁之前，先回顾一下自旋锁的使用注意事项：</p><ul><li>①、自旋锁保护的临界区要尽可能的短，因此在 open 函数中申请自旋锁，然后在 release 函数中释放自旋锁的方法就不可取。我们可以使用一个变量来表示设备的使用情况，如果设备被使用了那么变量就加一，设备被释放以后变量就减 1，我们只需要使用自旋锁保护这个变量即可。</li><li>②、考虑驱动的兼容性，合理的选择 API 函数。</li></ul><p>综上所述，在本节例程中，我们通过定义一个变量 dev_stats 表示设备的使用情况，dev_stats为 0 的时候表示设备没有被使用，dev_stats 大于 0 的时候表示设备被使用。驱动 open 函数中先判断 dev_stats 是否为 0，也就是判断设备是否可用，如果为 0 的话就使用设备，并且将 dev_stats加 1，表示设备被使用了。使用完以后在 release 函数中将 dev_stats 减 1，表示设备没有被使用了。因此真正实现设备互斥访问的是变量 dev_stats，但是我们要使用自旋锁对 dev_stats 来做保护。</p><h3 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a>驱动程序编写</h3><p>本节实验在第上一节实验驱动文件 atomic.c 的基础上修改而来。新建名为“8_spinlock”的文件夹，然后在 8_spinlock 文件夹里面创建 vscode 工程，工作区命名为“spinlock”。将 7_atomic实验中的 atomic.c 复制到 8_spinlock 文件夹中，并且重命名为 spinlock.c。将原来使用 atomic 的地方换为 spinlock 即可，其他代码不需要修改，完成以后的 spinlock.c 文件内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>LED_OFF = <span class="hljs-number">0</span>,LED_ON = !LED_OFF&#125;<span class="hljs-type">led_switch_t</span>;<span class="hljs-comment">/* 设备号个数 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span><span class="hljs-comment">/* gpioled设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-type">char</span> *devname;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span><span class="hljs-comment">//设备树节点</span><span class="hljs-type">int</span> led_gpio;<span class="hljs-comment">//led所使用的GPIO编号</span><span class="hljs-type">int</span> dev_status;<span class="hljs-comment">//设备状态|0:设备未使用|&gt;0:设备被使用</span><span class="hljs-type">spinlock_t</span> lock;<span class="hljs-comment">//自旋锁</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>&#123;<span class="hljs-comment">//int val = 0;</span><span class="hljs-keyword">if</span>(sw == LED_ON)&#123;<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;filp-&gt;private_data = &amp;gpioled; <span class="hljs-comment">/* 设置私有数据 */</span>spin_lock_irqsave(&amp;gpioled.lock, flags); <span class="hljs-comment">/*  上锁 */</span><span class="hljs-keyword">if</span> (gpioled.dev_status) &#123; <span class="hljs-comment">/*  如果设备被使用了 */</span>spin_unlock_irqrestore(&amp;gpioled.lock, flags); <span class="hljs-comment">/*  解锁 */</span><span class="hljs-keyword">return</span> -EBUSY;&#125;gpioled.dev_status++; <span class="hljs-comment">/*  如果设备没有打开，那么就标记已经打开了 */</span>spin_unlock_irqrestore(&amp;gpioled.lock, flags);<span class="hljs-comment">/*  解锁 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;/* 以访问私有数据 */</span><span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = copy_from_user(userDataBuf, buf, cnt);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;led_switch(userDataBuf[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;<span class="hljs-comment">/* 关闭驱动文件的时候将 dev_stats 减 1 */</span>spin_lock_irqsave(&amp;dev-&gt;lock, flags); <span class="hljs-comment">/*  上锁 */</span><span class="hljs-keyword">if</span> (dev-&gt;dev_status) &#123;dev-&gt;dev_status--;&#125;spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);<span class="hljs-comment">/*  解锁 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作集合 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;.owner = THIS_MODULE,.write = gpioled_write,.read = gpioled_read,.open = gpioled_open,.release = gpioled_release&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 初始化自旋锁 */</span>spin_lock_init(&amp;gpioled.lock);<span class="hljs-comment">/* 注册设备号 */</span>gpioled.devname = <span class="hljs-string">&quot;spinlock_led&quot;</span>;gpioled.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(gpioled.major)&#123;gpioled.devid = MKDEV(gpioled.major, gpioled.minor);ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);&#125;gpioled.major = MAJOR(gpioled.devid);gpioled.minor = MINOR(gpioled.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);<span class="hljs-comment">/* 添加字符设备 */</span>gpioled.cdev.owner = gpioled_fops.owner;cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>gpioled.class = class_create(THIS_MODULE, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);result = PTR_ERR(gpioled.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);result = PTR_ERR(gpioled.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 获取设备节点 */</span>gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_findnd;&#125;<span class="hljs-comment">/* 获取LED对应的GPIO */</span>gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;result = -EINVAL;printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);<span class="hljs-keyword">goto</span> fail_get_gpio;&#125;printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);<span class="hljs-comment">/* 申请IO */</span>ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_request_gpio;&#125;<span class="hljs-comment">/* 使用IO */</span>ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_gpio_failed;&#125;<span class="hljs-comment">/* 设置GPIO电平 */</span>printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 默认开灯 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_gpio_failed:<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);fail_request_gpio:fail_get_gpio:fail_findnd:<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 关灯 */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(gpioled_init);module_exit(gpioled_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>dev_stats 表示设备状态，如果为 0 的话表示设备还没有被使用，如果大于 0 的话就表示设备已经被使用了。定义自旋锁变量 lock。使用自旋锁实现对设备的互斥访问，</p><p>调用 spin_lock_irqsave 函数获取锁，为了考虑到驱动兼容性，这里并没有使用 spin_lock 函数来获取锁。判断dev_stats 是否大于 0，如果是的话表示设备已经被使用了，那么就调用spin_unlock_irqrestore函数释放锁，并且返回-EBUSY。如果设备没有被使用的话就将 dev_stats 加 1，表示设备要被使用了，然后调用 spin_unlock_irqrestore 函数释放锁。自旋锁的工作就是保护dev_stats 变量，真正实现对设备互斥访问的是 dev_stats。</p><p>在 release 函数中将 dev_stats 减 1，表示设备被释放了，可以被其他的应用程序使用。将 dev_stats 减 1 的时候需要自旋锁对其进行保护。</p><p>在驱动入口函数 led_init 中调用 spin_lock_init 函数初始化自旋锁。</p><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>编译运行。</p><p>驱动加载成功以后就可以使用 spinlockApp 软件测试驱动是否工作正常，测试方法和 前面测试小节中一样，先输入如下命令让 spinlockAPP 软件模拟占用 25S 的 LED 灯：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomicApp /</span>dev<span class="hljs-regexp">/spinlock_led 1&amp; /</span><span class="hljs-regexp">/打开 LED 灯</span></code></pre></div><p>紧接着再输入如下命令关闭 LED 灯：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomicApp /</span>dev<span class="hljs-regexp">/spinlock_led 0 /</span><span class="hljs-regexp">/关闭 LED 灯</span></code></pre></div><p>看一下能不能关闭 LED 灯，驱动正常工作的话并不会马上关闭 LED 灯，会提示你“open failed!”，必须等待第一个 atomicApp 软件运行完成(25S 计时结束)才可以再次操作 LED 灯。</p><h2 id="3-信号量实验"><a href="#3-信号量实验" class="headerlink" title="3|信号量实验"></a>3|信号量实验</h2><p>本节我们来使用信号量实现了一次只能有一个应用程序访问 LED 灯，信号量可以导致休眠，因此信号量保护的临界区没有运行时间限制，可以在驱动的 open 函数申请信号量，然后在release 函数中释放信号量。但是<strong>信号量不能用在中断中</strong>，本节实验我们不会在中断中使用信号量。</p><h3 id="LED-驱动修改-1"><a href="#LED-驱动修改-1" class="headerlink" title="LED  驱动修改"></a>LED  驱动修改</h3><p>本节实验在实验驱动文件 spinlock.c 的基础上修改而来。新建名为“9_semaphore”的文件夹，然后在 9_semaphore 文件夹里面创建 vscode 工程，工作区命名为“semaphore”。将8_spinlock 实验中的 spinlock.c 复制到 9_semaphore 文件夹中，并且重命名为 semaphore.c。将原来使用到自旋锁的地方换为信号量即可，其他的内容基本不变，完成以后的 semaphore.c 文件内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>LED_OFF = <span class="hljs-number">0</span>,LED_ON = !LED_OFF&#125;<span class="hljs-type">led_switch_t</span>;<span class="hljs-comment">/* 设备号个数 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span><span class="hljs-comment">/* gpioled设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-type">char</span> *devname;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span><span class="hljs-comment">//设备树节点</span><span class="hljs-type">int</span> led_gpio;<span class="hljs-comment">//led所使用的GPIO编号</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">sem</span>;</span> <span class="hljs-comment">//信号量</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>&#123;<span class="hljs-comment">//int val = 0;</span><span class="hljs-keyword">if</span>(sw == LED_ON)&#123;<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;gpioled; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-comment">/*  获取信号量, 进入休眠状态的进程可以被信号打断 */</span><span class="hljs-keyword">if</span> (down_interruptible(&amp;gpioled.sem)) &#123;<span class="hljs-keyword">return</span> -ERESTARTSYS;&#125;<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>down(&amp;gpioled.sem); <span class="hljs-comment">/*  不能被信号打断 */</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;/* 以访问私有数据 */</span><span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = copy_from_user(userDataBuf, buf, cnt);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;led_switch(userDataBuf[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;up(&amp;dev-&gt;sem); <span class="hljs-comment">/*  释放信号量，信号量值加 1 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作集合 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;.owner = THIS_MODULE,.write = gpioled_write,.read = gpioled_read,.open = gpioled_open,.release = gpioled_release&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 初始化信号量 */</span>sema_init(&amp;gpioled.sem, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 注册设备号 */</span>gpioled.devname = <span class="hljs-string">&quot;semaphore_led&quot;</span>;gpioled.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(gpioled.major)&#123;gpioled.devid = MKDEV(gpioled.major, gpioled.minor);ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);&#125;gpioled.major = MAJOR(gpioled.devid);gpioled.minor = MINOR(gpioled.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);<span class="hljs-comment">/* 添加字符设备 */</span>gpioled.cdev.owner = gpioled_fops.owner;cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>gpioled.class = class_create(THIS_MODULE, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);result = PTR_ERR(gpioled.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);result = PTR_ERR(gpioled.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 获取设备节点 */</span>gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_findnd;&#125;<span class="hljs-comment">/* 获取LED对应的GPIO */</span>gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;result = -EINVAL;printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);<span class="hljs-keyword">goto</span> fail_get_gpio;&#125;printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);<span class="hljs-comment">/* 申请IO */</span>ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_request_gpio;&#125;<span class="hljs-comment">/* 使用IO */</span>ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_gpio_failed;&#125;<span class="hljs-comment">/* 设置GPIO电平 */</span>printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 默认开灯 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_gpio_failed:<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);fail_request_gpio:fail_get_gpio:fail_findnd:<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 关灯 */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(gpioled_init);module_exit(gpioled_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>要使用信号量必须添加&lt;linux&#x2F;semaphore.h&gt;头文件。</p><p>在设备结构体中添加一个信号量成员变量 sem。然后在open函数中申请信号量，可以使用down函数，也可以使用down_interruptible函数。如果信号量值大于等于 1 就表示可用，那么应用程序就会开始使用 LED 灯。<strong>如果信号量值为 0 就表示应用程序不能使用 LED 灯，此时应用程序就会进入到休眠状态。等到信号量值大于 1 的时候应用程序就会唤醒，申请信号量，获取 LED 灯使用权</strong>。</p><p>在 release 函数中调用 up 函数释放信号量，这样其他因为没有得到信号量而进入休眠状态的应用程序就会唤醒，获取信号量。</p><p>在驱动入口函数中调用 sema_init 函数初始化信号量 sem 的值为 1，相当于 sem是个二值信号量。</p><h3 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h3><p>编译后，加载运行。</p><p>测试方法和前面小节中一样，先输入如下命令让 软件模拟占用 25S 的 LED 灯：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomic /</span>dev<span class="hljs-regexp">/semaphore_led 1&amp; /</span><span class="hljs-regexp">/打开 LED 灯</span></code></pre></div><p>紧接着再输入如下命令关闭 LED 灯：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/atomic /</span>dev<span class="hljs-regexp">/semaphore_led 0&amp; /</span><span class="hljs-regexp">/打开 LED 灯</span></code></pre></div><p>注意两个命令都是运行在后台，第一条命令先获取到信号量，因此可以操作 LED 灯，将LED 灯打开，并且占有 25S。第二条命令因为获取信号量失败而进入休眠状态，等待第一条命令运行完毕并释放信号量以后才拥有 LED 灯使用权，将 LED 灯关闭，运行结果如图 所示：</p><p><img src="/2020/09/11/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/6%E3%80%81Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/image-20200823150509236.png" alt="image-20200823150509236"></p><h2 id="4-互斥体实验"><a href="#4-互斥体实验" class="headerlink" title="4|互斥体实验"></a>4|互斥体实验</h2><p>前面我们使用原子操作、自旋锁和信号量实现了对 LED 灯的互斥访问，但是最适合互斥的就是互斥体 mutex 了。本节我们来学习一下如何使用 mutex 实现对 LED 灯的互斥访问。</p><h3 id="LED驱动修改"><a href="#LED驱动修改" class="headerlink" title="LED驱动修改"></a>LED驱动修改</h3><p>本节实验在第上一节实验驱动文件 semaphore.c 的基础上修改而来。新建名为“10_mutex”的文件夹，然后在10_mutex文件夹里面创建vscode工程，工作区命名为“mutex”。将9_semaphore实验中的semaphore.c 复制到 10_mutex 文件夹中，并且重命名为 mutex.c。将原来使用到信号量的地方换为mutex即可，其他的内容基本不变，完成以后的mutex.c文件内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_address.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>LED_OFF = <span class="hljs-number">0</span>,LED_ON = !LED_OFF&#125;<span class="hljs-type">led_switch_t</span>;<span class="hljs-comment">/* 设备号个数 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOLED_DEV_NUM 1</span><span class="hljs-comment">/* gpioled设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-type">char</span> *devname;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span><span class="hljs-comment">//设备树节点</span><span class="hljs-type">int</span> led_gpio;<span class="hljs-comment">//led所使用的GPIO编号</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">/*  互斥体 */</span>&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> <span class="hljs-title">gpioled</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>&#123;<span class="hljs-comment">//int val = 0;</span><span class="hljs-keyword">if</span>(sw == LED_ON)&#123;<span class="hljs-comment">/* 设置GPIO电平为低电平 点亮LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;gpioled; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-comment">/* 获取互斥体,可以被信号打断 */</span><span class="hljs-keyword">if</span> (mutex_lock_interruptible(&amp;gpioled.lock)) &#123;<span class="hljs-keyword">return</span> -ERESTARTSYS;&#125;<span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>mutex_lock(&amp;gpioled.lock); <span class="hljs-comment">/*  不能被信号打断 */</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">gpioled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-comment">//struct gpioled_dev *dev = (struct gpioled_dev*)filp-&gt;private_data;/* 以访问私有数据 */</span><span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = copy_from_user(userDataBuf, buf, cnt);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;led_switch(userDataBuf[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpioled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpioled_dev</span> *<span class="hljs-title">dev</span> =</span> filp-&gt;private_data;<span class="hljs-comment">/* 释放互斥锁 */</span>mutex_unlock(&amp;dev-&gt;lock);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 设备操作集合 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gpioled_fops</span> =</span> &#123;.owner = THIS_MODULE,.write = gpioled_write,.read = gpioled_read,.open = gpioled_open,.release = gpioled_release&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">gpioled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 初始化互斥体 */</span>mutex_init(&amp;gpioled.lock);<span class="hljs-comment">/* 注册设备号 */</span>gpioled.devname = <span class="hljs-string">&quot;mutex_led&quot;</span>;gpioled.major = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(gpioled.major)&#123;gpioled.devid = MKDEV(gpioled.major, gpioled.minor);ret = register_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM, gpioled.devname);&#125;<span class="hljs-keyword">else</span>&#123;ret = alloc_chrdev_region(&amp;gpioled.devid, <span class="hljs-number">0</span>, GPIOLED_DEV_NUM, gpioled.devname);&#125;gpioled.major = MAJOR(gpioled.devid);gpioled.minor = MINOR(gpioled.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register devid failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_devid;&#125;printk(<span class="hljs-string">&quot;gpioled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, gpioled.major, gpioled.minor);<span class="hljs-comment">/* 添加字符设备 */</span>gpioled.cdev.owner = gpioled_fops.owner;cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_DEV_NUM);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_register_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>gpioled.class = class_create(THIS_MODULE, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.class))&#123;printk(<span class="hljs-string">&quot;fail to create class!\r\n&quot;</span>);result = PTR_ERR(gpioled.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>gpioled.device = device_create(gpioled.class, <span class="hljs-literal">NULL</span>, gpioled.devid, <span class="hljs-literal">NULL</span>, gpioled.devname);<span class="hljs-keyword">if</span>(IS_ERR(gpioled.device))&#123;printk(<span class="hljs-string">&quot;fail to create device!\r\n&quot;</span>);result = PTR_ERR(gpioled.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* 获取设备节点 */</span>gpioled.np = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);<span class="hljs-keyword">if</span>(gpioled.np == <span class="hljs-literal">NULL</span>)&#123;printk(<span class="hljs-string">&quot;no device_node found!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_findnd;&#125;<span class="hljs-comment">/* 获取LED对应的GPIO */</span>gpioled.led_gpio = of_get_named_gpio(gpioled.np, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(gpioled.led_gpio &lt; <span class="hljs-number">0</span>)&#123;result = -EINVAL;printk(<span class="hljs-string">&quot;can&#x27;t find gpio!\r\n&quot;</span>);<span class="hljs-keyword">goto</span> fail_get_gpio;&#125;printk(<span class="hljs-string">&quot;gpio num is:%d \r\n&quot;</span>, gpioled.led_gpio);<span class="hljs-comment">/* 申请IO */</span>ret = gpio_request(gpioled.led_gpio, <span class="hljs-string">&quot;LED-GPIO&quot;</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;request GPIO failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_request_gpio;&#125;<span class="hljs-comment">/* 使用IO */</span>ret = gpio_direction_output(gpioled.led_gpio, <span class="hljs-number">1</span><span class="hljs-comment">/* HIGH默认关闭LED */</span>);<span class="hljs-keyword">if</span>(ret)&#123;printk(<span class="hljs-string">&quot;set GPIO output failed!\r\n&quot;</span>);result = -EINVAL;<span class="hljs-keyword">goto</span> fail_gpio_failed;&#125;<span class="hljs-comment">/* 设置GPIO电平 */</span>printk(<span class="hljs-string">&quot;set LED-GPIO to 0\r\n&quot;</span>);gpio_set_value(gpioled.led_gpio, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 默认开灯 */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_gpio_failed:<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);fail_request_gpio:fail_get_gpio:fail_findnd:<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);fail_register_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);fail_register_devid:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">gpioled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 关灯 */</span>gpio_set_value(gpioled.led_gpio, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 释放IO */</span>gpio_free(gpioled.led_gpio);<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(gpioled.class, gpioled.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(gpioled.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;gpioled.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(gpioled.devid, GPIOLED_DEV_NUM);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(gpioled_init);module_exit(gpioled_exit);<span class="hljs-comment">/* 许可 */</span>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">/* 作者信息 */</span>MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><h3 id="运行测试-2"><a href="#运行测试-2" class="headerlink" title="运行测试"></a>运行测试</h3><p>驱动加载成功以后就可以使用 mutexApp 软件测试驱动是否工作正常，测试方法和前面测试信号量的方法一样。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1| 字符设备驱动开发入门</title>
    <link href="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    <url>/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="字符设备驱动开发入门"><a href="#字符设备驱动开发入门" class="headerlink" title="字符设备驱动开发入门"></a>字符设备驱动开发入门</h1><p>字符设备驱动是Linux 驱动开发中最基础的开始，本章会以一个虚拟的设备为例，讲解如何进行字符设备驱动开发，以及如何编写测试 APP 来测试驱动工作是否正常，为以后的学习打下坚实的基础。</p><h2 id="一、字符设备驱动简介"><a href="#一、字符设备驱动简介" class="headerlink" title="一、字符设备驱动简介"></a>一、字符设备驱动简介</h2><p>字符设备是 Linux 驱动中最基本的一类设备驱动，<strong>字符设备就是一个一个字节，按照字节流进行读写操作的设备</strong>，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。</p><p>在详细的学习字符设备驱动架构之前，我们先来简单的了解一下 Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用如图  所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820131839783.png" alt="image-20200820131839783"></p><p>在 Linux 中一切皆为文件，驱动加载成功以后会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。</p><p>比如现在有个叫做**&#x2F;dev&#x2F;led** 的驱动文件，此文件是 led 灯的驱动文件。应用程序使用 open 函数来打开文件&#x2F;dev&#x2F;led，使用完成以后使用 close 函数关闭&#x2F;dev&#x2F;led 这个文件。open和 close 就是打开和关闭 led 驱动的函数，如果要点亮或关闭 led，那么就使用 write 函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开 led 的控制参数。如果要获取led 灯的状态，就用 read 函数从驱动中读取相应的状态。</p><p><strong>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间</strong>。当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开&#x2F;dev&#x2F;led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。</p><p>open、close、write 和 read 等这些函数是由 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分。当我们调用 open 函数的时候流程如图  所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820132050798.png" alt="image-20200820132050798"></p><p>其中关于 C 库以及如何通过系统调用“陷入”到内核空间这个我们不用去管，我们重点关注的是应用程序和具体的驱动，应用程序使用到的函数在具体驱动程序中都有与之对应的函数，比如应用程序中调用了 open 这个函数，那么在驱动程序中也得有一个名为 open 的函数。每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 include&#x2F;linux&#x2F;fs.h 中有个叫做 file_operations 的结构体，此结构体就是 Linux 内核驱动操作函数集合，内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1588</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><span class="hljs-number">1589</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><span class="hljs-number">1590</span> <span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<span class="hljs-number">1591</span> <span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<span class="hljs-number">1592</span> <span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<span class="hljs-number">1593</span> <span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<span class="hljs-number">1594</span> <span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<span class="hljs-number">1595</span> <span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<span class="hljs-number">1596</span> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;<span class="hljs-number">1597</span> <span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<span class="hljs-number">1598</span> <span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<span class="hljs-number">1599</span> <span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<span class="hljs-number">1600</span> <span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<span class="hljs-number">1601</span> <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<span class="hljs-number">1602</span> <span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<span class="hljs-number">1603</span> <span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<span class="hljs-number">1604</span> <span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<span class="hljs-number">1605</span> <span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<span class="hljs-number">1606</span> <span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<span class="hljs-number">1607</span> <span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<span class="hljs-number">1608</span> <span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<span class="hljs-number">1609</span> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<span class="hljs-number">1610</span> <span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<span class="hljs-number">1611</span> <span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<span class="hljs-number">1612</span> <span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<span class="hljs-number">1613</span> <span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<span class="hljs-number">1614</span> <span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<span class="hljs-number">1615</span> <span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset,<span class="hljs-number">1616</span> <span class="hljs-type">loff_t</span> len);<span class="hljs-number">1617</span> <span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<span class="hljs-number">1618</span> <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><span class="hljs-number">1619</span> <span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<span class="hljs-number">1620</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-number">1621</span> &#125;;</code></pre></div><p>简单介绍一下 file_operation 结构体中比较重要的、常用的函数：<br>第 <strong>1589</strong> 行，owner 拥有该结构体的模块的指针，一般设置为 THIS_MODULE。<br>第 <strong>1590</strong> 行，llseek 函数用于修改文件当前的读写位置。<br>第 <strong>1591</strong> 行，read 函数用于读取设备文件。<br>第 <strong>1592</strong> 行，write 函数用于向设备文件写入(发送)数据。<br>第 <strong>1596</strong> 行，poll 是个轮询函数，用于查询设备是否可以进行非阻塞的读写。<br>第 <strong>1597</strong> 行，unlocked_ioctl 函数提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。<br>第 <strong>1598</strong> 行，compat_ioctl 函数与 unlocked_ioctl 函数功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是unlocked_ioctl。<br>第 <strong>1599</strong> 行，mmap 函数用于将将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。<br>第 <strong>1601</strong> 行，open 函数用于打开设备文件。<br>第 <strong>1603</strong> 行，release 函数用于释放(关闭)设备文件，与应用程序中的 close 函数对应。<br>第 <strong>1604</strong> 行，fasync 函数用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。<br>第 <strong>1605</strong> 行，aio_fsync 函数与 fasync 函数的功能类似，只是 aio_fsync 是异步刷新待处理的数据。</p><p>在字符设备驱动开发中最常用的就是上面这些函数，关于其他的函数大家可以查阅相关文档。我们在字符设备驱动开发中最主要的工作就是实现上面这些函数，不一定全部都要实现，但是像 open、release、write、read 等都是需要实现的，当然了，具体需要实现哪些函数还是要看具体的驱动要求。</p><h2 id="二、字符设备驱动开发步骤"><a href="#二、字符设备驱动开发步骤" class="headerlink" title="二、字符设备驱动开发步骤"></a>二、字符设备驱动开发步骤</h2><p>我们简单的介绍了一下字符设备驱动，那么字符设备驱动开发都有哪些步骤呢？我们在学习裸机或者 STM32 的时候关于驱动的开发就是初始化相应的外设寄存器，在 Linux 驱动开发中肯定也是要初始化相应的外设寄存器，这个是毫无疑问的。只是<strong>在 Linux 驱动开发中我们需要按照其规定的框架来编写驱动</strong>，所以说<strong>学 Linux 驱动开发重点是学习其驱动框架</strong>。</p><h3 id="1、-驱动-模块的加载和卸载"><a href="#1、-驱动-模块的加载和卸载" class="headerlink" title="1、 驱动 模块的加载和卸载"></a>1、 驱动 模块的加载和卸载</h3><p>Linux 驱动有两种运行方式，第一种就是将驱动编译进 Linux 内核中，这样当 Linux 内核启动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在Linux 内核启动以后使用“insmod”命令加载驱动模块。</p><p>在调试驱动的时候一般都选择将其编译为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。而且在调试的时候只需要加载或者卸载驱动模块即可，不需要重启整个系统。总之，将驱动编译为模块最大的好处就是方便开发，当驱动开发完成，确定没有问题以后就可以将驱动编译进Linux 内核中，当然也可以不编译进 Linux 内核中，具体看自己的需求。</p><p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和卸载注册函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">module_init(xxx_init); <span class="hljs-comment">//注册模块加载函数</span>module_exit(xxx_exit); <span class="hljs-comment">//注册模块卸载函数</span></code></pre></div><p>module_init 函数用来向 Linux 内核注册一个模块加载函数，参数 xxx_init 就是需要注册的具体函数，<strong>当使用“insmod”命令加载驱动的时候，xxx_init 这个函数就会被调用</strong>。module_exit()函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，<strong>当使用“rmmod”命令卸载具体驱动的时候 xxx_exit 函数就会被调用</strong>。</p><p>字符设备驱动模块加载和卸载模板如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 驱动入口函数 */</span><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>3 &#123;<span class="hljs-number">4</span> <span class="hljs-comment">/* 入口函数具体内容 */</span><span class="hljs-number">5</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">6</span> &#125;<span class="hljs-number">7</span><span class="hljs-number">8</span> <span class="hljs-comment">/* 驱动出口函数 */</span><span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>10 &#123;<span class="hljs-number">11</span> <span class="hljs-comment">/* 出口函数具体内容 */</span><span class="hljs-number">12</span> &#125;<span class="hljs-number">13</span><span class="hljs-number">14</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><span class="hljs-number">15</span> module_init(xxx_init);<span class="hljs-number">16</span> module_exit(xxx_exit);</code></pre></div><p><strong>第 2 行</strong>，定义了个名为 xxx_init 的驱动入口函数，并且使用了“__init”来修饰。<br><strong>第 9 行</strong>，定义了个名为 xxx_exit 的驱动出口函数，并且使用了“__exit”来修饰。<br><strong>第 15 行</strong>，调用函数 module_init 来声明 xxx_init 为驱动入口函数，当加载驱动的时候 xxx_init函数就会被调用。<br><strong>第16行</strong>，调用函数module_exit来声明xxx_exit为驱动出口函数，当卸载驱动的时候xxx_exit函数就会被调用。</p><hr><p>驱动编译完成以后扩展名为.ko，有两种命令可以加载驱动模块：<strong>insmod</strong>和<strong>modprobe</strong>，insmod是最简单的模块加载命令，此命令用于加载指定的.ko 模块，比如加载 drv.ko 这个驱动模块，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">insmod drv.ko</code></pre></div><p><strong>insmod 命令不能解决模块的依赖关系，比如 drv.ko 依赖 first.ko 这个模块，就必须先使用insmod 命令加载 first.ko 这个模块，然后再加载 drv.ko 这个模块。</strong>但是 modprobe 就不会存在这个问题，modprobe 会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中，因此modprobe 命令相比 insmod 要智能一些。</p><hr><p><strong>modprobe</strong> 命令主要智能在提供了模块的依赖性分析、错误检查、错误报告等功能，推荐使用modprobe 命令来加载驱动。modprobe 命令默认会去<code>lib/modules/&lt;kernel-version&gt;</code>目录中查找模块，比如本书使用的 Linux kernel 的版本号为 4.1.15，因此 modprobe 命令默认会到&#x2F;lib&#x2F;modules&#x2F;4.1.15 这个目录中查找相应的驱动模块，一般自己制作的根文件系统中是不会有这个目录的，所以需要自己手动创建。</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">modprobe</span> drv.ko</code></pre></div><hr><p>驱动模块的卸载使用命令“<strong>rmmod</strong>”即可，比如要卸载 drv.ko，使用如下命令即可：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">rmmod drv.ko</code></pre></div><p>也可以使用“modprobe -r”命令卸载驱动，比如要卸载 drv.ko，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">modprobe -r drv.ko</code></pre></div><p>使用 modprobe 命令可以卸载掉驱动模块所依赖的其他模块，前提是这些依赖模块已经没有被其他模块所使用，否则就不能使用 modprobe 来卸载驱动模块。<strong>所以对于模块的卸载，还是推荐使用 rmmod 命令。</strong></p><h3 id="2、字符设备注册与注销"><a href="#2、字符设备注册与注销" class="headerlink" title="2、字符设备注册与注销"></a>2、字符设备注册与注销</h3><p><strong>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备</strong>。字符设备的注册和注销函数原型如下所示:</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, </span><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div><p><strong>register_chrdev 函数用于注册字符设备</strong>，此函数一共有三个参数，这三个参数的含义如下：</p><p><strong>major</strong> ：主设备号，Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分，关于设备号后面会详细讲解。<br><strong>name</strong>：设备名字，指向一串字符串。<br><strong>fops</strong> ：结构体 file_operations 类型指针，指向设备的操作函数集合变量。</p><p><strong>unregister_chrdev 函数用户注销字符设备</strong>，此函数有两个参数，这两个参数含义如下：</p><p><strong>major</strong> ：要注销的设备对应的主设备号。<br><strong>name</strong> ：要注销的设备对应的设备名。</p><p>一般字符设备的注册在驱动模块的入口函数 xxx_init 中进行，字符设备的注销在驱动模块的出口函数 xxx_exit 中进行。字符设备的注册和注销，内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span>;</span><span class="hljs-number">2</span><span class="hljs-number">3</span> <span class="hljs-comment">/* 驱动入口函数 */</span><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>5 &#123;<span class="hljs-number">6</span> <span class="hljs-comment">/* 入口函数具体内容 */</span><span class="hljs-number">7</span> <span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<span class="hljs-number">8</span><span class="hljs-number">9</span> <span class="hljs-comment">/* 注册字符设备驱动 */</span><span class="hljs-number">10</span> retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);<span class="hljs-number">11</span> <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-number">12</span> <span class="hljs-comment">/*  字符设备注册失败, 自行处理 */</span><span class="hljs-number">13</span> &#125;<span class="hljs-number">14</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">15</span> &#125;<span class="hljs-number">16</span><span class="hljs-number">17</span> <span class="hljs-comment">/* 驱动出口函数 */</span><span class="hljs-number">18</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>19 &#123;<span class="hljs-number">20</span> <span class="hljs-comment">/* 注销字符设备驱动 */</span><span class="hljs-number">21</span> unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);<span class="hljs-number">22</span> &#125;<span class="hljs-number">23</span><span class="hljs-number">24</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><span class="hljs-number">25</span> module_init(xxx_init);<span class="hljs-number">26</span> module_exit(xxx_exit);</code></pre></div><p><strong>第 1 行</strong>，定义了一个 file_operations 结构体变量 test_fops，test_fops 就是设备的操作函数集合，只是此时我们还没有初始化 test_fops 中的 open、release 等这些成员变量，所以这个操作函数集合还是空的。<br><strong>第 10 行</strong>，调用函数 register_chrdev 注册字符设备，主设备号为 200，设备名字为“chrtest”，设备操作函数集合就是第 1 行定义的 test_fops。</p><p><strong>第 21 行</strong>，调用函数 unregister_chrdev 注销主设备号为 200 的这个设备。</p><p>要注意的一点就是，选择没有被使用的主设备号，输入命令“cat &#x2F;proc&#x2F;devices”可以查看当前已经被使用掉的设备号，如图 所示(限于篇幅原因，只展示一部分)：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820134453560.png" alt="image-20200820134453560"></p><p>在图中可以列出当前系统中所有的字符设备和块设备，其中第 1 列就是设备对应的主设备号。200 这个主设备号在我的开发板中并没有被使用，所以我这里就用了 200 这个主设备号。</p><h3 id="3、实现设备的具体操作函数"><a href="#3、实现设备的具体操作函数" class="headerlink" title="3、实现设备的具体操作函数"></a>3、实现设备的具体操作函数</h3><p><strong>file_operations 结构体就是设备的具体操作函数</strong>，在前面示例代码中我们定义了file_operations结构体类型的变量test_fops，但是还没对其进行初始化，也就是初始化其中的open、release、read 和 write 等具体的设备操作函数。</p><p>本节我们就完成变量 test_fops 的初始化，设置好针对 chrtest 设备的操作函数。在初始化 test_fops 之前我们要分析一下需求，也就是要对chrtest 这个设备进行哪些操作，只有确定了需求以后才知道我们应该实现哪些操作函数。</p><p>假设对 chrtest 这个设备有如下两个要求：</p><ul><li><p>1 、能够对 chrtest  进行打开和关闭操作</p><p>设备打开和关闭是最基本的要求，几乎所有的设备都得提供打开和关闭的功能。因此我们需要实现 file_operations 中的 open 和 release 这两个函数。</p></li><li><p>2 、对 chrtest  进行读写操作</p><p>假设 chrtest 这个设备控制着一段缓冲区(内存)，应用程序需要通过 read 和 write 这两个函数对 chrtest 的缓冲区进行读写操作。所以需要实现 file_operations 中的 read 和 write 这两个函数。</p></li></ul><p>需求很清晰了，修改前面的示例代码，在其中加入 test_fops 这个结构体变量的初始化操作，完成以后的内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/*  打开设备 */</span><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>3 &#123;<span class="hljs-number">4</span> <span class="hljs-comment">/*  用户实现具体功能 */</span><span class="hljs-number">5</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">6</span> &#125;<span class="hljs-number">7</span><span class="hljs-number">8</span> <span class="hljs-comment">/*  从设备读取 */</span><span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrtest_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>10 &#123;<span class="hljs-number">11</span> <span class="hljs-comment">/*  用户实现具体功能 */</span><span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">13</span> &#125;<span class="hljs-number">14</span><span class="hljs-number">15</span> <span class="hljs-comment">/*  向设备写数据 */</span><span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrtest_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, </span><span class="hljs-params">                                <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>17 &#123;<span class="hljs-number">18</span> <span class="hljs-comment">/*  用户实现具体功能 */</span><span class="hljs-number">19</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">20</span> &#125;<span class="hljs-number">21</span><span class="hljs-number">22</span> <span class="hljs-comment">/*  关闭/ 释放设备 */</span><span class="hljs-number">23</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>24 &#123;<span class="hljs-number">25</span> <span class="hljs-comment">/*  用户实现具体功能 */</span><span class="hljs-number">26</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">27</span> &#125;<span class="hljs-number">28</span><span class="hljs-number">29</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;<span class="hljs-number">30</span> .owner = THIS_MODULE,<span class="hljs-number">31</span> .open = chrtest_open,<span class="hljs-number">32</span> .read = chrtest_read,<span class="hljs-number">33</span> .write = chrtest_write,<span class="hljs-number">34</span> .release = chrtest_release,<span class="hljs-number">35</span> &#125;;<span class="hljs-number">36</span><span class="hljs-number">37</span> <span class="hljs-comment">/* 驱动入口函数 */</span><span class="hljs-number">38</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>39 &#123;<span class="hljs-number">40</span> <span class="hljs-comment">/* 入口函数具体内容 */</span><span class="hljs-number">41</span> <span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<span class="hljs-number">42</span><span class="hljs-number">43</span> <span class="hljs-comment">/* 注册字符设备驱动 */</span><span class="hljs-number">44</span> retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);<span class="hljs-number">45</span> <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-number">46</span> <span class="hljs-comment">/* 字符设备注册失败,自行处理 */</span><span class="hljs-number">47</span> &#125;<span class="hljs-number">48</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">49</span> &#125;<span class="hljs-number">50</span><span class="hljs-number">51</span> <span class="hljs-comment">/* 驱动出口函数 */</span><span class="hljs-number">52</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>53 &#123;<span class="hljs-number">54</span> <span class="hljs-comment">/* 注销字符设备驱动 */</span><span class="hljs-number">55</span> unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);<span class="hljs-number">56</span> &#125;<span class="hljs-number">57</span><span class="hljs-number">58</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><span class="hljs-number">59</span> module_init(xxx_init);<span class="hljs-number">60</span> module_exit(xxx_exit);</code></pre></div><p>在此示例代码中我们一开始编写了四个函数：chrtest_open、chrtest_read、chrtest_write和 chrtest_release。这四个函数就是 chrtest 设备的 open、read、write 和 release 操作函数。第 29行~35 行初始化 test_fops 的 open、read、write 和 release 这四个成员变量。</p><h3 id="4、添加LICENSE-和-作者信息"><a href="#4、添加LICENSE-和-作者信息" class="headerlink" title="4、添加LICENSE 和 作者信息"></a>4、添加LICENSE 和 作者信息</h3><p>最后我们需要在驱动中加入 LICENSE 信息和作者信息，其中 LICENSE 是必须添加的，否则的话编译的时候会报错，作者信息可以添加也可以不添加。LICENSE 和作者信息的添加使用如下两个函数：</p><div class="hljs code-wrapper"><pre><code class="hljs c">MODULE_LICENSE() <span class="hljs-comment">//添加模块 LICENSE 信息</span>MODULE_AUTHOR() <span class="hljs-comment">//添加模块作者信息</span></code></pre></div><p>最后给示例代码加入 LICENSE 和作者信息，完成以后的内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* 打开设备 */</span><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>3 &#123;<span class="hljs-number">4</span> <span class="hljs-comment">/* 用户实现具体功能 */</span><span class="hljs-number">5</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">6</span> &#125;......<span class="hljs-number">57</span><span class="hljs-number">58</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><span class="hljs-number">59</span> module_init(xxx_init);<span class="hljs-number">60</span> module_exit(xxx_exit);<span class="hljs-number">61</span><span class="hljs-number">62</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-number">63</span> MODULE_AUTHOR(<span class="hljs-string">&quot;firestaradmin&quot;</span>);</code></pre></div><p>第 62 行，LICENSE 采用 GPL 协议。<br>第 63 行，添加作者名字。<br>至此，字符设备驱动开发的完整步骤就讲解完了，而且也编写好了一个完整的字符设备驱动模板，以后字符设备驱动开发都可以在此模板上进行。</p><h2 id="三、Linux-设备号"><a href="#三、Linux-设备号" class="headerlink" title="三、Linux 设备号"></a>三、Linux 设备号</h2><h3 id="1、设备号的组成"><a href="#1、设备号的组成" class="headerlink" title="1、设备号的组成"></a>1、设备号的组成</h3><p>为了方便管理，Linux 中每个设备都有一个设备号，<strong>设备号由主设备号和次设备号两部分组成</strong>，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。</p><p>Linux 提供了一个名为 <strong>dev_t</strong> 的数据类型表示设备号，dev_t 定义在文件 include&#x2F;linux&#x2F;types.h 里面，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">12</span> <span class="hljs-keyword">typedef</span> __u32 <span class="hljs-type">__kernel_dev_t</span>;......<span class="hljs-number">15</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">__kernel_dev_t</span> <span class="hljs-type">dev_t</span>;</code></pre></div><p>可以看出 dev_t 是__u32 类型的，而__u32 定义在文件 include&#x2F;uapi&#x2F;asm-generic&#x2F;int-ll64.h 里<br>面，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">26</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __u32;</code></pre></div><p>综上所述，<strong>dev_t 其实就是 unsigned int 类型</strong>，是一个 32 位的数据类型。这 32 位的数据构成了主设备号和次设备号两部分，<strong>其中高 12 位为主设备号，低 20 位为次设备号</strong>。因此 Linux系统中主设备号范围为 0~4095，所以大家在选择主设备号的时候一定不要超过这个范围。</p><hr><p>在文件<code>include/linux/kdev_t.h</code> 中提供了几个关于设备号的操作函数(本质是宏)，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORBITS 20</span><span class="hljs-number">7</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORMASK ((1U &lt;&lt; MINORBITS) - 1)</span><span class="hljs-number">8</span><span class="hljs-number">9</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))</span><span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi))</span></code></pre></div><p>第 6 行，宏 <strong>MINORBITS</strong> 表示次设备号位数，一共是 20 位。<br>第 7 行，宏 <strong>MINORMASK</strong> 表示次设备号掩码。<br>第 9 行，宏 <strong>MAJOR</strong> 用于从 dev_t 中获取主设备号，将 dev_t 右移 20 位即可。<br>第 10 行，宏 <strong>MINOR</strong> 用于从 dev_t 中获取次设备号，取 dev_t 的低 20 位的值即可。<br>第 11 行，宏 <strong>MKDEV</strong> 用于将给定的主设备号和次设备号的值组合成 dev_t 类型的设备号。</p><h3 id="2、设备号的分配"><a href="#2、设备号的分配" class="headerlink" title="2、设备号的分配"></a>2、设备号的分配</h3><h4 id="1-、静态分配设备号"><a href="#1-、静态分配设备号" class="headerlink" title="1 、静态分配设备号"></a>1 、静态分配设备号</h4><p>本小节讲的设备号分配主要是主设备号的分配。前面讲解字符设备驱动的时候说过了，注册字符设备的时候需要给设备指定一个设备号，这个设备号可以是驱动开发者静态的指定一个设备号，比如选择 200 这个主设备号。有一些常用的设备号已经被 Linux 内核开发者给分配掉了，具体分配的内容可以查看文档 Documentation&#x2F;devices.txt。</p><p>并不是说内核开发者已经分配掉的主设备号我们就不能用了，具体能不能用还得看我们的硬件平台运行过程中有没有使用这个主设备号，使用“cat &#x2F;proc&#x2F;devices”命令即可查看当前系统中所有已经使用了的设备号。</p><h4 id="2-、动态分配设备号"><a href="#2-、动态分配设备号" class="headerlink" title="2 、动态分配设备号"></a>2 、动态分配设备号</h4><p>静态分配设备号需要我们检查当前系统中所有被使用了的设备号，然后挑选一个没有使用的。而且静态分配设备号很容易带来冲突问题，<strong>Linux 社区推荐使用动态分配设备号</strong>，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。卸载驱动的时候释放掉这个设备号即可，设备号的申请函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, </span><span class="hljs-params">                        <span class="hljs-type">unsigned</span> baseminor, </span><span class="hljs-params">                        <span class="hljs-type">unsigned</span> count, </span><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div><p>函数 <strong>alloc_chrdev_region</strong> 用于申请设备号，此函数有 4 个参数：</p><p><strong>dev</strong>：保存申请到的设备号。<br><strong>baseminor</strong> ：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般baseminor 为 0，也就是说次设备号从 0 开始。<br><strong>count</strong> ：要申请的设备号数量。<br><strong>name</strong>：设备名字。</p><p>注销字符设备之后要释放掉设备号，设备号释放函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span></code></pre></div><p>此函数有两个参数：<br><strong>from</strong>：要释放的设备号。<br><strong>count</strong> ：表示从 from 开始，要释放的设备号数量。</p><h2 id="四、chrdevbase字符设备驱动开发实验"><a href="#四、chrdevbase字符设备驱动开发实验" class="headerlink" title="四、chrdevbase字符设备驱动开发实验"></a>四、chrdevbase字符设备驱动开发实验</h2><p>字符设备驱动开发的基本步骤我们已经了解了，本节我们就以 chrdevbase 这个虚拟设备为例，完整的编写一个字符设备驱动模块。</p><p>chrdevbase 不是实际存在的一个设备，是笔者为了方便讲解字符设备的开发而引入的一个虚拟设备。chrdevbase 设备有两个缓冲区，一个为读缓冲区，一个为写缓冲区，这两个缓冲区的大小都为 100 字节。在应用程序中可以向 chrdevbase 设备的写缓冲区中写入数据，从读缓冲区中读取数据。chrdevbase 这个虚拟设备的功能很简单，但是它包含了字符设备的最基本功能。</p><h3 id="1、实验程序编写"><a href="#1、实验程序编写" class="headerlink" title="1、实验程序编写"></a>1、实验程序编写</h3><p>应用程序调用 open 函数打开 chrdevbase 这个设备，打开以后可以使用 write 函数向chrdevbase 的写缓冲区 writebuf 中写入数据(不超过 100 个字节)，也可以使用 read 函数读取读缓冲区 readbuf 中的数据操作，操作完成以后应用程序使用 close 函数关闭 chrdevbase 设备。</p><h4 id="1、建立VSCode工程"><a href="#1、建立VSCode工程" class="headerlink" title="1、建立VSCode工程"></a>1、建立VSCode工程</h4><p>在 Ubuntu 中创建一个目录用来存放 Linux 驱动程序，比如我创建了一个名为 linux_drivers的目录来存放所有的 Linux 驱动。在 linux_drivers 目录下新建一个名为 1_chrdevbase 的子目录来存放本实验所有文件.</p><p>之后在 1_chrdevbase 目录中新建 VSCode 工程，并且新建 chrdevbase.c 文件、chrdevbaseAPP.c、Makefile文件，完成以后1_chrdevbase 目录中的文件如图所示</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820141213153.png" alt="image-20200820141213153"></p><h4 id="2、添加头文件路径"><a href="#2、添加头文件路径" class="headerlink" title="2、添加头文件路径"></a>2、添加头文件路径</h4><p>因为是编写Linux 驱动，因此会用到Linux 源码中的函数。我们需要在VSCode中添加Linux源码中的头文件路径。</p><p>打开 VSCode，按下“Crtl+Shift+P”打开 VSCode 的控制台，然后输入</p><p><code>C/C++: Edit configurations(JSON) </code></p><p>打开 C&#x2F;C++编辑配置文件，如图所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820141458574.png" alt="image-20200820141458574"></p><p>打开以后会自动在.vscode 目录下生成一个名为 <strong>c_cpp_properties.json</strong> 的文件，此文件默认内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c11&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++17&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc-x64&quot;</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p><strong>includePath</strong> 表示头文件路径，需要将 Linux 源码里面的头文件路径添加进来，也就是我们前面移植的 Linux 源码中的头文件路径。</p><p>添加头文件路径以后的 c_cpp_properties.json的文件内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;/home/firestaradmin/linux/IMX6U/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg/include&quot;</span><span class="hljs-punctuation">,</span>                 <span class="hljs-string">&quot;/home/firestaradmin/linux/IMX6U/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg/arch/arm/include&quot;</span><span class="hljs-punctuation">,</span>                 <span class="hljs-string">&quot;/home/firestaradmin/linux/IMX6U/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg/arch/arm/include/generated/&quot;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c11&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++17&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc-x64&quot;</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p><strong>第7~9行</strong>就是添加好的Linux头文件路径。分别是开发板所使用的Linux源码下的include、arch&#x2F;arm&#x2F;include 和 arch&#x2F;arm&#x2F;include&#x2F;generated 这三个目录的路径，注意，这里使用了绝对路径。</p><h4 id="3、编写实验程序"><a href="#3、编写实验程序" class="headerlink" title="3、编写实验程序"></a>3、编写实验程序</h4><p>工程建立好以后就可以开始编写驱动程序了，打开chrdevbase.c，然后在里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHRDEVBASE_MAJOR 200 <span class="hljs-comment">//主设备号</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHRDEVBASE_NAME <span class="hljs-string">&quot;chrdevbase&quot;</span></span><span class="hljs-type">char</span> readbuf[<span class="hljs-number">100</span>];<span class="hljs-type">char</span> writebuf[<span class="hljs-number">100</span>];<span class="hljs-type">char</span> kernel_data[] = &#123;<span class="hljs-string">&quot;kernel data&quot;</span>&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 打开设备</span><span class="hljs-comment"> * @param - inode : 传递给驱动的inode</span><span class="hljs-comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><span class="hljs-comment"> *   一般在open的时候将private_data指向设备结构体。</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrdevbase_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-comment">// printk(&quot;chrdevbase open!\r\n&quot;);</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 从设备读取数据 </span><span class="hljs-comment"> * @param - filp : 要打开的设备文件(文件描述符)</span><span class="hljs-comment"> * @param - buf : 返回给用户空间的数据缓冲区</span><span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span><span class="hljs-comment"> * @param - offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrdevbase_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 向用户空间发送数据 */</span><span class="hljs-built_in">memcpy</span>(readbuf, kernel_data, <span class="hljs-keyword">sizeof</span>(kernel_data));ret = copy_to_user(buf, readbuf, cnt);<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;kernel senddata ok!\r\n&quot;</span>);&#125;<span class="hljs-keyword">else</span>&#123;printk(<span class="hljs-string">&quot;kernel senddata failed!\r\n&quot;</span>);&#125;<span class="hljs-comment">// printk(&quot;chrdevbase read!\r\n&quot;);</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 向设备写数据 </span><span class="hljs-comment"> * @param - filp : 设备文件，表示打开的文件描述符</span><span class="hljs-comment"> * @param - buf : 要写给设备写入的数据</span><span class="hljs-comment"> * @param - cnt : 要写入的数据长度</span><span class="hljs-comment"> * @param - offt : 相对于文件首地址的偏移</span><span class="hljs-comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrdevbase_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 接收用户空间传递给内核的数据并且打印出来 */</span>ret = copy_from_user(writebuf, buf, cnt);<span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;kernel recevdata:%s\r\n&quot;</span>, writebuf);&#125;<span class="hljs-keyword">else</span>&#123;printk(<span class="hljs-string">&quot;kernel recevdata failed!\r\n&quot;</span>);&#125;<span class="hljs-comment">// printk(&quot;chrdevbase write!\r\n&quot;);</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @description: 关闭/释放设备</span><span class="hljs-comment"> * @param - filp : 要关闭的设备文件(文件描述符)</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrdevbase_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-comment">// printk(&quot;chrdevbase release！\r\n&quot;);</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">chrdevbase_fops</span> =</span> &#123;    .owner = THIS_MODULE,    .open = chrdevbase_open,    .write = chrdevbase_write,    .read = chrdevbase_read,    .release = chrdevbase_release&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">chrdevbase_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;    printk(<span class="hljs-string">&quot;chrdevbase_init\r\n&quot;</span>);    <span class="hljs-comment">/* 注册字符设备 */</span>    ret = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;chrdevbase_fops);    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;        printk(<span class="hljs-string">&quot;chrdevbase_init failed！\r\n&quot;</span>);    &#125;                            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">chrdevbase_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    printk(<span class="hljs-string">&quot;chrdevbase_exit\r\n&quot;</span>);    <span class="hljs-comment">/* 卸载字符设备 */</span>    unregister_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> *  模块入口与出口</span><span class="hljs-comment"> */</span>module_init(chrdevbase_init);module_exit(chrdevbase_exit);MODULE_DESCRIPTION(<span class="hljs-string">&quot;Test for driver development&quot;</span>);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><p>printk 相当于 printf 的孪生兄妹，printf运行在用户态，printk 运行在内核态。在内核中想要向控制台输出或显示一些内容，必须使用printk 这个函数。</p><hr><p><strong>chrdevbase_read</strong>通过函数 copy_to_user 将readbuf 中的数据复制到参数 buf 中。因为内核空间不能直接操作用户空间的内存，因此需要借助 copy_to_user 函数来完成内核空间的数据到用户空间的复制。copy_to_user 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title function_">copy_to_user</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *to, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *from, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span></code></pre></div><p><strong>参数 to</strong> 表示目的，<strong>参数 from</strong> 表示源，<strong>参数 n</strong> 表示要复制的数据长度。如果复制成功，返回值为 0，如果复制失败则返回负数。</p><hr><p><strong>chrdevbase_write</strong>通过函数 copy_from_user 将 buf 中的数据复制到写缓冲区 writebuf 中，因为用户空间内存不能直接访问内核空间的内存，所以需要借助函数 copy_from_user 将用户空间的数据复制到 writebuf 这个内核空间中。</p><hr><p><strong>chrdevbase_release</strong> 函数，应用程序调用 close 关闭设备文件的时候此函数会执行，一般会在此函数里面执行一些释放操作。如果在 open 函数中设置了 filp 的 private_data成员变量指向设备结构体，那么在 release 函数最终就要释放掉。</p><hr><h3 id="2、编写测试APP"><a href="#2、编写测试APP" class="headerlink" title="2、编写测试APP"></a>2、编写测试APP</h3><h4 id="1-、C-库文件操作基本函数"><a href="#1-、C-库文件操作基本函数" class="headerlink" title="1 、C  库文件操作基本函数"></a>1 、C  库文件操作基本函数</h4><p>编写测试 APP 就是编写 Linux 应用，需要用到 C 库里面和文件操作有关的一些函数，比如open、read、write 和 close 这四个函数。</p><hr><p><strong>①、open  函数</strong></p><p>open 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></code></pre></div><p>open 函数参数含义如下：</p><p><strong>pathname</strong>：要打开的设备或者文件名。<br><strong>flags</strong> ：文件打开模式，以下三种模式必选其一：</p><ul><li><p>O_RDONLY         只读模式<br>O_WRONLY         只写模式<br>O_RDWR             读写模式<br>因为我们要对 chrdevbase 这个设备进行读写操作，所以选择 O_RDWR。除了上述三种<br>模式以外还有其他的可选模式，通过逻辑或来选择多种模式：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820145926694.png" alt="image-20200820145926694"></p></li></ul><p><strong>返回值</strong>：如果文件打开成功的话返回文件的文件描述符.</p><p>在 Ubuntu 中输入<code>man 2 open</code>即可查看 open 函数的详细内容，如图  所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820150054066.png" alt="image-20200820150054066"></p><hr><p><strong>②、read  函数</strong></p><p>read 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></code></pre></div><p>read 函数参数含义如下：</p><p><strong>fd</strong>：要读取的文件描述符，读取文件之前要先用 open 函数打开文件，open 函数打开文件成功以后会得到文件描述符。<br><strong>buf</strong> ：数据读取到此 buf 中。<br><strong>count</strong> ：要读取的数据长度，也就是字节数。</p><p><strong>返回值</strong>：读取成功的话返回读取到的字节数；如果返回 0 表示读取到了文件末尾；如果返回负值，表示读取失败。</p><p>在 Ubuntu 中输入“man 2 read”命令即可查看 read 函数的详细内容。</p><hr><p><strong>③、write  函数</strong></p><p>write 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;</code></pre></div><p>write 函数参数含义如下：<br><strong>fd</strong>：要进行写操作的文件描述符，写文件之前要先用 open 函数打开文件，open 函数打开文<br>件成功以后会得到文件描述符。<br><strong>buf</strong> ：要写入的数据。<br><strong>count</strong> ：要写入的数据长度，也就是字节数。<br><strong>返回值</strong>：写入成功的话返回写入的字节数；如果返回 0 表示没有写入任何数据；如果返回负值，表示写入失败。</p><p>在 Ubuntu 中输入“man 2 write”命令即可查看 write 函数的详细内容。</p><hr><p><strong>④、close  函数</strong></p><p>close 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;</code></pre></div><p>close 函数参数含义如下：<br><strong>fd</strong>：要关闭的文件描述符。<br><strong>返回值</strong>：0 表示关闭成功，负值表示关闭失败。</p><p>在 Ubuntu 中输入“man 2 close”命令即可查看 close 函数的详细内容。</p><h4 id="2、编写测试-APP-程序"><a href="#2、编写测试-APP-程序" class="headerlink" title="2、编写测试 APP  程序"></a>2、编写测试 APP  程序</h4><p>驱动编写好以后是需要测试的，一般编写一个简单的测试 APP，测试 APP 运行在用户空间。测试 APP 很简单通过输入相应的指令来对 chrdevbase 设备执行读或者写操作。打开 chrdevbaseApp.c 文件，在此文件中输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-comment">/*</span><span class="hljs-comment"> *  usage:</span><span class="hljs-comment"> *  ./chrdevbaseAPP     &lt;openFileName&gt;      &lt;1:read|2:write&gt;   </span><span class="hljs-comment"> *  ./chrdevbaseAPP     /dev/chrdevbase     1               //读</span><span class="hljs-comment"> *  ./chrdevbaseAPP     /dev/chrdevbase     2               //写</span><span class="hljs-comment"> */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * @description : main 主程序</span><span class="hljs-comment"> * @param - argc : argv 数组元素个数</span><span class="hljs-comment"> * @param - argv : 具体参数</span><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> *filename;    <span class="hljs-type">char</span> readbuf[<span class="hljs-number">100</span>], writebuf[<span class="hljs-number">100</span>];    <span class="hljs-type">char</span> user_data[] = &#123;<span class="hljs-string">&quot;write test!&quot;</span>&#125;;    filename = argv[<span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:\r\n./chrdevbaseAPP     &lt;openFileName&gt;      &lt;1:read|2:write&gt;   \r\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MyAPP start!\r\n&quot;</span>);    <span class="hljs-comment">/* 打开 */</span>    fd =  open(filename, O_RDWR);    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">if</span>(atoi(argv[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//read</span>        <span class="hljs-comment">/* 读取 */</span>        ret = read(fd, readbuf, <span class="hljs-number">50</span>);        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read file %s failed!\r\n&quot;</span>, filename);        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read file %s success!\r\n&quot;</span>, filename);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read value:\r\n%s\r\n&quot;</span>, readbuf);        &#125;    &#125;    <span class="hljs-keyword">if</span>(atoi(argv[<span class="hljs-number">2</span>]) == <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//write</span>        <span class="hljs-comment">/* 写入 */</span>        <span class="hljs-built_in">memcpy</span>(writebuf, user_data, <span class="hljs-keyword">sizeof</span>(user_data));        ret = write(fd, writebuf, <span class="hljs-number">50</span>);        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s failed!\r\n&quot;</span>, filename);        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s success!\r\n&quot;</span>, filename);        &#125;    &#125;    <span class="hljs-comment">/* 关闭 */</span>    ret = close(fd);    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close file %s failed！\r\n&quot;</span>, filename);    &#125;&#125;</code></pre></div><p>程序开始判断运行测试 APP 的时候输入的参数是不是为 3 个，main 函数的 argc 参数表示参数数量，argv[]保存着具体的参数，如果参数不为 3 个的话就表示测试 APP 用法错误，然后给出提示。</p><p>比如，现在要从 chrdevbase 设备中读取数据，需要输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">/chrdevbaseAPP /dev/chrdevbase 1</code></pre></div><p>上述命令一共有三个参数“.&#x2F;chrdevbaseApp”、“&#x2F;dev&#x2F;chrdevbase”和“1”，这三个参数分别对应 argv[0]、argv[1]和 argv[2]。</p><h3 id="3、编译驱动程序和测试-APP"><a href="#3、编译驱动程序和测试-APP" class="headerlink" title="3、编译驱动程序和测试 APP"></a>3、编译驱动程序和测试 APP</h3><h4 id="1-、编译驱动程序"><a href="#1-、编译驱动程序" class="headerlink" title="1 、编译驱动程序"></a>1 、编译驱动程序</h4><p>首先编译驱动程序，也就是 chrdevbase.c 这个文件，我们需要将其编译为.ko 模块，创建Makefile 文件，然后在其中输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">KERNEL_DIR := /home/firestaradmin/linux/IMX6UL/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga_lxgCURRENT_PATH := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span>obj-m := chrdevbase.o<span class="hljs-section">build: kernel_modules</span><span class="hljs-section">kernel_modules:  </span><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNEL_DIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> modules<span class="hljs-section">clean: </span><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNEL_DIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> clean</code></pre></div><p><strong>KERNELDIR</strong> 表示开发板所使用的 Linux 内核源码目录，使用绝对路径，大家根据自己的实际情况填写即可。</p><p><strong>CURRENT_PATH</strong> 表示当前路径，直接通过运行“pwd”命令来获取当前所处路径。</p><p><strong>obj-m</strong> 表示将 chrdevbase.c 这个文件编译为 chrdevbase.ko 模块。</p><p><strong>$(MAKE) -C $(KERNEL_DIR) M&#x3D;$(CURRENT_PATH) modules</strong>具体的编译命令，后面的 modules 表示编译模块，**-C 表示将当前的工作目录切换到指定目录中<strong>，也就是 KERNERLDIR 目录。M 表示模块源码目录，“make modules”命令中</strong>加入 M&#x3D;dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件**。</p><p>Makefile 编写好以后输入“make”命令编译驱动模块，编译过程如图  所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820151835351.png" alt="image-20200820151835351"></p><p>编译成功以后就会生成一个叫做 chrdevbaes.ko 的文件，此文件就是 chrdevbase 设备的驱动模块。至此，chrdevbase 设备的驱动就编译成功。</p><h4 id="2、编译测试-APP"><a href="#2、编译测试-APP" class="headerlink" title="2、编译测试 APP"></a>2、编译测试 APP</h4><p>测试 APP 比较简单，只有一个文件，因此就不需要编写 Makefile 了，直接输入命令编译。因为测试 APP 是要在 ARM 开发板上运行的，所以需要使用 arm-linux-gnueabihf-gcc 来编译，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-gcc chrdevbaseApp.c -o chrdevbaseApp</code></pre></div><p>编译完成以后会生成一个叫做 chrdevbaseApp 的可执行程序，输入如下命令查看chrdevbaseAPP 这个程序的文件信息：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">file chrdevbaseApp</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152045899.png" alt="image-20200820152045899"></p><p>从图可以看出，chrdevbaseAPP 这个可执行文件是 32 位 LSB 格式，ARM 版本的，因此 chrdevbaseAPP 只能在 ARM 芯片下运行。</p><h3 id="4、运行测试"><a href="#4、运行测试" class="headerlink" title="4、运行测试"></a>4、运行测试</h3><h4 id="1、加载模块驱动"><a href="#1、加载模块驱动" class="headerlink" title="1、加载模块驱动"></a>1、加载模块驱动</h4><p>通过 NFS 将 Ubuntu 中的 rootfs(制作好的根文件系统)目录挂载为根文件系统，所以可以很方便的将chrdevbase.ko 和 chrdevbaseAPP 复制到rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15 目录中.</p><p>输入如下命令加载 chrdevbase.ko 驱动文件：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">insmod chrdevbase.ko</code></pre></div><p>或</p><div class="hljs code-wrapper"><pre><code class="hljs sh">modprobe chrdevbase.ko</code></pre></div><p>如果使用 modprobe 加载驱动的话，可能会出现如图 所示的提示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152529602.png" alt="image-20200820152529602"></p><p>从图可以看出，modprobe 提示无法打开“modules.dep”这个文件，因此驱动挂载失败了。我们不用手动创建 modules.dep 这个文件，直接输入 depmod 命令即可自动生成modules.dep，有些根文件系统可能没有 depmod 这个命令，如果没有这个命令就只能重新配置busybox，使能此命令，然后重新编译 busybox。</p><p>输入“depmod”命令以后会自动生成 modules.alias、modules.symbols 和 modules.dep 这三个文件，如图所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152622765.png" alt="image-20200820152622765"></p><p>重新使用 modprobe 加载 chrdevbase.ko，结果如图所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152702937.png" alt="image-20200820152702937"></p><p>从图可以看到“chrdevbase init！”这一行，这一行正是 chrdevbase.c 中模块入口函数 chrdevbase_init 输出的信息，说明模块加载成功！<br>输入“lsmod”命令即可查看当前系统中存在的模块，结果如图 所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152749421.png" alt="image-20200820152749421"></p><p>从图可以看出，当前系统只有“chrdevbase”这一个模块。输入如下命令查看当前系统中有没有 chrdevbase 这个设备：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /proc/devices</code></pre></div><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820152847237.png" alt="image-20200820152847237"></p><p>从图 可以看出，当前系统存在 chrdevbase 这个设备，主设备号为 200，跟我们设置的主设备号一致。</p><h4 id="2-、创建设备节点文件"><a href="#2-、创建设备节点文件" class="headerlink" title="2 、创建设备节点文件"></a>2 、创建设备节点文件</h4><p>驱动加载成功需要在&#x2F;dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操作这个设备节点文件来完成对具体设备的操作。输入如下命令创建&#x2F;dev&#x2F;chrdevbase 这个设备节点文件：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mknod</span> /dev/chrdevbase c 200 0</code></pre></div><p>其中“mknod”是创建节点命令，“&#x2F;dev&#x2F;chrdevbase”是要创建的节点文件，“c”表示这是个字符设备，“200”是设备的主设备号，“0”是设备的次设备号。</p><p>创建完成以后就会存在&#x2F;dev&#x2F;chrdevbase 这个文件，可以使用<code>ls /dev/chrdevbase -l</code>命令查看，结果如图所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153138996.png" alt="image-20200820153138996"></p><p>如果 chrdevbaseAPP 想要读写 chrdevbase 设备，直接对&#x2F;dev&#x2F;chrdevbase 进行读写操作即可。相当于&#x2F;dev&#x2F;chrdevbase 这个文件是 chrdevbase 设备在用户空间中的实现。前面一直说 Linux 下一切皆文件，包括设备也是文件，现在大家应该是有这个概念了吧？</p><h4 id="3、chrdevbase设备操作测试"><a href="#3、chrdevbase设备操作测试" class="headerlink" title="3、chrdevbase设备操作测试"></a>3、chrdevbase设备操作测试</h4><p>使用 chrdevbaseApp 软件操作 chrdevbase 这个设备，看看读写是否正常，首先进行读操作，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">./chrdevbaseAPP /dev/chrdevbase 1</code></pre></div><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153332666.png" alt="image-20200820153332666"></p><p>从图可以看出，首先输出“kernel senddata ok!”这一行信息，这是驱动程序中chrdevbase_read 函数输出的信息，因为 chrdevbaseAPP 使用 read 函数从 chrdevbase 设备读取数据，因此 chrdevbase_read 函数就会执行。chrdevbase_read 函数向 chrdevbaseAPP 发送“kerneldata!”数据，chrdevbaseAPP 接收到以后就打印出来，“read data:kernel data!”就是 chrdevbaseAPP打印出来的接收到的数据。说明对 chrdevbase 的读操作正常，接下来测试对 chrdevbase 设备的写操作，输入如下命令</p><div class="hljs code-wrapper"><pre><code class="hljs sh">./chrdevbaseAPP /dev/chrdevbase 2</code></pre></div><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153515594.png" alt="image-20200820153515594"></p><p> chrdevbase 的写操作正常，既然读写都没问题，说明我们编写的 chrdevbase 驱动是没有问题的。</p><h4 id="4、卸载驱动模块"><a href="#4、卸载驱动模块" class="headerlink" title="4、卸载驱动模块"></a>4、卸载驱动模块</h4><p>如果不再使用某个设备的话可以将其驱动卸载掉，比如输入如下命令卸载掉 chrdevbase 这个设备：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">rmmod chrdevbase.ko</code></pre></div><p>卸载以后使用 lsmod 命令查看 chrdevbase 这个模块还存不存在，结果如图  所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/image-20200820153622245.png" alt="image-20200820153622245"></p><p>从图可以看出，模块成功推出，此时系统已经没有任何模块了，chrdevbase 这个模块也不存在了，<br>说明模块卸载成功。至此，chrdevbase 这个设备的整个驱动就验证完成了，驱动工作正常。本章我们详细的讲解了字符设备驱动的开发步骤，并且以一个虚拟的 chrdevbase 设备为例，带领大家完成了第一个字符设备驱动的开发，掌握了字符设备驱动的开发框架以及测试方法，以后的字符设备驱动实验基本都以此为蓝本。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2| LED灯驱动开发实验记录</title>
    <link href="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/2%E3%80%81LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/2%E3%80%81LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="LED灯驱动开发实验记录"><a href="#LED灯驱动开发实验记录" class="headerlink" title="LED灯驱动开发实验记录"></a>LED灯驱动开发实验记录</h1><h2 id="一、Linux-下-LED-灯驱动原理"><a href="#一、Linux-下-LED-灯驱动原理" class="headerlink" title="一、Linux 下 LED  灯驱动原理"></a>一、Linux 下 LED  灯驱动原理</h2><p>Linux 下的任何外设驱动，最终都是要配置相应的硬件寄存器。所以本章的 LED 灯驱动最终也是对 I.MX6ULL 的 IO 口进行配置，与裸机实验不同的是，在 Linux 下编写驱动要符合 Linux的驱动框架。I.MX6U-ALPHA开发板上的LED连接到 I.MX6ULL 的 GPIO1_IO03 这个引脚上，因此本实验的重点就是编写 Linux 下 I.MX6UL 引脚控制驱动。</p><h3 id="1、地址映射"><a href="#1、地址映射" class="headerlink" title="1、地址映射"></a>1、地址映射</h3><p>在编写驱动之前，我们需要先简单了解一下 MMU 这个神器，MMU 全称叫做 MemoryManage Unit，也就是内存管理单元。在老版本的 Linux 中要求处理器必须有 MMU，但是现在Linux 内核已经支持无 MMU 的处理器了。</p><p><strong>MMU 主要完成的功能如下</strong>：<br><strong>①、</strong>完成虚拟空间到物理空间的映射。<br><strong>②、</strong>内存保护，设置存储器的访问权限，设置虚拟存储空间的缓冲特性。</p><p>我们重点来看一下第①点，也就是<strong>虚拟空间到物理空间的映射，也叫做地址映射</strong>。首先了解两个地址概念：</p><p><strong>虚拟地址(VA,Virtual Address)、物理地址(PA，Physcical Address)</strong></p><p>对于 32 位的处理器来说，虚拟地址范围是 2^32&#x3D;4GB，我们的开发板上有 512MB 的 DDR3，这 512MB 的<br>内存就是物理内存，经过 MMU 可以将其映射到整个 4GB 的虚拟空间，如图所示：</p><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/2%E3%80%81LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C/image-20200820154115074.png" alt="image-20200820154115074"></p><p>物理内存只有 512MB，虚拟内存有 4GB，那么肯定存在多个虚拟地址映射到同一个物理地址上去，虚拟地址范围比物理地址范围大的问题处理器自会处理，这里我们不要去深究，因为MMU 是很复杂的一个东西，后续有时间的话可以再参考正点原子 Linux 团队打算做的MMU 专题教程。</p><p>Linux 内核启动的时候会初始化 MMU，设置好内存映射，设置好以后 CPU 访问的都是虚拟地址。比如I.MX6ULL 的 <strong>GPIO1_IO03</strong> 引 脚 的 复 用 寄 存 器<strong>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</strong>的地址为 <strong>0X020E0068</strong>。如果没有开启 MMU 的话直接向 0X020E0068 这个寄存器地址写入数据就可以配置GPIO1_IO03 的复用功能。现在开启了 MMU，并且设置了内存映射，因此就不能直接向 0X020E0068 这个地址写入数据了。我们必须得到 0X020E0068 这个物理地址在 Linux 系统里面对应的虚拟地址，这里就涉及到了物理内存和虚拟内存之间的转换，需要用到两个函数：<strong>ioremap</strong> 和 <strong>iounmap</strong>。</p><h4 id="ioremap-函数"><a href="#ioremap-函数" class="headerlink" title="ioremap  函数"></a>ioremap  函数</h4><p>ioremap 函 数 用 于 获 取 指 定 物 理 地 址 空 间 对 应 的 虚 拟 地 址 空 间 ， 定 义 在arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;io.h 文件中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ioremap(cookie,size) __arm_ioremap((cookie), (size),</span>MT_DEVICE)    <span class="hljs-type">void</span> __iomem * __arm_ioremap(<span class="hljs-type">phys_addr_t</span> phys_addr, <span class="hljs-type">size_t</span> size,                                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mtype)&#123;    <span class="hljs-keyword">return</span> arch_ioremap_caller(phys_addr, size, mtype,                               __builtin_return_address(<span class="hljs-number">0</span>));&#125;</code></pre></div><p>ioremap 是个宏，有两个参数：<strong>cookie</strong> 和 <strong>size</strong>，真正起作用的是函数<strong>__arm_ioremap</strong>，此函数有三个参数和一个返回值，这些参数和返回值的含义如下：<br><strong>phys_addr</strong>：要映射给的物理起始地址。<br><strong>size</strong>：要映射的内存空间大小。<br><strong>mtype</strong>：ioremap 的类型，可以选择 MT_DEVICE、MT_DEVICE_NONSHARED、MT_DEVICE_CACHED 和 MT_DEVICE_WC，ioremap 函数选择 MT_DEVICE。<br><strong>返回值</strong>：__iomem 类型的指针，指向映射后的虚拟空间首地址。</p><p>假如我们要获取 I.MX6ULL 的<strong>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</strong> 寄存器对应的虚拟地址，使用如下代码即可：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_MUX_GPIO1_IO03_BASE  (0X020E0068)</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem* SW_MUX_GPIO1_IO03;SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);</code></pre></div><p><strong>宏 SW_MUX_GPIO1_IO03_BASE</strong> 是寄存器物理地址，<strong>SW_MUX_GPIO1_IO03</strong> 是映射后的虚拟地址。对于 I.MX6ULL 来说一个寄存器是 4 字节(32 位)的，因此映射的内存长度为 4。映射完成以后直接对SW_MUX_GPIO1_IO03 进行读写操作即可。</p><h4 id="iounmap-函数"><a href="#iounmap-函数" class="headerlink" title="iounmap  函数"></a>iounmap  函数</h4><p>卸载驱动的时候需要使用 iounmap 函数释放掉 ioremap 函数所做的映射，iounmap 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">iounmap</span> <span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span></code></pre></div><p>iounmap 只有一个参数 addr，此参数就是要取消映射的虚拟地址空间首地址。假如我们现在要取消掉 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 寄存器的地址映射，使用如下代码即可：</p><div class="hljs code-wrapper"><pre><code class="hljs c">iounmap(SW_MUX_GPIO1_IO03);</code></pre></div><h3 id="2、-I-x2F-O-内存访问函数"><a href="#2、-I-x2F-O-内存访问函数" class="headerlink" title="2、 I&#x2F;O  内存访问函数"></a>2、 I&#x2F;O  内存访问函数</h3><p>这里说的 I&#x2F;O 是输入&#x2F;输出的意思，并不是我们学习单片机的时候讲的 GPIO 引脚。这里涉及到两个概念：<strong>I&#x2F;O 端口</strong>和 <strong>I&#x2F;O 内存</strong>。</p><p>当外部寄存器或内存映射到 IO 空间时，称为 <strong>I&#x2F;O 端口</strong>。</p><p>当外部寄存器或内存映射到内存空间时，称为 <strong>I&#x2F;O 内存</strong>。</p><p>但是<strong>对于 ARM 来说没有 I&#x2F;O 空间这个概念</strong>，**因此 ARM 体系下只有 I&#x2F;O 内存(可以直接理解为内存)**。</p><p>使用ioremap函数将寄存器的物理地址映射到虚拟地址以后，我们就可以直接通过指针访问这些地址，但是 Linux 内核不建议这么做，而是推荐使用一组操作函数来对映射后的内存进行读写操作。</p><h4 id="1、读操作函数"><a href="#1、读操作函数" class="headerlink" title="1、读操作函数"></a>1、读操作函数</h4><p>读操作函数有如下几个：</p><div class="hljs code-wrapper"><pre><code class="hljs c">u8 <span class="hljs-title function_">readb</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span>u16 <span class="hljs-title function_">readw</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span>u32 <span class="hljs-title function_">readl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span></code></pre></div><p>readb、readw 和 readl 这三个函数分别对应 8bit、16bit 和 32bit 读操作，参数 addr 就是要读取写内存地址，返回值就是读取到的数据。</p><h4 id="2-、写操作函数"><a href="#2-、写操作函数" class="headerlink" title="2 、写操作函数"></a>2 、写操作函数</h4><p>写操作函数有如下几个：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">writeb</span><span class="hljs-params">(u8 value, <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span><span class="hljs-type">void</span> <span class="hljs-title function_">writew</span><span class="hljs-params">(u16 value, <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span><span class="hljs-type">void</span> <span class="hljs-title function_">writel</span><span class="hljs-params">(u32 value, <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span></code></pre></div><p>writeb、writew 和 writel 这三个函数分别对应 8bit、16bit 和 32bit 写操作，参数 value 是要写入的数值，addr 是要写入的地址。</p><h2 id="二、硬件原理图"><a href="#二、硬件原理图" class="headerlink" title="二、硬件原理图"></a>二、硬件原理图</h2><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/2%E3%80%81LED%E7%81%AF%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C/image-20200820172059339.png" alt="image-20200820172059339"></p><h2 id="三、实验程序编写"><a href="#三、实验程序编写" class="headerlink" title="三、实验程序编写"></a>三、实验程序编写</h2><h3 id="LED-灯驱动程序编写"><a href="#LED-灯驱动程序编写" class="headerlink" title="LED  灯驱动程序编写"></a>LED  灯驱动程序编写</h3><p>新建名为“2_led”文件夹，然后在 2_led 文件夹里面创建 VSCode 工程，工作区命名为“led”。工程创建好以后新建 led.c 文件，此文件就是 led 的驱动文件，在 led.c 里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_MAJOR 200</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_NAME <span class="hljs-string">&quot;led_driver&quot;</span></span><span class="hljs-comment">// #define LED_ON 1</span><span class="hljs-comment">// #define LED_OFF 0</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>LED_OFF = <span class="hljs-number">0</span>,LED_ON = !LED_OFF&#125;<span class="hljs-type">led_switch_t</span>;<span class="hljs-comment">/* 寄存器物理地址 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_CCM_CCGR1_BASE(0X020C406C)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_GPIO1_DR_BASE (0X0209C000)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_GPIO1_GDIR_BASE (0X0209C004)</span><span class="hljs-comment">/* 寄存器虚拟地址 */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_CCM_CCGR1;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_SW_MUX_GPIO1_IO03;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_SW_PAD_GPIO1_IO03;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_GPIO1_DR;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_GPIO1_GDIR;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>&#123;<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(sw == LED_ON)&#123;<span class="hljs-comment">/* 设置GPIO电平为低电平 默认点亮LED */</span>val = readl(VA_GPIO1_DR);val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>val = readl(VA_GPIO1_DR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);&#125;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;    <span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">1</span>)    &#123;printk(<span class="hljs-string">&quot;write led failed!\r\nwrite conut exceed limit,should be 1.\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;<span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = copy_from_user(userDataBuf, buf, cnt);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;write led failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;led_switch(userDataBuf[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 字符设备操作集 */</span><span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;.owner = THIS_MODULE, .open = led_open, .write = led_write,.release = led_release&#125;;<span class="hljs-comment">/* 入口 */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val;printk(<span class="hljs-string">&quot;led_init\r\n&quot;</span>);<span class="hljs-comment">/* LED 初始化 地址映射 */</span>VA_CCM_CCGR1 = ioremap(PA_CCM_CCGR1_BASE, <span class="hljs-number">4</span>);VA_SW_MUX_GPIO1_IO03 = ioremap(PA_SW_MUX_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);VA_SW_PAD_GPIO1_IO03 = ioremap(PA_SW_PAD_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);VA_GPIO1_DR = ioremap(PA_GPIO1_DR_BASE, <span class="hljs-number">4</span>);VA_GPIO1_GDIR = ioremap(PA_GPIO1_GDIR_BASE, <span class="hljs-number">4</span>);<span class="hljs-comment">/* 使能 GPIO1 时钟 */</span>val = readl(VA_CCM_CCGR1);val &amp;=  ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);writel(val, VA_CCM_CCGR1);writel(<span class="hljs-number">0x5</span>, VA_SW_MUX_GPIO1_IO03);<span class="hljs-comment">/* 设置复用 */</span>writel(<span class="hljs-number">0x10B0</span>, VA_SW_PAD_GPIO1_IO03);<span class="hljs-comment">/* 设置电气属性 */</span><span class="hljs-comment">/* 设置GPIO方向为输出*/</span>val = readl(VA_GPIO1_GDIR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_GDIR);<span class="hljs-comment">/* 设置GPIO电平为低电平 默认点亮LED */</span>val = readl(VA_GPIO1_DR);val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);<span class="hljs-comment">/* 注册字符设备 */</span>ret = register_chrdev(LED_MAJOR, LED_NAME, &amp;led_fops);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register %s failed!\r\n&quot;</span>, LED_NAME);<span class="hljs-keyword">return</span> -EIO;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 出口 */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">led_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val;printk(<span class="hljs-string">&quot;led_exit\r\n&quot;</span>);<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>val = readl(VA_GPIO1_DR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);<span class="hljs-comment">/* 地址映射释放 */</span>iounmap(VA_CCM_CCGR1);iounmap(VA_SW_MUX_GPIO1_IO03);iounmap(VA_SW_PAD_GPIO1_IO03);iounmap(VA_GPIO1_DR);iounmap(VA_GPIO1_GDIR);<span class="hljs-comment">/* 卸载字符设备 */</span>unregister_chrdev(LED_MAJOR, LED_NAME);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(led_init);module_exit(led_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><h3 id="编写测试APP"><a href="#编写测试APP" class="headerlink" title="编写测试APP"></a>编写测试APP</h3><p>编写测试 APP，led 驱动加载成功以后手动创建&#x2F;dev&#x2F;led 节点，应用 APP 通过操作&#x2F;dev&#x2F;led文件来完成对 LED 设备的控制。</p><p>向&#x2F;dev&#x2F;led 文件写 0 表示关闭 LED 灯，写 1 表示打开 LED 灯。新建 ledApp.c 文件，在里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-comment">/*</span><span class="hljs-comment"> *  usage:</span><span class="hljs-comment"> *  ./ledAPP     &lt;openFileName&gt;     &lt;0:OFF|1:ON&gt;   </span><span class="hljs-comment"> *  ./ledAPP     /dev/led           0               //关灯</span><span class="hljs-comment"> *  ./ledAPP     /dev/led           1               //开灯</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> *filename;    <span class="hljs-type">char</span> writebuf [<span class="hljs-number">1</span>];     filename = argv[<span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bad usage!\r\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:\r\n./ledAPP     &lt;openFileName&gt;     &lt;0:OFF|1:ON&gt;  \r\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-comment">/* 打开 */</span>    fd =  open(filename, O_WRONLY);    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    writebuf[<span class="hljs-number">0</span>] = atoi(argv[<span class="hljs-number">2</span>]);    ret = write(fd, writebuf, <span class="hljs-keyword">sizeof</span>(writebuf));    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s failed!\r\n&quot;</span>, filename);        close(fd);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s success!\r\n&quot;</span>, filename);    &#125;    <span class="hljs-comment">/* 关闭 */</span>    ret = close(fd);    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close file %s failed！\r\n&quot;</span>, filename);    &#125;&#125;</code></pre></div><p>ledApp.c 的内容还是很简单的，就是对 led 的驱动文件进行最基本的打开、关闭、写操作等。</p><h2 id="四、运行测试"><a href="#四、运行测试" class="headerlink" title="四、运行测试"></a>四、运行测试</h2><h3 id="1、编译驱动程序和测试-APP"><a href="#1、编译驱动程序和测试-APP" class="headerlink" title="1、编译驱动程序和测试 APP"></a>1、编译驱动程序和测试 APP</h3><p>编译驱动程序</p><p>编写 Makefile 文件，本章实验的 Makefile 文件和前面实验基本一样，只是将 obj-m 变量的值改为 led.o，Makefile 内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">KERNEL_DIR := /home/firestaradmin/linux/IMX6U/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga_lxgCURRENT_PATH := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span>obj-m := led.o<span class="hljs-section">build: kernel_modules</span><span class="hljs-section">kernel_modules:  </span><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNEL_DIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> modules<span class="hljs-section">clean: </span><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNEL_DIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> clean</code></pre></div><hr><p>编译测试 APP</p><p>输入如下命令编译测试 ledApp.c 这个测试程序：</p><p><code>arm-linux-gnueabihf-gcc ledAPP.c -o ledAPP</code></p><p>编译成功以后就会生成 ledApp 这个应用程序。</p><h3 id="2、运行测试"><a href="#2、运行测试" class="headerlink" title="2、运行测试"></a>2、运行测试</h3><p>将上一小节编译出来的led.ko和ledApp这两个文件拷贝到rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15目录中，重启开发板，进入到目录 lib&#x2F;modules&#x2F;4.1.15 中，输入如下命令加载 led.ko 驱动模块：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">depmod <span class="hljs-regexp">//</span>第一次加载驱动的时候需要运行此命令modprobe led.ko  <span class="hljs-regexp">//</span>加载驱动</code></pre></div><p>驱动加载成功以后创建“&#x2F;dev&#x2F;led”设备节点，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">mknod</span> /dev/led c <span class="hljs-number">200</span> <span class="hljs-number">0</span></code></pre></div><p>驱动节点创建成功以后就可以使用 ledApp 软件来测试驱动是否工作正常，输入如下命令打开 LED 灯：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/ledAPP /</span>dev<span class="hljs-regexp">/led 1 /</span><span class="hljs-regexp">/打开 LED 灯</span></code></pre></div><p>输入上述命令以后观察 I.MX6U-ALPHA 开发板上的红色 LED 灯是否点亮，如果点亮的话</p><p>说明驱动工作正常。在输入如下命令关闭 LED 灯：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/ledApp /</span>dev<span class="hljs-regexp">/led 0 /</span><span class="hljs-regexp">/关闭 LED 灯</span></code></pre></div><p>输入上述命令以后观察 I.MX6U-ALPHA 开发板上的红色 LED 灯是否熄灭，如果熄灭的话说明我们编写的 LED 驱动工作完全正常！至此，我们成功编写了第一个真正的 Linux 驱动设备程序。</p><p>如果要卸载驱动的话输入如下命令即可：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">rmmod</span> led.ko</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3| 新字符设备驱动实验</title>
    <link href="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/3%E3%80%81%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <url>/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/3%E3%80%81%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="新字符设备驱动实验"><a href="#新字符设备驱动实验" class="headerlink" title="新字符设备驱动实验"></a>新字符设备驱动实验</h1><p>经过前两实验的实战操作，我们已经掌握了 Linux 字符设备驱动开发的基本步骤，字符设备驱动开发重点是使用 register_chrdev 函数注册字符设备，当不再使用设备的时候就使用unregister_chrdev 函数注销字符设备，驱动模块加载成功以后还需要手动使用 mknod 命令创建设备节点。</p><p><strong>register_chrdev</strong> 和 <strong>unregister_chrdev</strong> 这两个函数是老版本驱动使用的函数，现在新的字符设备驱动已经不再使用这两个函数，而是使用Linux内核推荐的新字符设备驱动API函数。</p><p>本节我们就来学习一下如何编写新字符设备驱动，并且在驱动模块加载的时候自动创建设备节点文件。</p><h2 id="一、新字符设备驱动原理"><a href="#一、新字符设备驱动原理" class="headerlink" title="一、新字符设备驱动原理"></a>一、新字符设备驱动原理</h2><h3 id="1-分配和释放设备号"><a href="#1-分配和释放设备号" class="headerlink" title="1|分配和释放设备号"></a>1|分配和释放设备号</h3><p>使用 register_chrdev 函数注册字符设备的时候只需要给定一个主设备号即可，但是这样会带来两个问题：</p><p>①、需要我们事先确定好哪些主设备号没有使用。<br>②、会将一个主设备号下的所有次设备号都使用掉，比如现在设置 LED 这个主设备号为200，那么0~1048575(2^20-1)这个区间的次设备号就全部都被 LED 一个设备分走了。这样太浪费次设备号了！一个 LED 设备肯定只能有一个主设备号，一个次设备号。</p><p>解决这两个问题最好的方法就是要使用设备号的时候向 Linux 内核申请，需要几个就申请几个，由 Linux 内核分配设备可以使用的设备号。</p><p>如果没有指定设备号的话就使用如下函数来申请设备号：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, <span class="hljs-type">unsigned</span> baseminor, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div><p>如果给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号即可：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></code></pre></div><p>参数 <strong>from</strong> 是要申请的起始设备号，也就是给定的设备号；</p><p>参数 <strong>count</strong> 是要申请的数量，一般都是一个；</p><p>参数 <strong>name</strong> 是设备名字。</p><p>注销字符设备之后要释放掉设备号，不管是通过 alloc_chrdev_region 函数还是register_chrdev_region 函数申请的设备号，统一使用如下释放函数：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span></code></pre></div><p>新字符设备驱动下，设备号分配示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><span class="hljs-number">2</span> <span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><span class="hljs-number">3</span> <span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><span class="hljs-number">4</span><span class="hljs-number">5</span> <span class="hljs-keyword">if</span> (major) &#123; <span class="hljs-comment">/* 定义了主设备号 */</span><span class="hljs-number">6</span> devid = MKDEV(major, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 大部分驱动次设备号都选择 0 */</span><span class="hljs-number">7</span> register_chrdev_region(devid, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>);<span class="hljs-number">8</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 没有定义设备号 */</span><span class="hljs-number">9</span> alloc_chrdev_region(&amp;devid, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">/* 申请设备号 */</span><span class="hljs-number">10</span> major = MAJOR(devid); <span class="hljs-comment">/* 获取分配号的主设备号 */</span><span class="hljs-number">11</span> minor = MINOR(devid); <span class="hljs-comment">/* 获取分配号的次设备号 */</span><span class="hljs-number">12</span> &#125;</code></pre></div><p>如果要注销设备号的话，使用如下代码即可：</p><div class="hljs code-wrapper"><pre><code class="hljs c">unregister_chrdev_region(devid, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 注销设备号 */</span></code></pre></div><p>注销设备号的代码很简单。</p><h3 id="2-新的字符设备注册方法"><a href="#2-新的字符设备注册方法" class="headerlink" title="2|新的字符设备注册方法"></a>2|新的字符设备注册方法</h3><h4 id="1-、字符设备结构"><a href="#1-、字符设备结构" class="headerlink" title="1 、字符设备结构"></a>1 、字符设备结构</h4><p>在 Linux 中使用 cdev 结构体表示一个字符设备，cdev 结构体在 include&#x2F;linux&#x2F;cdev.h 文件中的定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> &#123;</span><span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><span class="hljs-number">4</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">ops</span>;</span><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><span class="hljs-number">6</span><span class="hljs-type">dev_t</span> dev;<span class="hljs-number">7</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;<span class="hljs-number">8</span> &#125;;</code></pre></div><p>在 cdev 中有两个重要的成员变量：<strong>ops</strong> 和 <strong>dev</strong>，这两个就是字符设备文件操作函数集合file_operations 以及设备号 dev_t。</p><p>编写字符设备驱动之前需要定义一个 cdev 结构体变量，这个变量就表示一个字符设备，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">test_cdev</span>;</span></code></pre></div><h4 id="2-、cdev-init-函数"><a href="#2-、cdev-init-函数" class="headerlink" title="2 、cdev_init  函数"></a>2 、cdev_init  函数</h4><p>定义好 cdev 变量以后就要使用 cdev_init 函数对其进行初始化，cdev_init 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cdev_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *cdev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span></code></pre></div><p>参数 cdev 就是要初始化的 cdev 结构体变量，参数 fops 就是字符设备文件操作函数集合。使用 cdev_init 函数初始化 cdev 变量的示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">testcdev</span>;</span><span class="hljs-number">2</span><span class="hljs-number">3</span> <span class="hljs-comment">/* 设备操作函数 */</span><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;<span class="hljs-number">5</span> .owner = THIS_MODULE,<span class="hljs-number">6</span> <span class="hljs-comment">/* 其他具体的初始项 */</span><span class="hljs-number">7</span> &#125;;<span class="hljs-number">8</span><span class="hljs-number">9</span> testcdev.owner = THIS_MODULE;<span class="hljs-number">10</span> cdev_init(&amp;testcdev, &amp;test_fops); <span class="hljs-comment">/* 初始化 cdev 结构体变量 */</span></code></pre></div><h4 id="3-、cdev-add-函数"><a href="#3-、cdev-add-函数" class="headerlink" title="3 、cdev_add  函数"></a>3 、cdev_add  函数</h4><p>cdev_add 函数用于向 Linux 系统添加字符设备(cdev 结构体变量)，首先使用 cdev_init 函数完成对 cdev 结构体变量的初始化，然后使用 cdev_add 函数向 Linux 系统添加这个字符设备。</p><p>cdev_add 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cdev_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p, <span class="hljs-type">dev_t</span> dev, <span class="hljs-type">unsigned</span> count)</span></code></pre></div><p>参数 <strong>p</strong> 指向要添加的字符设备(cdev 结构体变量)</p><p>参数 <strong>dev</strong> 就是设备所使用的设备号，</p><p>参数 <strong>count</strong> 是要添加的设备数量。</p><p>完善示例代码，加入 cdev_add 函数，内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">testcdev</span>;</span><span class="hljs-number">2</span><span class="hljs-number">3</span> <span class="hljs-comment">/* 设备操作函数 */</span><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;<span class="hljs-number">5</span> .owner = THIS_MODULE,<span class="hljs-number">6</span> <span class="hljs-comment">/* 其他具体的初始项 */</span><span class="hljs-number">7</span> &#125;;<span class="hljs-number">8</span><span class="hljs-number">9</span> testcdev.owner = THIS_MODULE;<span class="hljs-number">10</span> cdev_init(&amp;testcdev, &amp;test_fops); <span class="hljs-comment">/* 初始化 cdev 结构体变量  */</span><span class="hljs-number">11</span> cdev_add(&amp;testcdev, devid, <span class="hljs-number">1</span>); <span class="hljs-comment">/*  添加字符设备 */</span></code></pre></div><p>以上示例代码  就是新的注册字符设备代码段，Linux 内核中大量的字符设备驱动都是采用这种方法向 Linux 内核添加字符设备。</p><p><strong>如果在加上之前示例代码中分配设备号的程序，那么就它们一起实现的就是函数 register_chrdev 的功能。</strong></p><h4 id="4-、cdev-del-函数"><a href="#4-、cdev-del-函数" class="headerlink" title="4 、cdev_del  函数"></a>4 、cdev_del  函数</h4><p>卸载驱动的时候一定要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备，cdev_del函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cdev_del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p)</span></code></pre></div><p>参数 p 就是要删除的字符设备。如果要删除字符设备，参考如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c">cdev_del(&amp;testcdev);  <span class="hljs-comment">/* 删除 cdev */</span></code></pre></div><p><strong>cdev_del</strong> 和 <strong>unregister_chrdev_region</strong> 这两个函数合起来的功能相当于 <strong>unregister_chrdev</strong> 函数。</p><h2 id="二、自动创建设备节点"><a href="#二、自动创建设备节点" class="headerlink" title="二、自动创建设备节点"></a>二、自动创建设备节点</h2><p>在前面的 Linux 驱动实验中，当我们使用 modprobe 加载驱动程序以后还需要使用命令<code>mknod</code>手动创建设备节点。本节就来讲解一下<strong>如何实现自动创建设备节点</strong>，在驱动中实现自动创建设备节点的功能以后，使用 <code>modprobe</code> 加载驱动模块成功的话就会自动在&#x2F;dev 目录下创建对应的设备文件。</p><h3 id="1-mdev-机制"><a href="#1-mdev-机制" class="headerlink" title="1|mdev  机制"></a>1|mdev  机制</h3><p>udev 是一个用户程序，在 Linux 下通过 udev 来实现设备文件的创建与删除，udev 可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用modprobe 命令成功加载驱动模块以后就自动在&#x2F;dev 目录下创建对应的设备节点文件,使用 rmmod 命令卸载驱动模块以后就删除掉&#x2F;dev 目录下的设备节点文件。</p><p>使用 busybox 构建根文件系统的时候，busybox 会创建一个 udev 的<strong>简化版本—mdev</strong>，所以在嵌入式 Linux 中我们使用 mdev 来实现设备节点文件的自动创建与删除，Linux 系统中的热插拔事件也由 mdev 管理，在&#x2F;etc&#x2F;init.d&#x2F;rcS 文件中有如下语句：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</code></pre></div><p>上述命令设置热插拔事件由 mdev 来管理，关于 udev 或 mdev 更加详细的工作原理这里就不详细探讨了，我们重点来学习一下如何通过 mdev 来实现设备文件节点的自动创建与删除。</p><h3 id="2-创建和删除类"><a href="#2-创建和删除类" class="headerlink" title="2|创建和删除类"></a>2|创建和删除类</h3><p>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。</p><p>首先要创建一个 class 类，class 是个结构体，定义在文件include&#x2F;linux&#x2F;device.h 里面。class_create 是类创建函数，class_create 是个宏定义，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> class_create(owner, name) \</span><span class="hljs-meta">2 (&#123; \</span><span class="hljs-meta">3 static struct lock_class_key __key; \</span><span class="hljs-meta">4 __class_create(owner, name, &amp;__key); \</span><span class="hljs-meta">5 &#125;)</span><span class="hljs-number">6</span><span class="hljs-number">7</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *__<span class="hljs-title">class_create</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>, <span class="hljs-title">const</span> <span class="hljs-title">char</span> *<span class="hljs-title">name</span>,</span><span class="hljs-class">8    <span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span> *<span class="hljs-title">key</span>)</span></code></pre></div><p>class_create 一共有两个参数，<strong>参数 owner</strong> 一般为 THIS_MODULE，<strong>参数 name</strong> 是类名字。<strong>返回值</strong>是个指向结构体 class 的指针，也就是创建的类。</p><p>卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">class_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> class *cls)</span>;</code></pre></div><p><strong>参数 cls</strong> 就是要删除的类。</p><h3 id="3-创建设备"><a href="#3-创建设备" class="headerlink" title="3|创建设备"></a>3|创建设备</h3><p>上一小节创建好类以后还不能实现自动创建设备节点，我们还需要在这个类下创建一个设<br>备。使用 device_create 函数在类下面创建设备，device_create 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device *<span class="hljs-title function_">device_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> class *class,</span><span class="hljs-params">                             <span class="hljs-keyword">struct</span> device *parent,</span><span class="hljs-params">                             <span class="hljs-type">dev_t</span> devt,</span><span class="hljs-params">                             <span class="hljs-type">void</span> *drvdata,</span><span class="hljs-params">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span></code></pre></div><p><strong>device_create</strong> 是个可变参数函数</p><ul><li><p><strong>参数 class</strong> 就是设备要创建哪个类下面；</p><p><strong>参数 parent</strong> 是父设备，一般为 NULL，也就是没有父设备；</p><p><strong>参数 devt</strong> 是设备号；</p><p><strong>参数 drvdata</strong> 是设备可能会使用的一些数据，一般为 NULL；</p><p><strong>参数 fmt</strong> 是设备名字，如果设置 fmt&#x3D;xxx 的话，就会生成&#x2F;dev&#x2F;xxx这个设备文件。</p><p><strong>返回值</strong>就是创建好的设备。</p></li></ul><p>同样的，卸载驱动的时候需要删除掉创建的设备，设备删除函数为 device_destroy，函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">device_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> class *class, <span class="hljs-type">dev_t</span> devt)</span></code></pre></div><p>参数 classs 是要删除的设备所处的类，参数 devt 是要删除的设备号。</p><h3 id="4-参考示例"><a href="#4-参考示例" class="headerlink" title="4|参考示例"></a>4|参考示例</h3><p>在驱动入口函数里面创建类和设备，在驱动出口函数里面删除类和设备，参考示例如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span><span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><span class="hljs-number">3</span> <span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><span class="hljs-number">4</span><span class="hljs-number">5</span> <span class="hljs-comment">/* 驱动入口函数 */</span><span class="hljs-number">6</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>7 &#123;<span class="hljs-number">8</span> <span class="hljs-comment">/* 创建类 */</span><span class="hljs-number">9</span> <span class="hljs-class"><span class="hljs-keyword">class</span> =</span> class_create(THIS_MODULE, <span class="hljs-string">&quot;xxx&quot;</span>);<span class="hljs-number">10</span> <span class="hljs-comment">/* 创建设备 */</span><span class="hljs-number">11</span> device = device_create(class, <span class="hljs-literal">NULL</span>, devid, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;xxx&quot;</span>);<span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">13</span> &#125;<span class="hljs-number">14</span><span class="hljs-number">15</span> <span class="hljs-comment">/* 驱动出口函数 */</span><span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">led_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>17 &#123;<span class="hljs-number">18</span> <span class="hljs-comment">/* 删除设备 */</span><span class="hljs-number">19</span> device_destroy(class, newchrled.devid);<span class="hljs-number">20</span> <span class="hljs-comment">/* 删除类 */</span><span class="hljs-number">21</span> class_destroy(class);<span class="hljs-number">22</span> &#125;<span class="hljs-number">23</span><span class="hljs-number">24</span> module_init(led_init);<span class="hljs-number">25</span> module_exit(led_exit);</code></pre></div><h2 id="三、设置文件私有数据"><a href="#三、设置文件私有数据" class="headerlink" title="三、设置文件私有数据"></a>三、设置文件私有数据</h2><p>每个硬件设备都有一些属性，比如主设备号(dev_t)，类(class)、设备(device)、开关状态(state)等等，在编写驱动的时候你可以将这些属性全部写成变量的形式，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">/* cdev */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span></code></pre></div><p>这样写肯定没有问题，但是这样写不专业！对于一个设备的所有属性信息我们最好将其做成一个结构体。编写驱动 open 函数的时候将设备结构体作为私有数据添加到设备文件中，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 设备结构体 */</span><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_dev</span>&#123;</span><span class="hljs-number">2</span> <span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">/* cdev */</span><span class="hljs-number">4</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><span class="hljs-number">6</span> <span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><span class="hljs-number">7</span> <span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><span class="hljs-number">8</span> &#125;;<span class="hljs-number">9</span><span class="hljs-number">10</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_dev</span> <span class="hljs-title">testdev</span>;</span><span class="hljs-number">11</span><span class="hljs-number">12</span> <span class="hljs-comment">/* open 函数 */</span><span class="hljs-number">13</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>14 &#123;<span class="hljs-number">15</span> filp-&gt;private_data = &amp;testdev; <span class="hljs-comment">/* 设置私有数据 */</span><span class="hljs-number">16</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">17</span> &#125;</code></pre></div><p><strong>在 open 函数里面设置好私有数据以后，在 write、read、close 等函数中直接读取 private_data即可得到设备结构体。</strong></p><h2 id="四、硬件原理图"><a href="#四、硬件原理图" class="headerlink" title="四、硬件原理图"></a>四、硬件原理图</h2><p><img src="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/3%E3%80%81%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/image-20200820181615173.png" alt="image-20200820181615173"></p><h2 id="五、实验程序编写"><a href="#五、实验程序编写" class="headerlink" title="五、实验程序编写"></a>五、实验程序编写</h2><p>本章实验在上一章实验的基础上完成，重点是使用了新的字符设备驱动、设置了文件私有数据、添加了自动创建设备节点相关内容。</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><span class="hljs-comment">// #define LED_ON 1</span><span class="hljs-comment">// #define LED_OFF 0</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">led_switch_enum</span>&#123;</span>LED_OFF = <span class="hljs-number">0</span>,LED_ON = !LED_OFF&#125;<span class="hljs-type">led_switch_t</span>;<span class="hljs-comment">/* 寄存器物理地址 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_CCM_CCGR1_BASE(0X020C406C)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_GPIO1_DR_BASE (0X0209C000)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA_GPIO1_GDIR_BASE (0X0209C004)</span><span class="hljs-comment">/* 寄存器虚拟地址 */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_CCM_CCGR1;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_SW_MUX_GPIO1_IO03;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_SW_PAD_GPIO1_IO03;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_GPIO1_DR;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *VA_GPIO1_GDIR;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(<span class="hljs-type">led_switch_t</span> sw)</span>&#123;<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(sw == LED_ON)&#123;<span class="hljs-comment">/* 设置GPIO电平为低电平 默认点亮LED */</span>val = readl(VA_GPIO1_DR);val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 设置GPIO电平为高电平 关闭LED */</span>val = readl(VA_GPIO1_DR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);&#125;&#125;<span class="hljs-comment">/* LED设备结构体 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">newchrled_dev</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><span class="hljs-comment">//字符设备</span><span class="hljs-type">dev_t</span> devid;<span class="hljs-comment">//设备号</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-comment">//类</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span><span class="hljs-comment">//设备</span><span class="hljs-type">int</span> major;<span class="hljs-type">int</span> minor;<span class="hljs-type">char</span> *chrdevname;&#125;;<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">newchrled_dev</span> <span class="hljs-title">newchrled</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newchrled_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;filp-&gt;private_data = &amp;newchrled;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">newchrled_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span>&#123;<span class="hljs-type">char</span> userDataBuf[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret = copy_from_user(userDataBuf, buf, cnt);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;write failed!\r\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;led_switch(userDataBuf[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newchrled_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">newchrled_fops</span> =</span> &#123;.owner = THIS_MODULE,.write = newchrled_write,.open = newchrled_open,.release = newchrled_release&#125;;<span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">newchrled_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> result;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;printk(<span class="hljs-string">&quot;newchrled_init!\r\n&quot;</span>);<span class="hljs-comment">/* 注册设备号 */</span>newchrled.chrdevname = <span class="hljs-string">&quot;newchrdev_led&quot;</span>;<span class="hljs-keyword">if</span>(newchrled.major)&#123;<span class="hljs-comment">//如果给定了主设备号</span>newchrled.devid= MKDEV(newchrled.major, <span class="hljs-number">0</span>);ret = register_chrdev_region(newchrled.devid, <span class="hljs-number">1</span>, newchrled.chrdevname);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果没给定主设备号</span>ret = alloc_chrdev_region(&amp;newchrled.devid, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, newchrled.chrdevname);&#125;newchrled.major = MAJOR(newchrled.devid);newchrled.minor = MINOR(newchrled.devid);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register dev failed!\r\n&quot;</span>);result = <span class="hljs-number">-1</span>;<span class="hljs-keyword">goto</span> fail_register;&#125;printk(<span class="hljs-string">&quot;newchrled  MAJOR:%d  MINOR:%d\r\n&quot;</span>, newchrled.major, newchrled.minor);<span class="hljs-comment">/* 注册字符设备 */</span>newchrled.cdev.owner = newchrled_fops.owner;cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops);ret = cdev_add(&amp;newchrled.cdev, newchrled.devid, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">&quot;register chrdev failed!\r\n&quot;</span>);result = <span class="hljs-number">-2</span>;<span class="hljs-keyword">goto</span> fail_cdev;&#125;<span class="hljs-comment">/* 创建设备节点 */</span><span class="hljs-comment">/* 1.创建类 */</span>newchrled.class = class_create(THIS_MODULE, newchrled.chrdevname);<span class="hljs-keyword">if</span>(IS_ERR(newchrled.class))&#123;result = PTR_ERR(newchrled.class);<span class="hljs-keyword">goto</span> fail_class;&#125;<span class="hljs-comment">/*2.创建设备*/</span>newchrled.device = device_create(newchrled.class, <span class="hljs-literal">NULL</span>,newchrled.devid, <span class="hljs-literal">NULL</span>, newchrled.chrdevname);<span class="hljs-keyword">if</span>(IS_ERR(newchrled.device))&#123;result = PTR_ERR(newchrled.device);<span class="hljs-keyword">goto</span> fail_device;&#125;<span class="hljs-comment">/* LED初始化 */</span><span class="hljs-comment">/* -&gt;1.地址映射 */</span>VA_CCM_CCGR1 = ioremap(PA_CCM_CCGR1_BASE, <span class="hljs-number">4</span>);VA_SW_MUX_GPIO1_IO03 = ioremap(PA_SW_MUX_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);VA_SW_PAD_GPIO1_IO03 = ioremap(PA_SW_PAD_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);VA_GPIO1_DR = ioremap(PA_GPIO1_DR_BASE, <span class="hljs-number">4</span>);VA_GPIO1_GDIR = ioremap(PA_GPIO1_GDIR_BASE, <span class="hljs-number">4</span>);<span class="hljs-comment">/* -&gt;2.初始化 */</span><span class="hljs-comment">/* -&gt;-&gt;打开时钟 */</span>val = readl(VA_CCM_CCGR1);val &amp;=  ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);writel(val, VA_CCM_CCGR1);writel(<span class="hljs-number">0x5</span>, VA_SW_MUX_GPIO1_IO03);<span class="hljs-comment">/* 设置复用 */</span>writel(<span class="hljs-number">0x10B0</span>, VA_SW_PAD_GPIO1_IO03);<span class="hljs-comment">/* 设置电气属性 */</span><span class="hljs-comment">/* -&gt;-&gt;设置GPIO方向为输出*/</span>val = readl(VA_GPIO1_GDIR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_GDIR);<span class="hljs-comment">/* -&gt;-&gt;设置GPIO电平为高电平 默认关闭LED */</span>val = readl(VA_GPIO1_DR);val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);writel(val, VA_GPIO1_DR);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;fail_device:<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(newchrled.class);fail_class:<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;newchrled.cdev);fail_cdev:<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(newchrled.devid, <span class="hljs-number">1</span>);fail_register:<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">newchrled_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;printk(<span class="hljs-string">&quot;newchrled_exit!\r\n&quot;</span>);<span class="hljs-comment">/* 地址映射释放 */</span>iounmap(VA_CCM_CCGR1);iounmap(VA_SW_MUX_GPIO1_IO03);iounmap(VA_SW_PAD_GPIO1_IO03);iounmap(VA_GPIO1_DR);iounmap(VA_GPIO1_GDIR);<span class="hljs-comment">/* 摧毁设备 */</span>device_destroy(newchrled.class, newchrled.devid);<span class="hljs-comment">/* 摧毁类 */</span>class_destroy(newchrled.class);<span class="hljs-comment">/* 注销字符设备 */</span>cdev_del(&amp;newchrled.cdev);<span class="hljs-comment">/* 注销设备号 */</span>unregister_chrdev_region(newchrled.devid, <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">/* 驱动入口和出口 */</span>module_init(newchrled_init);module_exit(newchrled_exit);MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);MODULE_AUTHOR(<span class="hljs-string">&quot;LXG@firestaradmin&quot;</span>);</code></pre></div><h2 id="六、运行测试"><a href="#六、运行测试" class="headerlink" title="六、运行测试"></a>六、运行测试</h2><p>和之前一样，编译运行，这边APP程序直接使用上次的即可。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核常用函数</title>
    <link href="/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/10/NOTE/ARM-Linux/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="内核常用函数"><a href="#内核常用函数" class="headerlink" title="内核常用函数"></a>内核常用函数</h1><h2 id="printk-输出信息"><a href="#printk-输出信息" class="headerlink" title="printk 输出信息"></a>printk 输出信息</h2><p>这里使用了 printk 来输出信息，而不是 printf！因为在 Linux 内核中没有 printf 这个函数。printk 相当于 printf 的孪生兄妹，printf运行在用户态，printk 运行在内核态。在内核中想要向控制台输出或显示一些内容，必须使用printk 这个函数。不同之处在于，printk 可以根据日志级别对消息进行分类，一共有 8 个消息级别，这 8 个消息级别定义在文件 include&#x2F;linux&#x2F;kern_levels.h 里面，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_SOH  <span class="hljs-string">&quot;\001&quot;</span> </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_EMERG KERN_SOH <span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-comment">/* 紧急事件，一般是内核崩溃 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_ALERT KERN_SOH <span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-comment">/* 必须立即采取行动 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_CRIT  KERN_SOH <span class="hljs-string">&quot;2&quot;</span>  <span class="hljs-comment">/* 临界条件，比如严重的软件或硬件错误*/</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_ERR  KERN_SOH <span class="hljs-string">&quot;3&quot;</span>  <span class="hljs-comment">/* 错误状态，一般设备驱动程序中使用KERN_ERR 报告硬件错误 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_WARNING KERN_SOH <span class="hljs-string">&quot;4&quot;</span>  <span class="hljs-comment">/* 警告信息，不会对系统造成严重影响 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_NOTICE  KERN_SOH <span class="hljs-string">&quot;5&quot;</span>  <span class="hljs-comment">/* 有必要进行提示的一些信息 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_INFO  KERN_SOH <span class="hljs-string">&quot;6&quot;</span>  <span class="hljs-comment">/* 提示性的信息 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_DEBUG KERN_SOH <span class="hljs-string">&quot;7&quot;</span>  <span class="hljs-comment">/* 调试信息 */</span></span></code></pre></div><p>一共定义了 8 个级别，其中 0 的优先级最高，7 的优先级最低。如果要设置消息级别，参考如下示例：</p><div class="hljs code-wrapper"><pre><code class="hljs c">printk(KERN_EMERG <span class="hljs-string">&quot;gsmi: Log Shutdown Reason\n&quot;</span>);</code></pre></div><p>上述代码就是设置“gsmi: Log Shutdown Reason\n”这行消息的级别为 KERN_EMERG。在具体的消息前面加上 KERN_EMERG 就可以将这条消息的级别设置为 KERN_EMERG。</p><p>如果使用 printk 的 时 候 不 显 式 的 设 置 消 息 级 别 ， 那 么 printk 将 会 采 用 默 认 级 别MESSAGE_LOGLEVEL_DEFAULT，MESSAGE_LOGLEVEL_DEFAULT 默认为 4。在 include&#x2F;linux&#x2F;printk.h 中有个宏 CONSOLE_LOGLEVEL_DEFAULT，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONSOLE_LOGLEVEL_DEFAULT 7</span></code></pre></div><p>CONSOLE_LOGLEVEL_DEFAULT 控制着哪些级别的消息可以显示在控制台上，此宏默认为 7，意味着只有优先级高于 7 的消息才能显示在控制台上。</p><p>这个就是 printk 和 printf 的最大区别，可以通过消息级别来决定哪些消息可以显示在控制台上。默认消息级别为 4，4 的级别比 7 高，所示直接使用 printk 输出的信息是可以显示在控制台上的。</p><hr><h2 id="内核和用户间的数据传递"><a href="#内核和用户间的数据传递" class="headerlink" title="内核和用户间的数据传递"></a>内核和用户间的数据传递</h2><p><strong>copy_to_user()</strong> </p><p>因为内核空间不能直接操作用户空间的内存，因此需要借助 <strong>copy_to_user</strong> 函数来完成内核空间的数据到用户空间的复制。copy_to_user 函数原型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title function_">copy_to_user</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *to, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *from, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span></code></pre></div><p><strong>参数 to</strong> 表示目的，<strong>参数 from</strong> 表示源，<strong>参数 n</strong> 表示要复制的数据长度。如果复制成功，返回值为 0，如果复制失败则返回负数。</p><p><strong>copy_from_user</strong> </p><p>函数 <strong>copy_from_user</strong> 将 buf 中的数据复制到写缓冲区 writebuf 中，因为用户空间内存不能直接访问内核空间的内存，所以需要借助函数 copy_from_user 将用户空间的数据复制到 writebuf 这个内核空间中。</p><hr><h2 id="动态内存申请释放"><a href="#动态内存申请释放" class="headerlink" title="动态内存申请释放"></a>动态内存申请释放</h2><p><strong>kmalloc申请内存</strong></p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 申请内存 </span><span class="hljs-comment"> * 如果使用的是 u32 *u32_array; 来表示数组 则需要申请内存</span><span class="hljs-comment"> * 如果使用 u32 u32_array[8]; 则不需要申请内存</span><span class="hljs-comment"> * 使用u32 u32_array[8]模式，前提是要知道要读取的属性有几个元素</span><span class="hljs-comment"> */</span>u32_array = kmalloc(elem_num * <span class="hljs-keyword">sizeof</span>(u32), GFP_KERNEL);<span class="hljs-keyword">if</span>(!u32_array)&#123;    ret = -EINVAL;    printk(<span class="hljs-string">&quot;malloc falied!\r\n&quot;</span>);    <span class="hljs-keyword">goto</span> fail_malloc;&#125;</code></pre></div><p><strong>kfree释放内存</strong> </p><div class="hljs code-wrapper"><pre><code class="hljs c">kfree(u32_array);</code></pre></div><h1 id="对Linux下常用头文件总结"><a href="#对Linux下常用头文件总结" class="headerlink" title="对Linux下常用头文件总结"></a>对Linux下常用头文件总结</h1><p>Author@firestaradmin 2020年5月4日17:55:50</p><p><strong>asm.current.h  定义全局项current ，其指向结构体struct task_struct</strong></p><p><strong>linux&#x2F;sched.h  定义结构体task_struct ，只要包含此头文件即可引用当前进程</strong></p><p><strong>linux&#x2F;modules.h 定义含有可装载模块需要的大量符号和函数</strong></p><p><strong>linux&#x2F;init.h   定义初始化和清楚函数</strong></p><p><strong>linux&#x2F;errno.h  定义错误编码</strong></p><p><strong>linux&#x2F;stat.h   定义成员访问许可值</strong></p><p><strong>linux&#x2F;sched.h  定义大部分内核API，包括睡眠函数以及各种变量声明</strong></p><p><strong>linux&#x2F;version.h  定义内核版本信息</strong></p><p><strong>linux&#x2F;moduleparam.h 定义用来创建模块的宏</strong></p><p><strong>linux&#x2F;kernel.h  定义函数printf的内核代码</strong></p><p><strong>linux&#x2F;types.h   定义dev_t ，岂作用是用来保存设备编号</strong></p><p><strong>linux&#x2F;kdev_t.h  定义用来操作设备编号的宏</strong></p><p><strong>linux&#x2F;fs.h    定义file_operations , file 等重要结构体，和inode结构</strong></p><p><strong>linux&#x2F;cdev.h   定义字符设备struct cdev 结构体以及与其相关的一些辅助函数</strong></p><p><strong>linux&#x2F;slab.h   定义内存管理的连个核心函数：*kmalloc kfree</strong></p><p><strong>asm&#x2F;uaccess.h  定义访问用户缓冲区函数如：copy_from_user</strong></p><p><strong>linux&#x2F;uio.h   定义iovec结构体</strong></p><p><strong>sys&#x2F;syslog.h  定义syslogd可选值</strong></p><p><strong>linux&#x2F;proc_fs.h 定义&#x2F;proc 的模块</strong></p><p><strong>linux&#x2F;seq_file.h  定义seq_file接口</strong></p><p><strong>asm&#x2F;semaphore.h 定义信号量相关的东西</strong></p><p><strong>linux&#x2F;rwsem.h  定义读取中&#x2F;写入者信号量</strong></p><p><strong>linux&#x2F;completion.h 定义complete 相关</strong></p><p><strong>linux&#x2F;spinlock.h  定义spinlock 相关</strong></p><p><strong>asm&#x2F;atomic.h   定义原子操作相关</strong></p><p><strong>asm&#x2F;bitops.h    定义位操作相关（宏）</strong></p><p><strong>linux&#x2F;seqlock.h  定义seqlock 相关</strong></p><p><strong>linux&#x2F;rcupdate.h  定义RCU 相关（read_copy_update）</strong></p><p><strong>linux&#x2F;ioctrl.h   定义ioctrl命令相关符号</strong></p><p><strong>asm&#x2F;ioctrl.h   定义一些构造命令编号的宏</strong></p><p><strong>linux&#x2F;kd.h    定义用来定义ioctrl命令的16位标量值（旧风格）</strong></p><p><strong>asm&#x2F;uaccsee.h  定义access_ok函数（验证地址）</strong></p><p><strong>linux&#x2F;capability.h 定义linux的全部权能操作</strong></p><p><strong>sys&#x2F;sched.h    定义权能检查函数：capable（1C）</strong></p><p><strong>linux&#x2F;wait.h   定义等待序列相关</strong></p><p><strong>linux&#x2F;fcntl.h   定义I&#x2F;O操作相关标志</strong></p><p><strong>linux&#x2F;poll.h   定义poll和lelect相关</strong></p><p><strong>linux&#x2F;param.h   定义与体系结构有关的常熟：HZ</strong></p><p><strong>linux&#x2F;jiffies.h   定义jiffies计数器，只需包含&lt;sys&#x2F;sched.h&gt;，会自动放入jiffies.h</strong></p><p><strong>linux&#x2F;timex.h  定义定时相关</strong></p><p><strong>asm&#x2F;msr.h   X86专用头文件</strong></p><p><strong>linux&#x2F;time&#x2F;h  定义一些时间操作函数：do_gtetimeofday</strong></p><p><strong>linux&#x2F;workqueue.h 定义struct workqueue_struct 结构体</strong></p><p><strong>linux&#x2F;slab.h   定义*kmalloc(2C )函数</strong></p><p><strong>linux&#x2F;gfp.h    定义分配内存参数标志</strong></p><p><strong>asm&#x2F;pgtable.h  定义vmalloc（1C）可获得地址范围的连个宏</strong></p><p><strong>linux&#x2F;percpu_counter.h 定义封装使用per_CPU变量来简历的简单整数计数器</strong></p><p><strong>linux&#x2F;vmalloc.h    定义函数vmalloc（1C）</strong></p><p><strong>asm&#x2F;io.h      定义I&#x2F;O mapping等函数</strong></p><p><strong>linux&#x2F;ioport.h    定义I&#x2F;O 内存分配区域的接口</strong></p><p><strong>linux&#x2F;sched.h   定义中断函数接口</strong></p><p><strong>linux&#x2F;interrupt.h  定义中断相关</strong></p><p><strong>asm&#x2F;page.h    定义页大小</strong></p><p><strong>asm&#x2F;byteorder.h  定义字节序</strong></p><p><strong>linux&#x2F;err.h    定义指针和错误值</strong></p><p><strong>linux&#x2F;list.h     定义链表相关</strong></p><p><strong>linux&#x2F;pci.h     定义数据传输访问配置空间函数</strong></p><p><strong>#include &lt;linux&#x2F;of_address.h&gt;    of_iomap()</strong></p><p><strong>Led字符设备驱动用到的</strong></p><p><strong>#include &lt;linux&#x2F;module.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;kernel.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;fs.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;init.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;uaccess.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;io.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;cdev.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;device.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;of.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;of_address.h&gt;</strong></p><p><strong>#include &lt;linux&#x2F;slab.h&gt;</strong></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>驱动开发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Linux</tag>
      
      <tag>驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10| linux下烧录至SD卡启动</title>
    <link href="/2020/09/09/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/10.linux%E4%B8%8B%E7%83%A7%E5%BD%95%E8%87%B3SD%E5%8D%A1%E5%90%AF%E5%8A%A8/"/>
    <url>/2020/09/09/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/10.linux%E4%B8%8B%E7%83%A7%E5%BD%95%E8%87%B3SD%E5%8D%A1%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="linux下烧录uboot、linux-kernel、dtb、rootfs到SD卡启动"><a href="#linux下烧录uboot、linux-kernel、dtb、rootfs到SD卡启动" class="headerlink" title="linux下烧录uboot、linux-kernel、dtb、rootfs到SD卡启动"></a>linux下烧录uboot、linux-kernel、dtb、rootfs到SD卡启动</h1><p><strong>[假设识别u盘为设备&#x2F;dev&#x2F;sdb]</strong></p><p>@author:firestaradmin 2020年4月28日19:15:33</p><h2 id="0-清除SD卡前1024KB的数据-dd命令（可选步骤）"><a href="#0-清除SD卡前1024KB的数据-dd命令（可选步骤）" class="headerlink" title="0.清除SD卡前1024KB的数据 dd命令（可选步骤）"></a>0.清除SD卡前1024KB的数据 dd命令（可选步骤）</h2><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/dev/sdb bs=1024 count=1024</code></pre></div><ul><li><p><strong>if&#x3D;文件名</strong>：输入文件名，默认为标准输入。即指定源文件。</p><p><strong>&#x2F;dev&#x2F;zero</strong>，是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0。 </p></li><li><p><strong>of&#x3D;文件名</strong>：输出文件名，默认为标准输出。即指定目的文件。 </p></li><li><p><strong>ibs&#x3D;bytes</strong>：一次读入bytes个字节，即指定一个块大小为bytes个字节。</p><p><strong>obs&#x3D;bytes</strong>：一次输出bytes个字节，即指定一个块大小为bytes个字节。 </p><p><strong>bs&#x3D;bytes</strong>：同时设置读入&#x2F;输出的块大小为bytes个字节。</p></li><li><p><strong>count&#x3D;blocks</strong>：仅拷贝blocks个块，块大小等于ibs指定的字节数。</p></li></ul><h2 id="1-插入SD卡并分区-fdisk命令"><a href="#1-插入SD卡并分区-fdisk命令" class="headerlink" title="1. 插入SD卡并分区 fdisk命令"></a>1. 插入SD卡并分区 fdisk命令</h2><p>Linux下使用fdisk命令进行分区：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">fdisk /dev/sdb</code></pre></div><p>需要建立两个分区：  </p><ul><li><p>p1为fat32 用于存放linux-kernel和dtb文件（一般64MB）</p></li><li><p>p2为ext4 用于存放根文件系统（一般剩余空间都给它）</p></li></ul><p>（注意，第一个分区起始扇区需要为uboot保留一定空间 所以在扇区大小为512B时，一般第一个起始扇区地址为8192即512*8192B&#x3D;4MB保留给uboot）</p><h2 id="2-使用mkfs命令进行分区的格式化"><a href="#2-使用mkfs命令进行分区的格式化" class="headerlink" title="2. 使用mkfs命令进行分区的格式化"></a>2. 使用mkfs命令进行分区的格式化</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">mkfs.vfat -F 32 -n <span class="hljs-string">&quot;boot&quot;</span> /dev/sdb1</code></pre></div><p>将sd卡分区1格式化为FAT32</p><p><strong>-n</strong> “boot” 设置卷标为boot</p><div class="hljs code-wrapper"><pre><code class="hljs bash">mkfs.ext4 -F -L <span class="hljs-string">&quot;rootfs&quot;</span> /dev/sdb2</code></pre></div><p>将sd卡分区2格式化为ext4</p><p><strong>-L</strong> “rootfs” 设置卷标为rootfs</p><p>格式化前需要先取消挂载，使用umount命令</p><div class="hljs code-wrapper"><pre><code class="hljs bash">umount /dev/sdb1</code></pre></div><h2 id="3-使用dd命令烧写uboot-imx到sd卡起始位置"><a href="#3-使用dd命令烧写uboot-imx到sd卡起始位置" class="headerlink" title="3. 使用dd命令烧写uboot.imx到sd卡起始位置"></a>3. 使用dd命令烧写uboot.imx到sd卡起始位置</h2><p>在uboot目录下打开终端 </p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=uboot.imx of=/dev/sdb bs=1024 seek=1 conv=fsync</code></pre></div><ul><li><p>if&#x3D;文件名：输入文件名，默认为标准输入。即指定源文件。 </p></li><li><p>of&#x3D;文件名：输出文件名，默认为标准输出。即指定目的文件。 </p></li><li><p>ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</p><p>obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</p><p>bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</p></li><li><p>seek&#x3D;blocks：从输出文件开头跳过blocks个块后再开始复制。</p></li><li><p>conv&#x3D;&lt;关键字&gt;，关键字可以有以下11种：</p><ul><li><p>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</p><p>……</p></li></ul></li></ul><h2 id="4-将zImage和dtb设备树文件拷贝到第一个分区"><a href="#4-将zImage和dtb设备树文件拷贝到第一个分区" class="headerlink" title="4. 将zImage和dtb设备树文件拷贝到第一个分区"></a>4. 将zImage和dtb设备树文件拷贝到第一个分区</h2><p>将p1挂载到某个地方</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /media/bootmount /dev/sdb1 /media/boot/<span class="hljs-built_in">cp</span> zImage *.dtb /media/boot/</code></pre></div><h2 id="5-拷贝根文件系统至第二个分区"><a href="#5-拷贝根文件系统至第二个分区" class="headerlink" title="5. 拷贝根文件系统至第二个分区"></a><strong>5.</strong> <strong>拷贝根文件系统至第二个分区</strong></h2><h3 id="1-压缩根文件系统"><a href="#1-压缩根文件系统" class="headerlink" title="1.压缩根文件系统"></a>1.压缩根文件系统</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> rootfs/tar -vcjf rootfs.tar.bz2 *</code></pre></div><h3 id="2-挂载设备并解压"><a href="#2-挂载设备并解压" class="headerlink" title="2.挂载设备并解压"></a>2.挂载设备并解压</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /media/rootfsmount /dev/sdb2 /media/rootfs/tar jxfm \**rootfs.tar.bz2\** -C /media/rootfs/</code></pre></div><h2 id="6-同步和卸载u盘"><a href="#6-同步和卸载u盘" class="headerlink" title="6.同步和卸载u盘"></a>6.同步和卸载u盘</h2><p>输入<code>sync</code>同步数据，然后<code>umount /run/media/sda1/</code>去卸载一个目录，</p><p>然后用<code>df</code> 指令查看 sda1 这个目录已经不存在了，表明已经卸载了，U 盘可以正常拔出了！</p><h2 id="7-插入开发板，并修改bootcmd和bootargs启动系统进行测试"><a href="#7-插入开发板，并修改bootcmd和bootargs启动系统进行测试" class="headerlink" title="7. 插入开发板，并修改bootcmd和bootargs启动系统进行测试"></a>7. 插入开发板，并修改bootcmd和bootargs启动系统进行测试</h2><h1 id="命令附录："><a href="#命令附录：" class="headerlink" title="命令附录："></a>命令附录：</h1><h2 id="fdisk命令："><a href="#fdisk命令：" class="headerlink" title="fdisk命令："></a>fdisk命令：</h2><p>磁盘操作命令</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><div class="hljs code-wrapper"><pre><code class="hljs css">fdisk <span class="hljs-selector-attr">[必要参数]</span><span class="hljs-selector-attr">[选择参数]</span></code></pre></div><h3 id="必要参数："><a href="#必要参数：" class="headerlink" title="必要参数："></a>必要参数：</h3><ul><li><p>-l 列出素所有分区表</p></li><li><p>-u 与”-l”搭配使用，显示分区数目</p></li></ul><h3 id="选择参数："><a href="#选择参数：" class="headerlink" title="选择参数："></a>选择参数：</h3><ul><li><p>-s&lt;分区编号&gt; 指定分区</p></li><li><p>-v 版本信息</p></li></ul><h3 id="菜单操作说明"><a href="#菜单操作说明" class="headerlink" title="菜单操作说明"></a>菜单操作说明</h3><ul><li><p>m ：显示菜单和帮助信息</p></li><li><p>a ：活动分区标记&#x2F;引导分区</p></li><li><p>d ：删除分区</p></li><li><p>l ：显示分区类型</p></li><li><p>n ：新建分区</p></li><li><p>p ：显示分区信息</p></li><li><p>q ：退出不保存</p></li><li><p>t ：设置分区号</p></li><li><p>v ：进行分区检查</p></li><li><p>w ：保存修改</p></li><li><p>x ：扩展应用，高级功能</p></li></ul><h2 id="mkfs命令："><a href="#mkfs命令：" class="headerlink" title="mkfs命令："></a>mkfs命令：</h2><p>Linux mkfs命令用于在特定的分区上建立 linux 文件系统</p><p>使用方式 : </p><div class="hljs code-wrapper"><pre><code class="hljs bash">mkfs [-V] [-t fstype] [fs-options] filesys [blocks]</code></pre></div><h3 id="参数-："><a href="#参数-：" class="headerlink" title="参数 ："></a>参数 ：</h3><ul><li><p>device ： 预备检查的硬盘分区，例如：&#x2F;dev&#x2F;sda1</p></li><li><p>-V : 详细显示模式</p></li><li><p>-t : 给定档案系统的型式，Linux 的预设值为 ext2</p></li><li><p>-c : 在制做档案系统前，检查该partition 是否有坏轨</p></li><li><p>-l bad_blocks_file : 将有坏轨的block资料加到 bad_blocks_file 里面</p></li><li><p>block : 给定 block 的大小</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li><p>在 &#x2F;dev&#x2F;hda5 上建一个 msdos 的档案系统，同时检查是否有坏轨存在，并且将过程详细列出来 :</p><div class="hljs code-wrapper"><pre><code class="hljs bash">mkfs -V -t msdos -c /dev/hda5</code></pre></div></li><li><p>将sda6分区格式化为ext3格式</p><div class="hljs code-wrapper"><pre><code class="hljs bash">mfks -t ext3 /dev/sda6</code></pre></div><p><strong>注意：这里的文件系统是要指定的，比如 ext3 ；reiserfs ；ext2 ；fat32 ；msdos 等。</strong></p></li></ul><h2 id="dd命令："><a href="#dd命令：" class="headerlink" title="dd命令："></a>dd命令：</h2><p>Linux dd命令用于读取、转换并输出数据。</p><p>dd可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p><p>如我们上面使用的命令</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/dev/sdb bs=1024 count=1024<span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=uboot.imx of=/dev/sdb bs=1024 seek=1 conv=fsync</code></pre></div><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h3><p>  if&#x3D;文件名：输入文件名，默认为标准输入。即指定源文件。</p><p>  of&#x3D;文件名：输出文件名，默认为标准输出。即指定目的文件。</p><p>  ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</p><p>  obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</p><p>  bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</p><p>  cbs&#x3D;bytes：一次转换bytes个字节，即指定转换缓冲区大小。</p><p>  skip&#x3D;blocks：从输入文件开头跳过blocks个块后再开始复制。</p><p>  seek&#x3D;blocks：从输出文件开头跳过blocks个块后再开始复制。</p><p>  count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</p><p>  conv&#x3D;&lt;关键字&gt;，关键字可以有以下11种：</p><p>​    conversion：用指定的参数转换文件。</p><p>​    ascii：转换ebcdic为ascii</p><p>​    ebcdic：转换ascii为ebcdic</p><p>​    ibm：转换ascii为alternate ebcdic</p><p>​    block：把每一行转换为长度为cbs，不足部分用空格填充</p><p>​    unblock：使每一行的长度都为cbs，不足部分用空格填充</p><p>​    lcase：把大写字符转换为小写字符</p><p>​    ucase：把小写字符转换为大写字符</p><p>​    swab：交换输入的每对字节</p><p>​    noerror：出错时不停止</p><p>​    notrunc：不截短输出文件</p><p>​    sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</p><p>​    –help：显示帮助信息</p><p>​    –version：显示版本信息</p><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令:"></a>tar命令:</h2><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><p>tar [必要参数] [选择参数] [文件] </p><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的 </p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p>必要参数有如下：</p><p>-A 新增压缩文件到已存在的压缩</p><p>-B 设置区块大小</p><p>-c 建立新的压缩文件</p><p>-d 记录文件的差别</p><p>-r 添加文件到已经压缩的文件</p><p>-u 添加改变了和现有的文件到已经存在的压缩文件</p><p>-x 从压缩的文件中提取文件</p><p>-t 显示压缩文件的内容</p><p>-z 支持gzip解压文件</p><p>-j 支持bzip2解压文件</p><p>-Z 支持compress解压文件</p><p>-v 显示操作过程</p><p>-l 文件系统边界设置</p><p>-k 保留原有文件不覆盖</p><p>-m 保留文件不被覆盖</p><p>-W 确认压缩文件的正确性</p><p>可选参数如下：</p><p>-b 设置区块数目</p><p>-C 切换到指定目录</p><p>-f 指定压缩文件</p><p>–help 显示帮助信息</p><p>–version 显示版本信息</p><h3 id="4．常见解压-x2F-压缩命令"><a href="#4．常见解压-x2F-压缩命令" class="headerlink" title="4．常见解压&#x2F;压缩命令"></a>4．常见解压&#x2F;压缩命令</h3><ul><li><p>tar </p><p>解包：tar xvf FileName.tar</p><p>打包：tar cvf FileName.tar DirName</p><p><strong>（注：tar是打包，不是压缩！）</strong></p></li><li><p>.gz</p><p>解压1：gunzip FileName.gz</p><p>解压2：gzip -d FileName.gz</p><p>压缩：gzip FileName</p></li><li><p>.tar.gz 和 .tgz</p><p>解压：tar zxvf FileName.tar.gz</p><p>压缩：tar zcvf FileName.tar.gz DirName</p></li><li><p>.bz2</p><p>解压1：bzip2 -d FileName.bz2</p><p>解压2：bunzip2 FileName.bz2</p><p>压缩： bzip2 -z FileName</p></li><li><p>.tar.bz2</p><p>解压：tar jxvf FileName.tar.bz2</p><p>压缩：tar jcvf FileName.tar.bz2 DirName</p></li><li><p>.bz</p><p>解压1：bzip2 -d FileName.bz</p><p>解压2：bunzip2 FileName.bz</p><p>压缩：未知</p></li><li><p>.tar.bz</p><p>解压：tar jxvf FileName.tar.bz</p><p>压缩：未知</p></li><li><p>.Z</p><p>解压：uncompress FileName.Z</p><p>压缩：compress FileName</p></li><li><p>.tar.Z</p><p>解压：tar Zxvf FileName.tar.Z</p><p>压缩：tar Zcvf FileName.tar.Z DirName</p></li><li><p>.zip</p><p>解压：unzip FileName.zip</p><p>压缩：zip FileName.zip DirName</p></li><li><p>.rar</p><p>解压：rar x FileName.rar</p><p>压缩：rar a FileName.rar DirName</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9| BusyBox根文件系统rootfs构建</title>
    <link href="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/"/>
    <url>/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="根文件系统rootfs构建"><a href="#根文件系统rootfs构建" class="headerlink" title="根文件系统rootfs构建"></a>根文件系统rootfs构建</h1><p>Linux“三巨头”除了uboot、linux-kernel，就剩最后一个 rootfs(根文件系统)了</p><p>这里我们就来学习一下根文件系统的组成以及如何构建根文件系统，这是 Linux 移植的最后一步。根文件系统构建好以后就意味着我们已经拥有了一个完整的、可以运行的最小系统。</p><p>以后我们就在这个最小系统上编写、测试 Linux 驱动，移植一些第三方组件，逐步的完善这个最小系统。最终得到一个功能完善、驱动齐全、相对完善的操作系统。</p><h2 id="一、根文件系统简介"><a href="#一、根文件系统简介" class="headerlink" title="一、根文件系统简介"></a>一、根文件系统简介</h2><p>根文件系统一般也叫做 <strong>rootfs</strong>，那么什么叫根文件系统？看到“文件系统”这四个字，很多人，包括我第一反应就是 FATFS、FAT、EXT4、YAFFS 和 NTFS 等这样的文件系统。</p><p><strong>在这里，文件系统并不是 FATFS 这样的文件系统代码</strong>，EXT4 这样的文件系统代码属于 Linux 内核的一部分。</p><p>Linux 中的根文件系统更像是一个文件夹或者叫做目录(在我看来就是一个文件夹，只不过是特殊的文件夹)，在这个目录里面会有很多的子目录。根目录下和子目录中会有很多的文件，这些文件是 <strong>Linux 运行所必须</strong>的，比如<strong>库</strong>、<strong>常用的软件和命令</strong>、<strong>设备文件</strong>、<strong>配置文件</strong>等等。以后我们说到文件系统，如果不特别指明，统一表示根文件系统。</p><p>对于根文件系统专业的解释，百度百科上是这么说的：</p><blockquote><p>根文件系统首先是内核启动时所 mount(挂载)的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。</p></blockquote><p>百度百科上说内核代码镜像文件保存在根文件系统中，但是我们嵌入式 Linux 并没有将内核代码镜像保存在根文件系统中，而是保存到了其他地方。比如 NAND Flash 的指定存储地址、EMMC 专用分区中。根文件系统是 Linux 内核启动以后挂载(mount)的第一个文件系统，然后从根文件系统中读取初始化脚本，比如 rcS，inittab 等。</p><p>根文件系统和 Linux 内核是分开的，单独的 Linux 内核是没法正常工作的，必须要搭配根文件系统。如果不提供根文件系统，Linux 内核在启动的时候就会提示内核崩溃(Kernel panic)的提示。</p><p>根文件系统的这个“根”字就说明了这个文件系统的重要性，它是其他文件系统的根，没有这个“根”，其他的文件系统或者软件就别想工作。比如我们常用的 ls、mv、ifconfig 等命令其实就是一个个小软件，只是这些软件没有图形界面，而且需要输入命令来运行。这些小软件就保存在根文件系统中，这些小软件是怎么来的呢？这个就是我们本章教程的目的，教大家来构建自己的根文件系统，这个根文件系统是满足 Linux 运行的最小根文件系统，后续我们可以根据自己的实际工作需求不断的去填充这个最小根文件系统，最终使其成为一个相对完善的根文件系统。</p><p>在构建根文件系统之前，我们先来看一下根文件系统里面大概都有些什么内容，以 Ubuntu为例，根文件系统的目录名字为‘&#x2F;’，没看错就是一个斜杠，所以输入如下命令就可以进入根目录中：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> / <span class="hljs-string">//</span>进入根目录</code></pre></div><p>进入根目录以后输入“ls”命令查看根目录下的内容都有哪些，结果如图所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819184433558.png" alt="image-20200819184433558"></p><p>图中根目录下子目录和文件不少，但是这些都是 Ubuntu 所需要的，其中有很多子目录和文件我们嵌入式 Linux 是用不到的，所以这里就讲解一些常用的子目录：</p><ul><li><p><strong>1 、&#x2F;bin  目录</strong></p><p>看到“bin”大家应该能想到 bin 文件，bin 文件就是可执行文件。所以此目录下存放着系统需要的可执行文件，一般都是一些命令，比如 ls、mv 等命令。此目录下的命令所有的客户都可以使用。</p></li><li><p><strong>2 、&#x2F;dev  目录</strong></p><p>dev 是 device 的缩写，所以此目录下的文件都是和设备有关的，此目录下的文件都是设备文件。在 Linux 下一切皆文件，即使是硬件设备，也是以文件的形式存在的，比如 <strong>&#x2F;dev&#x2F;ttymxc0</strong>(I.MX6ULL 根目录会有此文件)就表示 I.MX6ULL 的串口 0，我们要想通过串口 0发送或者接收数据就要操作文件&#x2F;dev&#x2F;ttymxc0，通过对文件&#x2F;dev&#x2F;ttymxc0 的读写操作来实现串口0 的数据收发。</p></li><li><p><strong>3 、&#x2F;etc  目录</strong></p><p>此目录下存放着各种配置文件，大家可以进入 Ubuntu 的 etc 目录看一下，里面的配置文件非常多！但是在嵌入式 Linux 下此目录会很简洁。</p></li><li><p><strong>4 、&#x2F;lib  目录</strong></p><p>lib 是 library 的简称，也就是库的意思，因此此目录下存放着 Linux 所必须的库文件。这些库文件是共享库，命令和用户编写的应用程序要使用这些库文件。</p></li><li><p><strong>5 、&#x2F;mnt  目录</strong></p><p>临时挂载目录，一般是空目录，可以在此目录下创建空的子目录，比如&#x2F;mnt&#x2F;sd、&#x2F;mnt&#x2F;usb，这样就可以将 SD 卡或者 U 盘挂载到&#x2F;mnt&#x2F;sd 或者&#x2F;mnt&#x2F;usb 目录中。</p></li><li><p><strong>6 、&#x2F;proc  目录</strong></p><p>此目录一般是空的，当 Linux 系统启动以后会将此目录作为 proc 文件系统的挂载点，proc是个虚拟文件系统，没有实际的存储设备。proc 里面的文件都是临时存在的，一般用来存储系统运行信息文件。</p></li><li><p><strong>7 、&#x2F;usr  目录</strong></p><p>要注意，usr 不是 user 的缩写，而是 Unix Software Resource 的缩写，也就是 Unix 操作系统软件资源目录。这里有个小知识点，那就是 Linux 一般被称为类 Unix 操作系统，苹果的 MacOS也是类 Unix 操作系统。关于 Linux 和 Unix 操作系统的渊源大家可以直接在网上找 Linux 的发展历史来看。既然是软件资源目录，因此&#x2F;usr 目录下也存放着很多软件，一般系统安装完成以后此目录占用的空间最多。</p></li><li><p><strong>8 、&#x2F;var  目录</strong></p><p>此目录存放一些可以改变的数据。</p></li><li><p><strong>9 、&#x2F;sbin  目录</strong></p><p>此目录页用户存放一些可执行文件，但是此目录下的文件或者说命令只有管理员才能使用，主要用户系统管理。</p></li><li><p><strong>10 、&#x2F;sys  目录</strong></p><p>系统启动以后此目录作为 sysfs 文件系统的挂载点，sysfs 是一个类似于 proc 文件系统的特殊文件系统，sysfs 也是基于 ram 的文件系统，也就是说它也没有实际的存储设备。此目录是系统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息。</p></li><li><p><strong>11 、&#x2F;opt</strong></p><p>可选的文件、软件存放区，由用户选择将哪些文件或软件放到此目录中。</p></li></ul><p>关于 Linux 的根目录就介绍到这里，接下来的构建根文件系统就是研究如何创建上面这些子目<br>录以及子目录中的文件。</p><h2 id="二、BusyBox-构建根文件系统"><a href="#二、BusyBox-构建根文件系统" class="headerlink" title="二、BusyBox  构建根文件系统"></a>二、BusyBox  构建根文件系统</h2><h3 id="1、BusyBox-简介"><a href="#1、BusyBox-简介" class="headerlink" title="1、BusyBox  简介"></a>1、BusyBox  简介</h3><p>上面说了，根文件系统里面就是一堆的可执行文件和其他文件组成的？难道我们得一个一个的从网上去下载这些文件？显然这是不现实的！那么有没有人或者组织专门干这个事呢？他们负责“收集”这些文件，然后将其打包，像我们这样的开发者可以直接拿来用。</p><p>答案是有的，它就叫做 <strong>BusyBox</strong>！其名字分为“Busy”和“Box”，也就是忙碌的盒子。盒子是用来放东西的，忙碌的是因为它要提供根文件系统所需的文件，所以忙碌。BusyBox 是一个集成了大量的 Linux 命令和工具的软件，像 ls、mv、ifconfig 等命令 BusyBox 都会提供。BusyBox 就是一个大的工具箱，这个工具箱里面集成了 Linux 的许多工具和命令。一般下载 BusyBox 的源码，然后配置 BusyBox，选择自己想要的功能，最后编译即可。</p><p><strong>BusyBox</strong> 可以在其官网下载到，官网地址为：<a href="https://busybox.net/%EF%BC%8C%E5%AE%98%E7%BD%91%E6%AF%94%E8%BE%83%E7%AE%80%E9%99%8B%EF%BC%8C%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">https://busybox.net/，官网比较简陋，如图所示：</a></p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819185354041.png" alt="image-20200819185354041"></p><p>在官网左侧的“Get BusyBox”栏有一行“Download Source”，点击“Download Source”即可打开 BusyBox 的下载页，如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819185410941.png" alt="image-20200819185410941"></p><p>BusyBox 准备好以后就可以构建根文件系统了。</p><h3 id="2、编译-BusyBox-构建根文件系统"><a href="#2、编译-BusyBox-构建根文件系统" class="headerlink" title="2、编译 BusyBox  构建根文件系统"></a>2、编译 BusyBox  构建根文件系统</h3><p>一般我们在 Linux 驱动开发的时候都是通过 nfs 挂载根文件系统的，当产品最终上市开卖的时候才会将根文件系统烧写到 EMMC 或者 NAND 中。</p><p>所以要根据之前的教程，设置的 nfs 服务器目录，我们在nfs目录中创建一个名为 rootfs 的子目录(名字大家可以随意起，为了方便就用了 rootfs)，比如我的电脑中“&#x2F;home&#x2F;firestaradmin&#x2F;linux&#x2F;nfs”就是我设置的 NFS 服务器目录，使用如下命令创建名为rootfs 的子目录：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> rootfs</code></pre></div><p>创建好的 rootfs 子目录就用来存放我们的根文件系统了。将 busybox-1.29.0.tar.bz2 发送到 Ubuntu 中，存放位置大家随便选择。然后使用如下命令将其解压：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">tar -vxjf busybox-1.29.0.tar.bz2</code></pre></div><p>解压完成以后进入到 busybox-1.29.0 目录中，此目录中的文件和文件夹如图所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819185909349.png" alt="image-20200819185909349"></p><h4 id="1-、修改-Makefile-，添加编译器"><a href="#1-、修改-Makefile-，添加编译器" class="headerlink" title="1 、修改 Makefile ，添加编译器"></a>1 、修改 Makefile ，添加编译器</h4><p>同 Uboot 和 Linux 移植一样，打开 busybox 的顶层 Makefile，添加 ARCH 和CROSS_COMPILE的值，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs"></code></pre></div><h4 id="2-、busybox-中文字符支持"><a href="#2-、busybox-中文字符支持" class="headerlink" title="2 、busybox  中文字符支持"></a>2 、busybox  中文字符支持</h4><p>如果默认直接编译 busybox 的话，在使用 一些串口终端的时候中文字符是显示不正常的，中文字符会显示为“?”，比如你的中文目录，中文文件都显示为“?”。不知道从哪个版本开始busybox中的 shell 命令对中文输入即显示做了限制，即使内核支持中文但在 shell 下也依然无法正确显示。所以我们需要修改 busybox 源码，取消 busybox 对中文显示的限制，打开文件 busybox-1.29.0&#x2F;libbb&#x2F;printable_string.c，找到函数 printable_string，函数内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* FAST_FUNC <span class="hljs-title function_">printable_string</span><span class="hljs-params">(<span class="hljs-type">uni_stat_t</span> *stats, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span>&#123;<span class="hljs-type">char</span> *dst;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s;s = str;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *s;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<span class="hljs-comment">/* 99+% of inputs do not need conversion */</span><span class="hljs-keyword">if</span> (stats) &#123;......&#125;<span class="hljs-keyword">return</span> str;&#125;<span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">0x7f</span>)<span class="hljs-keyword">break</span>;s++;&#125;<span class="hljs-meta">#<span class="hljs-keyword">if</span> ENABLE_UNICODE_SUPPORT</span>dst = unicode_conv_to_printable(stats, str);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>&#123;<span class="hljs-type">char</span> *d = dst = xstrdup(str);<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> || c &gt;= <span class="hljs-number">0x7f</span>)*d = <span class="hljs-string">&#x27;?&#x27;</span>;d++;&#125;......&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-keyword">return</span> auto_string(dst);&#125;</code></pre></div><p>这里第一部分当字符大于 0X7F 以后就跳出去了。</p><p>第二部分，如果支持 UNICODE 码的话，当字符大于 0X7F 就直接输出‘?’。</p><p>所以我们需要对这两部分代码进行修改，修改以后如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* FAST_FUNC <span class="hljs-title function_">printable_string</span><span class="hljs-params">(<span class="hljs-type">uni_stat_t</span> *stats, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span>&#123;<span class="hljs-type">char</span> *dst;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s;s = str;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *s;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<span class="hljs-comment">/* 99+% of inputs do not need conversion */</span>......<span class="hljs-keyword">return</span> str;&#125;<span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">/* 注释掉以下代码以支持中文 */</span><span class="hljs-comment">/*</span><span class="hljs-comment">if (c &gt;= 0x7f)</span><span class="hljs-comment">break; */</span>s++;&#125;<span class="hljs-meta">#<span class="hljs-keyword">if</span> ENABLE_UNICODE_SUPPORT</span>dst = unicode_conv_to_printable(stats, str);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>&#123;<span class="hljs-type">char</span> *d = dst = xstrdup(str);<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">/* 修改以下代码，以支持中文 */</span><span class="hljs-comment">/* 原代码为：</span><span class="hljs-comment">if (c &lt; &#x27; &#x27; || c &gt;= 0x7f)</span><span class="hljs-comment">*d = &#x27;?&#x27;; */</span><span class="hljs-keyword">if</span>(c &lt; <span class="hljs-string">&#x27; &#x27;</span>)*d = <span class="hljs-string">&#x27;?&#x27;</span>;d++;&#125;......<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-keyword">return</span> auto_string(dst);&#125;</code></pre></div><p>接着打开文件 <strong>busybox-1.29.0&#x2F;libbb&#x2F;unicode.c</strong>，找到如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span>* FAST_FUNC <span class="hljs-title function_">unicode_conv_to_printable2</span><span class="hljs-params">(<span class="hljs-type">uni_stat_t</span> *stats, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">unsigned</span> width, <span class="hljs-type">int</span> flags)</span>&#123;<span class="hljs-type">char</span> *dst;<span class="hljs-type">unsigned</span> dst_len;<span class="hljs-type">unsigned</span> uni_count;<span class="hljs-type">unsigned</span> uni_width;<span class="hljs-keyword">if</span> (unicode_status != UNICODE_ON) &#123;<span class="hljs-type">char</span> *d;<span class="hljs-keyword">if</span> (flags &amp; UNI_FLAG_PAD) &#123;d = dst = xmalloc(width + <span class="hljs-number">1</span>);......*d++ = (c &gt;= <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; c &lt; <span class="hljs-number">0x7f</span>) ? c : <span class="hljs-string">&#x27;?&#x27;</span>;src++;&#125;*d = <span class="hljs-string">&#x27;\0&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;d = dst = xstrndup(src, width);<span class="hljs-keyword">while</span> (*d) &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;<span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> || c &gt;= <span class="hljs-number">0x7f</span>)*d = <span class="hljs-string">&#x27;?&#x27;</span>;d++;&#125;&#125;......<span class="hljs-keyword">return</span> dst;&#125;......<span class="hljs-keyword">return</span> dst;&#125;</code></pre></div><p>修改为：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span>* FAST_FUNC <span class="hljs-title function_">unicode_conv_to_printable2</span><span class="hljs-params">(<span class="hljs-type">uni_stat_t</span> *stats, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">unsigned</span> width, <span class="hljs-type">int</span> flags)</span>&#123;<span class="hljs-type">char</span> *dst;<span class="hljs-type">unsigned</span> dst_len;<span class="hljs-type">unsigned</span> uni_count;<span class="hljs-type">unsigned</span> uni_width;<span class="hljs-keyword">if</span> (unicode_status != UNICODE_ON) &#123;<span class="hljs-type">char</span> *d;<span class="hljs-keyword">if</span> (flags &amp; UNI_FLAG_PAD) &#123;d = dst = xmalloc(width + <span class="hljs-number">1</span>);......    <span class="hljs-comment">/* 修改下面一行代码，以支持中文 */</span>    <span class="hljs-comment">/* *d++ = (c &gt;= &#x27; &#x27; &amp;&amp; c &lt; 0x7f) ? c : &#x27;?&#x27;; */</span>*d++ = (c &gt;= <span class="hljs-string">&#x27; &#x27;</span>) ? c : <span class="hljs-string">&#x27;?&#x27;</span>;src++;&#125;*d = <span class="hljs-string">&#x27;\0&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;d = dst = xstrndup(src, width);<span class="hljs-keyword">while</span> (*d) &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;                <span class="hljs-comment">/* 修改下面一行代码，以支持中文 */</span><span class="hljs-comment">/* if (c &lt; &#x27; &#x27; || c &gt;= 0x7f) */</span>                <span class="hljs-keyword">if</span>(c &lt; <span class="hljs-string">&#x27; &#x27;</span>)*d = <span class="hljs-string">&#x27;?&#x27;</span>;d++;&#125;&#125;......<span class="hljs-keyword">return</span> dst;&#125;......<span class="hljs-keyword">return</span> dst;&#125;</code></pre></div><p>修改以后的代码，同样主要是禁止字符大于 0X7F 的时候设置为‘?’。busybox 中文字符支持跟代码修改有关的就改好了，最后还需要配置 busybox来使能 unicode 码，这个稍后我们配置 busybox 的时候在设置。</p><h4 id="3、配置BusyBox"><a href="#3、配置BusyBox" class="headerlink" title="3、配置BusyBox"></a>3、配置BusyBox</h4><p>根我们编译 Uboot、Linux kernel 一样，我们要先对 <strong>busybox</strong> 进行默认的配置，有以下几种配置选项：</p><ul><li>①、<strong>defconfig</strong>，缺省配置，也就是默认配置选项。</li><li>②、<strong>allyesconfig</strong>，全选配置，也就是选中 busybox 的所有功能。</li><li>③、<strong>allnoconfig</strong>，最小配置。</li></ul><p>我们一般使用默认配置即可，因此使用如下命令先使用默认配置来配置一下 busybox：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make defconfig</span></code></pre></div><p><strong>busybox</strong> 也支持图形化配置，通过图形化配置我们可以进一步选择自己想要的功能，输入如下命令打开图形化配置界面：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span></code></pre></div><p>打开以后如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819191938958.png" alt="image-20200819191938958"></p><p>配置路径如下：</p><div class="hljs code-wrapper"><pre><code class="hljs livescript">Location:-&gt; Settings-&gt; Build <span class="hljs-keyword">static</span> binary (<span class="hljs-literal">no</span> shared libs)</code></pre></div><p>选项“**Build static binary (no shared libs)**”用来决定是静态编译 busybox 还是动态编译，静态编译的话就不需要库文件，但是编译出来的库会很大。动态编译的话要求根文件系统中有库文件，但是编译出来的 busybox 会小很多。</p><p>这里我们不能采用静态编译！因为采用静态编译的话 DNS 会出问题！无法进行域名解析，配置如图所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192134684.png" alt="image-20200819192134684"></p><p>继续配置如下路径配置项：</p><div class="hljs code-wrapper"><pre><code class="hljs clean">Location:-&gt; Settings-&gt; vi-style line editing commands</code></pre></div><p>结果如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192414064.png" alt="image-20200819192414064"></p><p>继续配置如下路径配置项：</p><div class="hljs code-wrapper"><pre><code class="hljs coq">Location:-&gt; Linux <span class="hljs-keyword">Module</span> Utilities-&gt; Simplified modutils</code></pre></div><p>默认会选中“<strong>Simplified modutils</strong>”，这里我们要取消勾选！！结果如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192630679.png" alt="image-20200819192630679"></p><p>继续配置如下路径配置项：</p><div class="hljs code-wrapper"><pre><code class="hljs clean">Location:-&gt; Linux System Utilities-&gt; mdev (<span class="hljs-number">16</span> kb) <span class="hljs-comment">//确保下面的全部选中，默认都是选中的</span></code></pre></div><p>结果如图：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819192900203.png" alt="image-20200819192900203"></p><p>最后就是使能 busybox 的 unicode 编码以支持中文，配置路径如下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">Location:-&gt; Settings-&gt; Support Unicode <span class="hljs-regexp">//</span>选中-&gt; Check <span class="hljs-variable">$LC_ALL</span>, <span class="hljs-variable">$LC_CTYPE</span> and <span class="hljs-variable">$LANG</span> environment variables  <span class="hljs-regexp">//</span>选中</code></pre></div><p>结果如图所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819193104374.png" alt="image-20200819193104374"></p><p>busybox 的配置就到此结束了，大家也可以根据自己的实际需求选择配置其他的选项，不过对于初学者笔者不建议再做其他的修改，可能会出现编译出错的情况发生。</p><h4 id="4、编译BusyBox"><a href="#4、编译BusyBox" class="headerlink" title="4、编译BusyBox"></a>4、编译BusyBox</h4><p>配置好 busybox 以后就可以编译了，我们可以指定编译结果的存放目录，我们肯定要将编译结果存放到前面创建的 rootfs 目录中，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">makemake install CONFIG_PREFIX=/home/firestaradmin/linux/nfs/rootfs</code></pre></div><p>COFIG_PREFIX指定编译结果的存放目录，比如我存放到“&#x2F;home&#x2F;firestaradmin&#x2F;linux&#x2F;nfs&#x2F;rootfs”目录中，等待编译完成。</p><p>编译完成以后如图所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819193855569.png" alt="image-20200819193855569"></p><p>编译完成以后会在 busybox 的所有工具和文件就会被安装到 rootfs 目录中.</p><p>rootfs 目录内容如图所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819193944234.png" alt="image-20200819193944234"></p><p>从图 可以看出，rootfs 目录下有 bin、sbin 和 usr 这三个目录，以及 linuxrc 这个文件。前面说过 Linux 内核 init 进程最后会查找用户空间的 init 程序，找到以后就会运行这个用户空间的 init 程序，从而切换到用户态。</p><p>如果 bootargs 设置 init&#x3D;&#x2F;linuxrc，那么 linuxrc 就是可以作为用户空间的 init 程序，所以用户态空间的 init 程序是 busybox 来生成的。</p><p>busybox 的工作就完成了，但是此时的根文件系统还不能使用，还需要一些其他的文件，我<br>们继续来完善 rootfs。</p><h4 id="5、向根文件系统添加-lib-库"><a href="#5、向根文件系统添加-lib-库" class="headerlink" title="5、向根文件系统添加 lib 库"></a>5、向根文件系统添加 lib 库</h4><h5 id="1-、向-rootfs-的“-x2F-lib-”目录添加库文件"><a href="#1-、向-rootfs-的“-x2F-lib-”目录添加库文件" class="headerlink" title="1 、向 rootfs  的“&#x2F;lib ”目录添加库文件"></a>1 、向 rootfs  的“&#x2F;lib ”目录添加库文件</h5><p>Linux 中的应用程序一般都是需要动态库的，当然你也可以编译成静态的，但是静态的可执行文件会很大。如果编译为动态的话就需要动态库，所以我们需要先根文件系统中添加动态库。在 rootfs 中创建一个名为“lib”的文件夹，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> lib</code></pre></div><p>lib 文件夹创建好了，库文件从哪里来呢？<strong>lib 库文件从交叉编译器中获取</strong>，前面我们搭建交叉编译环境的时候将交叉编译器存放到了“&#x2F;usr&#x2F;local&#x2F;arm&#x2F;”目录中。交叉编译器里面有很多的库文件，这些库文件具体是做什么的我们作为初学者肯定不知道，既然我不知道那就简单粗暴的把所有的库文件都放到我们的根文件系统中。这样做出来的根文件系统肯定很大，但是我们现在是学习阶段，还做不了裁剪。</p><p>进入arm交叉编译器路径对应的目录：</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/arm/g</span>cc-linaro-<span class="hljs-number">4.9</span>.<span class="hljs-number">4</span>-<span class="hljs-number">2017.01</span>-x86_64_arm-linux-gnueabihf<span class="hljs-regexp">/arm-linux-gnueabihf/</span>libc/lib</code></pre></div><p>此目录下有很多的<em>so</em>(<em>是通配符)和.a 文件，这些就是库文件，将此目录下所有的</em>so*和.a文件都拷贝到 rootfs&#x2F;lib 目录中，拷贝命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> *so* *.a /home/firestaradmin/linux/nfs/rootfs/lib/ -d</code></pre></div><p><strong>后面的“-d”表示拷贝符号链接</strong>，这里有个比较特殊的库文件：ld-linux-armhf.so.3，此库文件也是个符号链接，相当于 Windows 下的快捷方式。会链接到库 ld-2.19-2014.08-1-git.so 上，输入命令“ls ld-linux-armhf.so.3 -l”查看此文件详细信息，如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819194904576.png" alt="image-20200819194904576"></p><p>从图  可以看出，<strong>ld-linux-armhf.so.3</strong> 后面有个“-&gt;”，表示其是个软连接文件，链接到文件 <strong>ld-2.19-2014.08-1-git.so</strong>，因为其是一个“快捷方式”，因此大小只有 24B。但是，ld-linux-armhf.so.3 不能作为符号链接，否则的话在根文件系统中执行程序无法执行！所以我们需要 ld-linux-armhf.so.3 完成逆袭，由“快捷方式”变为“本尊”，方法很简单，那就是重新复制 ld-linux-armhf.so.3，只是不复制软链接即可，先将 rootfs&#x2F;lib 中的 ld-linux-armhf.so.3 文件删除掉，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">rm</span> ld-linux-armhf.so.3</code></pre></div><p>然后重新进入到 <strong>&#x2F;usr&#x2F;local&#x2F;arm&#x2F;gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf&#x2F;arm-linux-gnueabihf&#x2F;libc&#x2F;lib</strong> 目录中，重新拷贝 ld-linux-armhf.so.3，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> ld-linux-armhf.so.3 /home/firestaradmin/linux/nfs/rootfs/lib/</code></pre></div><p>拷贝完成以后再到 rootfs&#x2F;lib 目录下查看 ld-linux-armhf.so.3 文件详细信息，如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819195259649.png" alt="image-20200819195259649"></p><p>从图 可以看出，此时 ld-linux-armhf.so.3 已经不是软连接了，而是实实在在的一个库文件，而且文件大小为 724392B。</p><p>继续进入如下目录中：</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/arm/g</span>cc-linaro-<span class="hljs-number">4.9</span>.<span class="hljs-number">4</span>-<span class="hljs-number">2017.01</span>-x86_64_arm-linux-gnueabihf<span class="hljs-regexp">/arm-linux-gnueabihf/</span>lib</code></pre></div><p>此目录下也有很多的的<em>so</em>和.a 库文件，我们将其也拷贝到 rootfs&#x2F;lib 目录中，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">cp *so* *.a <span class="hljs-regexp">/home/</span>zuozhongkai<span class="hljs-regexp">/linux/</span>nfs<span class="hljs-regexp">/rootfs/</span>lib/ -d</code></pre></div><p>rootfs&#x2F;lib 目录的库文件就这些了，完成以后的 rootfs&#x2F;lib 目录如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819195519385.png" alt="image-20200819195519385"></p><h5 id="2-、向-rootfs-的“usr-x2F-lib-”目录添加库文件"><a href="#2-、向-rootfs-的“usr-x2F-lib-”目录添加库文件" class="headerlink" title="2 、向 rootfs  的“usr&#x2F;lib ”目录添加库文件"></a>2 、向 rootfs  的“usr&#x2F;lib ”目录添加库文件</h5><p>在 rootfs 的 usr 目录下创建一个名为 lib 的目录，将如下目录中的库文件拷贝到 <strong>rootfs&#x2F;usr&#x2F;lib</strong>目录下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/arm/g</span>cc-linaro-<span class="hljs-number">4.9</span>.<span class="hljs-number">4</span>-<span class="hljs-number">2017.01</span>-x86_64_arm-linux-gnueabihf<span class="hljs-regexp">/arm-linux-gnueabihf/</span>libc<span class="hljs-regexp">/usr/</span>lib</code></pre></div><p>将此目录下的 so 和.a 库文件都拷贝到 <strong>rootfs&#x2F;usr&#x2F;lib</strong> 目录中，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> *so* *.a /home/firestaradmin/linux/nfs/rootfs/usr/lib/ -d</code></pre></div><p>完成以后的 rootfs&#x2F;usr&#x2F;lib 目录如图所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819195915564.png" alt="image-20200819195915564"></p><p>至此，根文件系统的库文件就全部添加好了，可以使用“du”命令来查看一下 <strong>rootfs&#x2F;lib</strong> 和<strong>rootfs&#x2F;usr&#x2F;lib</strong> 这两个目录的大小，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> rootfs <span class="hljs-built_in">du</span> ./lib ./usr/lib/ -sh</code></pre></div><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819200024505.png" alt="image-20200819200024505"></p><p>可以看出lib和usr&#x2F;lib这两个文件的大小分别为57MB和67MB，加起来就是57+67&#x3D;124MB。非常大！</p><h5 id="3、创建其他文件夹"><a href="#3、创建其他文件夹" class="headerlink" title="3、创建其他文件夹"></a>3、创建其他文件夹</h5><p>在根文件系统中创建其他文件夹，如 dev、proc、mnt、sys、tmp 和 root 等，创建完成以后如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819200209958.png" alt="image-20200819200209958"></p><p>目前来看，这个根文件系统好像已经准备好了，究竟有没有准备好，直接测一下就知道了！</p><h2 id="三、根文件系统初步测试"><a href="#三、根文件系统初步测试" class="headerlink" title="三、根文件系统初步测试"></a>三、根文件系统初步测试</h2><p>接下来我们使用测试一下前面创建好的根文件系统 rootfs，测试方法就是使用 <strong>NFS 挂载</strong>。</p><p>uboot 里面的 bootargs 环境变量会设置“root”的值，所以我们将 root 的值改为 NFS 挂载即可。在 Linux 内核源码里面有相应的文档讲解如何设置，文档为Documentation&#x2F;filesystems&#x2F;nfs&#x2F;nfsroot.txt，格式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs ruby">root=<span class="hljs-regexp">/dev/nfs</span> nfsroot=[&lt;server-ip&gt;<span class="hljs-symbol">:</span>]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;<span class="hljs-symbol">:&lt;server-ip&gt;</span><span class="hljs-symbol">:&lt;gw-ip&gt;</span><span class="hljs-symbol">:&lt;netmask&gt;</span><span class="hljs-symbol">:&lt;hostname&gt;</span><span class="hljs-symbol">:&lt;device&gt;</span><span class="hljs-symbol">:&lt;autoconf&gt;</span><span class="hljs-symbol">:&lt;dns0-ip&gt;</span><span class="hljs-symbol">:&lt;dns1-ip&gt;</span></code></pre></div><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819200416444.png" alt="image-20200819200416444"></p><p>根据上面的格式 bootargs 环境变量的 root 值如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">root=/dev/nfs nfsroot=192.168.0.111:/home/firestaradmin/linux/nfs/rootfs,proto=tcp rw ip=192.168.0.112:192.168.0.111:192.168.0.1:255.255.255.0::eth0:off</code></pre></div><p>“proto&#x3D;tcp”表示使用 TCP 协议，“rw”表示 nfs 挂载的根文件系统为可读可写。启动开发<br>板，进入 uboot 命令行模式，然后重新设置 bootargs 环境变量，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">setenv bootargs <span class="hljs-string">&#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.0.111:/home/firestaradmin/linux/nfs/rootfs,proto=tcp rw ip=192.168.0.113:192.168.0.111:192.168.0.1:255.255.255.0::eth0:off&#x27;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">saveenv</span></code></pre></div><p>设置好以后使用“boot”命令启动 Linux 内核，结果如图  所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819221525029.png" alt="image-20200819221525029"></p><p>从图可以看出，我们进入了根文件系统，说明我们的根文件系统工作了！如果没有启动进入根文件系统的话可以重启一次开发板试试。</p><p>大家注意，在进入根文件系统的时候会有下面这一行错误提示：</p><p><code>can&#39;t run &#39;/etc/init.d/rcS&#39;: No such file or directory</code></p><p>提示很简单，说是无法运行“&#x2F;etc&#x2F;init.d&#x2F;rcS”这个文件，因为这个文件不存在。</p><h2 id="四、完善根文件系统"><a href="#四、完善根文件系统" class="headerlink" title="四、完善根文件系统"></a>四、完善根文件系统</h2><h3 id="1、创建-x2F-etc-x2F-init-d-x2F-rcS-文件"><a href="#1、创建-x2F-etc-x2F-init-d-x2F-rcS-文件" class="headerlink" title="1、创建&#x2F;etc&#x2F;init.d&#x2F;rcS  文件"></a>1、创建&#x2F;etc&#x2F;init.d&#x2F;rcS  文件</h3><p>rcS 是个 shell 脚本，Linux 内核启动以后需要启动一些服务，而 rcS 就是规定启动哪些文件的脚本文件。在 rootfs 中创建&#x2F;etc&#x2F;init.d&#x2F;rcS 文件，然后在 rcS 中输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"> 1 <span class="hljs-comment">#!/bin/bash</span> 2 PATH=/sbin:/bin:/usr/sbin:/usr/bin:<span class="hljs-variable">$PATH</span> 3 LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/lib:/usr/lib 4 <span class="hljs-built_in">export</span> PATH LD_LIBRARY_PATH 5  6 mount -a 7 <span class="hljs-built_in">mkdir</span> /dev/pts 8 mount -t devpts devpts /dev/pts 9 10 <span class="hljs-built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug11 mdev -s</code></pre></div><p>第 1 行，表示这是一个 shell 脚本。<br>第 2 行，PATH 环境变量保存着可执行文件可能存在的目录，这样我们在执行一些命令或者可执行文件的时候就不会提示找不到文件这样的错误。<br>第 3 行，LD_LIBRARY_PATH 环境变量保存着库文件所在的目录。<br>第 4 行，使用 export 来导出上面这些环境变量，相当于声明一些“全局变量”。<br>第 6 行，使用 mount 命令来挂载所有的文件系统，这些文件系统由文件&#x2F;etc&#x2F;fstab 来指定，所以我们一会还要创建&#x2F;etc&#x2F;fstab 文件。<br>第 7 和 8 行，创建目录&#x2F;dev&#x2F;pts，然后将 devpts 挂载到&#x2F;dev&#x2F;pts 目录中。<br>第 10 和 11 行，使用 mdev 来管理热插拔设备，通过这两行，Linux 内核就可以在&#x2F;dev 目录下自动创建设备节点。关于 mdev 的详细内容可以参考 busybox 中的 docs&#x2F;mdev.txt 文档。示例代码 中的 rcS 文件内容是最精简的，大家如果去看 Ubuntu 或者其他大型 Linux操作系统中的 rcS 文件，就会发现其非常复杂。因为我们是初次学习，所以不用搞这么复杂的，而且这么复杂的 rcS 文件也是借助其他工具创建的，比如 buildroot 等。</p><p><strong>创建好文件&#x2F;etc&#x2F;init.d&#x2F;rcS 以后一定要给其可执行权限！</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 rcS</code></pre></div><p>重启内核：如图：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819223835685.png" alt="image-20200819223835685"></p><p>从图可以看到，提示找不到&#x2F;etc&#x2F;fstab 文件，还有一些其他的错误，我们先把&#x2F;etc&#x2F;fstab这个错误解决了。说不定把这个问题解决以后其他的错误也就解决了。</p><p>前面我们说了“mount -a”挂载所有根文件系统的时候需要读取&#x2F;etc&#x2F;fstab，因为&#x2F;etc、fstab 里面定义了该挂载哪些文件，好了，接下来就是创建&#x2F;etc&#x2F;fstab 文件。</p><h3 id="2、创建-x2F-etc-x2F-fstab-文件"><a href="#2、创建-x2F-etc-x2F-fstab-文件" class="headerlink" title="2、创建&#x2F;etc&#x2F;fstab 文件"></a>2、创建&#x2F;etc&#x2F;fstab 文件</h3><p>在 rootfs中创建&#x2F;etc&#x2F;fstab 文件，fstab在Linux开机以后自动配置哪些需要自动挂载的分区，格式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-section">&lt;file system&gt;</span> <span class="hljs-section">&lt;mount point&gt;</span> <span class="hljs-section">&lt;type&gt;</span> <span class="hljs-section">&lt;options&gt;</span> <span class="hljs-section">&lt;dump&gt;</span> <span class="hljs-section">&lt;pass&gt;</span></code></pre></div><p><code>&lt;file system&gt;</code>：要挂载的特殊的设备，也可以是块设备，比如&#x2F;dev&#x2F;sda 等等。</p><p><code>&lt;mount point&gt;</code>：挂载点。</p><p><code>&lt;type&gt;</code>：文件系统类型，比如 ext2、ext3、proc、romfs、tmpfs 等等。</p><p><code>&lt;options&gt;</code>：挂载选项，在 Ubuntu 中输入“man mount”命令可以查看具体的选项。一般使用 defaults，也就是默认选项，defaults 包含了 rw、suid、 dev、 exec、 auto、 nouser 和 async。</p><p><code>&lt;dump&gt;</code>：为 1 的话表示允许备份，为 0 不备份，一般不备份，因此设置为 0。</p><p><code>&lt;pass&gt;</code>：磁盘检查设置，为 0 表示不检查。根目录‘&#x2F;’设置为 1，其他的都不能设置为 1，其他的分区从 2 开始。一般不在 fstab 中挂载根目录，因此这里一般设置为 0。</p><p>按照上述格式，在 fstab 文件中输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>#&lt;file <span class="hljs-keyword">system</span>&gt;  &lt;mount <span class="hljs-keyword">point</span>&gt;   &lt;type&gt;  &lt;options&gt;   &lt;dump&gt;  &lt;pass&gt;<span class="hljs-symbol">2 </span>proc            /proc           proc    defaults    <span class="hljs-number">0</span>       <span class="hljs-number">0</span><span class="hljs-symbol">3 </span>tmpfs          /tmp            tmpfs  defaults    <span class="hljs-number">0</span>       <span class="hljs-number">0</span><span class="hljs-symbol">4 </span>sysfs           /sys            sysfs   defaults    <span class="hljs-number">0</span>       <span class="hljs-number">0</span></code></pre></div><p>fstab 文件创建完成以后重新启动 Linux，结果如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819224700923.png" alt="image-20200819224700923"></p><p>从图可以看出，启动成功，而且没有任何错误提示。但是我们要还需要创建一个文件&#x2F;etc&#x2F;inittab。</p><h3 id="3、创建-x2F-etc-x2F-inittab-文件"><a href="#3、创建-x2F-etc-x2F-inittab-文件" class="headerlink" title="3、创建&#x2F;etc&#x2F;inittab 文件"></a>3、创建&#x2F;etc&#x2F;inittab 文件</h3><p>inittab 的详细内容可以参考 busybox 下的文件 examples&#x2F;inittab。init 程序会读取**&#x2F;etc&#x2F;inittab**这个文件，inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成，格式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs elixir">&lt;id&gt;<span class="hljs-symbol">:&lt;runlevels&gt;</span><span class="hljs-symbol">:&lt;action&gt;</span><span class="hljs-symbol">:&lt;process&gt;</span></code></pre></div><p><code>&lt;id&gt;</code>：每个指令的标识符，不能重复。但是对于 busybox 的 init 来说，<code>&lt;id&gt;</code>有着特殊意义。对于 busybox 而言<code>&lt;id&gt;</code>用来指定启动进程的控制 tty，一般我们将串口或者 LCD 屏幕设置为控制 tty。<br><code>&lt;runlevels&gt;</code> ：对 busybox 来说此项完全没用，所以空着。<br><code>&lt;action&gt;</code>：动作，用于指定<code>&lt;process&gt;</code>可能用到的动作。</p><p>busybox 支持的动作如图所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819231003064.png" alt="image-20200819231003064"></p><p><code>&lt;process&gt;</code> ：具体的动作，比如程序、脚本或命令等。<br>参考 busybox 的 examples&#x2F;inittab 文件，我们也创建一个&#x2F;etc&#x2F;inittab，在里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">1 <span class="hljs-comment">#etc/inittab</span>2 ::sysinit:/etc/init.d/rcS3 console::askfirst:-/bin/sh4 ::restart:/sbin/init5 ::ctrlaltdel:/sbin/reboot6 ::shutdown:/bin/umount -a -r7 ::shutdown:/sbin/swapoff -a</code></pre></div><p>第 2 行，系统启动以后运行&#x2F;etc&#x2F;init.d&#x2F;rcS 这个脚本文件。<br>第 3 行，将 console 作为控制台终端，也就是 ttymxc0。<br>第 4 行，重启的话运行&#x2F;sbin&#x2F;init。<br>第 5 行，按下 ctrl+alt+del 组合键的话就运行&#x2F;sbin&#x2F;reboot，看来 ctrl+alt+del 组合键用于重启系统。<br>第 6 行，关机的时候执行&#x2F;bin&#x2F;umount，也就是卸载各个文件系统。<br>第 7 行，关机的时候执行&#x2F;sbin&#x2F;swapoff，也就是关闭交换分区。</p><p><strong>&#x2F;etc&#x2F;initta</strong> 文件创建好以后就可以重启开发板即可，至此！根文件系统要创建的文件就已经全部完成了。接下来就要对根文件系统进行其他的测试，比如是我们自己编写的软件运行是否正常、是否支持软件开机自启动、中文支持是否正常以及能不能链接等。</p><h3 id="4、根文件系统其他功能测试"><a href="#4、根文件系统其他功能测试" class="headerlink" title="4、根文件系统其他功能测试"></a>4、根文件系统其他功能测试</h3><h4 id="1、软件运行测试"><a href="#1、软件运行测试" class="headerlink" title="1、软件运行测试"></a>1、软件运行测试</h4><p>我们使用 Linux 的目的就是运行我们自己的软件，我们编译的应用软件一般都使用动态库，使用动态库的话应用软件体积就很小，但是得提供库文件，库文件我们已经添加到了根文件系统中。我们编写一个小小的测试软件来测试一下库文件是否工作正常，在根文件系统下创建一个名为“drivers”的文件夹，以后我们学习 Linux 驱动的时候就把所有的实验文件放到这个文件夹里面。</p><p>在 ubuntu 下使用 vim 编辑器新建一个 hello.c 文件，在 hello.c 里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span> <span class="hljs-number">2</span>  <span class="hljs-number">3</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> 4 &#123; <span class="hljs-number">5</span>     <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-number">6</span>     &#123; <span class="hljs-number">7</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\r\n&quot;</span>); <span class="hljs-number">8</span>         sleep(<span class="hljs-number">2</span>); <span class="hljs-number">9</span>     &#125;<span class="hljs-number">10</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">11</span> &#125;</code></pre></div><p>hello.c 内容很简单，就是循环输出“hello world”，sleep 相当于 Linux 的延时函数，单位为秒，所以 sleep(2)就是延时 2 秒。编写好以后就是编译，因为我们是要在 ARM 芯片上运行的，所以要用交叉编译器去编译，也就是使用 arm-linux-gnueabihf-gcc 编译，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-gcc hello.c -o hello</code></pre></div><p>使用 arm-linux-gnueabihf-gcc 将 hello.c 编译为 hello 可执行文件。这个 hello 可执行文件究<br>竟是不是 ARM 使用的呢？使用“file”命令查看文件类型以及编码格式：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">file hello</code></pre></div><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232015712.png" alt="image-20200819232015712"></p><p>从图  可以看出，输入“file hello”输入了如下所示信息：<br><code>hello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked……</code><br>hello 是个 32 位的 LSB 可执行文件，ARM 架构的，并且是动态链接的。所以我们编译出来的 hello 文件没有问题。将其拷贝到 rootfs&#x2F;drivers 目录下，在开发板中输入如下命令来执行这<br>个可执行文件：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /drivers  ./hello</code></pre></div><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232131493.png" alt="image-20200819232131493"></p><p>可以看出，hello 这个软件运行正常，说明我们的根文件系统中的共享库是没问题的，要想终止 hello 的运行，按下“ctrl+c”组合键即可。</p><p>此时大家应该能感觉到，hello 执行的时候终端是没法用的，除非使用“ctrl+c”来关闭 hello，那么有没有办法既能让 hello 正常运行，而且终端能够正常使用？那肯定是有的，让 hello 进入后台运行就行了，让一个软件进入后台的方法很简单，运行软件的时候加上“&amp;”即可，比如<strong>“.&#x2F;hello &amp;”</strong>就是让 hello 在后台运行。</p><p>在后台运行的软件可以使用<strong>“kill -9 pid(进程 ID)”</strong>命令来关闭掉，首先使用<strong>“ps”</strong>命令查看要关闭的软件 PID 是多少，ps 命令用于查看所有当前正在运行的进程，并且会给出进程的 PID。</p><h4 id="2、中文字符测试"><a href="#2、中文字符测试" class="headerlink" title="2、中文字符测试"></a>2、中文字符测试</h4><p>在 ubuntu 中向在 rootfs 目录新建一个名为“中文测试”的文件夹，然后在串口终端 下查看中文名能不能显示正确。输入“ls”命令，结果如图所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232935309.png" alt="image-20200819232935309"></p><p>可以看出“中文测试”这个文件夹显示正常，接着“touch”命令在“中文测试”文件夹中新建一个名为“测试文档.txt”的文件，并且使用 vim 编辑器在其中输入“这是一个中文测试文件”，借此来测试一下中文文件名和中文内容显示是否正常。结果如图 38.5.2.3 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819232952811.png" alt="image-20200819232952811"></p><p>从图  可以看出，“测试文档.txt”的中文内容显示正确，而且中文路径也完全正常，说明我们的根文件系统已经完美支持中文了！</p><h4 id="3、开机自启动测试"><a href="#3、开机自启动测试" class="headerlink" title="3、开机自启动测试"></a>3、开机自启动测试</h4><p>在前面测试 hello 软件的时候都是等 Linux 启动进入根文件系统以后手动输入命令“.&#x2F;hello”来完成的。我们一般做好产品以后都是需要开机自动启动相应的软件，本节我们就以hello 这个软件为例，讲解一下如何实现开机自启动。前面我们说过了，进入根文件系统的时候会运行&#x2F;etc&#x2F;init.d&#x2F;rcS 这个 shell 脚本，因此我们可以在这个脚本里面添加自启动相关内容。添加<br>完成以后的&#x2F;etc&#x2F;init.d&#x2F;rcS 文件内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"> 1 <span class="hljs-comment">#!/bin/sh</span> 2 PATH=/sbin:/bin:/usr/sbin:/usr/bin:<span class="hljs-variable">$PATH</span> 3 LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/lib:/usr/lib 4 <span class="hljs-built_in">export</span> PATH LD_LIBRARY_PATH 5  6 mount -a 7 <span class="hljs-built_in">mkdir</span> /dev/pts 8 mount -t devpts devpts /dev/pts 9 10 <span class="hljs-built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug11 mdev -s12 13 <span class="hljs-comment">#开机自启动</span>14 <span class="hljs-built_in">cd</span> /drivers15 ./hello &amp;16 <span class="hljs-built_in">cd</span> /</code></pre></div><p>自启动代码添加完成以后就可以重启开发板，看看 hello 这个软件会不会自动运行。结果如图 所示:</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819233330591.png" alt="image-20200819233330591"></p><p>从图可以看出，hello 开机自动运行了，说明开机自启动成功。</p><h4 id="4、连接外网测试"><a href="#4、连接外网测试" class="headerlink" title="4、连接外网测试"></a>4、连接外网测试</h4><p>这里说的外网不是外国哪些 404 网站的连接测试，而是百度、淘宝等这些网站的测试。也就是说看看我们的开发板能不能上网，能不能和我们的局域网外的这些网站进行通信。测试方法很简单，就是通过 ping 命令来 ping 一下百度的官网：<code>www.baidu.com</code>。输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">ping www.baidu.com</code></pre></div><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819233513402.png" alt="image-20200819233513402"></p><p>可以看出，测试失败，提示 <code>www.baidu.com</code> 是个“bad address”，也就是地址不对，显然我们的地址是正确的。之所以出现这个错误提示是因为<code> www.baidu.com</code> 的地址解析失败了，并没有解析出其对应的 IP 地址。</p><p>我们需要配置域名解析服务器的 IP 地址，一般域名解析地址可以设置为所处网络的网关地址，比如 192.168.0.1。也可以设置为 114.114.1144.114，这个是运营商的域名解析服务器地址。</p><p>在 rootfs 中新建文件**&#x2F;etc&#x2F;resolv.conf**，然后在里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>nameserver <span class="hljs-number">114.114</span>.<span class="hljs-number">114.114</span><span class="hljs-symbol">2 </span>nameserver <span class="hljs-number">192.168</span>.<span class="hljs-number">0.1</span></code></pre></div><p>设置很简单，nameserver 表示这是个域名服务器，设置了两个域名服务器地址：</p><p><code>114.114.114.114</code> 和 <code>192.168.0.1</code></p><p>大家也可以改为其他的域名服务器试试。如果使用“udhcpc”命令自动获取 IP 地址，“udhcpc”命令会修改 nameserver 的值，一般是将其设置为对应的网关地址。</p><p>修改好以后保存退出，重启开发板！重启以后重新 ping 一下百度官网，结果如图 所示：</p><p><img src="/2020/09/08/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/9.rootfs%E5%88%B6%E4%BD%9C/image-20200819233819089.png" alt="image-20200819233819089"></p><p>可以看出 ping 百度官网成功了！域名也成功的解析了，至此！我们的根文件系统就彻底的制作完成，这个根文件系统最好打包保存一下，防止以后做实验不小心破坏了根文件系统而功亏一篑，又得从头制作根文件系统。</p><p>uboot、Linux kernel、rootfs 这三个共同构成了一个完整的Linux 系统，现在的系统至少是一个可以正常运行的系统，后面我们就可以在这个系统上完成Linux 驱动开发的学习。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Linux</tag>
      
      <tag>rootfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8| linux内核移植</title>
    <link href="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/"/>
    <url>/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="linux内核移植"><a href="#linux内核移植" class="headerlink" title="linux内核移植"></a>linux内核移植</h1><h2 id="一、获取内核源码"><a href="#一、获取内核源码" class="headerlink" title="一、获取内核源码"></a>一、获取内核源码</h2><p>Linux 官网为 <a href="https://www.kernel.org,所以你想获取最新的linux/">https://www.kernel.org，所以你想获取最新的Linux</a> 版本就可以在这个网站上下载，网站界面如图所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819114832709.png" alt="image-20200819114832709"></p><p>从图可以看出最新的稳定版 Linux 已经到了 5.1.4，大家没必要追新，因为 4.x 版本的 Linux 和 5.x 版本没有本质上的区别，5.x 更多的是加入了一些新的平台、新的外设驱动而已。NXP 会从 <a href="https://www.kernel.org/">https://www.kernel.org</a> 下载某个版本的 Linux 内核，然后将其移植到自己的 CPU上，测试成功以后就会将其开放给 NXP 的 CPU 开发者。开发者下载 NXP 提供的 Linux 内核，然后将其移植到自己的产品上。本章的移植我们就使用 NXP 提供的Linux 源码。</p><p>和uboot源码一样，从对应的开发板厂商或SOC厂商获取，具体看你的开发板参考谁的板子</p><h2 id="二、内核浅析"><a href="#二、内核浅析" class="headerlink" title="二、内核浅析"></a>二、内核浅析</h2><h3 id="1、内核目录分析"><a href="#1、内核目录分析" class="headerlink" title="1、内核目录分析"></a>1、内核目录分析</h3><p>将 Linux 源码进行解压，解压完成以后的目录如图所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819120745881.png" alt="image-20200819120745881"></p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819120815125.png" alt="image-20200819120815125"></p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819120827827.png" alt="image-20200819120827827"></p><ul><li><p>1 、arch  目录</p><p>这个目录是和架构有关的目录，比如 arm、arm64、avr32、x86 等等架构。每种架构都对应一个目录，在这些目录中又有很多子目录，比如 boot、common、configs 等等</p><p>以 arch&#x2F;arm 为例，其子目录如图 35.3.2 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819121018040.png" alt="image-20200819121018040"></p><p>图 35.3.2 是 arch&#x2F;arm 的一部分子目录，这些子目录用于控制系统引导、系统调用、动态调频、主频设置等。</p><p>arch&#x2F;arm&#x2F;configs 目录是不同平台的默认配置文件：xxx_defconfig，如图 35.3.3所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819121036268.png" alt="image-20200819121036268"></p><p>在 <strong>arch&#x2F;arm&#x2F;configs</strong> 中就包含有 I.MX6U-ALPHA 开发板的默认配置文件：imx_v7_defconfig,执行“make imx_v7_defconfig”即可完成配置。</p><p><strong>arch&#x2F;arm&#x2F;boot&#x2F;dts</strong> 目录里面是对应开发平台的设备树文件，正点原子 I.MX6U-ALPHA 开发板对应的设备树文件如图 35.3.4 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819121223952.png" alt="image-20200819121223952"></p><p><strong>arch&#x2F;arm&#x2F;boot</strong> 目录下会保存编译出来的 Image 和 zImage 镜像文件，而 zImage 就是我们要用的 linux 镜像文件。</p><p><strong>arch&#x2F;arm&#x2F;mach-xxx</strong> 目录分别为相应平台的驱动和初始化文件，比如 mach-imx 目录里面就是 I.MX 系列 CPU 的驱动和初始化文件。</p></li><li><p>2 、block  目录</p><p>block 是 Linux 下块设备目录，像 SD 卡、EMMC、NAND、硬盘等存储设备就属于块设备，block 目录中存放着管理块设备的相关文件。</p></li><li><p>3 、crypto  目录</p><p>crypto 目录里面存放着加密文件，比如常见的 crc、crc32、md4、md5、hash 等加密算法。</p></li><li><p>4 、Documentation 目录</p><p>此目录里面存放着 Linux 相关的文档，如果要想了解 Linux 某个功能模块或驱动架构的功能，就可以在 Documentation 目录中查找有没有对应的文档。</p></li><li><p>5 、drivers  目录</p><p>驱动目录文件，此目录根据驱动类型的不同，分门别类进行整理，比如 drivers&#x2F;i2c 就是 I2C相关驱动目录，drivers&#x2F;gpio 就是 GPIO 相关的驱动目录，这是我们学习的重点。</p></li><li><p>6 、firmware  目录</p><p>此目录用于存放固件。</p></li><li><p>7 、fs  目录</p><p>此目录存放文件系统，比如 fs&#x2F;ext2、fs&#x2F;ext4、fs&#x2F;f2fs 等，分别是 ext2、ext4 和 f2fs 等文件系统。</p></li><li><p>8 、include  目录</p><p>头文件目录。</p></li><li><p>9 、init  目录</p><p>此目录存放 Linux 内核启动的时候初始化代码。</p></li><li><p>10 、ipc  目录</p><p>IPC 为进程间通信，ipc 目录是进程间通信的具体实现代码。</p></li><li><p>11 、kernel  目录</p><p>Linux 内核代码。</p></li><li><p>12 、lib  目录</p><p>lib 是库的意思，lib 目录都是一些公用的库函。</p></li><li><p>13 、mm  目录</p><p>此目录存放内存管理相关代码。</p></li><li><p>14 、net  目录</p><p>此目录存放网络相关代码。</p></li><li><p>15 、samples  目录</p><p>此目录存放一些示例代码文件。</p></li><li><p>16 、scripts  目录</p><p>脚本目录，Linux 编译的时候会用到很多脚本文件，这些脚本文件就保存在此目录中。</p></li><li><p>17 、security  目录</p><p>此目录存放安全相关的文件。</p></li><li><p>18 、sound  目录</p><p>此目录存放音频相关驱动文件，音频驱动文件并没有存放到 drivers 目录中，而是单独的目录。</p></li><li><p>19 、tools  目录</p><p>此目录存放一些编译的时候使用到的工具。</p></li><li><p>20 、usr  目录</p><p>此目录存放与 initramfs 有关的代码。</p></li><li><p>21 、virt  目录</p><p>此目录存放虚拟机相关文件。</p></li><li><p>22 、.config  文件</p><p>跟 uboot 一样，.config 保存着 Linux 最终的配置信息，编译 Linux 的时候会读取此文件中<br>的配置信息。最终根据配置信息来选择编译 Linux 哪些模块，哪些功能。</p></li><li><p>23 、Kbuild  文件</p><p>有些 Makefile 会读取此文件。</p></li><li><p>24 、Kconfig </p><p>图形化配置界面的配置文件。</p></li><li><p>25 、Makefile  文件</p><p>Linux 顶层 Makefile 文件，建议好好阅读一下此文件。</p></li><li><p>26 、README  文件</p><p>此文件详细讲解了如何编译 Linux 源码，以及 Linux 源码的目录信息，建议仔细阅读一下此文件。</p></li></ul><h3 id="2、顶层Makefile分析"><a href="#2、顶层Makefile分析" class="headerlink" title="2、顶层Makefile分析"></a>2、顶层Makefile分析</h3><p>参考正点原子IMX6U驱动开发指南35.5节。</p><h3 id="3、内核启动流程分析"><a href="#3、内核启动流程分析" class="headerlink" title="3、内核启动流程分析"></a>3、内核启动流程分析</h3><p>参考正点原子IMX6U驱动开发指南36.1、36.2节。</p><h2 id="三、内核移植"><a href="#三、内核移植" class="headerlink" title="三、内核移植"></a>三、内核移植</h2><h3 id="1、创建VSCode工程"><a href="#1、创建VSCode工程" class="headerlink" title="1、创建VSCode工程"></a>1、创建VSCode工程</h3><p>这里我们使用 NXP 官方提供的 Linux 源码，将其移植到正点原子 I.MX6U-ALPHA 开发板上。</p><p>源码压缩包<strong>linux-imx-rel_imx_4.1.15_2.1.0_ga.tar.bz2</strong>。使用FileZilla将其发送到Ubuntu中并解压，得到名为<code>linux-imx-rel_imx_4.1.15_2.1.0_ga</code>的目录，为了和 NXP 官方的名字区分，可 以使用“ mv ”命令对其重命名，我这里将其重命名为 “ linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg”.</p><p>命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mv</span> linux-imx-rel_imx_4.1.15_2.1.0_ga linux-imx-rel_imx_4.1.15_2.1.0_ga_lxg</code></pre></div><p>完成以后创建 VSCode 工程，步骤和 Windows 下一样，重点是.vscode&#x2F;settings.json 这个文件。</p><h3 id="2、NXP-官方开发板-Linux-内核初次编译"><a href="#2、NXP-官方开发板-Linux-内核初次编译" class="headerlink" title="2、NXP  官方开发板 Linux 内核初次编译"></a>2、NXP  官方开发板 Linux 内核初次编译</h3><p>编译内核之前需要先在 ubuntu 上安装 lzop 库，否则内核编译会失败！命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo apt-get install lzop</code></pre></div><p>修改顶层 Makefile，直接在顶层 Makefile 文件里面定义 ARCH 和 CROSS_COMPILE 这两个的变量值为 arm 和 arm-linux-gnueabihf-，结果如图 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819122938067.png" alt="image-20200819122938067"></p><p>分别设置了 ARCH 和 CROSS_COMPILE 这两个变量的值，这样在编译的时候就不用输入很长的命令了。</p><p>和 uboot 一样，在编译 Linux 内核之前要先配置 Linux 内核。每个板子都有其对应的默认配置文件，这些默认配置文件保存 在 <strong>arch&#x2F;arm&#x2F;configs</strong> 目录中。 imx_v7_defconfig 和imx_v7_mfg_defconfig 都可作为 I.MX6ULL EVK 开发板所使用的默认配置文件。但是这里建议使用 imx_v7_mfg_defconfig 这个默认配置文件，首先此配置文件默认支持 I.MX6UL 这款芯片，而且重要的一点就是此文件编译出来的 zImage 可以通过 NXP 官方提供的 MfgTool 工具烧写！！imx_v7_mfg_defconfig 中的“mfg”的意思就是 MfgTool。进入到 Ubuntu 中的 Linux 源码根目录下，执行如下命令配置 Linux 内核：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">make clean  <span class="hljs-regexp">//</span>第一次编译 Linux 内核之前先清理一下make imx_v7_mfg_defconfig <span class="hljs-regexp">//</span>配置 Linux 内核</code></pre></div><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819123316222.png" alt="image-20200819123316222"></p><p>配置完成以后就可以编译了，使用如下命令编译 Linux 内核：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">make -j12  <span class="hljs-regexp">//</span>编译 Linux 内核</code></pre></div><p>等待编译完成，结果如图所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819123555197.png" alt="image-20200819123555197"></p><p>Linux 内核编译完成以后会在 <strong>arch&#x2F;arm&#x2F;boot</strong> 目录下生成 <strong>zImage</strong> 镜像文件，如果使用设备树的话还会在 <strong>arch&#x2F;arm&#x2F;boot&#x2F;dts</strong> 目录下开发板对应的**.dtb**(设备树)文件，比如 imx6ull-14x14-evk.dtb就是 NXP 官方的 I.MX6ULL EVK 开发板对应的设备树文件。至此我们得到两个文件：<br><strong>①、Linux 内核镜像文件：zImage。</strong><br><strong>②、NXP 官方 I.MX6ULL EVK 开发板对应的设备树文件：imx6ull-14x14-evk.dtb。</strong></p><h3 id="3、Linux-内核启动测试"><a href="#3、Linux-内核启动测试" class="headerlink" title="3、Linux 内核启动测试"></a>3、Linux 内核启动测试</h3><p>在上一小节我们已经得到了 NXP 官方 I.MX6ULL EVK 开发板对应的 zImage 和 imx6ull-14x14-evk.dtb 这两个文件。</p><p>现在测试这两个文件能不能在正点原子的 I.MX6U-ALPHA EMMC 版开发板上启动，在测试之前确保 uboot 中的环境变量 bootargs 内容如下：<br><code>console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw</code><br>将上一小节编译出来的 zImage 和 imx6ull-14x14-evk.dtb 复制到 Ubuntu 中的 tftp 目录下，因为我们要在 uboot 中使用 tftp 命令将其下载到开发板中，拷贝命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> <span class="hljs-built_in">arch</span>/arm/boot/zImage /home/firestaradmin/linux/tftpboot/ -f<span class="hljs-built_in">cp</span> <span class="hljs-built_in">arch</span>/arm/boot/dts/imx6ull-14x14-evk.dtb /home/firestaradmin/linux/tftpboot/ -f</code></pre></div><p>拷贝完成以后就可以测试了，启动开发板，进入 uboot 命令行模式，然后输入如下命令将zImage 和 imx6ull-14x14-evk.dtb 下载到开发板中并启动：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">tftp 80800000 zImagetftp 83000000 imx6ull-14x14-evk.dtbbootz 80800000 - 83000000</code></pre></div><p>结果图所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819130548552.png" alt="image-20200819130548552"></p><h3 id="4、在linux内核中添加自己的开发板"><a href="#4、在linux内核中添加自己的开发板" class="headerlink" title="4、在linux内核中添加自己的开发板"></a>4、在linux内核中添加自己的开发板</h3><h4 id="1、添加默认配置文件"><a href="#1、添加默认配置文件" class="headerlink" title="1、添加默认配置文件"></a>1、添加默认配置文件</h4><p>将 arch&#x2F;arm&#x2F;configs 目 录 下 的 imx_v7_mfg_defconfig 重 新 复 制 一 份 ， 命 名 imx_lxg_emmc_defconfig，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">arch</span>/arm/configs<span class="hljs-built_in">cp</span> imx_v7_mfg_defconfig imx_lxg_emmc_defconfig</code></pre></div><p>以后 imx_lxg_emmc_defconfig就是我们的 EMMC 版开发板默认配置文件了。完成以后如图 37.3.1.1 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819131258173.png" alt="image-20200819131258173"></p><h4 id="2、添加开发板对应的设备树文件"><a href="#2、添加开发板对应的设备树文件" class="headerlink" title="2、添加开发板对应的设备树文件"></a>2、添加开发板对应的设备树文件</h4><p>添加适合正点原子 EMMC 版开发板的设备树文件，进入目录 arch&#x2F;arm&#x2F;boot&#x2F;dts 中，复制一份 imx6ull-14x14-evk.dts，然后将其重命名为 imx6ull-lxg-emmc.dts，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">arch</span>/arm/boot/dts<span class="hljs-built_in">cp</span> imx6ull-14x14-evk.dts imx6ull-lxg-emmc.dts</code></pre></div><p>.dts 是设备树源码文件，编译 Linux 的时候会将其编译为.dtb 文件。imx6ull-lxg-emmc.dts<br>创建好以后我们还需要修改arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;Makefile，找到 “ dtb-$(CONFIG_SOC_IMX6ULL)”配置项，在此配置项中加入“imx6ull-lxg-emmc.dtb” ，如下所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819131816436.png" alt="image-20200819131816436"></p><p>这样编译 Linux 的时候就可以从 imx6ull-lxg-emmc.dts 编译出 imx6ull-lxg-emmc.dtb 文件了。</p><h4 id="3、编译测试"><a href="#3、编译测试" class="headerlink" title="3、编译测试"></a>3、编译测试</h4><p>经过前面两个小节，Linux 内核里面已经添加了我们自己的I.MX6UL-LXG-EMMC 版开发板了，接下接编译测试一下，我们可以创建一个编译脚本，imx6ull_lxg_emmc.sh，脚本内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distcleanmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_lxg_emmc_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all -j12</code></pre></div><p>第 2 行，清理工程。<br>第 3 行，使用默认配置文件 imx_lxg_emmc_defconfig 来配置 Linux 内核。<br>第 4 行，打开 Linux 的图形配置界面，如果不需要每次都打开图形配置界面可以删除此行。<br>第 5 行，编译 Linux。</p><p>执行 shell 脚本 imx_lxg_emmc.sh 编译 Linux 内核，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 imx_lxg_emmc.sh //给予可执行权限./imx_lxg_emmc.sh //执行 shell 脚本编译内核</code></pre></div><p>编译完成以后就会在目录 arch&#x2F;arm&#x2F;boot 下生成 zImage 镜像文件。在 arch&#x2F;arm&#x2F;boot&#x2F;dts 目录下生成 imx6ull-lxg-emmc.dtb 文件。将这两个文件拷贝到 tftp 目录下，然后重启开发板，在uboot 命令模式中使用 tftp 命令下载这两个文件并启动，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">tftp 80800000 zImagetftp 83000000 imx6ull-lxg-emmc.dtbbootz 80800000 – 83000000</code></pre></div><p>只要出现如图所示内容就表示 Linux 内核启动成功：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819133111334.png" alt="image-20200819133111334"></p><p>红框为linux内核的编译时间</p><h3 id="5、部分驱动修改（CPU、NET、EMMC）"><a href="#5、部分驱动修改（CPU、NET、EMMC）" class="headerlink" title="5、部分驱动修改（CPU、NET、EMMC）"></a>5、部分驱动修改（CPU、NET、EMMC）</h3><h4 id="1、CPU主频修改"><a href="#1、CPU主频修改" class="headerlink" title="1、CPU主频修改"></a>1、CPU主频修改</h4><h5 id="1、在linux下手动修改cpu配置文件或修改linux内核配置文件"><a href="#1、在linux下手动修改cpu配置文件或修改linux内核配置文件" class="headerlink" title="1、在linux下手动修改cpu配置文件或修改linux内核配置文件"></a>1、在linux下手动修改cpu配置文件或修改linux内核配置文件</h5><p>正点原子 I.MX6U-ALPHA 开发板所使用的 I.MX6ULL 芯片主频都是 792MHz 的，也就是NXP 官方宣传的 800MHz 版本。这里以此板为例。</p><p>1 、设置 I.MX6U-ALPHA  开发板工作在 792MHz<br>确保 EMMC 中的根文件系统可用！然后重新启动开发板，进入终端(可以输入命令)，如图</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /proc/cpuinfo</code></pre></div><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819143359337.png" alt="image-20200819143359337"></p><p>在图 中有 BogoMIPS 这一条，此时 BogoMIIS 为 3.00，BogoMIPS 是 Linux 系统中衡量处理器运行速度的一个“尺子”，处理器性能越强，主频越高，BogoMIPS 值就越大。BogoMIPS 只是粗略的计算 CPU 性能，并不十分准确。但是我们可以通过 BogoMIPS 值来大致的判断当前处理器的性能。在图中并没有看到当前 CPU 的工作频率，那我们就转变另一种方法查看当前 CPU 的工作频率。进入到目录 &#x2F;sys&#x2F;bus&#x2F;cpu&#x2F;devices&#x2F;cpu0&#x2F;cpufreq 中，此目录下会有很多文件，如图 37.4.1.3 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819143452149.png" alt="image-20200819143452149"></p><p>此目录中记录了 CPU 频率等信息，这些文件的含义如下：<br><strong>cpuinfo_cur_freq</strong>：当前 cpu 工作频率，从 CPU 寄存器读取到的工作频率。<br><strong>cpuinfo_max_freq</strong>：处理器所能运行的最高工作频率(单位: KHz）。<br><strong>cpuinfo_min_freq</strong> ：处理器所能运行的最低工作频率(单位: KHz）。<br><strong>cpuinfo_transition_latency</strong>：处理器切换频率所需要的时间(单位:ns)。<br><strong>scaling_available_frequencies</strong>：处理器支持的主频率列表(单位: KHz）。<br><strong>scaling_available_governors</strong>：当前内核中支持的所有 governor(调频)类型。<br><strong>scaling_cur_freq</strong>：保存着 cpufreq 模块缓存的当前 CPU 频率，不会对 CPU 硬件寄存器进行检查。<br><strong>scaling_driver</strong>：该文件保存当前 CPU 所使用的调频驱动。<br><strong>scaling_governor</strong> ：governor(调频)策略，Linux 内核一共有 5 中调频策略，</p><ul><li>①、Performance，最高性能，直接用最高频率，不考虑耗电。<br>②、Interactive，一开始直接用最高频率，然后根据 CPU 负载慢慢降低。<br>③、Powersave，省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！<br>④、Userspace，可以在用户空间手动调节频率。<br>⑤、Ondemand，定时检查负载，然后根据负载来调节频率。负载低的时候降低 CPU 频率，这样省电，负载高的时候提高 CPU 频率，增加性能。</li></ul><p><strong>scaling_max_freq</strong> ：governor(调频)可以调节的最高频率。<br><strong>cpuinfo_min_freq</strong>：governor(调频)可以调节的最低频率。</p><p><strong>stats 目录</strong>下给出了 CPU 各种运行频率的统计情况，比如 CPU 在各频率下的运行时间以及<br>变频次数。</p><p>使用如下命令查看当前 CPU 频率：<code>cat cpuinfo_cur_freq</code><br>结果如图 37.4.1.4 所示</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819143815635.png" alt="image-20200819143815635"></p><p>从图 37.4.1.4 可以看出，当前 CPU 频率为 198MHz，工作频率很低！其他的值如下：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cpuinfo_cur_freq</span> = <span class="hljs-number">198000</span><span class="hljs-attribute">cpuinfo_max_freq</span> = <span class="hljs-number">792000</span><span class="hljs-attribute">cpuinfo_min_freq</span> = <span class="hljs-number">198000</span><span class="hljs-attribute">scaling_cur_freq</span> = <span class="hljs-number">198000</span><span class="hljs-attribute">scaling_max_freq</span> = <span class="hljs-number">792000</span><span class="hljs-attribute">cat</span> scaling_min_freq = <span class="hljs-number">198000</span><span class="hljs-attribute">scaling_available_frequencies</span> = <span class="hljs-number">198000</span> <span class="hljs-number">396000</span> <span class="hljs-number">528000</span> <span class="hljs-number">792000</span><span class="hljs-attribute">cat</span> scaling_governor = ondemand</code></pre></div><p>可以看出，当前 CPU 支持 198MHz、396MHz、528Mhz 和 792000 四种频率切换，其中调频策略为 ondemand，也就是定期检查负载，然后根据负载情况调节 CPU 频率。因为当前我们开发板并没有做什么工作，因此 CPU 频率降低为 198MHz 以省电。如果开发板做一些高负载的工作，比如播放视频等操作那么 CPU 频率就会提升上去。</p><p>查看 stats 目录下的 time_in_state 文件可以看到 CPU 在各频率下的工作时间，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /sys/bus/cpu/devices/cpu0/cpufreq/stats/time_in_state</code></pre></div><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819144003337.png" alt="image-20200819144003337"></p><p>从图中可以看出，CPU 在 198MHz、396MHz、528MHz 和 792MHz 都工作过，其中 198MHz 的工作时间最长！假如我们想让 CPU 一直工作在 792MHz 那该怎么办？很简单，配置 Linux 内核，将调频策略选择为 performance（直接修改<strong>scaling_governor</strong> 文件的内容，将ondemand修改为performance）。</p><p>或者修改 imx_lxg_emmc_defconfig 文件，此文件中有下面几行：</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND</span>=y<span class="hljs-attr">CONFIG_CPU_FREQ_GOV_POWERSAVE</span>=y<span class="hljs-attr">CONFIG_CPU_FREQ_GOV_USERSPACE</span>=y<span class="hljs-attr">CONFIG_CPU_FREQ_GOV_INTERACTIVE</span>=y</code></pre></div><p>分别为：</p><p>配置 ondemand 为默认调频策略。<br>使能 powersave 策略。<br>使能 userspace 策略。<br>使能 interactive 策略</p><p>将示例代码中的第 1 行屏蔽掉，然后在最后面添加：</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_CPU_FREQ_GOV_ONDEMAND</span>=y</code></pre></div><p>修改完成以后重新编译 Linux 内核，编译之前先清理一下工程！因为我们重新修改过默认配置文件了，编译完成以后使用新的 zImage 镜像文件重新启动 Linux。再次查看&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F; cpuinfo_cur_freq 文件的值，如图 37.4.1.6 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819144814735.png" alt="image-20200819144814735"></p><p>从图可以看出，当前 CPU 频率为 792MHz 了。查看 scaling_governor 文件看一下当前的调频策略，如图 37.4.1.7 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819144848532.png" alt="image-20200819144848532"></p><p>从图 可以看出当前的 CPU 调频策略为 preformance，也就是高性能模式，一直以最高主频运行。</p><h5 id="2、使用linux图形化配置界面配置"><a href="#2、使用linux图形化配置界面配置" class="headerlink" title="2、使用linux图形化配置界面配置"></a>2、使用linux图形化配置界面配置</h5><p>输入<code>make menuconfig</code>打开 Linux 内核的图形化配置界面</p><p>进入如下路径：<br>CPU Power Management<br>    -&gt; CPU Frequency scaling<br>        -&gt; CPU Frequency scaling<br>            -&gt; Default CPUFreq governor<br>打开默认调频策略选择界面，选择“performance”，如图所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819145152374.png" alt="image-20200819145152374"></p><p>在图中选择“performance”即可，选择以后退出图形化配置界面，然后编译 Linux内核，一定不要清理工程！否则的话我们刚刚的设置就会被清理掉。编译完成以后使用新的zImage 重启 Linux，查看当前 CPU 的工作频率和调频策略。</p><p>我们学习的时候为了高性能，大家可以使用 performance 模式。但是在以后的实际产品开发中，从省电的角度考虑，建议大家使用 ondemand 模式，一来可以省电，二来可以减少发热。</p><h5 id="3、超频设置"><a href="#3、超频设置" class="headerlink" title="3、超频设置"></a>3、超频设置</h5><p>I.MX6ULL 有多种型号，按照工作频率可以分为 528MHz、700Mhz(实际 696MHz)，800MHz(实际 792MHz)和 900MHz(实际频率未知，应该在 900MHz 左右)。</p><p><strong>声明：</strong><br>想体验一下高性能的朋友可以体验一下超频，但是！毕竟是超频了的，工作肯定没有在默认频率稳定。<strong>如果因为超频带来任何损坏，本文档不负任何责任！</strong></p><p>在实际的产品中，禁止任何超频！务必严格按照 I.MX6ULL 手册上给出的标准工作频率来运行！！如果想要更高的性能，请购买相应型号的处理器！看到这里，如果您还是执意要超频，那么就接着往下看，如果要放弃超频，那就跳过本小节。</p><p>超频设置其实很简单，修改一下设备树文件 arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi 即可，打开imx6ull.dtsi，找到下面代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c">cpu0: cpu@<span class="hljs-number">0</span> &#123;compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;device_type = <span class="hljs-string">&quot;cpu&quot;</span>;reg = &lt;<span class="hljs-number">0</span>&gt;;clock-latency = &lt;<span class="hljs-number">61036</span>&gt;; <span class="hljs-comment">/* two CLK32 periods */</span>operating-points = &lt;<span class="hljs-comment">/* kHzuV */</span><span class="hljs-number">996000</span><span class="hljs-number">1275000</span><span class="hljs-number">792000</span><span class="hljs-number">1225000</span><span class="hljs-number">528000</span><span class="hljs-number">1175000</span><span class="hljs-number">396000</span><span class="hljs-number">1025000</span><span class="hljs-number">198000</span><span class="hljs-number">950000</span>&gt;;fsl,soc-operating-points = &lt;<span class="hljs-comment">/* KHzuV */</span><span class="hljs-number">996000</span><span class="hljs-number">1175000</span><span class="hljs-number">792000</span><span class="hljs-number">1175000</span><span class="hljs-number">528000</span><span class="hljs-number">1175000</span><span class="hljs-number">396000</span><span class="hljs-number">1175000</span><span class="hljs-number">198000</span><span class="hljs-number">1175000</span>&gt;;fsl,low-power-run;clocks = &lt;&amp;clks IMX6UL_CLK_ARM&gt;,</code></pre></div><p>想要超频的小伙伴只需要添加两行代码：如下：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819150034290.png" alt="image-20200819150034290"></p><p>加入了“696000 1225000”，这个就是 696MHz 的支持。<br>加入了“696000 1175000”，也是对 696MHz 的支持。</p><p>修改好以后保存，并且编译设备树，在 Linux 内核源码根目录下输入如下命令编译设备树：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make dtbs</span></code></pre></div><p>命令“make dtbs”只编译设备树文件，也就是将.dts 编译为.dtb，编译完成以后使用新的设备树文件imx6ull-lxg_emmc.dtb 启动Linux.</p><p>重启以后查看文件&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F; scaling_available_frequencies 的内容，如图 37.4.1.10 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819150158116.png" alt="image-20200819150158116"></p><p>从图可以看出，此时支持了 696MHz。如果设置调频策略为 performance，那么处理器就会一直工作在696MHz。可以对比一下工作在528MHz和696MHz下的BogoMIPS的值</p><h3 id="6、使能8线EMMC驱动"><a href="#6、使能8线EMMC驱动" class="headerlink" title="6、使能8线EMMC驱动"></a>6、使能8线EMMC驱动</h3><p>正点原子 EMMC 版本核心板上的 EMMC 采用的 8 位数据线，原理图如图 37.4.2.1 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819150756416.png" alt="image-20200819150756416"></p><p>Linux 内核驱动里面 EMMC 默认是 4 线模式的，4 线模式肯定没有 8 线模式的速度快，所以本节我们将 EMMC 的驱动修改为 8 线模式。修改方法很简单，直接修改设备树即可，打开文件 imx6ull-lxg-emmc.dts，找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c">&amp;usdhc2 &#123;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_usdhc2&gt;;non-removable;status = <span class="hljs-string">&quot;okay&quot;</span>;&#125;;</code></pre></div><p>关于设备树的原理以及内容后面会专门讲解，示例代码中的代码含义我们现在不去纠结，只需要将其改为如下代码即可：</p><div class="hljs code-wrapper"><pre><code class="hljs c">&amp;usdhc2 &#123;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;state_100mhz&quot;</span>, <span class="hljs-string">&quot;state_200mhz&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_usdhc2_8bit&gt;;pinctrl<span class="hljs-number">-1</span> = &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;;pinctrl<span class="hljs-number">-2</span> = &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;;bus-width = &lt;<span class="hljs-number">8</span>&gt;;non-removable;status = <span class="hljs-string">&quot;okay&quot;</span>;&#125;;</code></pre></div><p>修改完成以后保存一下 imx6ull-lxg-emmc.dts，然后使用命令“make dtbs”重新编译一下设备树，编译完成以后使用新的设备树重启 Linux 系统即可。</p><h3 id="7、修改网络驱动"><a href="#7、修改网络驱动" class="headerlink" title="7、修改网络驱动"></a>7、修改网络驱动</h3><p>因为在后面学习 Linux 驱动开发的时候要用到网络调试驱动，所以必须要把网络驱动调试好。在讲解uboot 移植的时候就已经说过了，正点原子开发板的网络和 NXP 官方的网络硬件上不同，网络 PHY 芯片由 KSZ8081 换为了 LAN8720A，两个网络 PHY 芯片的复位 IO 也不同。所以 Linux 内核自带的网络驱动是驱动不起来 I.MX6U-ALPHA 开发板上的网络的，需要做修改。</p><h4 id="1、修改LAN8720-的复位-以及网络时钟引脚驱动"><a href="#1、修改LAN8720-的复位-以及网络时钟引脚驱动" class="headerlink" title="1、修改LAN8720  的复位 以及网络时钟引脚驱动"></a>1、修改LAN8720  的复位 以及网络时钟引脚驱动</h4><p>ENET1 复位引脚 ENET1_RST 连接在 I.M6ULL 的 SNVS_TAMPER7 这个引脚上。ENET2的复位引脚 ENET2_RST 连接在 I.MX6ULL 的 SNVS_TAMPER8 上。打开设备树文件 imx6ull-lxg-emmc.dts，找到如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c">pinctrl_spi4: spi4grp &#123;                   fsl,pins = &lt;                           MX6ULL_PAD_BOOT_MODE0__GPIO5_IO10        <span class="hljs-number">0x70a1</span>                           MX6ULL_PAD_BOOT_MODE1__GPIO5_IO11        <span class="hljs-number">0x70a1</span>                           MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07      <span class="hljs-number">0x70a1</span>                           MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08      <span class="hljs-number">0x80000000</span>                       &gt;;               &#125;;</code></pre></div><p>示例代码中</p><div class="hljs code-wrapper"><pre><code class="hljs gcode">MX<span class="hljs-number">6</span>ULL_PAD_S<span class="hljs-symbol">NVS_TAMPER7</span>__GPI<span class="hljs-meta">O5</span>_I<span class="hljs-meta">O07</span>      <span class="hljs-number">0</span>x<span class="hljs-number">70</span>a<span class="hljs-number">1</span>MX<span class="hljs-number">6</span>ULL_PAD_S<span class="hljs-symbol">NVS_TAMPER8</span>__GPI<span class="hljs-meta">O5</span>_I<span class="hljs-meta">O08</span>      <span class="hljs-number">0</span>x<span class="hljs-number">80000000</span></code></pre></div><p>就是初始化 SNVS_TAMPER7 和 SNVS_TAMPER8 这两个引脚的，不过看样子好像是作为了 SPI4 的 IO，这不是我们想要的，所以将这两行删除掉！删除掉以后继续在 imx6ull-lxg-emmc.dts 中找到如下所示代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c">spi4 &#123;compatible = <span class="hljs-string">&quot;spi-gpio&quot;</span>;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_spi4&gt;;pinctrl-assert-gpios = &lt;&amp;gpio5 <span class="hljs-number">8</span> GPIO_ACTIVE_LOW&gt;;status = <span class="hljs-string">&quot;okay&quot;</span>;gpio-sck = &lt;&amp;gpio5 <span class="hljs-number">11</span> <span class="hljs-number">0</span>&gt;;gpio-mosi = &lt;&amp;gpio5 <span class="hljs-number">10</span> <span class="hljs-number">0</span>&gt;;cs-gpios = &lt;&amp;gpio5 <span class="hljs-number">7</span> <span class="hljs-number">0</span>&gt;;num-chipselects = &lt;<span class="hljs-number">1</span>&gt;;       ......</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs c">pinctrl-assert-gpios = &lt;&amp;gpio5 <span class="hljs-number">8</span> GPIO_ACTIVE_LOW&gt;;cs-gpios = &lt;&amp;gpio5 <span class="hljs-number">7</span> <span class="hljs-number">0</span>&gt;;</code></pre></div><p>其中这两行分别是</p><p>设置 GPIO5_IO08 为 SPI4 的一个功能引脚(我也不清楚具体作为什么功能用)，而 GPIO5_IO08 就是 SNVS_TAMPER8 的 GPIO 功能引脚。</p><p>设置 GPIO5_IO07 作为 SPI4 的片选引脚，而 GPIO5_IO07 就是 SNVS_TAMPER7的 GPIO 功能引脚。</p><p>现在我们需要 GPIO5_IO07 和 GPIO5_IO08 分别作为 ENET1 和 ENET2 的复位引脚，而不是 SPI4 的什么功能引脚，<strong>因此将示例代码 中的两行代码删除掉！！</strong>否则会干扰到网络复位引脚！</p><p>在 imx6ull-alientek-emmc.dts 里面找到名为“iomuxc_snvs”的节点(就是直接搜索)，然后在<br>此节点下添加网络复位引脚信息，添加完成以后的“iomuxc_snvs”的节点内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c">&amp;iomuxc_snvs &#123;pinctrl-names = <span class="hljs-string">&quot;default_snvs&quot;</span>;        pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_hog_2&gt;;        imx6ul-evk &#123;......        ......<span class="hljs-comment">/*enet1 reset firestaradmin*/</span>pinctrl_enet1_reset: enet1resetgrp &#123;fsl,pins = &lt;<span class="hljs-comment">/* used for enet1 reset */</span>MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 <span class="hljs-number">0x10B0</span>&gt;;&#125;;<span class="hljs-comment">/*enet2 reset firestaradmin*/</span>pinctrl_enet2_reset: enet2resetgrp &#123;fsl,pins = &lt;<span class="hljs-comment">/* used for enet2 reset */</span>MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 <span class="hljs-number">0x10B0</span>&gt;;&#125;;        &#125;;&#125;;</code></pre></div><p>最后还需要修改一下 ENET1 和 ENET2 的网络时钟引脚配置，继续在 imx6ull-lxg-emmc.dts 中找到如下所示代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c">pinctrl_enet1: enet1grp &#123;    fsl,pins = &lt;        MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1<span class="hljs-number">0x4001b009</span>    &gt;;&#125;;pinctrl_enet2: enet2grp &#123;    fsl,pins = &lt;        MX6UL_PAD_GPIO1_IO07__ENET2_MDC<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_GPIO1_IO06__ENET2_MDIO<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01<span class="hljs-number">0x1b0b0</span>        MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2<span class="hljs-number">0x4001b009</span>    &gt;;&#125;;</code></pre></div><p>两个节点中的最后一行分别为 ENET1 和 ENET2 的网络时钟引脚配置信息，<strong>将这两个引脚的电气属性值改为 0x4001b009，原来默认值为 0x4001b031</strong>。修改完成以后记得保存一下 imx6ull-lxg-emmc.dts，网络复位以及时钟引脚驱动就修改好了。</p><h4 id="2-、修改-fec1-和-和-fec2-节点的-pinctrl-0-属性"><a href="#2-、修改-fec1-和-和-fec2-节点的-pinctrl-0-属性" class="headerlink" title="2 、修改 fec1 和 和 fec2  节点的 pinctrl-0  属性"></a>2 、修改 fec1 和 和 fec2  节点的 pinctrl-0  属性</h4><p>在 imx6ull-lxg-emmc.dts 文件中找到名为“fec1”和“fec2”的这两个节点，修改其中的“pinctrl-0”属性值，修改以后如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c">&amp;fec1 &#123;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet1         &amp;pinctrl_enet1_reset&gt;;phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;phy-handle = &lt;&amp;ethphy0&gt;;status = <span class="hljs-string">&quot;okay&quot;</span>;&#125;;&amp;fec2 &#123;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet2         &amp;pinctrl_enet2_reset&gt;;phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;......    ......&#125;;</code></pre></div><h4 id="3、修改-LAN8720A-的-的-PHY-地址"><a href="#3、修改-LAN8720A-的-的-PHY-地址" class="headerlink" title="3、修改 LAN8720A 的 的 PHY 地址"></a>3、修改 LAN8720A 的 的 PHY 地址</h4><p>在 uboot 移植中，我们说过 ENET1 的 LAN8720A 地址为 0x0，ENET2 的 LAN8720A地址为 0x1。在 imx6ull-lxg-emmc.dts 中找到如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c">&amp;fec1 &#123;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet1         &amp;pinctrl_enet1_reset&gt;;phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;phy-handle = &lt;&amp;ethphy0&gt;;status = <span class="hljs-string">&quot;okay&quot;</span>;&#125;;&amp;fec2 &#123;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet2         &amp;pinctrl_enet2_reset&gt;;phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;phy-handle = &lt;&amp;ethphy1&gt;;status = <span class="hljs-string">&quot;okay&quot;</span>;mdio &#123;<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>ethphy0: ethernet-phy@<span class="hljs-number">2</span> &#123;compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;reg = &lt;<span class="hljs-number">2</span>&gt;;&#125;;ethphy1: ethernet-phy@<span class="hljs-number">1</span> &#123;compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;reg = &lt;<span class="hljs-number">1</span>&gt;;&#125;;&#125;;&#125;;</code></pre></div><p>上述代码中的</p><div class="hljs code-wrapper"><pre><code class="hljs c">mdio &#123;<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>ethphy0: ethernet-phy@<span class="hljs-number">2</span> &#123;compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;reg = &lt;<span class="hljs-number">2</span>&gt;;&#125;;ethphy1: ethernet-phy@<span class="hljs-number">1</span> &#123;compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;reg = &lt;<span class="hljs-number">1</span>&gt;;&#125;;&#125;;</code></pre></div><p>部分为mdio节点，述了 ENET1和 ENET2 的 PHY 地址信息。</p><p>将示例代码改为如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c">&amp;fec1 &#123;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet1         &amp;pinctrl_enet1_reset&gt;;phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;phy-handle = &lt;&amp;ethphy0&gt;;    phy-reset-gpios = &lt;&amp;gpio5 <span class="hljs-number">7</span> GPIO_ACTIVE_LOW&gt;;    phy-reset-duration = &lt;<span class="hljs-number">200</span>&gt;;status = <span class="hljs-string">&quot;okay&quot;</span>;&#125;;&amp;fec2 &#123;pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_enet2         &amp;pinctrl_enet2_reset&gt;;phy-mode = <span class="hljs-string">&quot;rmii&quot;</span>;phy-handle = &lt;&amp;ethphy1&gt;;    phy-reset-gpios = &lt;&amp;gpio5 <span class="hljs-number">8</span> GPIO_ACTIVE_LOW&gt;;    phy-reset-duration = &lt;<span class="hljs-number">200</span>&gt;;status = <span class="hljs-string">&quot;okay&quot;</span>;mdio &#123;<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span>ethphy0: ethernet-phy@<span class="hljs-number">0</span> &#123;compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;            smsc,disable-energy-detect;reg = &lt;<span class="hljs-number">0</span>&gt;;&#125;;ethphy1: ethernet-phy@<span class="hljs-number">1</span> &#123;compatible = <span class="hljs-string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;            smsc,disable-energy-detect;reg = &lt;<span class="hljs-number">1</span>&gt;;&#125;;&#125;;&#125;;</code></pre></div><p>先是添加了 ENET1 网络复位引脚所使用的 IO 为 GPIO5_IO07，低电平有效。复位低电平信号持续时间为 200ms。</p><p>然后添加ENET2 网络复位引脚所使用的 IO 为 GPIO5_IO08，同样低电平有效，持续时间同样为 200ms。</p><p>“smsc,disable-energy-detect”表明 PHY 芯片是 SMSC 公司的，这样 Linux内核就会找到 SMSC 公司的 PHY 芯片驱动来驱动 LAN8720A。</p><p>注意“ethernet-phy@”后面的数字是 PHY 的地址，ENET1 的 PHY 地址为 0，所以“@”后面是 0(默认为 2)。</p><p>reg 的值也表示 PHY 地址，ENET1 的 PHY 地址为 0，所以 reg&#x3D;0。</p><p>至此，LAN8720A 的 PHY 地址就改好了，保存一下 imx6ull-lxg-emmc.dts 文件。然后使用“make dtbs”命令重新编译一下设备树。</p><h4 id="4、修改-fec-main-c-文件"><a href="#4、修改-fec-main-c-文件" class="headerlink" title="4、修改 fec_main.c  文件"></a>4、修改 fec_main.c  文件</h4><p>要 在 I.MX6ULL 上 使 用 LAN8720A ， 需 要 修 改 一 下 Linux 内 核 源 码 ， 打 开drivers&#x2F;net&#x2F;ethernet&#x2F;freescale&#x2F;fec_main.c，找到函数 fec_probe，在 fec_probe 中加入如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><span class="hljs-title function_">fec_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fec_enet_private</span> *<span class="hljs-title">fep</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fec_platform_data</span> *<span class="hljs-title">pdata</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">ndev</span>;</span><span class="hljs-type">int</span> i, irq, ret = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">r</span>;</span><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">of_id</span>;</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> dev_id;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span> =</span> pdev-&gt;dev.of_node, *phy_node;<span class="hljs-type">int</span> num_tx_qs;<span class="hljs-type">int</span> num_rx_qs;<span class="hljs-comment">/* 设置 MX6UL_PAD_ENET1_TX_CLK 和 MX6UL_PAD_ENET2_TX_CLK</span><span class="hljs-comment">* 这两个 IO 的复用寄存器的 SION 位为 1。</span><span class="hljs-comment">*/</span><span class="hljs-type">void</span> __iomem *IMX6U_ENET1_TX_CLK;<span class="hljs-type">void</span> __iomem *IMX6U_ENET2_TX_CLK;IMX6U_ENET1_TX_CLK = ioremap(<span class="hljs-number">0X020E00DC</span>, <span class="hljs-number">4</span>);writel(<span class="hljs-number">0X14</span>, IMX6U_ENET1_TX_CLK);IMX6U_ENET2_TX_CLK = ioremap(<span class="hljs-number">0X020E00FC</span>, <span class="hljs-number">4</span>);writel(<span class="hljs-number">0X14</span>, IMX6U_ENET2_TX_CLK);fec_enet_get_queue_num(pdev, &amp;num_tx_qs, &amp;num_rx_qs);<span class="hljs-comment">/* Init network device */</span>ndev = alloc_etherdev_mqs(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fec_enet_private),  num_tx_qs, num_rx_qs);......</code></pre></div><p>如果要在 I.MX6ULL 上使用 LAN8720A 就需要设置ENET1 和 ENET2 的 TX_CLK 引脚复位寄存器的 SION 位为 1。</p><h4 id="5、配置-Linux-内核，使能-LAN8720-驱动"><a href="#5、配置-Linux-内核，使能-LAN8720-驱动" class="headerlink" title="5、配置 Linux  内核，使能 LAN8720  驱动"></a>5、配置 Linux  内核，使能 LAN8720  驱动</h4><p>输入命令“make menuconfig”，打开图形化配置界面，选择使能 LAN8720A 的驱动，路径如下：<br>-&gt; Device Drivers<br>    -&gt; Network device support<br>        -&gt; PHY Device support and infrastructure<br>            -&gt; Drivers for SMSC PHYs</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819160409699.png" alt="image-20200819160409699"></p><p>图中选择将“Drivers for SMSC PHYs”编译到 Linux 内核中，因此“&lt;&gt;”里面变为了“*”。LAN8720A 是 SMSC 公司出品的，因此勾选这个以后就会编译 LAN8720 驱动，配置好以后退出配置界面，然后重新编译一下 Linux 内核。</p><h4 id="6、修改-smsc-c-文件"><a href="#6、修改-smsc-c-文件" class="headerlink" title="6、修改 smsc.c  文件"></a>6、修改 smsc.c  文件</h4><p>在修改 smsc.c 文件之前先说点题外话，那就是我是怎么确定要修改 smsc.c 这个文件的。在写本书之前我并没有修改过 smsc.c 这个文件，都是使能 LAN8720A 驱动以后就直接使用。但是我在测试 NFS 挂载文件系统的时候发现文件系统挂载成功率很低！老是提示 NFS 服务器找不到，三四次就有一次挂载失败！很折磨人。NFS 挂载就是通过网络来挂载文件系统，这样做的好处就是方便我们后续调试 Linux 驱动。既然老是挂载失败那么可以肯定的是网络驱动有问题，网络驱动分两部分：内部 MAC+外部 PHY，内部 MAC 驱动是由 NXP 提供的，一般不会出问题，否则的话用户早就给 NXP 反馈了。而且我用 NXP 官方的开发板测试网络是一直正常的，但是 NXP 官方的开发板所使用的 PHY 芯片为KSZ8081。所以只有可能是外部 PHY，也就是LAN8720A 的驱动可能出问题了。</p><p>鉴于 LAN8720A有“前车之鉴”，那就是在 uboot 中需要对LAN8720A 进行一次软复位，要设置LAN8720A 的 BMCR(寄存器地址为 0)寄存器 bit15 为 1。所以我猜测，在 Linux 中也需要对 LAN8720A 进行一次软复位。首先需要找到 LAN8720A 的驱动文件，LAN8720A 的驱动文件是 drivers&#x2F;net&#x2F;phy&#x2F;smsc.c，在此文件中有个叫做 smsc_phy_reset 的函数，看名字都知道这是 SMSC PHY 的复位函数，因此，LAN8720A 肯定也会使用到这个复位函数，修改此函数的内容，修改以后的 smsc_phy_reset函数内容如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smsc_phy_reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> phy_device *phydev)</span>&#123;    <span class="hljs-comment">//添加的内容如下</span>    <span class="hljs-type">int</span> err, phy_reset;    <span class="hljs-type">int</span> msec = <span class="hljs-number">1</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span>    <span class="hljs-type">int</span> timeout = <span class="hljs-number">50000</span>;    <span class="hljs-keyword">if</span>(phydev-&gt;addr == <span class="hljs-number">0</span>) <span class="hljs-comment">/* FEC1 */</span> &#123;        <span class="hljs-comment">/*获取 FEC1 网卡对应的设备节点。*/</span>        np = of_find_node_by_path(<span class="hljs-string">&quot;/soc/aips-bus@02100000/ethernet@02188000&quot;</span>);        <span class="hljs-keyword">if</span>(np == <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">return</span> -EINVAL;        &#125;    &#125;    <span class="hljs-keyword">if</span>(phydev-&gt;addr == <span class="hljs-number">1</span>) <span class="hljs-comment">/* FEC2 */</span> &#123;        <span class="hljs-comment">/*获取 FEC2 网卡对应的设备节点。*/</span>        np = of_find_node_by_path(<span class="hljs-string">&quot;/soc/aips-bus@02000000/ethernet@020b4000&quot;</span>);        <span class="hljs-keyword">if</span>(np == <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">return</span> -EINVAL;        &#125;    &#125;    <span class="hljs-comment">/*从设备树中获取“phy-reset-duration”属性信息，也就是复位时间。*/</span>    err = of_property_read_u32(np, <span class="hljs-string">&quot;phy-reset-duration&quot;</span>, &amp;msec);    <span class="hljs-comment">/* A sane reset duration should not be longer than 1s */</span>    <span class="hljs-keyword">if</span> (!err &amp;&amp; msec &gt; <span class="hljs-number">1000</span>)        msec = <span class="hljs-number">1</span>;    <span class="hljs-comment">/*从设备树中获取“phy-reset-gpios”属性信息，也就是复位 IO。*/</span>    phy_reset = of_get_named_gpio(np, <span class="hljs-string">&quot;phy-reset-gpios&quot;</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (!gpio_is_valid(phy_reset))        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">/*设置 PHY 的复位 IO，复位 LAN8720A*/</span>    gpio_direction_output(phy_reset, <span class="hljs-number">0</span>);    gpio_set_value(phy_reset, <span class="hljs-number">0</span>);    msleep(msec);    gpio_set_value(phy_reset, <span class="hljs-number">1</span>);        <span class="hljs-type">int</span> rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);<span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> rc;<span class="hljs-comment">/* If the SMSC PHY is in power down mode, then set it</span><span class="hljs-comment"> * in all capable mode before using it.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span> ((rc &amp; MII_LAN83C185_MODE_MASK) == MII_LAN83C185_MODE_POWERDOWN) &#123;<span class="hljs-type">int</span> timeout = <span class="hljs-number">50000</span>;<span class="hljs-comment">/* set &quot;all capable&quot; mode and reset the phy */</span>rc |= MII_LAN83C185_MODE_ALL;phy_write(phydev, MII_LAN83C185_SPECIAL_MODES, rc);&#125;    <span class="hljs-comment">/*这里我们将软复位代码移出来，这样每次调用 smsc_phy_reset 函数 LAN8720A 都会被软复位*/</span>    phy_write(phydev, MII_BMCR, BMCR_RESET);    <span class="hljs-comment">/* wait end of reset (max 500 ms) */</span>    <span class="hljs-keyword">do</span> &#123;        udelay(<span class="hljs-number">10</span>);        <span class="hljs-keyword">if</span> (timeout-- == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        rc = phy_read(phydev, MII_BMCR);    &#125; <span class="hljs-keyword">while</span> (rc &amp; BMCR_RESET);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>最后我们还需要在 drivers&#x2F;net&#x2F;phy&#x2F;smsc.c 文件中添加两个头文件，因为修改后的smsc_phy_reset 函数用到了 gpio_direction_output 和 gpio_set_value 这两个函数，需要添加的头文件如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span></span></code></pre></div><h4 id="7、网络驱动测试"><a href="#7、网络驱动测试" class="headerlink" title="7、网络驱动测试"></a>7、网络驱动测试</h4><p>修改好设备树和 Linux 内核以后重新编译一下，得到新的 zImage 镜像文件和 imx6ull-lxg-emmc.dtb设备树文件，使用网线将 I.MX6U-ALPHA 开发板的两个网口与路由器或者电脑连接起来，最后使用新的文件启动 Linux 内核。启动以后使用“ifconfig”命令查看一下当前活动的网卡有哪些，结果如图 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162229077.png" alt="image-20200819162229077"></p><p>从图可以看出，当前没有活动的网卡。</p><p>输入命令“ifconfig -a”来查看一下开发板中存在的所有网卡，结果如图所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162256490.png" alt="image-20200819162256490"></p><p>图中 can0 和 can1 为 CAN 接口的网卡，eth0 和 eth1 才是网络接口的网卡，其中eth0 对应于 ENET2，eth1 对应于 ENET1。使用如下命令依次打开 eth0 和 eth1 这两个网卡：</p><div class="hljs code-wrapper"><pre><code class="hljs vim">ifconfig eth0 <span class="hljs-keyword">up</span>ifconfig eth1 <span class="hljs-keyword">up</span></code></pre></div><p>网卡的打开过程如图 37.4.3.4 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162751401.png" alt="image-20200819162751401"></p><p>可以看到“SMSC LAN8710&#x2F;LAN8720”字样，说明当前的网络驱动使用的就是我们前面使能的 SMSC 驱动。再次输入“ifconfig”命令来查看一下当前活动的网卡，结果如图所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162818948.png" alt="image-20200819162818948"></p><p>可以看出，此时 eth0 和 eth1 两个网卡都已经打开，并且工作正常，但是这两个网卡都还没<br>有 IP 地址，所以不能进行 ping 等操作。使用如下命令给两个网卡配置 IP 地址：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">ifconfig eth0 192.168.0.251ifconfig eth1 192.168.0.252</code></pre></div><p>上述命令配置 eth0 和 eth1 这两个网卡的 IP 地址，注意 IP 地址选择的合理性，一定要和自己的电脑处于同一个网段内，并且没有被其他的设备占用！</p><p>设置好以后，使用“ping”命令来 ping 一下自己的主机，如果能 ping 通那说明网络驱动修改成功！比如我的 Ubuntu 主机 IP 地址为 192.168.0.111，使用如下命令 ping 一下：ping 192.168.0.111<br>结果如图 37.4.3.6 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819162957546.png" alt="image-20200819162957546"></p><h4 id="8、保存修改后的图形化配置文件"><a href="#8、保存修改后的图形化配置文件" class="headerlink" title="8、保存修改后的图形化配置文件"></a>8、保存修改后的图形化配置文件</h4><p>在修改网络驱动的时候我们通过图形界面使能了 LAN8720A 的驱动，使能以后会在.config中存在如下代码：<br><code>CONFIG_SMSC_PHY=y</code><br>打开 drivers&#x2F;net&#x2F;phy&#x2F;Makefile，有如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">obj-$(CONFIG_SMSC_PHY) += smsc.o</code></pre></div><p>当 CONFIG_SMSC_PHY&#x3D;y 的时候就会编译 smsc.c 这个文件，smsc.c 就是 LAN8720A 的驱动文件。但是当我们执行“make clean”清理工程以后.config 文件就会被删除掉，因此我们所有的配置内容都会丢失，结果就是前功尽弃，一“删”回到解放前！所以我们在配置完图形界面以后经过测试没有问题，就必须要保存一下配置文件。保存配置的方法有两个。</p><h5 id="1、直接另存为-config-文件"><a href="#1、直接另存为-config-文件" class="headerlink" title="1、直接另存为.config 文件"></a>1、直接另存为.config 文件</h5><p>既然图形化界面配置后的配置项保存在.config 中，那么就简单粗暴，直接将.config 文件另存为 imx_lxg_emmc_defconfig，然后其复制到 arch&#x2F;arm&#x2F;configs 目录下，替换以前的imx_lxg_emmc_defconfig。这样以后执行“make imx_lxg_emmc_defconfig”重新配置Linux 内核的时候就会使用新的配置文件，默认就会使能 LAN8720A 的驱动。</p><h5 id="2、通过图形界面保存配置文件"><a href="#2、通过图形界面保存配置文件" class="headerlink" title="2、通过图形界面保存配置文件"></a>2、通过图形界面保存配置文件</h5><p>相比于第 1 种直接另存为.config 文件，第 2 种方法就很“文雅”了，在图形界面中保存配置文件，在图形界面中会有“&lt; Save &gt;”选项，如图 37.4.4.1 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819163450607.png" alt="image-20200819163450607"></p><p>通过键盘的“→”键，移动到“&lt; Save &gt;”选项，然后按下回车键，打开文件名输入对话框，<br>如图 37.4.4.2 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819163502121.png" alt="image-20200819163502121"></p><p>在图 中输入要保存的文件名，可以带路径，一般是相对路径(相对于 Linux 内核源码根目录)。比如我们要将新的配置文件保存到目录 arch&#x2F;arm&#x2F;configs 下，文件名为imx_lxg_emmc_defconfig，也就是用新的配置文件替换掉老的默认配置文件。那么我们在图中输入 “arch&#x2F;arm&#x2F;configs&#x2F;imx_lxg_emmc_defconfig”即可，如图 37.4.4.3 所示：</p><p><img src="/2020/09/07/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/8.linux-kernel%E7%A7%BB%E6%A4%8D/image-20200819163905798.png" alt="image-20200819163905798"></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7| uboot移植</title>
    <link href="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/"/>
    <url>/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="uboot移植"><a href="#uboot移植" class="headerlink" title="uboot移植"></a>uboot移植</h1><h2 id="一、获取uboot"><a href="#一、获取uboot" class="headerlink" title="一、获取uboot"></a>一、获取uboot</h2><p>uboot官网的源码，对某一芯片的支持肯定没有原厂完善，所以一般选择原厂的uboot源码。</p><p>这里我们以 NXP 官方的 uboot 移植到正点原子的 I.MX6ULL 开发板上为例。</p><h3 id="uboot官网下载"><a href="#uboot官网下载" class="headerlink" title="uboot官网下载"></a>uboot官网下载</h3><p><code>http://www.denx.de/wiki/U-Boot/</code></p><p>选择源码</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174610893.png" alt="image-20200817174610893"></p><p>ftp下载</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174626000.png" alt="image-20200817174626000">    选择要下载的版本</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817174641016.png" alt="image-20200817174641016"></p><h3 id="从你的板子参考厂商获取修改过的uboot"><a href="#从你的板子参考厂商获取修改过的uboot" class="headerlink" title="从你的板子参考厂商获取修改过的uboot"></a>从你的板子参考厂商获取修改过的uboot</h3><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817175657019.png" alt="image-20200817175657019"></p><p>首先 uboot 官方的基本是不会用的，因为支持太弱了。最常用的就是半导体厂商或者开发板厂商的 uboot，如果你用的半导体厂商的评估板，那么就使用半导体厂商的 uboot，如果你是购买的第三方开发板，比如正点原子的 I.MX6ULL 开发板，那么就使用正点原子提供的 uboot 源码（也是在半导体厂商的 uboot 上修改的）。当然了，你也可以在购买了第三方开发板以后使用半导体厂商提供的 uboot，只不过有些外设驱动可能不支持，需要自己移植，这个就是我们常说的 uboot 移植</p><p>uboot 的移植并不是说我们完完全全的从零开始将 uboot 移植到我们现在所使用的开发板或者开发平台上。这个对于我们来说基本是不可能的，这个工作一般是半导体厂商做的，半导<br>体厂商负责将 uboot 移植到他们的芯片上，因此半导体厂商都会自己做一个开发板，这个开发板就叫做原厂开发板。半导体厂商会将 uboot 移植到他们自己的原厂开发板上，测试好以后就会将这个 uboot 发布出去，这就是大家常说的原厂 BSP 包。</p><h2 id="二、uboot初次编译"><a href="#二、uboot初次编译" class="headerlink" title="二、uboot初次编译"></a>二、uboot初次编译</h2><p>首先在 Ubuntu 中安装 ncurses 库，否则编译会报错，安装命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install libncurses5-dev</code></pre></div><h3 id="1-解压uboot源码"><a href="#1-解压uboot源码" class="headerlink" title="1.解压uboot源码"></a>1.解压uboot源码</h3><p>获取uboot源码后，解压uboot得到这样一个目录</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817183254084.png" alt="image-20200817183254084"></p><h3 id="2-配置源码"><a href="#2-配置源码" class="headerlink" title="2.配置源码"></a>2.配置源码</h3><p>在目录下configs里找到默认的配置文件</p><p>如IMX6uLL的官方开发板EVK的配置文件为</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817183701255.png" alt="image-20200817183701255"></p><p>使用<code>make xxx_defconfig</code>命令即可配置 uboot，比如：**(注意要在uboot根目录输入命令)**</p><div class="hljs code-wrapper"><pre><code class="hljs sh">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_evk_emmc_defconfig</code></pre></div><h3 id="3-编译源码"><a href="#3-编译源码" class="headerlink" title="3.编译源码"></a>3.编译源码</h3><p>编译 NXP  官方开发板对应的 uboot:</p><div class="hljs code-wrapper"><pre><code class="hljs sh">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</code></pre></div><ul><li><code>V=1</code> 查看完整的编译信息</li><li><code>-j12</code>12核编译</li></ul><hr><p>这里每次输入那么长，很麻烦，可以直接在Makefile里给<code>ARCH</code> 和<code>CORSS_COMPILE </code>赋值, 或者可以写个SHELL脚本</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200817192750821.png" alt="image-20200817192750821"></p><p>这样我们就可以使用如下简短的命令来编译 uboot 了：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">make mx6ull_14x14_evk_emmc_defconfigmake V=1 -j16</code></pre></div><h3 id="4-烧写未修改过的uboot测试"><a href="#4-烧写未修改过的uboot测试" class="headerlink" title="4.烧写未修改过的uboot测试"></a>4.烧写未修改过的uboot测试</h3><p><code>sudo fdisk -l</code>查看当前储存设备。</p><p>将 imxdownload 软件拷贝到 uboot 源码根目录下然后使用 imxdownload 软件将 u-boot.bin烧写到 SD 卡中，烧写命令如下：<br><code>chmod 777 imxdownload</code> 给予 imxdownload 可执行权限<br><code>./imxdownload u-boot.bin /dev/sdb </code> 烧写 u-boot.bin 到 SD 卡中</p><h2 id="三、移植uboot"><a href="#三、移植uboot" class="headerlink" title="三、移植uboot"></a>三、移植uboot</h2><h3 id="1-添加开发板默认配置文件"><a href="#1-添加开发板默认配置文件" class="headerlink" title="1.添加开发板默认配置文件"></a>1.添加开发板默认配置文件</h3><p>先在 configs 目录下创建默认配置文件，复制 mx6ull_14x14_evk_emmc_defconfig，然后重<br>命名为 mx6ull_alientek_emmc_defconfig，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> configs<span class="hljs-built_in">cp</span> mx6ull_14x14_evk_emmc_defconfig mx6ull_lxg_emmc_defconfig</code></pre></div><p>然后将文件 mx6ull_lxg_emmc_defconfig 中的内容改成下面的：<br>示例代码 33.2.1.1 mx6ull_alientek_emmc_defconfig 文件</p><div class="hljs code-wrapper"><pre><code class="hljs c">CONFIG_SYS_EXTRA_OPTIONS=<span class="hljs-string">&quot;IMX_CONFIG=board/freescale/mx6ull_lxg_emmc/imximage.cfg,MX6ULL_EVK_EMMC_REWORK&quot;</span>CONFIG_ARM=yCONFIG_ARCH_MX6=yCONFIG_TARGET_MX6ULL_LXG_EMMC=yCONFIG_CMD_GPIO=y</code></pre></div><p>mx6ull_lxg_emmc_defconfig 基本和 mx6ull_14x14_evk_emmc_defconfig 中<br>的内容一样，只是第 1 行和第 4 行做了修改。</p><h3 id="2-添加开发板对应头文件"><a href="#2-添加开发板对应头文件" class="headerlink" title="2.添加开发板对应头文件"></a>2.添加开发板对应头文件</h3><p>在目录include&#x2F;configs 下添加 I.MX6ULL-ALPHA 开发板对应的头文件</p><p>复制<code>include/configs/mx6ullevk.h</code>，并重命名为 <code>mx6ull_lxg_emmc.h</code>，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> include/configs/mx6ullevk.h include/configs/mx6ull_lxg_emmc.h</code></pre></div><p>拷贝完成以后编辑文件，将：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MX6ULLEVK_CONFIG_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MX6ULLEVK_CONFIG_H</span></code></pre></div><p>改为：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MX6ULL_LXG_EMMC_CONFIG_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MX6ULL_LXG_EMMC_CONFIG_H</span></code></pre></div><p>mx6ull_lxg_emmc.h 里面有很多宏定义，这些宏定义基本用于配置 uboot，也有一些I.MX6ULL 的配置项目。如果我们自己要想使能或者禁止 uboot 的某些功能，那就在mx6ull_lxg_emmc.h 里面做修改即可。</p><h3 id="3-添加开发板对应的板级文件夹"><a href="#3-添加开发板对应的板级文件夹" class="headerlink" title="3.添加开发板对应的板级文件夹"></a>3.添加开发板对应的板级文件夹</h3><p>uboot 中每个板子都有一个对应的文件夹来存放板级文件，比如开发板上外设驱动文件等等。</p><p>NXP 的 I.MX 系列芯片的所有板级文件夹都存放在<code>board/freescale</code>目录下，在这个目录下有个名为 <code>mx6ullevk</code> 的文件夹，这个文件夹就是 NXP 官方 I.MX6ULL EVK 开发板的板级文件夹。复制 <code>mx6ullevk</code>，将其重命名为 <code>mx6ull_lxg_emmc</code>，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> board/freescale/<span class="hljs-built_in">cp</span> mx6ullevk/ -r mx6ull_lxg_emmc</code></pre></div><p>进 入 mx6ull_alientek_emmc 目录中，将其中的 mx6ullevk.c 文件重命名为<code>mx6ull_lxg_emmc.c</code></p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> mx6ull_lxg_emmc<span class="hljs-built_in">mv</span> mx6ullevk.c mx6ull_lxg_emmc.c</code></pre></div><p>我们还需要对<code> mx6ull_lxg_emmc</code>目录下的文件做一些修改：</p><ul><li><p><strong>修改 mx6ull_lxg_emmc  目录下的 Makefile 如下</strong></p><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># (C) Copyright 2015 Freescale Semiconductor, Inc.</span><span class="hljs-comment">#</span><span class="hljs-comment"># SPDX-License-Identifier:GPL-2.0+</span><span class="hljs-comment">#</span>obj-y  := mx6ull_lxg_emmc.oextra-<span class="hljs-variable">$(CONFIG_USE_PLUGIN)</span> :=  plugin.bin<span class="hljs-variable">$(obj)</span>/plugin.bin: <span class="hljs-variable">$(obj)</span>/plugin.o<span class="hljs-variable">$(OBJCOPY)</span> -O binary --gap-fill 0xff <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$@</span></code></pre></div></li><li><p><strong>修改 mx6ull_lxg_emmc  目录下的 imximage.cfg</strong> </p><p>将 imximage.cfg 中的下面一句：<br><code>PLUGIN board/freescale/mx6ullevk/plugin.bin 0x00907000</code><br>改为：<br><code>PLUGIN board/freescale/mx6ull_lxg_emmc /plugin.bin 0x00907000</code></p></li><li><p><strong>修改 mx6ull_alientek_emmc  目录下的 Kconfig</strong> </p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> TARGET_MX6ULL_LXG_EMMCconfig SYS_BOARD<span class="hljs-keyword">default</span> <span class="hljs-string">&quot;mx6ull_lxg_emmc&quot;</span>config SYS_VENDOR<span class="hljs-keyword">default</span> <span class="hljs-string">&quot;freescale&quot;</span>config SYS_SOC<span class="hljs-keyword">default</span> <span class="hljs-string">&quot;mx6&quot;</span>config SYS_CONFIG_NAME<span class="hljs-keyword">default</span> <span class="hljs-string">&quot;mx6ull_lxg_emmc&quot;</span>endif</code></pre></div></li><li><p><strong>修改 mx6ull_alientek_emmc  目录下的 MAINTAINERS</strong> </p><p>修改 MAINTAINERS 文件，修改后的内容如下</p><div class="hljs code-wrapper"><pre><code class="hljs dts">MX6ULLEVK BOARD<span class="hljs-symbol">M:</span>Peng Fan <span class="hljs-params">&lt;peng.fan@nxp.com&gt;</span><span class="hljs-symbol">S:</span>Maintained<span class="hljs-symbol">F:</span>board<span class="hljs-keyword">/freescale/</span>mx6ull_lxg_emmc/<span class="hljs-symbol">F:</span>include<span class="hljs-keyword">/configs/</span>mx6ull_lxg_emmc.h<span class="hljs-symbol">F:</span>configs/mx6ull_lxg_defconfig</code></pre></div></li></ul><h3 id="4-修改U-Boot图形界面配置文件"><a href="#4-修改U-Boot图形界面配置文件" class="headerlink" title="4.修改U-Boot图形界面配置文件"></a>4.修改U-Boot图形界面配置文件</h3><p>uboot 是支持图形界面配置，关于 uboot 的图形界面配置下一章会详细的讲解。修改文件<code>arch/arm/cpu/armv7/mx6/Kconfig</code>(如果用的 I.MX6UL 的话，应该修改 <code>arch/arm/Kconfig </code>这个文<br>件)</p><ul><li>在 207 行加入如下内容：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs csharp">config TARGET_MX6ULL_LXG_EMMC<span class="hljs-built_in">bool</span> <span class="hljs-string">&quot;Support mx6ull_lxg_emmc&quot;</span><span class="hljs-keyword">select</span> MX6ULL<span class="hljs-keyword">select</span> DM<span class="hljs-keyword">select</span> DM_THERMAL</code></pre></div><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818200355231.png" alt="image-20200818200355231"></p><ul><li>在最后一行的 endif 的前一行添加如下内容:</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> <span class="hljs-string">&quot;board/freescale/mx6ull_lxg_emmc/Kconfig&quot;</span></code></pre></div><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818200505813.png" alt="image-20200818200505813"></p><hr><p>到此为止，I.MX6U-ALPHA 开发板就已经添加到 uboot 中了，接下来就是编译这个新添加<br>的开发板。</p><h3 id="5-使用新添加的板子配置编译uboot"><a href="#5-使用新添加的板子配置编译uboot" class="headerlink" title="5.使用新添加的板子配置编译uboot"></a>5.使用新添加的板子配置编译uboot</h3><p>在uboot根目录下新建一个名为 <code>mx6ull_lxg_emmc.sh</code> 的 shell 脚本，在这个shell脚本里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash">!/bin/bash</span>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distcleanmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_lxg_emmc_defconfigmake V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</code></pre></div><p>第3行我们使用的默认配置文件就是之前新建的 <code>mx6ull_alientek_emmc_defconfig</code>这个配置文件。</p><p>给予 <code>mx6ull_lxg_emmc.sh</code> 可执行权限，然后运行脚本来完成编译，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 mx6ull_alientek_emmc.sh ./mx6ull_alientek_emmc.sh</code></pre></div><p>等待编译完成，编译完成以后输入如下命令，查看一下之前添加的<code>mx6ull_lxg_emmc.h</code>这个头文件有没有被引用, 输入命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">grep -nR <span class="hljs-string">&quot;`mx6ull_lxg_emmc.h&quot;</span></code></pre></div><p>如果有很多文件都引用了<code>mx6ull_lxg_emmc.h</code>这个头文件，那就说明新板子添加成功，</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818201707668.png" alt="image-20200818201707668"></p><p>编译完成以后就使用 imxdownload 将新编译出来的 u-boot.bin 烧写到 SD 卡中测试</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818203813549.png" alt="image-20200818203813549"></p><p>从图中第一行的编译时间可以看出，这是我们刚刚编译的uboot，此时的 Board 还是“MX6ULL 14x14 EVK”，因为我们参考的 NXP官方的 I.MX6ULL 开发板来添加自己的开发板。接了 LCD 屏幕的话会发现 LCD 屏幕并没有显示 NXP 的 logo，而且从图可以看出此时的网络同样也没识别出来。如果你的开发板和官方的有些区别，默认uboot中的LCD 驱动和网络驱动是有问题的，需要修改。</p><h3 id="6-LCD驱动修改"><a href="#6-LCD驱动修改" class="headerlink" title="6.LCD驱动修改"></a>6.LCD驱动修改</h3><p>一般 uboot 中修改驱动基本都是在 xxx.h 和 xxx.c 这两个文件中进行的，xxx 为板子名称，比如 mx6ull_lxg_emmc.h 和 mx6ull_lxg_emmc.c 这两个文件。<br>一般修改 LCD 驱动重点注意以下几点：<br><strong>①、LCD 所使用的 GPIO，查看 uboot 中 LCD 的 IO 配置是否正确。</strong><br><strong>②、LCD 背光引脚 GPIO 的配置。</strong><br><strong>③、LCD 配置参数是否正确。</strong></p><p>这里以正点原子的 I.MX6U-ALPHA 开发板 为例：</p><p>LCD 原理图和 NXP 官方 I.MX6ULL 开发板一致，也就是 LCD 的 IO 和背光 IO 都一样的，所以 IO 部分就不用修改了。需要修改的只有 LCD 参数，打开文件 mx6ull_lxg_emmc.c，找到如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">display_info_t</span> <span class="hljs-title">const</span> <span class="hljs-title">displays</span>[] =</span> &#123;&#123;.bus = MX6UL_LCDIF1_BASE_ADDR,.addr = <span class="hljs-number">0</span>,.pixfmt = <span class="hljs-number">24</span>,.detect = <span class="hljs-literal">NULL</span>,.enable= do_enable_parallel_lcd,.mode= &#123;.name= <span class="hljs-string">&quot;TFT43AB&quot;</span>,.xres           = <span class="hljs-number">480</span>,.yres           = <span class="hljs-number">272</span>,.pixclock       = <span class="hljs-number">108695</span>,.left_margin    = <span class="hljs-number">8</span>,.right_margin   = <span class="hljs-number">4</span>,.upper_margin   = <span class="hljs-number">2</span>,.lower_margin   = <span class="hljs-number">4</span>,.hsync_len      = <span class="hljs-number">41</span>,.vsync_len      = <span class="hljs-number">10</span>,.sync           = <span class="hljs-number">0</span>,.vmode          = FB_VMODE_NONINTERLACED&#125; &#125; &#125;;</code></pre></div><p>示例代码中定义了一个变量 displays, 类型为 display_info_t，这个结构体是 LCD信息结构体，其中包括了 LCD 的分辨率，像素格式，LCD 的各个参数等。</p><p>display_info_t 定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;imx-common&#x2F;video.h 中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">display_info_t</span> &#123;</span><span class="hljs-type">int</span>bus;<span class="hljs-type">int</span>addr;<span class="hljs-type">int</span>pixfmt;<span class="hljs-type">int</span>(*detect)(<span class="hljs-keyword">struct</span> <span class="hljs-type">display_info_t</span> <span class="hljs-type">const</span> *dev);<span class="hljs-type">void</span>(*enable)(<span class="hljs-keyword">struct</span> <span class="hljs-type">display_info_t</span> <span class="hljs-type">const</span> *dev);<span class="hljs-class"><span class="hljs-keyword">struct</span><span class="hljs-title">fb_videomode</span> <span class="hljs-title">mode</span>;</span>&#125;;</code></pre></div><p><code>pixfmt </code>是像素格式，也就是一个像素点是多少位，如果是 RGB565 的话就是 16 位，如果是 888 的话就是 24 位，一般使用 RGB888。</p><p>结构体 display_info_t 还有个 <code>mode</code> 成员变量，此成员变量也是个结构体，为 <code>fb_videomode</code>，定义在文件 include&#x2F;linux&#x2F;fb.h 中，定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_videomode</span> &#123;</span><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-comment">/* optional */</span>u32 refresh;<span class="hljs-comment">/* optional */</span>u32 xres;u32 yres;u32 pixclock;u32 left_margin;u32 right_margin;u32 upper_margin;u32 lower_margin;u32 hsync_len;u32 vsync_len;u32 sync;u32 vmode;u32 flag;&#125;;</code></pre></div><p>结构体 <code>fb_videomode</code> 里面的成员变量为 LCD 的参数，这些成员变量函数如下：</p><ul><li>name ：LCD 名字，要和环境变量中的 panel 相等。</li><li>xres 、yres ：LCD X 轴和 Y 轴像素数量。</li><li>pixclock：像素时钟，每个像素时钟周期的长度，单位为皮秒。</li><li>left_margin ：HBP，水平同步后肩。</li><li>right_margin ：HFP，水平同步前肩。</li><li>upper_margin：VBP，垂直同步后肩。</li><li>lower_margin：VFP，垂直同步前肩。</li><li>hsync_len ：HSPW，行同步脉宽。</li><li>vsync_len：VSPW，垂直同步脉宽。</li><li>vmode ：大多数使用 FB_VMODE_NONINTERLACED，也就是不使用隔行扫描。</li></ul><p>可以看出，这些参数与裸机驱动 RGB LCD 的时候参数基本一样，唯一不同的像素时钟 pixclock 的含义不同，以正点原子的 7 寸 1024x600 分辨率的屏幕(ATK7016)为例，屏幕要求的像素时钟为 51.2MHz，因此：<br>pixclock&#x3D;(1&#x2F;51200000)*10^12&#x3D;19531</p><p>在根据其他的屏幕参数，可以得出 ATK7016 屏幕的配置参数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">display_info_t</span> <span class="hljs-title">const</span> <span class="hljs-title">displays</span>[] =</span> &#123;&#123;.bus = MX6UL_LCDIF1_BASE_ADDR,.addr = <span class="hljs-number">0</span>,.pixfmt = <span class="hljs-number">24</span>,.detect = <span class="hljs-literal">NULL</span>,.enable= do_enable_parallel_lcd,.mode= &#123;.name= <span class="hljs-string">&quot;TFT7016&quot;</span>,.xres           = <span class="hljs-number">1024</span>,.yres           = <span class="hljs-number">600</span>,.pixclock       = <span class="hljs-number">19531</span>,.left_margin    = <span class="hljs-number">140</span>,.right_margin   = <span class="hljs-number">160</span>,.upper_margin   = <span class="hljs-number">20</span>,.lower_margin   = <span class="hljs-number">12</span>,.hsync_len      = <span class="hljs-number">20</span>,.vsync_len      = <span class="hljs-number">3</span>,.sync           = <span class="hljs-number">0</span>,.vmode          = FB_VMODE_NONINTERLACED&#125; &#125; &#125;;</code></pre></div><p>使用示例代码中的屏幕参数替换掉 mx6ull_lxg_emmc.c 中 uboot 默认的屏幕参数。</p><p>打开 mx6ull_lxg_emmc.h，找到所有如下语句：</p><div class="hljs code-wrapper"><pre><code class="hljs c">panel=TFT43AB</code></pre></div><p>将其改为：</p><div class="hljs code-wrapper"><pre><code class="hljs c">panel=TFT7016</code></pre></div><p>也就是设置 panel 为 TFT7016，panel 的值要与display_info_t结构体变量中的.name 成员变量的值<br>一致。修改完成以后重新编译一遍 uboot 并烧写到 SD 中启动。</p><p>重启以后 LCD 驱动一般就会工作正常了，LCD 上回显示 NXP 的 logo。但是有可能会遇到LCD 并没有工作，还是黑屏，这是什么原因呢？在 uboot 命令模式输入“print”来查看环境变量 panel 的值，会发现 panel 的值是 TFT43AB(或其他的，反正不是 TFT7016)</p><p>这是因为之前有将环境变量保存到 EMMC 中，uboot 启动以后会先从 EMMC 中读取环境变量，如果EMMC 中没有环境变量的话才会使用 mx6ull_alientek_emmc.h 中的默认环境变量。如果 EMMC 中的环境变量panel 不等于 TFT7016，那么 LCD 显示肯定不正常，我们只需要在uboot 中修改 panel 的值为 TFT7016 即可，在 uboot 的命令模式下输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">setenv panel TFT7016saveenv</code></pre></div><p>上述命令修改环境变量 panel 为 TFT7016，然后保存，重启 uboot，此时 LCD 驱动就工作正常了。如果 LCD 还是没有正常工作的，那就要检查自己哪里有没有改错，或者还有哪里没有修改。</p><h3 id="7-网络驱动修改"><a href="#7-网络驱动修改" class="headerlink" title="7.网络驱动修改"></a>7.网络驱动修改</h3><h4 id="1、网络硬件介绍"><a href="#1、网络硬件介绍" class="headerlink" title="1、网络硬件介绍"></a>1、网络硬件介绍</h4><p>I.MX6UL&#x2F;ULL 内部有个以太网 MAC 外设，也就是 ENET，需要外接一个 PHY 芯片来实现网络通信功能，也就是内部 MAC+外部 PHY 芯片的方案。</p><p>大家可能听过 DM9000 这个网络芯片，在一些没有内部 MAC 的 CPU 中，比如三星的 2440，4412 等，就会采用 DM9000 来实现联网功能。DM9000 提供了一个类似 SRAM 的访问接口，主控 CPU 通过这个接口即可与DM9000 进行通信，DM9000 就是一个 MAC+PHY 芯片。这个方案就相当于外部 MAC+外部PHY，那么 I.MX6U 这样的内部 MAC+PHY 芯片与 DM9000 方案比有什么优势吗？首先就是通信效率和速度，一般 SOC 内部的 MAC 是带有一个专用 DMA 的，专门用于处理网络数据包，采用 SRAM 来读写 DM9000 的速度是压根就没法和内部 MAC+外部 PHY 芯片的速度比。采用外部 DM9000 完全是无奈之举，谁让2440，4412 这些芯片内部没有以太网外设呢，现在又想用有线网络，没有办法只能找个 DM9000 的方案。</p><p>I.MX6UL&#x2F;ULL 有两个网络接口 ENET1 和 ENET2，正点原子的 I.MX6U-ALPHA 开发板提供了这两个网络接口，其中 ENET1 和 ENET2 都使用 LAN8720A 作为 PHY 芯片。NXP 官方的I.MX6ULL EVK 开发板使用 KSZ8081 这颗 PHY 芯片，LAN8720A 相比 KSZ8081 具有体积小、外围器件少、价格便宜等优点。</p><p>换了PHY芯片，这个时候官方的驱动就不适用啦，需要修改驱动，使网络工作正常。</p><p>正点原子I.MX6U-ALPHA 开发板 ENET1 的网络原理图如图：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818211726560.png" alt="image-20200818211726560"></p><p>ENET1 的网络 PHY 芯片为 LAN8720A，通过 RMII 接口与 I.MX6ULL 相连，正点原子I.MX6U-ALPHA 开发板的 ENET1 引脚与 NXP 官方的 I.MX6ULL EVK 开发板基本一样，唯独复位引脚不同。从图可以看出，正点原子 I.MX6U-ALPHA 开发板的 ENET1 复位引脚ENET1_RST 接到了 I.M6ULL 的 SNVS_TAMPER7 这个引脚上。</p><p>LAN8720A 内部是有寄存器的，I.MX6ULL 会读取 LAN8720 内部寄存器来判断当前的物理链接状态、连接速度(10M 还是 100M)和双工状态(半双工还是全双工)。I.MX6ULL 通过 MDIO接口来读取 PHY 芯片的内部寄存器，MDIO 接口有两个引脚，ENET_MDC 和 ENET_MDIO，ENET_MDC 提供时钟，ENET_MDIO 进行数据传输。一个 MIDO 接口可以管理 32 个 PHY 芯片，同一个 MDIO 接口下的这些 PHY 使用不同的器件地址来做区分，MIDO 接口通过不同的器件地址即可访问到相应的 PHY 芯片。I.MX6U-ALPHA 开发板 ENET1 上连接的 <strong>LAN8720A器件地址为 0X0</strong>，所示我们要修改 ENET1 网络驱动的话重点就三点：</p><ul><li>①、ENET1 复位引脚初始化。</li><li>②、LAN8720A 的器件 ID。</li><li>③、LAN8720 驱动</li></ul><p>再来看一下 开发板上的 ENET2 的原理图，如图所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818212327169.png" alt="image-20200818212327169"></p><p>关于 ENET2 网络驱动的修改也注意一下三点：<br>①、ENET2 的复位引脚，从图可以看出，ENET2 的复位引脚 ENET2_RST 接到了I.MX6ULL 的 SNVS_TAMPER8 上。<br>②、ENET2 所使用的 PHY 芯片器件地址，从图可以看出，<strong>PHY 器件地址为 0X1</strong>。<br>③、LAN8720 驱动，ENET1 和 ENET2 都使用的 LAN8720，所以驱动肯定是一样的。</p><h4 id="2、网络-PHY-地址修改"><a href="#2、网络-PHY-地址修改" class="headerlink" title="2、网络 PHY  地址修改"></a>2、网络 PHY  地址修改</h4><p>首先修改 uboot 中的 ENET1 和 ENET2 的 PHY 地址和驱动，打开<code>mx6ull_alientek_emmc.h</code>这个文件，找到如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMD_NET</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_PING</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_DHCP</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_MII</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_MII</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_ENET_DEV1</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> (CONFIG_FEC_ENET_DEV == 0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMX_FEC_BASEENET_BASE_ADDR</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC_PHYADDR          0x2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_XCV_TYPE             RMII</span><span class="hljs-meta">#<span class="hljs-keyword">elif</span> (CONFIG_FEC_ENET_DEV == 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMX_FEC_BASEENET2_BASE_ADDR</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC_PHYADDR0x1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_XCV_TYPERMII</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_ETHPRIME<span class="hljs-string">&quot;FEC&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_PHYLIB</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_PHY_MICREL</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>**宏<code>CONFIG_FEC_ENET_DEV</code>**用于选择使用哪个网口，默认为 1，也就是选择ENET2。</p><p>**宏<code>IMX_FEC_BASE</code>**为该ENET接口的寄存器基地址。</p><p>第一个**<code>CONFIG_FEC_MXC_PHYADDR</code>宏**为 ENET1 的 PHY 地址，默认是 0X2，第二个为 ENET2 的 PHY 地址，默认为 0x1。</p><p>根据前面的分析可知，正点原子的 I.MX6U-ALPHA 开发板 ENET1 的 PHY 地址为0X0，ENET2 的 PHY 地址为 0X1，所以需要将第第一个**<code>CONFIG_FEC_MXC_PHYADDR</code>宏**改为 0x0 。</p><p><strong>宏<code> CONFIG_PHY_MICREL</code><strong>用于使能 uboot 中 Micrel 公司的 PHY驱动，KSZ8081 这颗 PHY 芯片就是 Micrel 公司生产的，不过 Micrel 已经被 Microchip 收购了。如果要使用 LAN8720A，那么就得将</strong><code>CONFIG_PHY_MICREL</code></strong> 改为 **<code>CONFIG_PHY_SMSC</code>**，也就是使能 uboot 中的 SMSC 公司中的 PHY 驱动，因为 LAN8720A 就是 SMSC 公司生产的。所以示例代码有三处要修改：</p><p><strong>①、修改 ENET1 网络 PHY 的地址。</strong><br><strong>②、修改 ENET2 网络 PHY 的地址。</strong><br><strong>③、使能 SMSC 公司的 PHY 驱动。</strong><br>修改后的网络 PHY 地址参数如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMD_NET</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_PING</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_DHCP</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_CMD_MII</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_MII</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_ENET_DEV1</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> (CONFIG_FEC_ENET_DEV == 0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMX_FEC_BASEENET_BASE_ADDR</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC_PHYADDR          0x0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_XCV_TYPE             RMII</span><span class="hljs-meta">#<span class="hljs-keyword">elif</span> (CONFIG_FEC_ENET_DEV == 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMX_FEC_BASEENET2_BASE_ADDR</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_MXC_PHYADDR0x1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_FEC_XCV_TYPERMII</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_ETHPRIME<span class="hljs-string">&quot;FEC&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_PHYLIB</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_PHY_SMSC</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><h4 id="3-、删除-uboot-中-中-74LV595-的驱动代码"><a href="#3-、删除-uboot-中-中-74LV595-的驱动代码" class="headerlink" title="3 、删除 uboot 中 中 74LV595 的驱动代码"></a>3 、删除 uboot 中 中 74LV595 的驱动代码</h4><p>uboot 中网络 PHY 芯片地址修改完成以后就是网络复位引脚的驱动修改了，打开<code>mx6ull_lxg_emmc.c</code>找到如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOX_SDI IMX_GPIO_NR(5, 10)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOX_STCP IMX_GPIO_NR(5, 7)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOX_SHCP IMX_GPIO_NR(5, 11)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOX_OE IMX_GPIO_NR(5, 8)</span></code></pre></div><p>以上示例代码中以 IOX 开头的宏定义是 74LV595 的相关 GPIO，因为 NXP 官方I.MX6ULL EVK 开发板使用 74LV595 来扩展 IO，两个网络的复位引脚就是由 74LV595 来控制的。正点原子的 I.MX6U-ALPHA 开发板并没有使用 74LV595，因此我们将示例代码中的代码删除掉，替换为如下所示代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENET1_RESET IMX_GPIO_NR(5, 7)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENET2_RESET IMX_GPIO_NR(5, 8)</span></code></pre></div><p>ENET1 的复位引脚连接到 SNVS_TAMPER7 上，对应 GPIO5_IO07，ENET2 的复位引脚连接到 SNVS_TAMPER8 上，对应 GPIO5_IO08。</p><p>继续在 <code>mx6ull_lxg_emmc.c</code> 中找到如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> iox_pads[] = &#123;<span class="hljs-comment">/* IOX_SDI */</span>MX6_PAD_BOOT_MODE0__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),<span class="hljs-comment">/* IOX_SHCP */</span>MX6_PAD_BOOT_MODE1__GPIO5_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),<span class="hljs-comment">/* IOX_STCP */</span>MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),<span class="hljs-comment">/* IOX_nOE */</span>MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),&#125;;</code></pre></div><p>同理，示例代码是 74LV595 的 IO 配置参数结构体，将其删除掉。继续在mx6ull_lxg_emmc.c 中找到函数 iox74lv_init，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iox74lv_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> i;gpio_direction_output(IOX_OE, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (i = <span class="hljs-number">7</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;gpio_direction_output(IOX_SHCP, <span class="hljs-number">0</span>);gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="hljs-number">0</span>]);udelay(<span class="hljs-number">500</span>);gpio_direction_output(IOX_SHCP, <span class="hljs-number">1</span>);udelay(<span class="hljs-number">500</span>);&#125;......    ......<span class="hljs-comment">/*</span><span class="hljs-comment"> * shift register will be output to pins</span><span class="hljs-comment"> */</span>gpio_direction_output(IOX_STCP, <span class="hljs-number">1</span>);&#125;;<span class="hljs-type">void</span> <span class="hljs-title function_">iox74lv_set</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<span class="hljs-type">int</span> i;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">7</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;gpio_direction_output(IOX_SHCP, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (i == index)gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="hljs-number">0</span>]);<span class="hljs-keyword">else</span>gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="hljs-number">1</span>]);udelay(<span class="hljs-number">500</span>);gpio_direction_output(IOX_SHCP, <span class="hljs-number">1</span>);udelay(<span class="hljs-number">500</span>);&#125;......    ......<span class="hljs-comment">/*</span><span class="hljs-comment">  * shift register will be output to pins</span><span class="hljs-comment">  */</span>gpio_direction_output(IOX_STCP, <span class="hljs-number">1</span>);&#125;;</code></pre></div><p>iox74lv_init 函数是 74LV595 的初始化函数，iox74lv_set 函数用于控制 74LV595 的 IO 输出电平，将这两个函数全部删除掉！</p><p>继续在 mx6ull_lxg_emmc.c 中找到 board_init 函数，此函数是板子初始化函数，会被board_init_r 调用，board_init 函数内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">board_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;......imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));iox74lv_init();......<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>board_init 会调用 imx_iomux_v3_setup_multiple_pads 和 iox74lv_init 这两个函数来初始化74lv595 的 GPIO，<strong>将这两行删除掉</strong>。</p><p>至此，mx6ull_alientek_emmc.c 中关于 74LV595 芯片的驱动代码都删除掉了，接下来就是添加 I.MX6U-ALPHA 开发板两个网络复位引脚了。</p><h4 id="4-、添加-I-MX6U-ALPHA-开发板网络复位引脚驱动"><a href="#4-、添加-I-MX6U-ALPHA-开发板网络复位引脚驱动" class="headerlink" title="4 、添加 I.MX6U-ALPHA 开发板网络复位引脚驱动"></a>4 、添加 I.MX6U-ALPHA 开发板网络复位引脚驱动</h4><p>在 mx6ull_lxg_emmc.c 中找到如下所示代码：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> fec1_pads[] = &#123;MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),......MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),&#125;;<span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> fec2_pads[] = &#123;MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),......MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),&#125;;</code></pre></div><p>结构体数组 fec1_pads 和 fec2_pads 是 ENET1 和 ENET2 这两个网口的 IO 配置参数，在这两个数组中添加两个网口的复位 IO 配置参数，完成以后如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> fec1_pads[] = &#123;MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),......MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),    MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),&#125;;<span class="hljs-type">static</span> <span class="hljs-type">iomux_v3_cfg_t</span> <span class="hljs-type">const</span> fec2_pads[] = &#123;MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),......MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),    MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),&#125;;</code></pre></div><p>添加的两行分别是 ENET1 和 ENET2 的复位 IO 配置参数。继续在文件 mx6ull_lxg_emmc.c 中找到函数 setup_iomux_fec，此函数默认代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">setup_iomux_fec</span><span class="hljs-params">(<span class="hljs-type">int</span> fec_id)</span>&#123;<span class="hljs-keyword">if</span> (fec_id == <span class="hljs-number">0</span>)imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));<span class="hljs-keyword">else</span>imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));&#125;</code></pre></div><p>函数 setup_iomux_fec 就是根据 fec1_pads 和 fec2_pads 这两个网络 IO 配置数组来初始化I.MX6ULL 的网络 IO。我们需要在其中添加网络复位 IO 的初始化代码，并且复位一下 PHY 芯片，修改后的setup_iomux_fec 函数如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">setup_iomux_fec</span><span class="hljs-params">(<span class="hljs-type">int</span> fec_id)</span>&#123;<span class="hljs-keyword">if</span> (fec_id == <span class="hljs-number">0</span>)    &#123;        imx_iomux_v3_setup_multiple_pads(fec1_pads,                                         ARRAY_SIZE(fec1_pads));        gpio_direction_output(ENET1_RESET, <span class="hljs-number">1</span>);        gpio_set_value(ENET1_RESET, <span class="hljs-number">0</span>);        mdelay(<span class="hljs-number">20</span>);        gpio_set_value(ENET1_RESET, <span class="hljs-number">1</span>);    &#125;<span class="hljs-keyword">else</span>    &#123;        imx_iomux_v3_setup_multiple_pads(fec2_pads,                                         ARRAY_SIZE(fec2_pads));        gpio_direction_output(ENET2_RESET, <span class="hljs-number">1</span>);        gpio_set_value(ENET2_RESET, <span class="hljs-number">0</span>);        mdelay(<span class="hljs-number">20</span>);        gpio_set_value(ENET2_RESET, <span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><p>示例代码分别对应 ENET1 和 ENET2 的复位 IO 初始化，将这两个 IO 设置为输出并且硬件复位一下 LAN8720A，这个硬件复位很重要！否则可能导致 uboot 无法识别 LAN8720A。</p><h4 id="5-、修改-drivers-x2F-net-x2F-phy-x2F-phy-c-文件中的函数-genphy-update-link"><a href="#5-、修改-drivers-x2F-net-x2F-phy-x2F-phy-c-文件中的函数-genphy-update-link" class="headerlink" title="5 、修改 drivers&#x2F;net&#x2F;phy&#x2F;phy.c  文件中的函数 genphy_update_link"></a>5 、修改 drivers&#x2F;net&#x2F;phy&#x2F;phy.c  文件中的函数 genphy_update_link</h4><p>大功基本上告成，还差最后一步，uboot 中的 LAN8720A 驱动有点问题，打开文件drivers&#x2F;net&#x2F;phy&#x2F;phy.c，找到函数 genphy_update_link，这是个通用 PHY 驱动函数，此函数用于更新 PHY 的连接状态和速度。使用 LAN8720A 的时候需要在此函数中添加一些代码，修改后的函数 genphy_update_link 如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">genphy_update_link</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> phy_device *phydev)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mii_reg;    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PHY_SMSC</span>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> lan8720_flag = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> bmcr_reg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (lan8720_flag == <span class="hljs-number">0</span>) &#123;        bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);        phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);        <span class="hljs-keyword">while</span>(phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) &amp; <span class="hljs-number">0X8000</span>) &#123;            udelay(<span class="hljs-number">100</span>);        &#125;        phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);        lan8720_flag = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-comment">/*</span><span class="hljs-comment"> * Wait if the link is up, and autonegotiation is in progress</span><span class="hljs-comment"> * (ie - we&#x27;re capable and it&#x27;s not done)</span><span class="hljs-comment"> */</span>mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);......<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>前面**#ifdef**里就是新添加的代码，为条件编译代码段，只有使用 SMSC 公司的 PHY 这段代码才会执行(目前只测试了 LAN8720A，SMSC 公司其他的芯片还未测试)。</p><p><code>bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);</code>读取LAN8720A 的 BMCR 寄存器(寄存器地址为 0)，此寄存器为 LAN8720A 的配置寄存器，这里先读取此寄存器的默认值并保存起来。</p><p><code> phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);</code>向寄存器 BMCR 寄存器写入BMCR_RESET(值为0X8000)，因为 BMCR 的 bit15 是软件复位控制位，因此此行就是软件复位LAN8720A，复位完成以后此位会自动清零。</p><p>接下来while等待 LAN8720A 软件复位完成，也就是判断 BMCR的 bit15 位是否为 1，为 1 的话表示还没有复位完成。</p><p><code>phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);</code>重新向 BMCR 寄存器写入以前<br>的值，也就是之前读出的那个值。</p><p>至此网络的复位引脚驱动修改完成，重新编译 uboot，然后将 u-boot.bin 烧写到 SD 卡中并启动，uboot 启动信息如图所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818221858986.png" alt="image-20200818221858986"></p><p>可以看到“Net： FEC1”这一行，提示当前使用的 FEC1 这个网口，也就是 ENET2。</p><h4 id="6、uboot网络环境变量的配置"><a href="#6、uboot网络环境变量的配置" class="headerlink" title="6、uboot网络环境变量的配置"></a>6、uboot网络环境变量的配置</h4><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> ipaddr <span class="hljs-number">192.168.0.120</span>  //开发板 IP 地址<span class="hljs-attribute">setenv</span> ethaddr <span class="hljs-number">00</span>:<span class="hljs-number">04</span>:<span class="hljs-number">9</span>f:<span class="hljs-number">04</span>:d2:<span class="hljs-number">35</span> //开发板网卡 MAC 地址<span class="hljs-attribute">setenv</span> gatewayip <span class="hljs-number">192.168.0.1</span> //开发板默认网关<span class="hljs-attribute">setenv</span> netmask <span class="hljs-number">255.255.255.0</span>  //开发板子网掩码<span class="hljs-attribute">setenv</span> serverip <span class="hljs-number">192.168.0.111</span>  //服务器地址，也就是 Ubuntu 地址<span class="hljs-attribute">saveenv</span> //保存环境变量</code></pre></div><p>以上请根据自己的网络环境具体配置。</p><p>设置好环境变量以后就可以在 uboot 中使用网络了，用网线将 I.MX6U-ALPHA 上的 ENET2与电脑或者路由器连接起来，保证开发板和电脑在同一个网段内，通过 ping 命令来测试一下网络连接，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.0.111</span></code></pre></div><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818223729557.png" alt="image-20200818223729557"></p><p>从图可以看出，有“host 192.168.1.250 is alive”这句，说明 ping 主机成功，说明ENET2网络工作正常。再来测试一下ENET1的网络是否正常工作，打开mx6ull_lxg_emmc.h，将 CONFIG_FEC_ENET_DEV 改为 0，然后重新编译一下 uboot 并烧写到 SD 卡中重启。重启开发板</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818224125442.png" alt="image-20200818224125442"></p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818224138597.png" alt="image-20200818224138597"></p><p>从图可以看出，ping 主机也成功，说明 ENET1 网络也工作正常，至此，I.MX6U-ALPHA 开发板的两个网络都工作正常了.</p><h3 id="8、其他需要修改的地方"><a href="#8、其他需要修改的地方" class="headerlink" title="8、其他需要修改的地方"></a>8、其他需要修改的地方</h3><p>在 uboot 启动信息中会有“Board: MX6ULL 14x14 EVK”这一句，也就是说板子名字为“MX6ULL 14x14 EVK”，要将其改为我们所使用的板子名字，比如“MX6ULL LXG EMMC”或者“MX6ULL LXG NAND”。打开文件 mx6ull_lxg_emmc.c，找到函数checkboard，将其改为如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">checkboard</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-keyword">if</span> (is_mx6ull_9x9_evk())<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Board: MX6ULL 9x9 EVK\n&quot;</span>);<span class="hljs-keyword">else</span><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Board: MX6ULL LXG EMMC\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>修改完成以后重新编译 uboot 并烧写到 SD 卡中验证，uboot 启动信息如图所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818224533045.png" alt="image-20200818224533045"></p><p>从图可以看出，Board 变成了“MX6ULL LXG EMMC”。至此 uboot 的驱动部分就修改完成了，uboot 移植也完成了，uboot 的最终目的就是启动 Linux 内核，所以需要通过启动 Linux 内核来判断 uboot 移植是否成功。在启动 Linux 内核之前我们先来学习两个重要的环境变量 bootcmd 和 bootargs。</p><h2 id="四、uboot下的环境变量"><a href="#四、uboot下的环境变量" class="headerlink" title="四、uboot下的环境变量"></a>四、uboot下的环境变量</h2><p>uboot 中有两个非常重要的环境变量 bootcmd 和 bootargs，接下来看一下这两个环境变量。</p><p>bootcmd 和 bootagrs 是采用类似 shell 脚本语言编写的，里面有很多的变量引用，这些变量其实都是环境变量，有很多是NXP自己定义的。文 件 mx6ull_lxg_emmc.h 中的宏<code>CONFIG_EXTRA_ENV_SETTINGS</code>保存着这些环境变量的默认值，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SYS_BOOT_NAND)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_EXTRA_ENV_SETTINGS \</span><span class="hljs-meta">CONFIG_MFG_ENV_SETTINGS \</span><span class="hljs-meta"><span class="hljs-string">&quot;panel=TFT7016\0&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;fdt_addr=0x83000000\0&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;fdt_high=0xffffffff\0&quot;</span>  \</span><span class="hljs-meta">......</span><span class="hljs-string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;\0&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_EXTRA_ENV_SETTINGS \</span><span class="hljs-meta">CONFIG_MFG_ENV_SETTINGS \</span><span class="hljs-meta"><span class="hljs-string">&quot;script=boot.scr\0&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;image=zImage\0&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;console=ttymxc0\0&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;fdt_high=0xffffffff\0&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;initrd_high=0xffffffff\0&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;fdt_file=undefined\0&quot;</span> \</span><span class="hljs-meta">......</span><span class="hljs-string">&quot;findfdt=&quot;</span>\<span class="hljs-string">&quot;if test $fdt_file = undefined; then &quot;</span> \<span class="hljs-string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \<span class="hljs-string">&quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot;</span> \<span class="hljs-string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \<span class="hljs-string">&quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot;</span> \<span class="hljs-string">&quot;if test $fdt_file = undefined; then &quot;</span> \<span class="hljs-string">&quot;echo WARNING: Could not determine dtb to use; fi; &quot;</span> \<span class="hljs-string">&quot;fi;\0&quot;</span> \</code></pre></div><p><strong>宏 CONFIG_EXTRA_ENV_SETTINGS</strong> 是个条件编译语句，使用 NAND 和 EMMC 的时候<strong>宏 CONFIG_EXTRA_ENV_SETTINGS</strong> 的值是不同的。</p><p>板子第一次运行 uboot 的时候都会使用默认值来设置环境变量。打开文件 <strong>include&#x2F;env_default.h</strong>，在此文件中有如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">env_t</span> environment __PPCENV__ = &#123;ENV_CRC,<span class="hljs-comment">/* CRC Sum */</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYS_REDUNDAND_ENVIRONMENT</span><span class="hljs-number">1</span>,<span class="hljs-comment">/* Flags: valid */</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(DEFAULT_ENV_INSTANCE_STATIC)</span><span class="hljs-type">static</span> <span class="hljs-type">char</span> default_environment[] = &#123;<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-type">const</span> uchar default_environment[] = &#123;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_ENV_CALLBACK_LIST_DEFAULT</span>ENV_CALLBACK_VAR <span class="hljs-string">&quot;=&quot;</span> CONFIG_ENV_CALLBACK_LIST_DEFAULT <span class="hljs-string">&quot;\0&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_ENV_FLAGS_LIST_DEFAULT</span>ENV_FLAGS_VAR <span class="hljs-string">&quot;=&quot;</span> CONFIG_ENV_FLAGS_LIST_DEFAULT <span class="hljs-string">&quot;\0&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_BOOTARGS</span><span class="hljs-string">&quot;bootargs=&quot;</span>CONFIG_BOOTARGS<span class="hljs-string">&quot;\0&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_BOOTCOMMAND</span><span class="hljs-string">&quot;bootcmd=&quot;</span>CONFIG_BOOTCOMMAND<span class="hljs-string">&quot;\0&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_RAMBOOTCOMMAND</span><span class="hljs-string">&quot;ramboot=&quot;</span>CONFIG_RAMBOOTCOMMAND<span class="hljs-string">&quot;\0&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_NFSBOOTCOMMAND</span><span class="hljs-string">&quot;nfsboot=&quot;</span>CONFIG_NFSBOOTCOMMAND<span class="hljs-string">&quot;\0&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_BOOTDELAY) &amp;&amp; (CONFIG_BOOTDELAY &gt;= 0)</span><span class="hljs-string">&quot;bootdelay=&quot;</span>__stringify(CONFIG_BOOTDELAY)<span class="hljs-string">&quot;\0&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>................<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_EXTRA_ENV_SETTINGS</span>CONFIG_EXTRA_ENV_SETTINGS<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>        <span class="hljs-string">&quot;\0&quot;</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEFAULT_ENV_INSTANCE_EMBEDDED</span>&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;;</code></pre></div><p>从示例代码的第 1 行可以看出，environment 是个 env_t 类型的变量，env_t 类型如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">environment_s</span> &#123;</span><span class="hljs-type">uint32_t</span>crc;<span class="hljs-comment">/* CRC32 over data bytes*/</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYS_REDUNDAND_ENVIRONMENT</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>flags;<span class="hljs-comment">/* active/obsolete flags*/</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>data[ENV_SIZE]; <span class="hljs-comment">/* Environment data*/</span>&#125; <span class="hljs-type">env_t</span></code></pre></div><p><strong>env_t</strong>结构体中的<strong>crc</strong>为CRC值，<strong>flags</strong>是标志位，<strong>data</strong>数组就是环境变量值。因此，environment就是用来保存默认环境变量的.</p><h3 id="1、环境变量-bootcmd"><a href="#1、环境变量-bootcmd" class="headerlink" title="1、环境变量 bootcmd"></a>1、环境变量 bootcmd</h3><h5 id="bootcmd默认宏定义设置的解析"><a href="#bootcmd默认宏定义设置的解析" class="headerlink" title="bootcmd默认宏定义设置的解析"></a>bootcmd默认宏定义设置的解析</h5><p>bootcmd 保存着 uboot 默认命令，uboot 倒计时结束以后就会执行 bootcmd 中的命令。</p><p>这些命令一般都是用来启动 Linux 内核的，比如读取 EMMC 或者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。可以在 uboot 启动以后进入命令行设置 bootcmd 环境变量的值。如果 EMMC 或者 NAND 中没有保存 bootcmd 的值，那么 uboot 就会使用默认的值</p><p>在上一个示例代码中指定了很多环境变量的默认值，比如bootcmd 的 默 认 值 就 是CONFIG_BOOTCOMMAND，bootargs 的默认值就是CONFIG_BOOTARGS 。 我们可以在mx6ull_lxg_emmc.h文件中通过设置宏CONFIG_BOOTCOMMAND 来 设 置 bootcmd 的 默 认 值 ， NXP 官 方 设 置 的CONFIG_BOOTCOMMAND 值如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_BOOTCOMMAND \</span><span class="hljs-meta">   <span class="hljs-string">&quot;run findfdt;&quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;mmc dev $&#123;mmcdev&#125;;&quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;mmc dev $&#123;mmcdev&#125;; if mmc rescan; then &quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;if run loadbootscript; then &quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;run bootscript; &quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;else &quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;if run loadimage; then &quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;run mmcboot; &quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;else run netboot; &quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;fi; &quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;fi; &quot;</span> \</span><span class="hljs-meta">   <span class="hljs-string">&quot;else run netboot; fi&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>看起来很复杂的样子！因为 uboot 使用了类似 shell 脚本语言的方式来编写的，我们一行一行来分析。</p><ul><li><p>第二行 <code>run findfdt；</code>使用的是 uboot 的 run 命令来运行 findfdt，findfdt 是 NXP 自行添加的环境变量。findfdt 是用来查找开发板对应的设备树文件(.dtb)。IMX6ULL EVK 的设备树文件为 imx6ull-14x14-evk.dtb，findfdt 内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;findfdt=&quot;</span>\          <span class="hljs-string">&quot;if test $fdt_file = undefined; then &quot;</span> \<span class="hljs-string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \<span class="hljs-string">&quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot;</span> \<span class="hljs-string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \<span class="hljs-string">&quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot;</span> \<span class="hljs-string">&quot;if test $fdt_file = undefined; then &quot;</span> \<span class="hljs-string">&quot;echo WARNING: Could not determine dtb to use; fi; &quot;</span> \<span class="hljs-string">&quot;fi;\0&quot;</span> \</code></pre></div><p><strong>findfdt</strong> 里面用到的变量有 <code>fdt_file</code>，<code>board_name</code>，<code>board_rev</code>，这三个变量内容如下：</p><p><strong>fdt_file&#x3D;undefined，board_name&#x3D;EVK，board_rev&#x3D;14X14</strong></p><p><strong>findfdt</strong> 做的事情就是判断这些变量值从而得出所需的.dtb 文件名。此时 fdt_file 为 undefined，所以根据 board_name 和board_rev 来判断实际所需的.dtb 文件。</p><p>根据当前变量值，板子的设备树文件就是 imx6ull-14x14-evk.dtb，因此 run findfdt 的结果就是设置 fdt_file 为 imx6ull-14x14-evk.dtb。</p></li><li><p><code>mmc dev $&#123;mmcdev&#125;</code>用于切换 mmc 设备，mmcdev 为 1，因此这行代码就是：<code>mmc dev 1</code>，也就是切换到 EMMC 上。</p></li><li><p><code>&quot;mmc dev $&#123;mmcdev&#125;; if mmc rescan; then &quot; </code>先执行 mmc dev ${mmcdev}切换到 EMMC 上，然后使用命令 mmc rescan 扫描看有没有 SD 卡或者 EMMC 存在，如果没有的话就直接跳到<code>run netboot;&quot;</code>执行 run netboot，<strong>netboot</strong>也是一个自定义的环境变量，这个变量是从网络启动 Linux 的。如果 mmc 设备存在的话就从mmc 设备启动。</p></li><li><p>第五行<code>&quot;if run loadbootscript; then &quot;</code>运行 loadbootscript 环境变量，此环境变量内容如下：</p><p><code>loadbootscript=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;</code></p><p>其中 mmcdev&#x3D;1，mmcpart&#x3D;1，loadaddr&#x3D;0x80800000，script&#x3D; boot.scr，因此展开以后就是：</p><p><code>loadbootscript=fatload mmc 1:1 0x80800000 boot.scr;</code></p><p>loadbootscript 就是从 mmc1 的分区 1 中读取文件 boot.src 到 DRAM 的 0X80800000 处。但是 mmc1 的分区 1 中没有 boot.src 这个文件，可以使用命令“ls mmc 1:1”查看一下 mmc1 分区1 中的所有文件，看看有没有 boot.src 这个文件。</p><p>之后的一行<code>&quot;run bootscript; &quot;</code>如果加载 boot.src 文件成功的话就运行 bootscript 环境变量，bootscript 的内容如下：<br><code>bootscript=echo Running bootscript from mmc ...;</code><br><code>source</code><br>因为 boot.src 文件不存在，所以 bootscript 也就不会运行。</p></li><li><p>&#96;&#96;&#96;<br> “else “ <br> “if run loadimage; then “ <br>     “run mmcboot; “ <br> “else run netboot; “ <br> “fi; “ <br> “fi; “ \</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">  如果 loadbootscript 没有找到 boot.src 的话就运行环境变量`<span class="hljs-built_in">run</span> loadimage`，环境变量loadimage 内容如下：  `<span class="hljs-attribute">loadimage</span>=fatload mmc <span class="hljs-variable">$&#123;mmcdev&#125;</span>:<span class="hljs-variable">$&#123;mmcpart&#125;</span> <span class="hljs-variable">$&#123;loadaddr&#125;</span> <span class="hljs-variable">$&#123;image&#125;</span>`  其中 <span class="hljs-attribute">mmcdev</span>=1，mmcpart=1，loadaddr=0x80800000，image = zImage，展开以后就是：  `<span class="hljs-attribute">loadimage</span>=fatload mmc 1:1 0x80800000 zImage`  可以看出 loadimage 就是从 mmc1 的分区中读取 zImage 到内存的 0X80800000 处，而 mmc1  的分区 1 中存在 zImage。- `<span class="hljs-string">&quot;run mmcboot; &quot;</span>`，加载 linux 镜像文件 zImage 成功以后就运行环境变量 mmcboot，否则的话运行netboot 环境变量。mmcboot 环境变量如下：  ```c  <span class="hljs-string">&quot;mmcboot=echo Booting from mmc ...; &quot;</span> \  <span class="hljs-string">&quot;run mmcargs; &quot;</span> \  <span class="hljs-string">&quot;if test <span class="hljs-variable">$&#123;boot_fdt&#125;</span> = yes || test <span class="hljs-variable">$&#123;boot_fdt&#125;</span> = try; then &quot;</span> \  <span class="hljs-string">&quot;if run loadfdt; then &quot;</span> \  <span class="hljs-string">&quot;bootz <span class="hljs-variable">$&#123;loadaddr&#125;</span> - <span class="hljs-variable">$&#123;fdt_addr&#125;</span>; &quot;</span> \  <span class="hljs-string">&quot;else &quot;</span> \  <span class="hljs-string">&quot;if test <span class="hljs-variable">$&#123;boot_fdt&#125;</span> = try; then &quot;</span> \  <span class="hljs-string">&quot;bootz; &quot;</span> \  <span class="hljs-string">&quot;else &quot;</span> \  <span class="hljs-string">&quot;echo WARN: Cannot load the DT; &quot;</span> \  <span class="hljs-string">&quot;fi; &quot;</span> \  <span class="hljs-string">&quot;fi; &quot;</span> \  <span class="hljs-string">&quot;else &quot;</span> \  <span class="hljs-string">&quot;bootz; &quot;</span> \  <span class="hljs-string">&quot;fi;\0&quot;</span> \</code></pre></div></li></ul><p>Linux 内核启动，如此复杂的设置就是为了从 EMMC 中读取 zImage 镜像文件和设备树文件。经过分析，浓缩出来的仅仅是 4 行精华：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">mmc</span> dev <span class="hljs-number">1</span>  //切换到 EMMC<span class="hljs-attribute">fatload</span> mmc <span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">0</span>x80800000 zImage //读取 zImage 到 <span class="hljs-number">0</span>x80800000 处<span class="hljs-attribute">fatload</span> mmc <span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">0</span>x83000000 imx6ull-<span class="hljs-number">14</span>x14-evk.dtb //读取设备树到 <span class="hljs-number">0</span>x83000000 处<span class="hljs-attribute">bootz</span> <span class="hljs-number">0</span>x80800000 - <span class="hljs-number">0</span>x83000000 //启动 Linux</code></pre></div><p>NXP 官方将 CONFIG_BOOTCOMMAND 写的这么复杂只有一个目的：为了兼容多个板子，所以写了个很复杂的脚本。当我们明确知道我们所使用的板子的时候就可以大幅简化宏CONFIG_BOOTCOMMAND 的 设 置 ，比 如 我 们 要 从 EMMC 启 动 ， 那 么 宏CONFIG_BOOTCOMMAND 就可简化为：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_BOOTCOMMAND \</span><span class="hljs-meta"><span class="hljs-string">&quot;mmc dev 1;&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;fatload mmc 1:1 0x80800000 zImage;&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;fatload mmc 1:1 0x83000000 imx6ull-alientek-emmc.dtb;&quot;</span> \</span><span class="hljs-meta"><span class="hljs-string">&quot;bootz 0x80800000 - 0x83000000;&quot;</span></span></code></pre></div><p>或者可以直接在 uboot 中设置 bootcmd 的值，这个值就是保存到 EMMC 中的，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">setenv bootcmd <span class="hljs-string">&#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-lxg-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span></code></pre></div><h5 id="bootcmd设置栗子"><a href="#bootcmd设置栗子" class="headerlink" title="bootcmd设置栗子"></a>bootcmd设置栗子</h5><h6 id="从EMMC启-动"><a href="#从EMMC启-动" class="headerlink" title="从EMMC启 动"></a>从EMMC启 动</h6><div class="hljs code-wrapper"><pre><code class="hljs sh">setenv bootcmd <span class="hljs-string">&#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-lxg-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span></code></pre></div><h6 id="从SD卡-启动"><a href="#从SD卡-启动" class="headerlink" title="从SD卡 启动"></a>从SD卡 启动</h6><div class="hljs code-wrapper"><pre><code class="hljs sh">setenv bootcmd <span class="hljs-string">&#x27;mmc dev 0; fatload mmc 0:1 80800000 zImage; fatload mmc 0:1 83000000 imx6ull-lxg-emmc.dtb; bootz 80800000 – 83000000;&#x27;</span></code></pre></div><hr><h4 id="2、bootargs环境变量"><a href="#2、bootargs环境变量" class="headerlink" title="2、bootargs环境变量"></a>2、bootargs环境变量</h4><h5 id="bootargs默认宏定义设置的解析"><a href="#bootargs默认宏定义设置的解析" class="headerlink" title="bootargs默认宏定义设置的解析"></a>bootargs默认宏定义设置的解析</h5><p>bootargs 保存着 uboot 传递给 Linux 内核的参数，是由 <strong>mmcargs</strong> 设置的，mmcargs 环境变量如下：<br><code>mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</code></p><p>其中 console&#x3D;ttymxc0，baudrate&#x3D;115200，mmcroot&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw，因此将<br>mmcargs 展开以后就是：</p><p><code>mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw</code></p><p>可以看出环境变量 mmcargs 就是设置 bootargs 的值为：</p><p><code>“console= ttymxc0, 115200 root=/dev/mmcblk1p2 rootwait rw”</code></p><p>bootargs 就是设置了很多的参数的值。</p><p>例：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">setenv bootartgs <span class="hljs-string">&#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span></code></pre></div><p><strong>1 、console</strong></p><p>console 用来设置 linux 终端(或者叫控制台)，也就是通过什么设备来和 Linux 进行交互，是串口还是 LCD 屏幕？如果是串口的话应该是串口几等等。一般设置串口作为 Linux 终端，这样我们就可以在电脑上通过 SecureCRT 来和 linux 交互了。这里设置 console 为 ttymxc0，因为 linux启动以后 I.MX6ULL 的串口 1 在 linux 下的设备文件就是&#x2F;dev&#x2F;ttymxc0，在 Linux 下，一切皆文件。ttymxc0 后面有个“,115200”，这是设置串口的波特率，<strong>console&#x3D;ttymxc0,115200</strong> 综合起来就是设置 ttymxc0（也就是串口 1）作为 Linux 的终端，并且串口波特率设置为 115200。</p><p><strong>2 、root</strong></p><p>root 用来设置根文件系统的位置，<strong>root&#x3D;&#x2F;dev&#x2F;mmcblk1p2</strong> 用于指明根文件系统存放在mmcblk1 设备的分区 2 中。root 后面有<strong>“rootwait rw”</strong>，rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话mmc 设备还没初始化完成就挂载根文件系统会出错的。<strong>rw</strong> 表示根文件系统是可以读写的</p><p><strong>3 、rootfstype</strong></p><p>此选项一般配置 root 一起使用，rootfstype 用于指定根文件系统类型，如果根文件系统为ext 格式的话此选项无所谓。如果根文件系统是 yaffs、jffs 或 ubifs 的话就需要设置此选项，指定根文件系统的类型。</p><p>bootargs 常设置的选项就这三个</p><hr><h5 id="bootargs设置栗子"><a href="#bootargs设置栗子" class="headerlink" title="bootargs设置栗子"></a>bootargs设置栗子</h5><h6 id="挂载根文件至mmc设备："><a href="#挂载根文件至mmc设备：" class="headerlink" title="挂载根文件至mmc设备："></a>挂载根文件至mmc设备：</h6><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">setenv bootargs <span class="hljs-string">&#x27;console=ttymxc0,115200 root=/dev/mmcblk0p2 rootwait rw&#x27;</span></code></pre></div><hr><h6 id="挂载根文件至nfs网络下："><a href="#挂载根文件至nfs网络下：" class="headerlink" title="挂载根文件至nfs网络下："></a>挂载根文件至nfs网络下：</h6><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">setenv bootargs <span class="hljs-string">&#x27;console=ttymxc0,115200 root=/dev/nfs rw nfsroot=192.168.0.111:/home/firestaradmin/linux/nfs/rootfs ip=192.168.0.112:192.168.0.111:192.168.0.1:255.255.255.0::eth0:off&#x27;</span></code></pre></div><p>在 Linux 内核源码里面有相应的文档讲解如何设置，文档为Documentation&#x2F;filesystems&#x2F;nfs&#x2F;nfsroot.txt，格式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs ruby">root=<span class="hljs-regexp">/dev/nfs</span> nfsroot=[&lt;server-ip&gt;<span class="hljs-symbol">:</span>]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;<span class="hljs-symbol">:&lt;server-ip&gt;</span><span class="hljs-symbol">:&lt;gw-ip&gt;</span><span class="hljs-symbol">:&lt;netmask&gt;</span>:&lt;hostname&gt;<span class="hljs-symbol">:&lt;device&gt;</span><span class="hljs-symbol">:&lt;autoconf&gt;</span><span class="hljs-symbol">:&lt;dns0-ip&gt;</span><span class="hljs-symbol">:&lt;dns1-ip&gt;</span></code></pre></div><p><server-ip>：   服务器 IP 地址，也就是存放根文件系统主机的 IP 地址，那就是Ubuntu 的 IP地址，比如我的 Ubuntu 主机 IP 地址为 192.168.1.250。</server-ip></p><p><root-dir> ：   根文件系统的存放路径，比如我的就是&#x2F;home&#x2F;firestaradmin&#x2F;linux&#x2F;nfs&#x2F;rootfs。</root-dir></p><p><nfs-options>：  NFS 的其他可选选项，一般不设置。</nfs-options></p><p><client-ip> ：   客户端 IP 地址，也就是我们开发板的 IP 地址，Linux 内核启动以后就会使用此 IP 地址来配置开发板。</client-ip></p><p><server-ip> ：   服务器 IP 地址，前面已经说了。</server-ip></p><p><gw-ip> ：     网关地址，我的就是 192.168.1.1。</gw-ip></p><p><netmask>：    子网掩码，我的就是 255.255.255.0。</netmask></p><p><hostname>：   客户机的名字，一般不设置，此值可以空着。</hostname></p><p><device> ：     设备名，也就是网卡名，一般是 eth0，eth1….，正点原子的 I.MX6U-ALPHA 开发板的 ENET2 为 eth0，ENET1 为 eth1。如果你的电脑只有一个网卡，那么基本只能是 eth0。这里我们使用 ENET2，所以网卡名就是 eth0。</device></p><p><autoconf> ：   自动配置，一般不使用，所以设置为 off。</autoconf></p><p><dns0-ip> ：   DNS0 服务器 IP 地址，不使用。</dns0-ip></p><p><dns1-ip> ：   DNS1 服务器 IP 地址，不使用。</dns1-ip></p><hr><h6 id="Pc机Ubuntn-的nfs配置："><a href="#Pc机Ubuntn-的nfs配置：" class="headerlink" title="Pc机Ubuntn 的nfs配置："></a>Pc机Ubuntn 的nfs配置：</h6><p>安装NFS服务：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo apt-get install nfs-kernel-server rpcbind</code></pre></div><p>配置NFS文件：</p><p>​    <strong>打开 nfs 配置文件&#x2F;etc&#x2F;exports：</strong></p><p>​    <strong>打开&#x2F;etc&#x2F;exports 以后在文件后面添加如下所示内容：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/home/</span>firestaradmin<span class="hljs-regexp">/linux/</span>nfs *(rw,sync,no_root_squash)</code></pre></div><p>重启 NFS 服务，使用命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo /etc/init.d/nfs-kernel-server restart</code></pre></div><h2 id="uboot图形化配置"><a href="#uboot图形化配置" class="headerlink" title="uboot图形化配置"></a>uboot图形化配置</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>在前两章中我们知道 uboot 可以通过 mx6ull_lxg_emmc_defconfig 来配置，或者通过文件mx6ull_lxg_emmc.h 来配置 uboot。还有另外一种配置 uboot 的方法，就是图形化配置.</p><p>uboot 或 Linux 内核可以通过输入“<strong>make menuconfig</strong>”来打开图形化配置界面，menuconfig是一套图形化的配置工具，需要 ncurses 库支持。ncurses 库提供了一系列的 API 函数供调用者生成基于文本的图形界面，因此需要先在 Ubuntu 中安装 ncurses 库，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo apt-get install build-essentialsudo apt-get install libncurses5-dev</code></pre></div><p>menuconfig 重点会用到uboot根目录的两个文件：<code>.config</code> 和 <code>Kconfig</code>，<code>.config </code>文件前面已经说了，这个文件保存着 uboot 的配置项，使用 menuconfig 配置完 uboot 以后肯定要更新.config 文件。Kconfig文件是图形界面的描述文件，也就是描述界面应该有什么内容，很多目录下都会有 Kconfig 文件。</p><p>在打开图形化配置界面之前，要先使用“make xxx_defconfig”对 uboot 进行一次默认配置，只需要一次即可。如果使用“make clean”清理了工程的话就那就需要重新使用“make xxx_defconfig”再对 uboot 进行一次配置。进入 uboot 根目录，输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_lxg_emmc_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</code></pre></div><p>如果已经在 uboot 的顶层 Makefile 中定义了 ARCH 和 CROSS_COMPILE 的值，那么上述命令可以简化为：</p><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> mx6ull_lxg_emmc_defconfig<span class="hljs-built_in">make</span> menuconfig</code></pre></div><p>打开后的图形化界面如图 34.1.1 所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200818235039839.png" alt="image-20200818235039839"></p><h3 id="使能-dns-命令"><a href="#使能-dns-命令" class="headerlink" title="使能 dns 命令"></a>使能 dns 命令</h3><p>我们就以如何使能 dns 命令为例，讲解一下如何通过图形化界面来配置 uboot。进入“Command line interface —&gt;”这个配置项，此配置项用于配置 uboot 的命令，进入以后如图所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112010754.png" alt="image-20200819112010754"></p><p>从图 34.1.2 可以看出，有很多配置项，这些配置项也有子配置项，</p><p>选择“Network commands—&gt;”，进入网络相关命令配置项，如图所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112039004.png" alt="image-20200819112039004"></p><p>从图可以看出，uboot 中有很多和网络有关的命令，比如 bootp、tftpboot、dhcp 等等。选中 dns，然后按下键盘上的“Y”键，此时 dns 前面的“[ ]”变成了“[ * ]”，如图所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112102964.png" alt="image-20200819112102964"></p><p>每个选项有 3 种编译选项：</p><ul><li>编译进 uboot 中(也就是编译进 u-boot.bin 中)</li><li>取消编译(也就是不编译这个功能模块)</li><li>编译为模块</li></ul><p>按下“Y”键表示编译进 uboot 中，此时“[ ]”变成了“[ * ]”；</p><p>按下“N”表示不编译，“[ ]”默认表示不编译；</p><p>有些功能模块是支持编译为模块的，这个一般在 Linux 内核里面很常用，uboot 下面不使用，如果要将某个功能编译为模块，那就按下“M”，此时“[ ]”就会变为“&lt; M &gt;”。</p><p>细心的朋友应该会发现，在 mx6ull_lxg_emmc.h 里面我们配置使能了 dhcp 和 ping 命令，但是在图 中 dhcp 和 ping 前面的“[ ]”并不是“[ * ]”，也就是说不编译 dhcp 和 ping命令，这不是冲突了吗？实际情况是 dhcp 和 ping 命令是会编译的。之所以在图中没有体现出来时因为我们是直接在mx6ull_lxg_emmc.h 中定义的宏 CONFIG_CMD_PING 和CONFIG_CMD_DHCP，而 menuconfig 是通过读取.config 文件来判断使能了哪些功能，.config里面并没有宏CONFIG_CMD_PING ,CONFIG_CMD_DHCP，所以menuconfig就会识别出错。</p><p>选中 dns，然后按下“H”或者“?”键可以打开 dns 命令的提示信息，如图所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112413619.png" alt="image-20200819112413619"></p><hr><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112518396.png" alt="image-20200819112518396"></p><p>保存会询问是否保存新的配置文件，通过键盘的←或→键来选择“Yes”项，然后按下键盘上的回车键确认保存。至此，我们就完成了通过图形界面使能了 uboot 的 dns 命令，打开.config文件，会发现多了“CONFIG_CMD_DNS&#x3D;y”这一行，如图所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819112728189.png" alt="image-20200819112728189"></p><p>使用如下命令编译 uboot：</p><p><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</code></p><p>千万不能使用如下命令：</p><p><code>./mx6ull_lxg_emmc.sh</code></p><p>因为 mx6ull_lxg_emmc.sh 在编译之前会清理工程，会删除掉.config 文件！通过图形化界面配置所有配置项都会被删除，结果就是竹篮打水一场空。编译完成以后烧写到 SD 卡中，重启开发板进入 uboot 命令模式，输入“?”查看是否有“dns”命令，一般肯定有的。测试一下 dns 命令工作是否正常，使用 dns 命令来查看一下百度官网“<a href="http://www.baidu.com”的/">www.baidu.com”的</a> IP 地址。要先设置一下 dns 服务器的 IP 地址，也就是设置环境变量 dnsip的值，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">setenv dnsip 114.114.114.114saveenv</code></pre></div><p>设置好以后就可以使用 dns 命令查看百度官网的 IP 地址了，输入命令：<br><code>dns www.baidu.com</code><br>结果如图所示：</p><p><img src="/2020/09/06/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/7.uboot%E7%A7%BB%E6%A4%8D/image-20200819114151182.png" alt="image-20200819114151182"></p><p>从图可以看出，“<a href="http://www.baidu.com”的/">www.baidu.com”的</a> IP 地址，说明 dns 命令工作正常。这个就是通过图形化命令来配置 uboot，一般用来使能一些命令还是很方便的，这样就不需要到处找命令的配置宏是什么，然后在到配置文件里面去定义。</p><h3 id="menuconfig-图形化配置原理"><a href="#menuconfig-图形化配置原理" class="headerlink" title="menuconfig 图形化配置原理"></a>menuconfig 图形化配置原理</h3><p>参考正点原子I.MX6U驱动开发指南的第34.2节。</p><h3 id="Kconfig-语法简介"><a href="#Kconfig-语法简介" class="headerlink" title="Kconfig  语法简介"></a>Kconfig  语法简介</h3><p>参考正点原子I.MX6U驱动开发指南的第34.2节。</p><h3 id="添加自定义菜单"><a href="#添加自定义菜单" class="headerlink" title="添加自定义菜单"></a>添加自定义菜单</h3><p>参考正点原子I.MX6U驱动开发指南的第34.3节。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Linux</tag>
      
      <tag>uboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5| Makefile的简单编写</title>
    <link href="/2020/09/05/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/5.Makefile%E7%9A%84%E7%AE%80%E5%8D%95%E7%BC%96%E5%86%99(%E8%A7%81C++%E9%87%8C%E7%9A%84%E7%AC%94%E8%AE%B0)/"/>
    <url>/2020/09/05/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/5.Makefile%E7%9A%84%E7%AE%80%E5%8D%95%E7%BC%96%E5%86%99(%E8%A7%81C++%E9%87%8C%E7%9A%84%E7%AC%94%E8%AE%B0)/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile的简单编写"><a href="#Makefile的简单编写" class="headerlink" title="Makefile的简单编写"></a>Makefile的简单编写</h1><p>:label:@author:firestaradmin 2020年8月16日15:18:10 </p><hr><h2 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h2><h3 id="书写形式-例："><a href="#书写形式-例：" class="headerlink" title="书写形式 例："></a>书写形式 例：</h3><div class="hljs code-wrapper"><pre><code class="hljs makefile">foo.o : foo.c defs.h <span class="hljs-comment"># foo 模块</span>    cc -c -g foo.c</code></pre></div><ul><li>如果命令太长，你可以使用反斜框（‘\’）作为换行符</li><li>一般来说，make 会以 UNIX 的标准 Shell，也就是&#x2F;bin&#x2F;sh 来执行命令</li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul><li><p>make 支持三各通配符：“*”，“?”和“[…]”。这是和 Unix 的 B-Shell 是相同的。 波浪号（“<del>”）字符在文件名中也有比较特殊的用途。如果是“</del>&#x2F;test”，这就表示当前用户的$HOME 目录下的 test 目录</p></li><li><p>如“*.c”表示所有后缀为 c 的文件。一个需要我们注意的是，如果我们的文件名中有通配符，那么可以用转义字符“\”，如“\*”来表示真实的“*”字符，而不是任意长度的字符串。</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">print: *.c</span>    lpr -p <span class="hljs-variable">$?</span>    touch print</code></pre></div><p>上面这个例子说明了通配符也可以在我们的规则中，目标 print 依赖于所有的[.c]文件。</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">objects = *.o</code></pre></div><p>上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开！objects<br>的值就是“*.o”。Makefile 中的变量其实就是 C&#x2F;C++中的宏。如果你要让通配符在变量中<br>展开，也就是让 objects 的值是所有[.o]的文件名的集合，那么，你可以这样：</p><p>objects :&#x3D; $(wildcard *.o)</p><p>这种用法由关键字“wildcard”指出，关于 Makefile 的关键字，我们将在后面讨论</p><h3 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h3><ul><li>Makefile 文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make 只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs makefile">VPATH = src:../headers</code></pre></div><p>上面的的定义指定两个目录，“src”和“..&#x2F;headers”，make 会按照这个顺序进行搜<br>索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，</p><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span>    rm *.o temp</code></pre></div><p>我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用.（以“make clean”来使用该目标）</p><p>因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p><p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">.PHONY : clean</code></pre></div><p><strong>只要有这个声明，不管是否有“clean”文件，只要“make clean”都会运行“clean”这个目标。</strong></p><p>于是整个过程可以这样写：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><span class="hljs-section">clean:</span>    rm *.o temp</code></pre></div><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。</p></li><li><p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。看一个例子：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">objects = program.o foo.o utils.oprogram : <span class="hljs-variable">$(objects)</span>cc -o program <span class="hljs-variable">$(objects)</span><span class="hljs-variable">$(objects)</span> : defs.h</code></pre></div></li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>&#x3D; 是最基本的赋值<br>:&#x3D; 是覆盖之前的值<br>?&#x3D; 是如果没有被赋值过就赋予等号后面的值<br>+&#x3D; 是添加等号后面的值</p><p><strong>“&#x3D;”和“:&#x3D;”的区别到底有什么区别：</strong></p><ul><li><p>“&#x3D;”</p><p>make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：</p><div class="hljs code-wrapper"><pre><code class="hljs">  x = foo  y = $(x) bar  x = xyz</code></pre></div></li></ul><p>在上例中，y的值将会是 xyz bar ，而不是 foo bar 。</p><ul><li><p>“:&#x3D;”</p><p>  “:&#x3D;”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p><div class="hljs code-wrapper"><pre><code class="hljs">  x := foo  y := $(x) bar  x := xyz</code></pre></div></li></ul><p>在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。</p><h3 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h3><ul><li><p>$@<br>表示规则中的<strong>目标文件集</strong>。在模式规则中，如果有多个目标，那么，”$@”就是匹配于<br>目标中模式定义的集合。</p></li><li><p>$%<br>仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a<br>(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix<br>下是[.a]，Windows 下是[.lib]），那么，其值为空。</p></li><li><p>$&lt;<br>依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将<br>是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p></li><li><p>$?<br>所有比目标新的依赖目标的集合。以空格分隔。</p></li><li><p>$^<br>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量<br>会去除重复的依赖目标，只保留一份。</p></li><li><p>$+<br>这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p></li><li><p>$*<br>这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir&#x2F;a.foo.b”，并且目标的<br>模式是”a.%.b”，那么，”$<em>“的值就是”dir&#x2F;a.foo”。这个变量对于构造有关联的文件名是比<br>较有较。如果目标中没有模式的定义，那么”$</em>“也就不能被推导出，但是，如果目标文件的<br>后缀是 make 所识别的，那么”$<em>“就是除了后缀的那一部分。例如：如果目标是”foo.c”，因<br>为”.c”是 make 所能识别的后缀名，所以，”$</em>“的值就是”foo”。</p></li></ul><h3 id="部分函数"><a href="#部分函数" class="headerlink" title="部分函数"></a>部分函数</h3><h4 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h4><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> &lt;<span class="hljs-params">pattern</span>&gt;,&lt;<span class="hljs-params">replacement</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span></code></pre></div><p>名称：模式字符串替换函数——patsubst。</p><p>功能：查找&lt;text&gt;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。这里，&lt;pattern&gt;可以包括通配符“%”，表示任意长度的字串。如果&lt;replacement&gt;中也包含“%”，那么，&lt;replacement&gt;中的这个“%”将是&lt;pattern&gt;中的那个“%”所代表的字串。 （可以用“\”来转义，以“%”来表示真实含义的“%”字符）</p><p>返回：函数返回被替换过后的字符串。</p><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> %.<span class="hljs-params">c</span>,%.<span class="hljs-params">o</span>,<span class="hljs-params">x</span>.<span class="hljs-params">c</span>.<span class="hljs-params">c</span> <span class="hljs-params">bar</span>.<span class="hljs-params">c</span>)</span></code></pre></div><p>把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”</p><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">dir</span> &lt;<span class="hljs-params">names</span><span class="hljs-operator">...</span>&gt;)</span></code></pre></div><p>名称：取目录函数——dir。<br>功能：从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“&#x2F;”）之前<br>的部分。如果没有反斜杠，那么返回“.&#x2F;”。<br>返回：返回文件名序列&lt;names&gt;的目录部分。<br>示例： </p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">dir</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">foo</span>.<span class="hljs-params">c</span> <span class="hljs-params">hacks</span>)</span></code></pre></div><p>返回值是“src&#x2F; .&#x2F;”</p><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">notdir</span> &lt;<span class="hljs-params">names</span><span class="hljs-operator">...</span>&gt;)</span></code></pre></div><p>名称：取文件函数——notdir。<br>功能：从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“ &#x2F;”）<br>之后的部分。<br>返回：返回文件名序列&lt;names&gt;的非目录部分。<br>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">notdir</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">foo</span>.<span class="hljs-params">c</span> <span class="hljs-params">hacks</span>)</span></code></pre></div><p>返回值是“foo.c hacks”。</p><h4 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach  函数"></a>foreach  函数</h4><p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的 foreach 函数几乎是仿照于 Unix 标准 Shell（&#x2F;bin&#x2F;sh）中的 for 语句，或是 C-Shell（&#x2F;bin&#x2F;csh）中的 foreach 语句而构建的。它的语法是：</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">foreach</span> &lt;<span class="hljs-params">var</span>&gt;,&lt;<span class="hljs-params">list</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span></code></pre></div><p>这个函数的意思是，把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，然后再执行&lt;text&gt;所包含的表达式。每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。</p><p>所以，&lt;var&gt;最好是一个变量名，&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会使用&lt;var&gt;<br>这个参数来依次枚举&lt;list&gt;中的单词。举个例子：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">names := a b c dfiles := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> n,<span class="hljs-variable">$(names)</span>,<span class="hljs-variable">$(n)</span>.o)</span></code></pre></div><p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次<br>根据“$(n)”计算出一个值，这些值以空格分隔，最后作为 foreach 函数的返回，所以，<br>$(files)的值是“a.o b.o c.o d.o”。<br>注意，foreach 中的&lt;var&gt;参数是一个临时的局部变量，foreach 函数执行完后，参数<br>&lt;var&gt;的变量将不在作用，其作用域只在 foreach 函数当中。</p><h3 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h3><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p><p>&lt;targets …&gt;: <target-pattern>: &lt;prereq-patterns …&gt;<br>　　<commands><br>…</commands></target-pattern></p><p>没看明白没有关系，看下面的例子：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">objects = foo.o bar.oall : <span class="hljs-variable">$(objects)</span>    <span class="hljs-variable">$(objects)</span>: %.o: %.c    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span></code></pre></div><p>上面的例子中，指明了我们的目标从$objects中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">foo.o : foo.c    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> foo.c -o foo.obar.o : bar.c    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> bar.c -o bar.o</code></pre></div><p>试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。 </p><div class="hljs code-wrapper"><pre><code class="hljs makefile">.c.o：    gcc -c -o <span class="hljs-variable">$*</span>.o <span class="hljs-variable">$&lt;</span></code></pre></div><p>.c.o:<br>这句话的意思就是 %.o : %.c<br>也就是说，所有的.o文件，依赖于对应的.c文件<br>比如有三个a.c b.c c.c<br>那么就会有 a.o b.o c.o<br>a.o : a.c<br>b.o : b.c<br>c.o : c.c<br>这是makefile依赖的一种简写方法。makefile的依赖关系有很多种写法。这是其中一种。</p><h2 id="Makefile栗子预览："><a href="#Makefile栗子预览：" class="headerlink" title="Makefile栗子预览："></a>Makefile栗子预览：</h2><div class="hljs code-wrapper"><pre><code class="hljs makefile">CROSS_COMPILE ?= arm-linux-gnueabihf-TARGET  ?= uartCC := <span class="hljs-variable">$(CROSS_COMPILE)</span>gccLD:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ldOBJCOPY := <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopyOBJDUMP := <span class="hljs-variable">$(CROSS_COMPILE)</span>objdumpLIBPATH:= -lgcc -L /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/lib/gcc/arm-linux-gnueabihf/4.9.4INCDIRS := imx6ul \   bsp/clk \   bsp/led \   bsp/delay  \   bsp/beep \   bsp/gpio \   bsp/key \   bsp/exit \   bsp/int \   bsp/epittimer \   bsp/keyfilter \   bsp/uart       SRCDIRS:= project \   bsp/clk \   bsp/led \   bsp/delay \   bsp/beep \   bsp/gpio \   bsp/key \   bsp/exit \   bsp/int \   bsp/epittimer \   bsp/keyfilter \   bsp/uart       INCLUDE:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span>SFILES:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)CFILES:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span>)SFILENDIR:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(SFILES)</span>)</span>CFILENDIR:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(CFILES)</span>)</span>SOBJS:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)COBJS:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)OBJS:= <span class="hljs-variable">$(SOBJS)</span> <span class="hljs-variable">$(COBJS)</span>VPATH:= <span class="hljs-variable">$(SRCDIRS)</span><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><span class="hljs-variable">$(TARGET)</span>.bin : <span class="hljs-variable">$(OBJS)</span><span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$^</span> <span class="hljs-variable">$(LIBPATH)</span><span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$@</span><span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(TARGET)</span>.elf &gt; <span class="hljs-variable">$(TARGET)</span>.dis<span class="hljs-variable">$(SOBJS)</span> : obj/%.o : %.S<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -fno-builtin -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable">$(COBJS)</span> : obj/%.o : %.c<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -fno-builtin -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><span class="hljs-section">clean:</span>rm -rf <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$(TARGET)</span>.dis <span class="hljs-variable">$(TARGET)</span>.bin <span class="hljs-variable">$(COBJS)</span> <span class="hljs-variable">$(SOBJS)</span></code></pre></div><h3 id="栗子解析："><a href="#栗子解析：" class="headerlink" title="栗子解析："></a>栗子解析：</h3><p>在函数中使用到了除法运算，因此在链接的时候需要将编译器的数学库也链接进来。变量LIBPATH就是数学库的目录.</p><p>在后面的学习中，我们常常要用到一些第三方库，那么在连接程序的时候就需要指定这些<br>第三方库所在的目录，Makefile 在链接的时候使用选项“-L”来指定库所在的目录，比如变量 LIBPATH 就是指定了我们所使用的编译器库所在的目录。</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">LIBPATH:= -lgcc -L /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/lib/gcc/arm-linux-gnueabihf/4.9.4</code></pre></div><hr><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-variable">$(SOBJS)</span> : obj/%.o : %.S<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -fno-builtin -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable">$(COBJS)</span> : obj/%.o : %.c<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -fno-builtin -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span></code></pre></div><ul><li><p>-Wall,显示编译时候的所有警告</p></li><li><p>-nostdlib 编译时不链接系统标准启动文件和库文件</p></li><li><p>-O2 优化等级</p></li><li><p>选项“-fno-builtin”，否则编译的时候提示“putc”、“puts”<br>这两个函数与内建函数冲突，错误信息如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-built_in">warning</span>: conflicting <span class="hljs-keyword">types</span> <span class="hljs-keyword">for</span> built-<span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span> ‘putc’<span class="hljs-built_in">warning</span>: conflicting <span class="hljs-keyword">types</span> <span class="hljs-keyword">for</span> built-<span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span> ‘puts’</code></pre></div><p>在编译的时候加入选项“-fno-builtin”表示不使用内建函数，这样我们就可以自己实现 putc<br>和 puts 这样的函数了。</p></li></ul><hr><div class="hljs code-wrapper"><pre><code class="hljs makefile">INCLUDE:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span></code></pre></div><p>通过函数 patsubst 给变量 INCDIRS 添加一个“-I”，即：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">INCLUDE := -I imx6ul -I bsp/clk -I bsp/led -I bsp/delay</code></pre></div><p>加“-I”的目的是因为 Makefile 语法要求指明头文件目录的时候需要加上“-I”。</p><hr><div class="hljs code-wrapper"><pre><code class="hljs makefile">SFILES:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)</code></pre></div><p>将$(SRCDIRS)中的目录里的*.s文件取出</p><hr><h2 id="Makefile栗子预览2："><a href="#Makefile栗子预览2：" class="headerlink" title="Makefile栗子预览2："></a>Makefile栗子预览2：</h2><div class="hljs code-wrapper"><pre><code class="hljs makefile">TARGET = rtkCom<span class="hljs-comment">#您想要生成可执行文件的名字</span>BinName :=$&#123;TARGET&#125;<span class="hljs-comment">#真实二进制文件输出路径(绝对)</span>Bin := <span class="hljs-variable">$(pes_parent_dir)</span>/<span class="hljs-variable">$(BinName)</span><span class="hljs-comment">#C++编译器</span>GCC = g++<span class="hljs-comment">#C++配置参数</span>CXXFLAGS = -g -w -std=c++11 <span class="hljs-comment">#头文件搜索路径</span>INCLUDES = -I .<span class="hljs-comment">#链接库</span>LIBS = -lpthread<span class="hljs-comment">#编译输出文件</span>OBJ_PATH = objs<span class="hljs-comment">#源文件目录路径</span>SRCDIR = .CPP_SOURCES = <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIR)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.cpp)</span>)CPP_SOURCES_N_DIR = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(CPP_SOURCES)</span>)</span>CPP_OBJS = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.cpp, <span class="hljs-variable">$(OBJ_PATH)</span>/%.o, <span class="hljs-variable">$(CPP_SOURCES_N_DIR)</span>)</span><span class="hljs-section">default: init compile</span><span class="hljs-comment">#创建输出目录</span><span class="hljs-section">init:</span><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>,<span class="hljs-variable">$(SRCDIR)</span>, mkdir -p <span class="hljs-variable">$(OBJ_PATH)</span>/<span class="hljs-variable">$(dir)</span>;)</span>compile : <span class="hljs-variable">$(CPP_OBJS)</span>@echo Now compile <span class="hljs-variable">$(TARGET)</span>.....<span class="hljs-variable">$(GCC)</span>  <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$(TARGET)</span>  <span class="hljs-variable">$(LINKFLAGS)</span> <span class="hljs-variable">$(LIBS)</span><span class="hljs-variable">$(CPP_OBJS)</span> : <span class="hljs-variable">$(OBJ_PATH)</span>/%.o : %.cpp<span class="hljs-variable">$(GCC)</span> -c <span class="hljs-variable">$(CXXFLAGS)</span> <span class="hljs-variable">$(INCLUDES)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span>.PHONY : clean<span class="hljs-section">clean:</span>rm -rf <span class="hljs-variable">$(CPP_OBJS)</span><span class="hljs-section">test:</span>@echo <span class="hljs-string">&quot;CPP_SOURCES: <span class="hljs-variable">$(CPP_SOURCES)</span>&quot;</span>@echo <span class="hljs-string">&quot;CPP_OBJS: <span class="hljs-variable">$(CPP_OBJS)</span>&quot;</span>@echo <span class="hljs-string">&quot;CPP_SOURCES_N_DIR: <span class="hljs-variable">$(CPP_SOURCES_N_DIR)</span>&quot;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Linux</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6| 裸机程序编译运行</title>
    <link href="/2020/09/05/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/6.IMX6U%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/"/>
    <url>/2020/09/05/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/6.IMX6U%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="裸机程序编译运行"><a href="#裸机程序编译运行" class="headerlink" title="裸机程序编译运行"></a>裸机程序编译运行</h1><h2 id="1-编译程序"><a href="#1-编译程序" class="headerlink" title="1.编译程序"></a>1.编译程序</h2><h2 id="2-烧录程序"><a href="#2-烧录程序" class="headerlink" title="2.烧录程序"></a>2.烧录程序</h2><h2 id="3-运行程序"><a href="#3-运行程序" class="headerlink" title="3.运行程序"></a>3.运行程序</h2><hr><p>其实没什么好说的，就写完程序后，写Makefile、lds、然后编译烧录就完事了。</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4| 链接脚本lds的编写</title>
    <link href="/2020/09/04/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/4.%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <url>/2020/09/04/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/4.%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E7%9A%84%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="链接脚本-lds"><a href="#链接脚本-lds" class="headerlink" title="链接脚本.lds"></a>链接脚本.lds</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>我们链接代码的时候可以使用如下语句：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf <span class="hljs-variable">$^</span></code></pre></div><p>上面语句中我们是通过“-Ttext”来指定链接地址是 0X87800000 的，这样的话所有的文件都会链接到以 0X87800000 为起始地址的区域。</p><p>但是有时候我们很多文件需要链接到指定的区域，或者叫做段里面，比如在 Linux 里面初始化函数就会放到 init 段里面。因此我们需要能够自定义一些段，这些段的起始地址我们可以自由指定，同样的我们也可以指定一个文件或者函数应该存放到哪个段里面去。要完成这个功能我们就需要使用到链接脚本，看名字就知道链接脚本主要用于链接的，用于描述文件应该如何被链接在一起形成最终的可执行文件。其主要目的是描述输入文件中的段如何被映射到输出文件中，并且控制输出文件中的内存排布。比如我们编译生成的文件一般都包含 text 段、data 段等等。</p><p>链接脚本的语法很简单，就是编写一系列的命令，这些命令组成了链接脚本，每个命令是一个带有参数的关键字或者一个对符号的赋值，可以使用分号分隔命令。像文件名之类的字符串可以直接键入,也可以使用通配符“*”。</p><p>最简单的链接脚本可以只包含一个命令“SECTIONS”,我们可以在这一个 “SECTIONS”里面来描述输出文件的内存布局。我们一般编译出来的代码都包含在 text、data、bss 和 rodata 这四个段内，假设现在的代码要被链接到 0X10000000 这个地址，数据要被链接到 0X30000000 这个地方，下面就是完成此功能的最简单的链接脚本：</p><div class="hljs code-wrapper"><pre><code class="hljs c">SECTIONS&#123;    . = <span class="hljs-number">0X10000000</span>;    .text : &#123;*(.text)&#125;    . = <span class="hljs-number">0X30000000</span>;    .data <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123; *(.data) &#125;    .bss <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123; *(.bss) &#125;&#125;</code></pre></div><p>第 1 行我们先写了一个关键字“SECTIONS”，后面跟了一个大括号，这个大括号和第 7 行的大括号是一对，这是必须的。看起来就跟 C 语言里面的函数一样。</p><p>第 2 行对一个特殊符号“.”进行赋值，“.”在链接脚本里面叫做定位计数器，默认的定位计数器为 0。我们要求代码链接到以 0X10000000 为起始地址的地方，因此这一行给“.”赋值0X10000000，表示以 0X10000000 开始，后面的文件或者段都会以 0X10000000 为起始地址开始链接。</p><p>第 3 行的“.text”是段名，后面的冒号是语法要求，冒号后面的大括号里面可以填上要链接到“.text”这个段里面的所有文件，“*(.text)”中的“*”是通配符，表示所有输入文件的.text段都放到“.text”中。</p><p>第 4 行，我们的要求是数据放到 0X30000000 开始的地方，所以我们需要重新设置定位计数器“.”，将其改为 0X30000000。</p><p>第 5 行跟第 3 行一样，定义了一个名为“.data”的段，然后所有文件的“.data”段都放到这里面。但是这一行多了一个“ALIGN(4)”，这是什么意思呢？这是用来对“.data”这个段的起始地址做字节对齐的，ALIGN(4)表示 4 字节对齐。也就是说段“.data”的起始地址要能被 4 整除，一般常见的都是ALIGN(4)或者 ALIGN(8)，也就是 4 字节或者 8 字节对齐。</p><p>第 6 行定义了一个“.bss”段，所有文件中的“.bss”数据都会被放到这个里面，“.bss”数据就是那些定义了但是没有被初始化的变量。</p><h2 id="I-MX6U的裸机例程链接脚本例子"><a href="#I-MX6U的裸机例程链接脚本例子" class="headerlink" title="I.MX6U的裸机例程链接脚本例子"></a>I.MX6U的裸机例程链接脚本例子</h2><p>我们本试验的链接脚本要求如下：</p><ul><li>链接起始地址为 0X87800000。</li><li>start.o 要被链接到最开始的地方，因为 start.o 里面包含这第一个要执行的命令。</li></ul><p>根据要求，在 Makefile 同目录下新建一个名为“imx6ul.lds”的文件</p><div class="hljs code-wrapper"><pre><code class="hljs c">SECTIONS&#123;    . = <span class="hljs-number">0X87800000</span>;    .text :    &#123;        start.o        main.o        *(.text)    &#125;    .rodata <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123;*(.rodata*)&#125;    .data <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123; *(.data) &#125;    __bss_start = .;    .bss <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123; *(.bss) *(COMMON) &#125;    __bss_end = .;&#125;</code></pre></div><p>第5行设置链接到开始位置的文件为start.o，因为 start.o 里面包含着第一个要执行的指令，所以一定要链接到最开始的地方。</p><p>第 6 行是 main.o这个文件，其实可以不用写出来，因为 main.o 的位置就无所谓了，可以由编译器自行决定链接位置。</p><p>在第 11、13 行有“__bss_start”和“__bss_end”这两个东西？这个是什么呢？“__bss_start”和“__bss_end”是符号第 11、13 这两行其实就是对这两个符号进行赋值，其值为定位符“.”，这两个符号用来保存.bss 段的起始地址和结束地址。</p><p>前面说了.bss 段是定义了但是没有被初始化的变量，我们需要手动对.bss 段的变量清零的，因此我们需要知道.bss 段的起始和结束地址，这样我们直接对这段内存赋 0 即可完成清零。通过第 11、13 行代码，.bss 段的起始地址和结束地址就保存在了“__bss_start”和“__bss_end”中，我们就可以直接在汇编或者 C 文件里面使用这两个符号。</p><p>之后我们就可以将 Makefile 中的如下一行代码：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf <span class="hljs-variable">$^</span></code></pre></div><p>改为：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">arm-linux-gnueabihf-ld -Timx6ul.lds -o ledc.elf <span class="hljs-variable">$^</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3| I.MX6UL 启动方式浅析</title>
    <link href="/2020/09/03/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/3.I.MX6UL%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E6%B5%85%E6%9E%90/"/>
    <url>/2020/09/03/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/3.I.MX6UL%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="BOOT启动方式选择"><a href="#BOOT启动方式选择" class="headerlink" title="BOOT启动方式选择"></a>BOOT启动方式选择</h1><p>I.MX6U 芯片上电以后，芯片会根据 BOOT_MODE[1:0]的设置来选择 BOOT 方式。</p><p>通过修改 BOOT_MODE[1:0]对应的 GPIO 高低电平来选择启动方式</p><p><img src="/2020/09/03/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/3.I.MX6UL%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E6%B5%85%E6%9E%90/image-20200815222949425.png" alt="image-20200815222949425"></p><h2 id="串行下载"><a href="#串行下载" class="headerlink" title="串行下载"></a>串行下载</h2><p>当 BOOT_MODE1 为 0，BOOT_MODE0 为 1 的时候此模式使能，串行下载的意思就是可以通过 USB 或者UART 将代码下载到板子上的外置存储设备中，我们可以使用OTG1这个USB口向开发板上的 SD&#x2F;EMMC、NAND 等存储设备下载代码。</p><h2 id="内部-BOOT模式"><a href="#内部-BOOT模式" class="headerlink" title="内部 BOOT模式"></a>内部 BOOT模式</h2><p>当 BOOT_MODE1 为 1，BOOT_MODE0 为 0 的时候此模式使能，在此模式下，芯片会执行内部的 boot ROM 代码，这段 boot ROM 代码会进行硬件初始化(一部分外设)，然后从 boot 设备(就是存放代码的设备、比如 SD&#x2F;EMMC、NAND)中将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。</p><p><strong>BOOT ROM</strong> <strong>工作内容：</strong></p><ul><li><p>初始化时钟</p></li><li><p>为了加快执行速度会打开 MMU 和 Cache，下载镜像的时候 L1 ICache 会打开，验证镜像的时候 L1 DCache、L2 Cache 和 MMU 都会打开。一旦镜像验证完成，boot ROM就会关闭 L1 DCache、L2 Cache 和 MMU。</p></li><li><p>中断向量偏移会被设置到 boot ROM 的起始位置，当 boot ROM 启动了用户代码以后就可以重新设置中断向量偏移了。一般是重新设置到我们用户代码的开始地方</p></li></ul><h3 id="启动设备"><a href="#启动设备" class="headerlink" title="启动设备"></a>启动设备</h3><p>当 BOOT_MODE 设置为内部 BOOT 模式以后，可以从以下设备中启动：</p><p>①、接到 EIM 接口的 CS0 上的 16 位 NOR Flash。</p><p>②、接到 EIM 接口的 CS0 上的 OneNAND Flash。</p><p>③、接到 GPMI 接口上的 MLC&#x2F;SLC NAND Flash，NAND Flash 页大小支持 2KByte、4KByte和 8KByte，8 位宽。</p><p>④、Quad SPI Flash。</p><p>⑤、接到 USDHC 接口上的 SD&#x2F;MMC&#x2F;eSD&#x2F;SDXC&#x2F;eMMC 等设备。</p><p>⑥、SPI 接口的 EEPROM。</p><p><strong>这些启动设备如何选择呢？</strong></p><p>BOOT_CFG1[7:0]、BOOT_CFG2[7:0]和 BOOT_CFG4[7:0]这 24 个配置 IO，这 24 个配置 IO 刚好对应着 LCD 的 24 根数据线 LCD_DATA0~LCDDATA23，当启动完成以后这 24 个 IO 就可以作为 LCD 的数据线使用。这 24 根线和 BOOT_MODE1、BOOT_MODE0 共同组成了 I.MX6U的启动选择引脚，如图所示：</p><p><img src="/2020/09/03/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/3.I.MX6UL%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E6%B5%85%E6%9E%90/clip_image005.png" alt="clip_image005"></p><p><img src="/2020/09/03/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/3.I.MX6UL%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E6%B5%85%E6%9E%90/clip_image002-1597504407827.jpg" alt="clip_image002"></p><p><img src="/2020/09/03/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/3.I.MX6UL%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E6%B5%85%E6%9E%90/clip_image004.jpg" alt="clip_image004"></p><h1 id="镜像烧写（启动程序分析）"><a href="#镜像烧写（启动程序分析）" class="headerlink" title="镜像烧写（启动程序分析）"></a>镜像烧写（启动程序分析）</h1><p>前面我们设置好 BOOT 以后就能从指定的设备启动了，我们使用 imxdownload 这个软件将 led.bin 烧写到了 SD 卡中。imxdownload 会在 led.bin前面添加一些头信息，重新生成一个叫做 load.imx 的文件，最终实际烧写的是 laod.imx。</p><p>学习 STM32 的时候我们可以直接将编译生成的.bin 文件烧写到 STM32 内部 flash 里面，但是 I.MX6U 不能直接烧写编译生成的.bin 文件，我们需要在.bin 文件前面添加一些头信息构成满足 I.MX6U 需求的最终可烧写文件，I.MX6U 的最终可烧写文件组成如下：</p><p><strong>①、Image vector table</strong>，简称 IVT，IVT 里面包含了一系列的地址信息，这些地址信息在ROM 中按照固定的地址存放着。</p><p><strong>②、Boot data</strong>，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。</p><p><strong>③、Device configuration data</strong>，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置。</p><p><strong>④、用户代码可执行文件</strong>，比如 led.bin。</p><p>可以看出最终烧写到 I.MX6U 中的程序其组成为：IVT+Boot data+DCD+.bin。imxdownload 所生成的 load.imx 就是在 led.bin 前面加上 IVT+Boot data+DCD。<strong>内部 BootROM 会将 load.imx 拷贝到 DDR 中，用户代码是要一定要从 0X87800000 这个地方开始的，因为链接地址为 0X87800000</strong>，load.imx 在用户代码前面又有 3KByte 的 IVT+Boot Data+DCD 数据，下面会讲为什么是 3KByte，<strong>因此 load.imx 在 DDR 中的起始地址就是 0X87800000-3072&#x3D;0X877FF400。</strong></p><p>​    <strong>内部 Boot ROM 要求 IVT 应该放到指定的位置，不同的启动设备位置不同，而 IVT 在整个 load.imx 的最前面，其实就相当于要求 load.imx 在烧写的时候应该烧写到存储设备的指定位置去</strong>。整个位置都是相对于存储设备的起始地址的偏移，如图所示：</p><p><img src="/2020/09/03/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/3.I.MX6UL%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E6%B5%85%E6%9E%90/clip_image007.jpg" alt="clip_image007"></p><p>以 SD&#x2F;EMMC 为例，IVT 偏移为 1Kbyte，IVT+Boot data+DCD 的总大小为 4KByte-</p><p>1KByte&#x3D;3KByte。假如 SD&#x2F;EMMC 每个扇区为 512 字节，那么 load.imx 应该从第三个扇区开始烧写。</p><p>​    因为SD&#x2F;EMMC模式为例，整个Initial Load Region Size为4KB，包括前面的IVT1KB的偏移，所以.bin文件前面有imx添加的3KB信息</p><p><strong>具体详情请参考正点原子 I.MX6ULL 开发手册第九章9.4节</strong></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2| ARM交叉编译器的使用</title>
    <link href="/2020/09/02/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/2.ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/02/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/2.ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM交叉编译器的使用"><a href="#ARM交叉编译器的使用" class="headerlink" title="ARM交叉编译器的使用"></a>ARM交叉编译器的使用</h1><p>:label:@author:firestaradmin 2020年8月16日16:52:13</p><hr><h2 id="arm-linux-gnueabihf-gcc-编译文件"><a href="#arm-linux-gnueabihf-gcc-编译文件" class="headerlink" title="arm-linux-gnueabihf-gcc  编译文件"></a>arm-linux-gnueabihf-gcc  编译文件</h2><p>我们是要编译出在 ARM 开发板上运行的可执行文件，所以要使用交叉编译器 arm-linux-gnueabihf-gcc 来编译。</p><p>如果使用一个 led.s 源文件，先将 led.s 编译为对应的.o 文件，在终端中输入如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-gcc -g -c led.s -o led.o</code></pre></div><p>上述命令就是将 led.s 编译为 led.o，其中“-g”选项是产生调试信息，GDB 能够使用这些<br>调试信息进行代码调试。“-c”选项是编译源文件，但是不链接。“-o”选项是指定编译产生的文<br>件名字，这里我们指定 led.s 编译完成以后的文件名字为 led.o。执行上述命令以后就会编译生<br>成一个 led.o 文件</p><h2 id="arm-linux-gnueabihf-ld-链接文件"><a href="#arm-linux-gnueabihf-ld-链接文件" class="headerlink" title="arm-linux-gnueabihf-ld  链接文件"></a>arm-linux-gnueabihf-ld  链接文件</h2><p>arm-linux-gnueabihf-ld 用来将众多的.o 文件链接到一个指定的链接位置</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf</code></pre></div><p>上述命令中-Ttext 就是指定链接地址，“-o”选项指定链接生成的 elf 文件名，这里我们命名<br>为 led.elf。上述命令执行完以后就会在工程目录下多一个 led.elf 文件</p><p>那么为什么链接到<strong>0X87800000</strong> 这个地址呢？</p><p>以STM32为例：</p><p><img src="/2020/09/02/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/2.ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20200816165555861.png" alt="image-20200816165555861"></p><p>图中左侧的 IROM1 我们都知道是设置 STM32 芯片的 ROM 起始地址和大小的，右边的 IRAM1 是设置 STM32 芯片的 RAM 起始地址和大小的。其中 0X08000000 就是 STM32 内部 ROM 的起始地址，编译出来的指令肯定是要从 0X08000000 这个地址开始存放的。对于STM32 来说 0X08000000 就是它的链接地址   .o 文件就是这个链接地址开始依次存放，最终生成一个可以下载的 hex 或者 bin 文件，我们可以打开.map 文件查看一下这些文件的链接地址。</p><p><img src="/2020/09/02/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/2.ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20200816165708036.png" alt="image-20200816165708036"></p><p>从图中就可以看出 STM32 的各个.o 文件所处的位置，起始位置是 0X08000000。由此可以得知，我们用 MDK 开发 STM32 的时候也是有链接的，只是这些工作 MDK 都帮我们全部做好了，我们不用关心而已。但是我们在 Linux 下用交叉编译器开发 ARM 的是时候就需要自己处理这些了。</p><p>因此我们现在需要做的就是确定一下本试验最终的可执行文件其运行起始地址，也就是链接地址。这里我们要区分“存储地址”和“运行地址”这两个概念，</p><p>“存储地址”就是可执行文件存储在哪里，可执行文件的存储地址可以随意选择。</p><p>“运行地址”就是代码运行的时候所处的地址，这个我们在链接的时候就已经确定好了，代码要运行，那就必须处于运行地址处，否则代码肯定运行出错。</p><p>比如 I.MX6U 支持 SD 卡、EMMC、NAND 启动，因此代码可以存储到 SD 卡、EMMC 或者 NAND 中，但是要运行的话就必须将代码从 SD 卡、EMMC 或者NAND 中拷贝到其运行地址(链接地址)处，“存储地址”和“运行地址”可以一样，比如STM32 的存储起始地址和运行起始地址都是 0X08000000。</p><p>本教程所有的裸机例程都是烧写到 SD 卡中，上电以后 I.MX6U 的内部 boot rom 程序会将<br>可执行文件拷贝到链接地址处，这个链接地址可以在 I.MX6U 的内部 128KB RAM 中(0X900000~0X91FFFF)，也可以在外部的 DDR 中。本教程所有裸机例程的链接地址都在 DDR<br>中，链接起始地址为 0X87800000。之所以选择 0X87800000 这个地址是因为后面要讲的 Uboot 其链接地址就是 0X87800000，这样我们统一使用 0X87800000 这个链接地址，不容易记混。</p><hr><p>链接生成的led.elf 文件也不是我们最终烧写到 SD 卡中的可执行文件，我们要烧写的.bin 文件，因此还需要将 led.elf 文件转换为.bin 文件，这里我们就需要用到 arm-linux-gnueabihf-objcopy 这个工具了。</p><h2 id="arm-linux-gnueabihf-objcopy-格式转换"><a href="#arm-linux-gnueabihf-objcopy-格式转换" class="headerlink" title="arm-linux-gnueabihf-objcopy  格式转换"></a>arm-linux-gnueabihf-objcopy  格式转换</h2><p>arm-linux-gnueabihf-objcopy 更像一个格式转换工具，我们需要用它将 led.elf 文件转换为led.bin 文件，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</code></pre></div><p>上述命令中，“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试信息。</p><p>至此我们终于等到了想要的东西—led.bin 文件。</p><h2 id="arm-linux-gnueabihf-objdump-反汇编"><a href="#arm-linux-gnueabihf-objdump-反汇编" class="headerlink" title="arm-linux-gnueabihf-objdump 反汇编"></a>arm-linux-gnueabihf-objdump 反汇编</h2><p>大多数情况下我们都是用 C 语言写试验例程的，有时候需要查看其汇编代码来调试代码，因此就需要进行反汇编，一般可以将 elf 文件反汇编，比如如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</code></pre></div><p>上述代码中的“-D”选项表示反汇编所有的段，反汇编完成以后就会在当前目录下出现一个名为 led.dis 文件</p><p><img src="/2020/09/02/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/2.ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20200816170752022.png" alt="image-20200816170752022"></p><p>从图 可以看出 led.dis 里面是汇编代码，而且还可以看到内存分配情况。在0X87800000 处就是全局标号_start，也就是程序开始的地方。通过 led.dis 这个反汇编文件可以明显的看出到我们的代码已经链接到了以 0X87800000 为起始地址的区域</p><h2 id="代码烧写"><a href="#代码烧写" class="headerlink" title="代码烧写"></a>代码烧写</h2><p>肯定有人会认为直接复制led.bin 到 SD 卡中不就行了，错！编译出来的可执行文件是怎么存放到 SD 中的，存放的位置是什么？这个 NXP 是有详细规定的！我们必须按照 NXP 的规定来将代码烧写到 SD 卡中，否则代码是绝对运行不起来的。</p><p><strong>对于IMX6U来说，我们需要使用 imxdownload软件来烧写到SD卡</strong></p><p>imxdownload 会在 led.bin前面添加一些头信息，重新生成一个叫做 load.imx 的文件，最终实际烧写的是 laod.imx。</p><p>具体详情可以参考 I.MX6U驱动开发&#x2F;</p><p>使用 imxdownload 向 SD 卡烧写 led.bin 文件，命令格式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">./imxdownload &lt;.bin file&gt; &lt;SD Card&gt;</code></pre></div><p>其中.bin 就是要烧写的.bin 文件，SD Card 就是你要烧写的 SD 卡，比如使用如下<br>命令烧写 led.bin 到&#x2F;dev&#x2F;sdd 中：( &#x2F;dev&#x2F;sdd为你的SD卡)</p><div class="hljs code-wrapper"><pre><code class="hljs sh">./imxdownload led.bin /dev/sdd</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1| 开发环境搭建</title>
    <link href="/2020/09/01/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/09/01/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="一、FTP-File-Transfer-Protocol"><a href="#一、FTP-File-Transfer-Protocol" class="headerlink" title="一、FTP(File Transfer Protocol)"></a>一、FTP(File Transfer Protocol)</h1><h2 id="开启-linux下的-FTP-服务"><a href="#开启-linux下的-FTP-服务" class="headerlink" title="开启 linux下的 FTP 服务"></a>开启 linux下的 FTP 服务</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install vsftpdsudo vi /etc/vsftpd.conf</code></pre></div><p>打开 vsftpd.conf 文件以后找到如下两行：</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">local_enable</span>=<span class="hljs-literal">YES</span><span class="hljs-attr">write_enable</span>=<span class="hljs-literal">YES</span></code></pre></div><p>确保上面两行前面没有“#”，有的话就取消掉</p><p>保存退出后，重启服务</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo /etc/init.d/vsftpd restart</code></pre></div><h2 id="windows-下连接FTP"><a href="#windows-下连接FTP" class="headerlink" title="windows 下连接FTP:"></a>windows 下连接FTP:</h2><p>​    FTP软件中填写对应终端的IP 输入用户名和密码即可</p><h1 id="二、NFS-Network-File-System"><a href="#二、NFS-Network-File-System" class="headerlink" title="二、NFS(Network File System)"></a>二、NFS(Network File System)</h1><h2 id="NFS-服务端"><a href="#NFS-服务端" class="headerlink" title="NFS 服务端"></a>NFS 服务端</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install nfs-kernel-server rpcbind</code></pre></div><p>安装完成后创建一个nfs文件夹，以后需要通过网络用的文件都放这里.<code>xxxx/nfs</code></p><p>之后配置文件&#x2F;etc&#x2F;exports：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vi /etc/exports</code></pre></div><p>在文件末尾添加如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">xxxx/nfs *(rw,<span class="hljs-built_in">sync</span>,no_root_squash)</code></pre></div><p>重启 NFS 服务</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo /etc/init.d/nfs-kernel-server restart</code></pre></div><h2 id="NFS客户端"><a href="#NFS客户端" class="headerlink" title="NFS客户端"></a>NFS客户端</h2><p>安装客户端应用：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">apt-get install -y nfs-common</code></pre></div><p>用mkdir命令创建一个文件夹xxx&#x2F;nfs-mount。</p><p>将NFS服务器的xxx&#x2F;nfs 目录挂载到NFS客户端的xxx&#x2F;nfs-mount 目录，执行以下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">mount 192.168.119.128:xxx/nfs  xxx/nfs-mount</code></pre></div><h2 id="连接失败情况解决："><a href="#连接失败情况解决：" class="headerlink" title="连接失败情况解决："></a>连接失败情况解决：</h2><p>如果出现以下情况</p><p><img src="/2020/09/01/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200820013608568.png" alt="image-20200820013608568"></p><p>ARM-Linux NFS挂载不上，是由于高版本的NFS服务，默认不支持nfs v2的连接，而uboot中nfs服务是 V2版本的，所以需要修改<code>/etc/default/nfs-kernel-server </code>文件以支持v2 nfs。</p><p>修改完内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># Number of servers to start up</span><span class="hljs-comment">#RPCNFSDCOUNT=8</span>RPCNFSDCOUNT=<span class="hljs-string">&#x27;-V 2 8&#x27;</span><span class="hljs-comment"># Runtime priority of server (see nice(1))</span>RPCNFSDPRIORITY=0<span class="hljs-comment"># Options for rpc.mountd.</span><span class="hljs-comment"># If you have a port-based firewall, you might want to set up</span><span class="hljs-comment"># a fixed port here using the --port option. For more information, </span><span class="hljs-comment"># see rpc.mountd(8) or http://wiki.debian.org/SecuringNFS</span><span class="hljs-comment"># To disable NFSv4 on the server, specify &#x27;--no-nfs-version 4&#x27; here</span><span class="hljs-comment">#RPCMOUNTDOPTS=&quot;--manage-gids&quot;</span>RPCMOUNTDOPTS=<span class="hljs-string">&quot;-V 2 --manage-gids&quot;</span><span class="hljs-comment"># Do you want to start the svcgssd daemon? It is only required for Kerberos</span><span class="hljs-comment"># exports. Valid alternatives are &quot;yes&quot; and &quot;no&quot;; the default is &quot;no&quot;.</span>NEED_SVCGSSD=<span class="hljs-string">&quot;&quot;</span><span class="hljs-comment"># Options for rpc.svcgssd.</span>RPCSVCGSSDOPTS=<span class="hljs-string">&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span></code></pre></div><h1 id="三、SSH安全外壳协议-Secure-Shell"><a href="#三、SSH安全外壳协议-Secure-Shell" class="headerlink" title="三、SSH安全外壳协议 (Secure Shell)"></a>三、SSH安全外壳协议 (Secure Shell)</h1><h2 id="SSH-服务开启"><a href="#SSH-服务开启" class="headerlink" title="SSH 服务开启"></a>SSH 服务开启</h2><p>安装 ssh 服务</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install openssh-server</code></pre></div><p>ssh 的配置文件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config，使用默认配置即可</p><h1 id="四、交叉编译工具链"><a href="#四、交叉编译工具链" class="headerlink" title="四、交叉编译工具链"></a>四、交叉编译工具链</h1><p>编译 ARM 架构的代码，我们需要一个在 X86 架构的 PC 上运行，可以编译 ARM 架构代码的 GCC 编译器，这个编译器就叫做交叉编译器.</p><h2 id="Linaro-GCC-编译工具链-编译器-安装"><a href="#Linaro-GCC-编译工具链-编译器-安装" class="headerlink" title="Linaro GCC 编译工具链(编译器)安装"></a>Linaro GCC 编译工具链(编译器)安装</h2><p>下载地址：</p><p><a href="https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/">https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/</a></p><p><img src="/2020/09/01/NOTE/ARM-Linux/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/2222.png" alt="2222"></p><p>有很多种 GCC 交叉编译工具链，因为我们所使用的 I.MX6U-ALPHA 开发板是一个 Cortex-A7 内核的开发板，因此选择 arm-linux-gnueabihf，点击后面的“Binaries”进入可执行文件下载</p><p>创建目录：&#x2F;usr&#x2F;local&#x2F;arm：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /usr/local/arm</code></pre></div><p>将下载的文件放至该目录进行解压</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo tar -vxf gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar.xz</code></pre></div><p>解压完成以后会生成一个名为“gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf”的文件夹，这个文件夹里面就是我们的交叉编译工具链.</p><p>修改环境变量，使用 VI 打开&#x2F;etc&#x2F;profile 文件，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vi /etc/profile</code></pre></div><p>打开&#x2F;etc&#x2F;profile 以后，在最后面输入如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs elixir">export PATH=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/usr/local/arm/gcc-linaro-</span><span class="hljs-number">4.9</span>.<span class="hljs-number">4</span><span class="hljs-number">-2017.01</span>-x86_64_arm-linux-gnueabihf/bin</code></pre></div><p>重启 Ubuntu 系统，交叉编译工具链(编译器)就安装成功了</p><p>查看版本号</p><div class="hljs code-wrapper"><pre><code class="hljs bash">arm-linux-gnueabihf-gcc -v</code></pre></div><p>如果交叉编译器安装正确的话就会显示版本号</p><h1 id="五、TFTP服务"><a href="#五、TFTP服务" class="headerlink" title="五、TFTP服务"></a>五、TFTP服务</h1><p>tftp 命令的作用和 nfs 命令一样，都是用于通过网络下载东西到 DRAM 中，只是 tftp 命令使用的 TFTP 协议，Ubuntu 主机作为 TFTP 服务器。因此需要在 Ubuntu 上搭建 TFTP 服务器，需要安装 tftp-hpa 和 tftpd-hpa，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo apt-get install tftp-hpa tftpd-hpasudo apt-get install xinetd</code></pre></div><p>和 NFS 一样，TFTP 也需要一个文件夹来存放文件，在用户目录下新建一个目录，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> /home/firestaradmin/linux/tftpboot<span class="hljs-built_in">chmod</span> 777 /home/firestaradmin/linux/tftpboot</code></pre></div><p>这 样 我 就 在 我 的 电 脑 上 创 建 了 一 个 名 为 tftpboot 的目录 ( 文 件 夹 )，路径为**&#x2F;home&#x2F;firestaradmin&#x2F;linux&#x2F;tftpboot**</p><p>注意！我们要给 tftpboot 文件夹权限，否则的话 uboot 不能从tftpboot 文件夹里面下载文件。最后配置 tftp，安装完成以后新建文件&#x2F;etc&#x2F;xinetd.d&#x2F;tftp，如果没有&#x2F;etc&#x2F;xinetd.d 目录的话自行创建，然后在里面输入如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs c">server tftp&#123;    socket_type = dgram    protocol = udp    wait = yes    user = root    server = /usr/sbin/in.tftpd    server_args = -s /home/firestaradmin/linux/tftpboot/    disable = no    per_source = <span class="hljs-number">11</span>    cps = <span class="hljs-number">100</span> <span class="hljs-number">2</span>    flags = IPv4&#125;</code></pre></div><p> 完了以后启动 tftp 服务<code>sudo service tftpd-hpa start</code></p><p>之后打开**&#x2F;etc&#x2F;default&#x2F;tftpd-hpa** 文件，将其修改为如下所示内容：</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># /etc/default/tftpd-hpa</span><span class="hljs-attr">TFTP_USERNAME</span>=<span class="hljs-string">&quot;tftp&quot;</span><span class="hljs-attr">TFTP_DIRECTORY</span>=<span class="hljs-string">&quot;/home/firestaradmin/linux/tftpboot&quot;</span><span class="hljs-attr">TFTP_ADDRESS</span>=<span class="hljs-string">&quot;:69&quot;</span><span class="hljs-attr">TFTP_OPTIONS</span>=<span class="hljs-string">&quot;-l -c -s&quot;</span></code></pre></div><p>TFTP_DIRECTORY 就是我们上面创建的 tftp 文件夹目录，以后我们就将所有需要通过TFTP 传输的文件都放到这个文件夹里面，并且要给予这些文件相应的权限。</p><p>最后输入如下命令， 重启 tftp 服务器：<br><code>sudo service tftpd-hpa restart</code></p><p>tftp 服务器已经搭建好了，接下来就是使用了。将 zImage 镜像文件拷贝到 tftpboot 文件夹中，并且给予 zImage 相应的权限，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> zImage /home/firestaradmin/linux/tftpboot/<span class="hljs-built_in">cd</span> /home/firestaradmin/linux/tftpboot/<span class="hljs-built_in">chmod</span> 777 zImage</code></pre></div><p>万事俱备，只剩验证了，uboot 中的 tftp 命令格式如下：<br><code>tftpboot [loadAddress] [[hostIPaddr:]bootfilename]</code></p><p>看起来和 nfs 命令格式一样的，loadAddress 是文件在 DRAM 中的存放地址，**[[hostIPaddr:]bootfilename]**是要从 Ubuntu 中下载的文件。</p><p>但是和 nfs 命令的区别在于，tftp 命令不需要输入文件在 Ubuntu 中的完整路径，只需要输入文件名即可。比如我们现在将 tftpboot 文件夹里面的 zImage 文件下载到开发板 DRAM 的 0X80800000 地址处，命令如下：<br><code>tftp 80800000 zImage</code></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
      <category>环境搭建系统移植篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile的简单编写</title>
    <link href="/2020/08/16/NOTE/C&amp;C++/Makefile%E7%9A%84%E7%AE%80%E5%8D%95%E7%BC%96%E5%86%99/"/>
    <url>/2020/08/16/NOTE/C&amp;C++/Makefile%E7%9A%84%E7%AE%80%E5%8D%95%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile的简单编写"><a href="#Makefile的简单编写" class="headerlink" title="Makefile的简单编写"></a>Makefile的简单编写</h1><p>:label:@author:firestaradmin 2020年8月16日15:18:10 </p><hr><h2 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h2><h3 id="书写形式-例："><a href="#书写形式-例：" class="headerlink" title="书写形式 例："></a>书写形式 例：</h3><div class="hljs code-wrapper"><pre><code class="hljs makefile">foo.o : foo.c defs.h <span class="hljs-comment"># foo 模块</span>    cc -c -g foo.c</code></pre></div><ul><li>如果命令太长，你可以使用反斜框（‘\’）作为换行符</li><li>一般来说，make 会以 UNIX 的标准 Shell，也就是&#x2F;bin&#x2F;sh 来执行命令</li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul><li><p>make 支持三各通配符：“*”，“?”和“[…]”。这是和 Unix 的 B-Shell 是相同的。 波浪号（“<del>”）字符在文件名中也有比较特殊的用途。如果是“</del>&#x2F;test”，这就表示当前用户的$HOME 目录下的 test 目录</p></li><li><p>如“*.c”表示所有后缀为 c 的文件。一个需要我们注意的是，如果我们的文件名中有通配符，那么可以用转义字符“\”，如“\*”来表示真实的“*”字符，而不是任意长度的字符串。</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">print: *.c</span>    lpr -p <span class="hljs-variable">$?</span>    touch print</code></pre></div><p>上面这个例子说明了通配符也可以在我们的规则中，目标 print 依赖于所有的[.c]文件。</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">objects = *.o</code></pre></div><p>上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开！objects<br>的值就是“*.o”。Makefile 中的变量其实就是 C&#x2F;C++中的宏。如果你要让通配符在变量中<br>展开，也就是让 objects 的值是所有[.o]的文件名的集合，那么，你可以这样：</p><p>objects :&#x3D; $(wildcard *.o)</p><p>这种用法由关键字“wildcard”指出，关于 Makefile 的关键字，我们将在后面讨论</p><h3 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h3><ul><li>Makefile 文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make 只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs makefile">VPATH = src:../headers</code></pre></div><p>上面的的定义指定两个目录，“src”和“..&#x2F;headers”，make 会按照这个顺序进行搜<br>索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，</p><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span>    rm *.o temp</code></pre></div><p>我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用.（以“make clean”来使用该目标）</p><p>因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p><p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">.PHONY : clean</code></pre></div><p><strong>只要有这个声明，不管是否有“clean”文件，只要“make clean”都会运行“clean”这个目标。</strong></p><p>于是整个过程可以这样写：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><span class="hljs-section">clean:</span>    rm *.o temp</code></pre></div><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。</p></li><li><p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。看一个例子：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">objects = program.o foo.o utils.oprogram : <span class="hljs-variable">$(objects)</span>cc -o program <span class="hljs-variable">$(objects)</span><span class="hljs-variable">$(objects)</span> : defs.h</code></pre></div></li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>&#x3D; 是最基本的赋值<br>:&#x3D; 是覆盖之前的值<br>?&#x3D; 是如果没有被赋值过就赋予等号后面的值<br>+&#x3D; 是添加等号后面的值</p><p><strong>“&#x3D;”和“:&#x3D;”的区别到底有什么区别：</strong></p><ul><li><p>“&#x3D;”</p><p>make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：</p><div class="hljs code-wrapper"><pre><code class="hljs">  x = foo  y = $(x) bar  x = xyz</code></pre></div></li></ul><p>在上例中，y的值将会是 xyz bar ，而不是 foo bar 。</p><ul><li><p>“:&#x3D;”</p><p>  “:&#x3D;”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p><div class="hljs code-wrapper"><pre><code class="hljs">  x := foo  y := $(x) bar  x := xyz</code></pre></div></li></ul><p>在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。</p><h3 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h3><ul><li><p>$@<br>表示规则中的<strong>目标文件集</strong>。在模式规则中，如果有多个目标，那么，”$@”就是匹配于<br>目标中模式定义的集合。</p></li><li><p>$%<br>仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a<br>(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix<br>下是[.a]，Windows 下是[.lib]），那么，其值为空。</p></li><li><p>$&lt;<br>依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将<br>是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p></li><li><p>$?<br>所有比目标新的依赖目标的集合。以空格分隔。</p></li><li><p>$^<br>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量<br>会去除重复的依赖目标，只保留一份。</p></li><li><p>$+<br>这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p></li><li><p>$*<br>这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir&#x2F;a.foo.b”，并且目标的<br>模式是”a.%.b”，那么，”$<em>“的值就是”dir&#x2F;a.foo”。这个变量对于构造有关联的文件名是比<br>较有较。如果目标中没有模式的定义，那么”$</em>“也就不能被推导出，但是，如果目标文件的<br>后缀是 make 所识别的，那么”$<em>“就是除了后缀的那一部分。例如：如果目标是”foo.c”，因<br>为”.c”是 make 所能识别的后缀名，所以，”$</em>“的值就是”foo”。</p></li></ul><h3 id="部分函数"><a href="#部分函数" class="headerlink" title="部分函数"></a>部分函数</h3><h4 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h4><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> &lt;<span class="hljs-params">pattern</span>&gt;,&lt;<span class="hljs-params">replacement</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span></code></pre></div><p>名称：模式字符串替换函数——patsubst。</p><p>功能：查找&lt;text&gt;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。这里，&lt;pattern&gt;可以包括通配符“%”，表示任意长度的字串。如果&lt;replacement&gt;中也包含“%”，那么，&lt;replacement&gt;中的这个“%”将是&lt;pattern&gt;中的那个“%”所代表的字串。 （可以用“\”来转义，以“%”来表示真实含义的“%”字符）</p><p>返回：函数返回被替换过后的字符串。</p><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> %.<span class="hljs-params">c</span>,%.<span class="hljs-params">o</span>,<span class="hljs-params">x</span>.<span class="hljs-params">c</span>.<span class="hljs-params">c</span> <span class="hljs-params">bar</span>.<span class="hljs-params">c</span>)</span></code></pre></div><p>把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”</p><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">dir</span> &lt;<span class="hljs-params">names</span><span class="hljs-operator">...</span>&gt;)</span></code></pre></div><p>名称：取目录函数——dir。<br>功能：从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“&#x2F;”）之前<br>的部分。如果没有反斜杠，那么返回“.&#x2F;”。<br>返回：返回文件名序列&lt;names&gt;的目录部分。<br>示例： </p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">dir</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">foo</span>.<span class="hljs-params">c</span> <span class="hljs-params">hacks</span>)</span></code></pre></div><p>返回值是“src&#x2F; .&#x2F;”</p><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">notdir</span> &lt;<span class="hljs-params">names</span><span class="hljs-operator">...</span>&gt;)</span></code></pre></div><p>名称：取文件函数——notdir。<br>功能：从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“ &#x2F;”）<br>之后的部分。<br>返回：返回文件名序列&lt;names&gt;的非目录部分。<br>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">notdir</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">foo</span>.<span class="hljs-params">c</span> <span class="hljs-params">hacks</span>)</span></code></pre></div><p>返回值是“foo.c hacks”。</p><h4 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach  函数"></a>foreach  函数</h4><p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的 foreach 函数几乎是仿照于 Unix 标准 Shell（&#x2F;bin&#x2F;sh）中的 for 语句，或是 C-Shell（&#x2F;bin&#x2F;csh）中的 foreach 语句而构建的。它的语法是：</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">foreach</span> &lt;<span class="hljs-params">var</span>&gt;,&lt;<span class="hljs-params">list</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span></code></pre></div><p>这个函数的意思是，把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，然后再执行&lt;text&gt;所包含的表达式。每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。</p><p>所以，&lt;var&gt;最好是一个变量名，&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会使用&lt;var&gt;<br>这个参数来依次枚举&lt;list&gt;中的单词。举个例子：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">names := a b c dfiles := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> n,<span class="hljs-variable">$(names)</span>,<span class="hljs-variable">$(n)</span>.o)</span></code></pre></div><p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次<br>根据“$(n)”计算出一个值，这些值以空格分隔，最后作为 foreach 函数的返回，所以，<br>$(files)的值是“a.o b.o c.o d.o”。<br>注意，foreach 中的&lt;var&gt;参数是一个临时的局部变量，foreach 函数执行完后，参数<br>&lt;var&gt;的变量将不在作用，其作用域只在 foreach 函数当中。</p><h3 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h3><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p><p>&lt;targets …&gt;: <target-pattern>: &lt;prereq-patterns …&gt;<br>　　<commands><br>…</commands></target-pattern></p><p>没看明白没有关系，看下面的例子：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">objects = foo.o bar.oall : <span class="hljs-variable">$(objects)</span>    <span class="hljs-variable">$(objects)</span>: %.o: %.c    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span></code></pre></div><p>上面的例子中，指明了我们的目标从$objects中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">foo.o : foo.c    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> foo.c -o foo.obar.o : bar.c    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> bar.c -o bar.o</code></pre></div><p>试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。 </p><div class="hljs code-wrapper"><pre><code class="hljs makefile">.c.o：    gcc -c -o <span class="hljs-variable">$*</span>.o <span class="hljs-variable">$&lt;</span></code></pre></div><p>.c.o:<br>这句话的意思就是 %.o : %.c<br>也就是说，所有的.o文件，依赖于对应的.c文件<br>比如有三个a.c b.c c.c<br>那么就会有 a.o b.o c.o<br>a.o : a.c<br>b.o : b.c<br>c.o : c.c<br>这是makefile依赖的一种简写方法。makefile的依赖关系有很多种写法。这是其中一种。</p><h2 id="Makefile栗子预览："><a href="#Makefile栗子预览：" class="headerlink" title="Makefile栗子预览："></a>Makefile栗子预览：</h2><div class="hljs code-wrapper"><pre><code class="hljs makefile">CROSS_COMPILE ?= arm-linux-gnueabihf-TARGET  ?= uartCC := <span class="hljs-variable">$(CROSS_COMPILE)</span>gccLD:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ldOBJCOPY := <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopyOBJDUMP := <span class="hljs-variable">$(CROSS_COMPILE)</span>objdumpLIBPATH:= -lgcc -L /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/lib/gcc/arm-linux-gnueabihf/4.9.4INCDIRS := imx6ul \   bsp/clk \   bsp/led \   bsp/delay  \   bsp/beep \   bsp/gpio \   bsp/key \   bsp/exit \   bsp/int \   bsp/epittimer \   bsp/keyfilter \   bsp/uart       SRCDIRS:= project \   bsp/clk \   bsp/led \   bsp/delay \   bsp/beep \   bsp/gpio \   bsp/key \   bsp/exit \   bsp/int \   bsp/epittimer \   bsp/keyfilter \   bsp/uart       INCLUDE:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span>SFILES:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)CFILES:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span>)SFILENDIR:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(SFILES)</span>)</span>CFILENDIR:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(CFILES)</span>)</span>SOBJS:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)COBJS:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)OBJS:= <span class="hljs-variable">$(SOBJS)</span> <span class="hljs-variable">$(COBJS)</span>VPATH:= <span class="hljs-variable">$(SRCDIRS)</span><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><span class="hljs-variable">$(TARGET)</span>.bin : <span class="hljs-variable">$(OBJS)</span><span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$^</span> <span class="hljs-variable">$(LIBPATH)</span><span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$@</span><span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(TARGET)</span>.elf &gt; <span class="hljs-variable">$(TARGET)</span>.dis<span class="hljs-variable">$(SOBJS)</span> : obj/%.o : %.S<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -fno-builtin -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable">$(COBJS)</span> : obj/%.o : %.c<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -fno-builtin -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><span class="hljs-section">clean:</span>rm -rf <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$(TARGET)</span>.dis <span class="hljs-variable">$(TARGET)</span>.bin <span class="hljs-variable">$(COBJS)</span> <span class="hljs-variable">$(SOBJS)</span></code></pre></div><h3 id="栗子解析："><a href="#栗子解析：" class="headerlink" title="栗子解析："></a>栗子解析：</h3><p>在函数中使用到了除法运算，因此在链接的时候需要将编译器的数学库也链接进来。变量LIBPATH就是数学库的目录.</p><p>在后面的学习中，我们常常要用到一些第三方库，那么在连接程序的时候就需要指定这些<br>第三方库所在的目录，Makefile 在链接的时候使用选项“-L”来指定库所在的目录，比如变量 LIBPATH 就是指定了我们所使用的编译器库所在的目录。</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">LIBPATH:= -lgcc -L /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/lib/gcc/arm-linux-gnueabihf/4.9.4</code></pre></div><hr><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-variable">$(SOBJS)</span> : obj/%.o : %.S<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -fno-builtin -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable">$(COBJS)</span> : obj/%.o : %.c<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -fno-builtin -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span></code></pre></div><ul><li><p>-Wall,显示编译时候的所有警告</p></li><li><p>-nostdlib 编译时不链接系统标准启动文件和库文件</p></li><li><p>-O2 优化等级</p></li><li><p>选项“-fno-builtin”，否则编译的时候提示“putc”、“puts”<br>这两个函数与内建函数冲突，错误信息如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-built_in">warning</span>: conflicting <span class="hljs-keyword">types</span> <span class="hljs-keyword">for</span> built-<span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span> ‘putc’<span class="hljs-built_in">warning</span>: conflicting <span class="hljs-keyword">types</span> <span class="hljs-keyword">for</span> built-<span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span> ‘puts’</code></pre></div><p>在编译的时候加入选项“-fno-builtin”表示不使用内建函数，这样我们就可以自己实现 putc<br>和 puts 这样的函数了。</p></li></ul><hr><div class="hljs code-wrapper"><pre><code class="hljs makefile">INCLUDE:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span></code></pre></div><p>通过函数 patsubst 给变量 INCDIRS 添加一个“-I”，即：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile">INCLUDE := -I imx6ul -I bsp/clk -I bsp/led -I bsp/delay</code></pre></div><p>加“-I”的目的是因为 Makefile 语法要求指明头文件目录的时候需要加上“-I”。</p><hr><div class="hljs code-wrapper"><pre><code class="hljs makefile">SFILES:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)</code></pre></div><p>将$(SRCDIRS)中的目录里的*.s文件取出</p><hr><h2 id="Makefile栗子预览2："><a href="#Makefile栗子预览2：" class="headerlink" title="Makefile栗子预览2："></a>Makefile栗子预览2：</h2><div class="hljs code-wrapper"><pre><code class="hljs makefile">TARGET = rtkCom<span class="hljs-comment">#您想要生成可执行文件的名字</span>BinName :=$&#123;TARGET&#125;<span class="hljs-comment">#真实二进制文件输出路径(绝对)</span>Bin := <span class="hljs-variable">$(pes_parent_dir)</span>/<span class="hljs-variable">$(BinName)</span><span class="hljs-comment">#C++编译器</span>GCC = g++<span class="hljs-comment">#C++配置参数</span>CXXFLAGS = -g -w -std=c++11 <span class="hljs-comment">#头文件搜索路径</span>INCLUDES = -I .<span class="hljs-comment">#链接库</span>LIBS = -lpthread<span class="hljs-comment">#编译输出文件</span>OBJ_PATH = objs<span class="hljs-comment">#源文件目录路径</span>SRCDIR = .CPP_SOURCES = <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIR)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.cpp)</span>)CPP_SOURCES_N_DIR = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(CPP_SOURCES)</span>)</span>CPP_OBJS = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.cpp, <span class="hljs-variable">$(OBJ_PATH)</span>/%.o, <span class="hljs-variable">$(CPP_SOURCES_N_DIR)</span>)</span><span class="hljs-section">default: init compile</span><span class="hljs-comment">#创建输出目录</span><span class="hljs-section">init:</span><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>,<span class="hljs-variable">$(SRCDIR)</span>, mkdir -p <span class="hljs-variable">$(OBJ_PATH)</span>/<span class="hljs-variable">$(dir)</span>;)</span>compile : <span class="hljs-variable">$(CPP_OBJS)</span>@echo Now compile <span class="hljs-variable">$(TARGET)</span>.....<span class="hljs-variable">$(GCC)</span>  <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$(TARGET)</span>  <span class="hljs-variable">$(LINKFLAGS)</span> <span class="hljs-variable">$(LIBS)</span><span class="hljs-variable">$(CPP_OBJS)</span> : <span class="hljs-variable">$(OBJ_PATH)</span>/%.o : %.cpp<span class="hljs-variable">$(GCC)</span> -c <span class="hljs-variable">$(CXXFLAGS)</span> <span class="hljs-variable">$(INCLUDES)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span>.PHONY : clean<span class="hljs-section">clean:</span>rm -rf <span class="hljs-variable">$(CPP_OBJS)</span><span class="hljs-section">test:</span>@echo <span class="hljs-string">&quot;CPP_SOURCES: <span class="hljs-variable">$(CPP_SOURCES)</span>&quot;</span>@echo <span class="hljs-string">&quot;CPP_OBJS: <span class="hljs-variable">$(CPP_OBJS)</span>&quot;</span>@echo <span class="hljs-string">&quot;CPP_SOURCES_N_DIR: <span class="hljs-variable">$(CPP_SOURCES_N_DIR)</span>&quot;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>C&amp;C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Linux</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级C嵌入式深入知识点记录</title>
    <link href="/2020/08/15/NOTE/ARM-Linux/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%AB%98%E7%BA%A7C%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/08/15/NOTE/ARM-Linux/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%AB%98%E7%BA%A7C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>​        如果你爱编程，那么你就应该爱C，如果你爱C，那么你就应该爱指针，如果你爱指针，那么你就应该爱函数指针。        —— 东南大学 凌明 </p></blockquote><h3 id="ARMCC编译器，函数怎么传参的？（寄存器用哪些？传参顺序？）"><a href="#ARMCC编译器，函数怎么传参的？（寄存器用哪些？传参顺序？）" class="headerlink" title="ARMCC编译器，函数怎么传参的？（寄存器用哪些？传参顺序？）"></a>ARMCC编译器，函数怎么传参的？（寄存器用哪些？传参顺序？）</h3><h3 id="变量类型的大小？（char-几位-Short-Int-long？）"><a href="#变量类型的大小？（char-几位-Short-Int-long？）" class="headerlink" title="变量类型的大小？（char 几位? Short? Int? long？）"></a>变量类型的大小？（char 几位? Short? Int? long？）</h3><h3 id="ARMCC编译器后，链接的地址分配？有哪些段？程序各部分存储位置？（绝对地址？相对地址？TEXT段？DATA段？）"><a href="#ARMCC编译器后，链接的地址分配？有哪些段？程序各部分存储位置？（绝对地址？相对地址？TEXT段？DATA段？）" class="headerlink" title="ARMCC编译器后，链接的地址分配？有哪些段？程序各部分存储位置？（绝对地址？相对地址？TEXT段？DATA段？）"></a>ARMCC编译器后，链接的地址分配？有哪些段？程序各部分存储位置？（绝对地址？相对地址？TEXT段？DATA段？）</h3><h3 id="ARMCC下，for循环i-i—哪个效率相对更高一些？"><a href="#ARMCC下，for循环i-i—哪个效率相对更高一些？" class="headerlink" title="ARMCC下，for循环i++,i—哪个效率相对更高一些？"></a>ARMCC下，for循环i++,i—哪个效率相对更高一些？</h3><h3 id="如果要写一个内存拷贝的函数，你会怎么写？（-des-x3D-src-汇编效率或许更高）"><a href="#如果要写一个内存拷贝的函数，你会怎么写？（-des-x3D-src-汇编效率或许更高）" class="headerlink" title="如果要写一个内存拷贝的函数，你会怎么写？（*des++ &#x3D; *src++? 汇编效率或许更高）"></a>如果要写一个内存拷贝的函数，你会怎么写？（*des++ &#x3D; *src++? 汇编效率或许更高）</h3><h3 id="堆和栈的理解"><a href="#堆和栈的理解" class="headerlink" title="堆和栈的理解"></a>堆和栈的理解</h3><h3 id="很有意思的一个表达式：-void-void-0"><a href="#很有意思的一个表达式：-void-void-0" class="headerlink" title="很有意思的一个表达式：**(*(void (*)(void))0)();**"></a>很有意思的一个表达式：**(*(void (*)(void))0)();**</h3><ul><li>这条语句的意思是从0地址开始执行，在多数嵌入式系统中相当于系统的软复位</li><li>**(<em>0)();</em>* -&gt;函数调用</li><li><strong>(void (*)(void))</strong> -&gt;强制类型转换</li></ul>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>ARM-Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Embedded</tag>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下后台运行软件</title>
    <link href="/2020/08/13/NOTE/Linux/Linux%E4%B8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6/"/>
    <url>/2020/08/13/NOTE/Linux/Linux%E4%B8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux下后台运行软件"><a href="#Linux下后台运行软件" class="headerlink" title="Linux下后台运行软件"></a>Linux下后台运行软件</h1><h2 id="1-x2F-xxx-amp"><a href="#1-x2F-xxx-amp" class="headerlink" title="1. .&#x2F;xxx &amp;"></a>1. .&#x2F;xxx &amp;</h2><p>让一个软件进入后台的方法很简单，运行软件的时候加上“&amp;”即可，比如<strong>“.&#x2F;hello &amp;”</strong>就是让 hello 在后台运行。</p><p>在后台运行的软件可以使用<strong>“kill -9 pid(进程 ID)”</strong>命令来关闭掉，首先使用<strong>“ps”</strong>命令查看要关闭的软件 PID 是多少，ps 命令用于查看所有当前正在运行的进程，并且会给出进程的 PID。</p><p><strong>总结：</strong></p><p><strong>软件后面加“&amp;”、使用 ps 查看要关闭的软件 PID、使用“kill -9 pid”来关闭指定的软件。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs stata">xxx/<span class="hljs-keyword">app</span>.exe &amp;#runnning <span class="hljs-keyword">app</span> <span class="hljs-keyword">in</span> backgroundps -ef | grep <span class="hljs-keyword">app</span> #searching <span class="hljs-keyword">app</span>&#x27;s PID</code></pre></div><h2 id="2-nohup-x2F-xxx-amp"><a href="#2-nohup-x2F-xxx-amp" class="headerlink" title="2. nohup .&#x2F;xxx &amp;"></a>2. nohup .&#x2F;xxx &amp;</h2><p>当我们使用 &amp; 让软件后台运行的时候可能会发现，此时程序的输出信息还会显示在控制台中，这很影响我们操作.</p><p>所以可以使用 nohup 指令让程序的标准输出默认输出至当前目录下的 nohup.out 下。如图：</p><p><img src="/2020/08/13/NOTE/Linux/Linux%E4%B8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6/image-20220214101745104.png" alt="image-20220214101745104"></p><hr><p>当程序运行后，会自动生成 nohup.out 文件，使用 <code>tail -f ./nohup.out</code> 即可显示文件内容，并且当有更新时，自动输出显示。</p><p>如图：</p><p><img src="/2020/08/13/NOTE/Linux/Linux%E4%B8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6/image-20220214101916666.png" alt="image-20220214101916666"></p><h2 id="3-nohup-x2F-xxx-gt-xx-log-2-gt-amp-1-amp"><a href="#3-nohup-x2F-xxx-gt-xx-log-2-gt-amp-1-amp" class="headerlink" title="3.  nohup .&#x2F;xxx &gt; xx.log 2&gt;&amp;1 &amp;"></a>3.  nohup .&#x2F;xxx &gt; xx.log 2&gt;&amp;1 &amp;</h2><p>但是使用上方的 nohup 可能还会有问题，当我们运行多个程序后台，并且想把程序的输出储存至不同的文件中怎么办？</p><p>这个时候就要使用 &gt; 符号 将输出定向至 文件，如：</p><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> ./a.py &gt; py.log 2&gt;&amp;1 &amp;</code></pre></div><p><img src="/2020/08/13/NOTE/Linux/Linux%E4%B8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6/image-20220214102419451.png" alt="image-20220214102419451"></p><p>运行后，会在当前路径下生成 py.log 文件</p><ul><li>&gt;  输出定向至文件</li><li>2&gt;&amp;1   将标准错误输出定向至标准输出</li></ul>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络配置</title>
    <link href="/2020/08/13/NOTE/Linux/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/08/13/NOTE/Linux/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-net-config"><a href="#Linux-net-config" class="headerlink" title="Linux net config"></a>Linux net config</h1><p>Linux 系统有两种版本（以ubuntu为例）：</p><ul><li><p>Ubuntu Server<br>  Ubuntu的Server版本只有终端界面，没有桌面GUI，且Server版本不会安装NetworkManager，所以Ubuntu Server网络由配置文件进行配置。</p><p>  由于Server版本一般用作服务器的操作系统，服务器IP一般是固定的，通过命令修改 &#x2F;etc&#x2F;network&#x2F;interfaces 配置文件来修改IP。</p></li><li><p>Ubuntu Desktop<br>  Ubuntu桌面系统，由于具有GUI，所以Desktop配置网络可以以下两种模式：</p><ol><li>通过修改配置文件：&#x2F;etc&#x2F;network&#x2F;interfaces 的方法；</li><li>通过 NetworkManager进行配置；</li></ol></li></ul><h2 id="Ubuntu-Server"><a href="#Ubuntu-Server" class="headerlink" title="Ubuntu Server:"></a>Ubuntu Server:</h2><p>Server 版本只有命令行，这个时候一般没有NetWorkManager，所以需要使用 <code>/etc/network/interfaces</code>文件来配置网络。</p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>文件</p><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo vim /etc/network/interfaces</code></pre></div><p>无线网络可能是 <code>/etc/wpa_supplicant/wpa_supplicant.conf</code> 文件</p><h4 id="1-DHCP-mode"><a href="#1-DHCP-mode" class="headerlink" title="1. DHCP mode"></a>1. DHCP mode</h4><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># The primary network interface - use DHCP to find our address</span>auto eth0iface eth0 inet dhcp</code></pre></div><h4 id="2-Static-mode"><a href="#2-Static-mode" class="headerlink" title="2. Static mode"></a>2. Static mode</h4><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># The primary network interface</span>auto eth0iface eth0 inet staticaddress 192.168.3.90gateway 192.168.3.1netmask 255.255.255.0<span class="hljs-comment">#network 192.168.3.0</span><span class="hljs-comment">#broadcast 192.168.3.255</span></code></pre></div><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>file</p><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo vim /etc/resolv.conf</code></pre></div><p>sample</p><div class="hljs code-wrapper"><pre><code class="hljs sh">nameserver 8.8.8.8nameserver 114.114.114.114</code></pre></div><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>配置完对应的配置文件，需要使其生效：</p><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo /etc/init.d/networking restart</code></pre></div><h2 id="Ubuntu-Desktop"><a href="#Ubuntu-Desktop" class="headerlink" title="Ubuntu Desktop:"></a>Ubuntu Desktop:</h2><p>桌面版可以直接进入桌面进行配置网络，其实际是调用NetworkManager。</p><p>NetworkManager 的配置文件在<code>/etc/NetworkManger/NetworkManager.conf</code>，其配置的连接（有线、WIFI） 配置文件在 <code>/etc/NetworkManager/system-connections/</code>目录下。</p><p>一般来说会默认使用NetworkManager管理网络；<br>如果手动修改了&#x2F;etc&#x2F;network&#x2F;interfaces，则NetworkManager停止管理网络，由配置文件interfaces内的参数对网络进行管理，并自动会将managed参数改为true，NetworkManager 只会管理 &#x2F;etc&#x2F;network&#x2F;interfaces 里没配置的网络接口；</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>右上角网络图标不见了怎么办：如下操作：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo service network-manager restart</span></code></pre></div><p>不行的话试试下面的方法</p><div class="hljs code-wrapper"><pre><code class="hljs pf">sudo service network-manager stopsudo rm /var/lib/NetworkManager/NetworkManager.<span class="hljs-keyword">state</span>sudo service network-manager start</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>NetworkManager/NetworkManager.conf</code></pre></div><p>把false改成true</p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zsh终端以及ohmyzsh安装配置</title>
    <link href="/2020/08/12/NOTE/Linux/zsh%E7%BB%88%E7%AB%AF%E4%BB%A5%E5%8F%8Aohmyzsh%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/08/12/NOTE/Linux/zsh%E7%BB%88%E7%AB%AF%E4%BB%A5%E5%8F%8Aohmyzsh%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="zsh终端以及ohmyzsh安装配置"><a href="#zsh终端以及ohmyzsh安装配置" class="headerlink" title="zsh终端以及ohmyzsh安装配置"></a>zsh终端以及ohmyzsh安装配置</h1><h2 id="1-安装zsh"><a href="#1-安装zsh" class="headerlink" title="1.安装zsh"></a>1.安装zsh</h2><p>安装zsh<code>sudo apt-get install zsh</code></p><p>确认安装是否成功，查看版本<code>zsh --version </code></p><p><img src="/2020/08/12/NOTE/Linux/zsh%E7%BB%88%E7%AB%AF%E4%BB%A5%E5%8F%8Aohmyzsh%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20200817121050528.png" alt="image-20200817121050528"></p><h2 id="2-安装oh-my-zsh"><a href="#2-安装oh-my-zsh" class="headerlink" title="2.安装oh-my-zsh"></a>2.安装oh-my-zsh</h2><p>去<code>https://github.com/ohmyzsh/ohmyzsh</code>这里把tools目录下的<code>install.sh</code>弄到本地去执行就好了</p><p>记得要安装<code>git</code></p><h2 id="3-设置默认终端"><a href="#3-设置默认终端" class="headerlink" title="3.设置默认终端"></a>3.设置默认终端</h2><p>设置zsh为默认shell</p><p><code>sudo chsh -s $(which zsh)</code></p><p>注销重新登录, 打开终端</p><p>确认zsh是否是默认SHELL<code>echo $SHELL</code></p><p>如果是则会输出<code>/usr/bin/zsh</code></p><h2 id="4-设置配置文件主题"><a href="#4-设置配置文件主题" class="headerlink" title="4.设置配置文件主题"></a>4.设置配置文件主题</h2><p>Oh-My-Zsh的默认配置文件在：~&#x2F;.zshrc</p><p>主题配置 <code>ZSH_THEME=&quot;xxx&quot;</code></p><p>这里我喜欢用 <code>af-magic</code> 作为主题。</p><h2 id="5-语法高亮插件下载"><a href="#5-语法高亮插件下载" class="headerlink" title="5.语法高亮插件下载"></a>5.语法高亮插件下载</h2><p>下载zsh-syntax-highlighting插件</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.oh-my-zsh/custom/pluginsgit <span class="hljs-built_in">clone</span> git://github.com/zsh-users/zsh-syntax-highlighting.git</code></pre></div><p>在.zshrc中增加配置</p><div class="hljs code-wrapper"><pre><code class="hljs undefined">plugins=( [plugins...] zsh-syntax-highlighting)</code></pre></div><p><img src="/2020/08/12/NOTE/Linux/zsh%E7%BB%88%E7%AB%AF%E4%BB%A5%E5%8F%8Aohmyzsh%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20200817124337943.png" alt="image-20200817124337943"></p><p>读取配置使其生效</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc</code></pre></div><p>然后就会有效果了</p><p><img src="/2020/08/12/NOTE/Linux/zsh%E7%BB%88%E7%AB%AF%E4%BB%A5%E5%8F%8Aohmyzsh%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20200817124500987.png" alt="image-20200817124500987"></p>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Terminal</tag>
      
      <tag>zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++ Technique[技巧]</title>
    <link href="/2020/07/29/NOTE/C&amp;C++/C-technique/"/>
    <url>/2020/07/29/NOTE/C&amp;C++/C-technique/</url>
    
    <content type="html"><![CDATA[<h1 id="C-x2F-C-技巧"><a href="#C-x2F-C-技巧" class="headerlink" title="C&#x2F;C++ 技巧"></a>C&#x2F;C++ 技巧</h1><blockquote><p>我不敢正视你的眼睛，我怕我看你的每一眼都是在表白。 </p></blockquote><h2 id="一、模板"><a href="#一、模板" class="headerlink" title="一、模板"></a>一、模板</h2><h4 id="1-C语言中’-’-和-‘-’-的模板用法"><a href="#1-C语言中’-’-和-‘-’-的模板用法" class="headerlink" title="1.C语言中’#’ 和 ‘##’ 的模板用法"></a>1.C语言中’#’ 和 ‘##’ 的模板用法</h4><h5 id="运算符"><a href="#运算符" class="headerlink" title="#运算符"></a><strong>#运算符</strong></h5><p><strong>#运算符</strong>将一个宏的参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中。如：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_INT(x) printf(#x <span class="hljs-string">&quot; = %d\n&quot;</span>, x)</span></code></pre></div><p><strong>x</strong>之前的#运算符通知预处理器根据PRINT_INT的参数创建一个字符串字面量。<br>因此，调用 “PRINT_INT(i&#x2F;j);” 等同于：</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i/j&quot;</span> <span class="hljs-string">&quot; = %d\n&quot;</span>, i/j);</code></pre></div><p>而在C语言中相邻的字符串字面量会被合并<br>因此上边的语句等价于：<strong>printf(“i&#x2F;j &#x3D; %d\n”, i&#x2F;j);</strong></p><hr><h5 id="运算符-1"><a href="#运算符-1" class="headerlink" title="##运算符"></a><strong>##运算符</strong></h5><p> <strong>##运算符</strong>可以将两个记号（例如标识符）“粘”在一起，成为一个记号。（##运算符被称为“记号粘合”。）如果其中一个操作数是宏参数，“粘合”会在当形式参数被相应的实际参数替换后发生。</p><p>例如我们需要定义一个加法函数  </p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">int_add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;    <span class="hljs-keyword">return</span> a + b;&#125;</code></pre></div><p>但是这种情况下，如果我们要计算float类型的数据怎么办？重新在定义一个是可以的，但是如果有更多的类型呢？难道一个个全部定义嘛，这里有更好的办法。</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#define <span class="hljs-constructor">GENERIC_ADD(<span class="hljs-params">type</span>)</span> \<span class="hljs-keyword">type</span> <span class="hljs-keyword">type</span>##<span class="hljs-constructor">_add(<span class="hljs-params">type</span> <span class="hljs-params">a</span>, <span class="hljs-params">type</span> <span class="hljs-params">b</span>)</span> \&#123; \return a + b; \&#125; \</code></pre></div><p>现在，如果我们需要一个float类型的加法，只需要这一行代码</p><div class="hljs code-wrapper"><pre><code class="hljs c">GENERIC_ADD(<span class="hljs-type">float</span>)</code></pre></div><p>预处理器会自动展开为</p><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">float_add</span><span class="hljs-params">(flaot a, <span class="hljs-type">float</span> b)</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;</code></pre></div><h4 id="2-C-Template模板"><a href="#2-C-Template模板" class="headerlink" title="2.C++ Template模板"></a>2.C++ Template模板</h4><h5 id="1、类模板的格式为："><a href="#1、类模板的格式为：" class="headerlink" title="1、类模板的格式为："></a>1、类模板的格式为：</h5><div class="hljs code-wrapper"><pre><code class="hljs cpp">　　　　<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>  形参名，<span class="hljs-keyword">class</span> 形参名，…&gt;　　　　<span class="hljs-keyword">class</span> 类名&#123; ... &#125;;</code></pre></div><p>类模板和函数模板都是以<code>template</code> 开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如</p><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;    <span class="hljs-keyword">public</span>:     T a;    T b;     <span class="hljs-function">T <span class="hljs-title">hy</span><span class="hljs-params">(T c, T &amp;d)</span></span>;&#125;;</code></pre></div><p>当我们实例化一个类 m 时就可以这样：</p><div class="hljs code-wrapper"><pre><code class="hljs c++">A&lt;<span class="hljs-type">int</span>&gt; m;</code></pre></div><p>这样上面的类A中所有 T 的类型会被int 替代。</p><h5 id="2、函数模板"><a href="#2、函数模板" class="headerlink" title="2、函数模板"></a>2、函数模板</h5><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>  T&gt; <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; t1, T&amp; t2)</span> </span>&#123;    T tmpT;    tmpT = t1;    t1 = t2;    t2 = tmpT;&#125;</code></pre></div><p>用法：</p><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> num1 = <span class="hljs-number">1</span>, num2 = <span class="hljs-number">2</span>;<span class="hljs-built_in">swap</span>&lt;<span class="hljs-type">int</span>&gt;(num1, num2);</code></pre></div><h5 id="3、模板的偏特化和全特化"><a href="#3、模板的偏特化和全特化" class="headerlink" title="3、模板的偏特化和全特化"></a>3、模板的偏特化和全特化</h5><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/* 模板 */</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Test</span>(T1 i,T2 j):<span class="hljs-built_in">a</span>(i),<span class="hljs-built_in">b</span>(j)&#123;cout&lt;&lt;<span class="hljs-string">&quot;模板类&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-keyword">private</span>:    T1 a;    T2 b;&#125;;<span class="hljs-comment">/* 模板全特化 */</span><span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;<span class="hljs-type">int</span> , <span class="hljs-type">char</span>&gt;&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">char</span> j):<span class="hljs-built_in">a</span>(i),<span class="hljs-built_in">b</span>(j)&#123;cout&lt;&lt;<span class="hljs-string">&quot;全特化&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-keyword">private</span>:    <span class="hljs-type">int</span> a;    <span class="hljs-type">char</span> b;&#125;;<span class="hljs-comment">/* 模板偏特化 */</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;<span class="hljs-type">char</span>, T2&gt;&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Test</span>(<span class="hljs-type">char</span> i, T2 j):<span class="hljs-built_in">a</span>(i),<span class="hljs-built_in">b</span>(j)&#123;cout&lt;&lt;<span class="hljs-string">&quot;偏特化&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-keyword">private</span>:    <span class="hljs-type">char</span> a;    T2 b;&#125;;</code></pre></div><p>使用：</p><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Test&lt;<span class="hljs-type">double</span> , <span class="hljs-type">double</span>&gt; <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">0.1</span>,<span class="hljs-number">0.2</span>)</span></span>;  <span class="hljs-function">Test&lt;<span class="hljs-type">int</span> , <span class="hljs-type">char</span>&gt; <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;A&#x27;</span>)</span></span>;  <span class="hljs-function">Test&lt;<span class="hljs-type">char</span>, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">t3</span><span class="hljs-params">(<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-literal">true</span>)</span></span>;  <span class="hljs-comment">//依次打印：</span><span class="hljs-comment">//类模板</span><span class="hljs-comment">//全特化</span><span class="hljs-comment">//偏特化</span></code></pre></div><h5 id="4、使用枚举替代-class-x2F-typename-关键字"><a href="#4、使用枚举替代-class-x2F-typename-关键字" class="headerlink" title="4、使用枚举替代 class&#x2F;typename 关键字"></a>4、使用枚举替代 class&#x2F;typename 关键字</h5><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">enum</span> <span class="hljs-title class_">type_enum</span>&#123;    MYTYPE_INT = <span class="hljs-number">1</span>,    MYTYPE_FLOAT,    MYTYPE_STR&#125;;<span class="hljs-comment">/* 与传统模板不同，这里使用的枚举替代了class/typename */</span><span class="hljs-keyword">template</span>&lt;type_enum T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">T_Struct</span>&#123;    <span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> type;&#125;;<span class="hljs-comment">/* 模板的全特化 */</span><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">T_Struct</span>&lt;MYTYPE_INT&gt; &#123;<span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> type;&#125;;<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">T_Struct</span>&lt;MYTYPE_FLOAT&gt; &#123;<span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> type;&#125;;<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">T_Struct</span>&lt;MYTYPE_STR&gt; &#123;<span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* type;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">/* 模板使用 */</span>    T_Struct&lt;MYTYPE_INT&gt;::type a = <span class="hljs-number">10</span>;    T_Struct&lt;MYTYPE_FLOAT&gt;::type b = <span class="hljs-number">10.99</span>;    T_Struct&lt;MYTYPE_STR&gt;::type c = <span class="hljs-string">&quot;hello world\n&quot;</span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;T_Struct&lt;MYTYPE_INT&gt;::type a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">&quot;T_Struct&lt;MYTYPE_FLOAT&gt;::type b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">&quot;T_Struct&lt;MYTYPE_STR&gt;::type c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
      <category>C&amp;C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>note</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
